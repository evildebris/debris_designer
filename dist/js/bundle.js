/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(37);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _Canvas = __webpack_require__(184);

	var _Canvas2 = _interopRequireDefault(_Canvas);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*ReactDOM.render(<Parent />, document.getElementById('content'))*/
	_reactDom2.default.render(_react2.default.createElement(_Canvas2.default, null), document.getElementById('content')); /*import Parent from './Parent'*/

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(2);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var ReactBaseClasses = __webpack_require__(5);
	var ReactChildren = __webpack_require__(14);
	var ReactDOMFactories = __webpack_require__(22);
	var ReactElement = __webpack_require__(16);
	var ReactPropTypes = __webpack_require__(28);
	var ReactVersion = __webpack_require__(33);

	var createReactClass = __webpack_require__(34);
	var onlyChild = __webpack_require__(36);

	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;

	if (process.env.NODE_ENV !== 'production') {
	  var lowPriorityWarning = __webpack_require__(13);
	  var canDefineProperty = __webpack_require__(10);
	  var ReactElementValidator = __webpack_require__(23);
	  var didWarnPropTypesDeprecated = false;
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}

	var __spread = _assign;
	var createMixin = function (mixin) {
	  return mixin;
	};

	if (process.env.NODE_ENV !== 'production') {
	  var warnedForSpread = false;
	  var warnedForCreateMixin = false;
	  __spread = function () {
	    lowPriorityWarning(warnedForSpread, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.');
	    warnedForSpread = true;
	    return _assign.apply(null, arguments);
	  };

	  createMixin = function (mixin) {
	    lowPriorityWarning(warnedForCreateMixin, 'React.createMixin is deprecated and should not be used. ' + 'In React v16.0, it will be removed. ' + 'You can use this mixin directly instead. ' + 'See https://fb.me/createmixin-was-never-implemented for more info.');
	    warnedForCreateMixin = true;
	    return mixin;
	  };
	}

	var React = {
	  // Modern

	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },

	  Component: ReactBaseClasses.Component,
	  PureComponent: ReactBaseClasses.PureComponent,

	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,

	  // Classic

	  PropTypes: ReactPropTypes,
	  createClass: createReactClass,
	  createFactory: createFactory,
	  createMixin: createMixin,

	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,

	  version: ReactVersion,

	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};

	if (process.env.NODE_ENV !== 'production') {
	  var warnedForCreateClass = false;
	  if (canDefineProperty) {
	    Object.defineProperty(React, 'PropTypes', {
	      get: function () {
	        lowPriorityWarning(didWarnPropTypesDeprecated, 'Accessing PropTypes via the main React package is deprecated,' + ' and will be removed in  React v16.0.' + ' Use the latest available v15.* prop-types package from npm instead.' + ' For info on usage, compatibility, migration and more, see ' + 'https://fb.me/prop-types-docs');
	        didWarnPropTypesDeprecated = true;
	        return ReactPropTypes;
	      }
	    });

	    Object.defineProperty(React, 'createClass', {
	      get: function () {
	        lowPriorityWarning(warnedForCreateClass, 'Accessing createClass via the main React package is deprecated,' + ' and will be removed in React v16.0.' + " Use a plain JavaScript class instead. If you're not yet " + 'ready to migrate, create-react-class v15.* is available ' + 'on npm as a temporary, drop-in replacement. ' + 'For more info see https://fb.me/react-create-class');
	        warnedForCreateClass = true;
	        return createReactClass;
	      }
	    });
	  }

	  // React.DOM factories are deprecated. Wrap these methods so that
	  // invocations of the React.DOM namespace and alert users to switch
	  // to the `react-dom-factories` package.
	  React.DOM = {};
	  var warnedForFactories = false;
	  Object.keys(ReactDOMFactories).forEach(function (factory) {
	    React.DOM[factory] = function () {
	      if (!warnedForFactories) {
	        lowPriorityWarning(false, 'Accessing factories like React.DOM.%s has been deprecated ' + 'and will be removed in v16.0+. Use the ' + 'react-dom-factories package instead. ' + ' Version 1.0 provides a drop-in replacement.' + ' For more info, see https://fb.me/react-dom-factories', factory);
	        warnedForFactories = true;
	      }
	      return ReactDOMFactories[factory].apply(ReactDOMFactories, arguments);
	    };
	  });
	}

	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(6),
	    _assign = __webpack_require__(4);

	var ReactNoopUpdateQueue = __webpack_require__(7);

	var canDefineProperty = __webpack_require__(10);
	var emptyObject = __webpack_require__(11);
	var invariant = __webpack_require__(12);
	var lowPriorityWarning = __webpack_require__(13);

	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}

	ReactComponent.prototype.isReactComponent = {};

	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};

	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};

	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          lowPriorityWarning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}

	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}

	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;

	module.exports = {
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';

	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */

	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;

	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }

	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

	  throw error;
	}

	module.exports = reactProdInvariant;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var warning = __webpack_require__(8);

	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}

	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};

	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var emptyFunction = __webpack_require__(9);

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = emptyFunction;

	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };

	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }

	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }

	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }

	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}

	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    // $FlowFixMe https://github.com/facebook/flow/issues/285
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}

	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var emptyObject = {};

	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}

	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var validateFormat = function validateFormat(format) {};

	if (process.env.NODE_ENV !== 'production') {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}

	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Forked from fbjs/warning:
	 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
	 *
	 * Only change is we use console.warn instead of console.error,
	 * and do nothing when 'console' is not supported.
	 * This really simplifies the code.
	 * ---
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var lowPriorityWarning = function () {};

	if (process.env.NODE_ENV !== 'production') {
	  var printWarning = function (format) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    var argIndex = 0;
	    var message = 'Warning: ' + format.replace(/%s/g, function () {
	      return args[argIndex++];
	    });
	    if (typeof console !== 'undefined') {
	      console.warn(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };

	  lowPriorityWarning = function (condition, format) {
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	    if (!condition) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments[_key2];
	      }

	      printWarning.apply(undefined, [format].concat(args));
	    }
	  };
	}

	module.exports = lowPriorityWarning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var PooledClass = __webpack_require__(15);
	var ReactElement = __webpack_require__(16);

	var emptyFunction = __webpack_require__(9);
	var traverseAllChildren = __webpack_require__(19);

	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;

	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}

	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func,
	      context = bookKeeping.context;

	  func.call(context, child, bookKeeping.count++);
	}

	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}

	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result,
	      keyPrefix = bookKeeping.keyPrefix,
	      func = bookKeeping.func,
	      context = bookKeeping.context;


	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}

	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}

	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}

	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}

	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}

	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}

	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};

	module.exports = ReactChildren;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(6);

	var invariant = __webpack_require__(12);

	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};

	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};

	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};

	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};

	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};

	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;

	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};

	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler
	};

	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var ReactCurrentOwner = __webpack_require__(17);

	var warning = __webpack_require__(8);
	var canDefineProperty = __webpack_require__(10);
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	var REACT_ELEMENT_TYPE = __webpack_require__(18);

	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};

	var specialPropKeyWarningShown, specialPropRefWarningShown;

	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}

	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}

	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function () {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}

	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function () {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}

	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,

	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,

	    // Record the component responsible for creating this element.
	    _owner: owner
	  };

	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};

	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }

	  return element;
	};

	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;

	  // Reserved names are extracted
	  var props = {};

	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;

	  if (config != null) {
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }

	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (Object.freeze) {
	        Object.freeze(childArray);
	      }
	    }
	    props.children = childArray;
	  }

	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};

	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};

	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

	  return newElement;
	};

	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;

	  // Original props are copied
	  var props = _assign({}, element.props);

	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;

	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;

	  if (config != null) {
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }

	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }

	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};

	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};

	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	var ReactCurrentOwner = {
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	};

	module.exports = ReactCurrentOwner;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.

	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

	module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(6);

	var ReactCurrentOwner = __webpack_require__(17);
	var REACT_ELEMENT_TYPE = __webpack_require__(18);

	var getIteratorFn = __webpack_require__(20);
	var invariant = __webpack_require__(12);
	var KeyEscapeUtils = __webpack_require__(21);
	var warning = __webpack_require__(8);

	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';

	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */

	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */

	var didWarnAboutMaps = false;

	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}

	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;

	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }

	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }

	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }

	  return subtreeCount;
	}

	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }

	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}

	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/* global Symbol */

	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}

	module.exports = getIteratorFn;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */

	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });

	  return '$' + escapedString;
	}

	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}

	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};

	module.exports = KeyEscapeUtils;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactElement = __webpack_require__(16);

	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(23);
	  createDOMFactory = ReactElementValidator.createFactory;
	}

	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),

	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};

	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */

	'use strict';

	var ReactCurrentOwner = __webpack_require__(17);
	var ReactComponentTreeHook = __webpack_require__(24);
	var ReactElement = __webpack_require__(16);

	var checkReactTypeSpec = __webpack_require__(25);

	var canDefineProperty = __webpack_require__(10);
	var getIteratorFn = __webpack_require__(20);
	var warning = __webpack_require__(8);
	var lowPriorityWarning = __webpack_require__(13);

	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	function getSourceInfoErrorAddendum(elementProps) {
	  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
	    var source = elementProps.__source;
	    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
	    var lineNumber = source.lineNumber;
	    return ' Check your code at ' + fileName + ':' + lineNumber + '.';
	  }
	  return '';
	}

	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};

	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();

	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}

	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;

	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;

	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }

	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}

	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}

	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}

	var ReactElementValidator = {
	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      if (typeof type !== 'function' && typeof type !== 'string') {
	        var info = '';
	        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
	          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
	        }

	        var sourceInfo = getSourceInfoErrorAddendum(props);
	        if (sourceInfo) {
	          info += sourceInfo;
	        } else {
	          info += getDeclarationErrorAddendum();
	        }

	        info += ReactComponentTreeHook.getCurrentStackAddendum();

	        var currentSource = props !== null && props !== undefined && props.__source !== undefined ? props.__source : null;
	        ReactComponentTreeHook.pushNonStandardWarningStack(true, currentSource);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
	        ReactComponentTreeHook.popNonStandardWarningStack();
	      }
	    }

	    var element = ReactElement.createElement.apply(this, arguments);

	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }

	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }

	    validatePropTypes(element);

	    return element;
	  },

	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;

	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            lowPriorityWarning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }

	    return validatedFactory;
	  },

	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	};

	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(6);

	var ReactCurrentOwner = __webpack_require__(17);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty
	  // Strip regex characters so we can use it for regex
	  ).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&'
	  // Remove hasOwnProperty from the template to make it generic
	  ).replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}

	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

	var setItem;
	var getItem;
	var removeItem;
	var getItemIDs;
	var addRoot;
	var removeRoot;
	var getRootIDs;

	if (canUseCollections) {
	  var itemMap = new Map();
	  var rootIDSet = new Set();

	  setItem = function (id, item) {
	    itemMap.set(id, item);
	  };
	  getItem = function (id) {
	    return itemMap.get(id);
	  };
	  removeItem = function (id) {
	    itemMap['delete'](id);
	  };
	  getItemIDs = function () {
	    return Array.from(itemMap.keys());
	  };

	  addRoot = function (id) {
	    rootIDSet.add(id);
	  };
	  removeRoot = function (id) {
	    rootIDSet['delete'](id);
	  };
	  getRootIDs = function () {
	    return Array.from(rootIDSet.keys());
	  };
	} else {
	  var itemByKey = {};
	  var rootByKey = {};

	  // Use non-numeric keys to prevent V8 performance issues:
	  // https://github.com/facebook/react/pull/7232
	  var getKeyFromID = function (id) {
	    return '.' + id;
	  };
	  var getIDFromKey = function (key) {
	    return parseInt(key.substr(1), 10);
	  };

	  setItem = function (id, item) {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  };
	  getItem = function (id) {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  };
	  removeItem = function (id) {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  };
	  getItemIDs = function () {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  };

	  addRoot = function (id) {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  };
	  removeRoot = function (id) {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  };
	  getRootIDs = function () {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  };
	}

	var unmountedIDs = [];

	function purgeDeep(id) {
	  var item = getItem(id);
	  if (item) {
	    var childIDs = item.childIDs;

	    removeItem(id);
	    childIDs.forEach(purgeDeep);
	  }
	}

	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}

	function getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}

	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}

	var ReactComponentTreeHook = {
	  onSetChildren: function (id, nextChildIDs) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.childIDs = nextChildIDs;

	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = getItem(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent id is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function (id, element, parentID) {
	    var item = {
	      element: element,
	      parentID: parentID,
	      text: null,
	      childIDs: [],
	      isMounted: false,
	      updateCount: 0
	    };
	    setItem(id, item);
	  },
	  onBeforeUpdateComponent: function (id, element) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function (id) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function (id) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function (id) {
	    var item = getItem(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function () {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }

	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function (id) {
	    var item = getItem(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function (topElement) {
	    var info = '';
	    if (topElement) {
	      var name = getDisplayName(topElement);
	      var owner = topElement._owner;
	      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
	    }

	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;

	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function (id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function (id) {
	    var item = getItem(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return getDisplayName(element);
	  },
	  getElement: function (id) {
	    var item = getItem(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function (id) {
	    var item = getItem(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function (id) {
	    var item = getItem(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function (id) {
	    var item = getItem(id);
	    return item ? item.updateCount : 0;
	  },


	  getRootIDs: getRootIDs,
	  getRegisteredIDs: getItemIDs,

	  pushNonStandardWarningStack: function (isCreatingElement, currentSource) {
	    if (typeof console.reactStack !== 'function') {
	      return;
	    }

	    var stack = [];
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;

	    try {
	      if (isCreatingElement) {
	        stack.push({
	          name: id ? ReactComponentTreeHook.getDisplayName(id) : null,
	          fileName: currentSource ? currentSource.fileName : null,
	          lineNumber: currentSource ? currentSource.lineNumber : null
	        });
	      }

	      while (id) {
	        var element = ReactComponentTreeHook.getElement(id);
	        var parentID = ReactComponentTreeHook.getParentID(id);
	        var ownerID = ReactComponentTreeHook.getOwnerID(id);
	        var ownerName = ownerID ? ReactComponentTreeHook.getDisplayName(ownerID) : null;
	        var source = element && element._source;
	        stack.push({
	          name: ownerName,
	          fileName: source ? source.fileName : null,
	          lineNumber: source ? source.lineNumber : null
	        });
	        id = parentID;
	      }
	    } catch (err) {
	      // Internal state is messed up.
	      // Stop building the stack (it's just a nice to have).
	    }

	    console.reactStack(stack);
	  },
	  popNonStandardWarningStack: function () {
	    if (typeof console.reactStackEnd !== 'function') {
	      return;
	    }
	    console.reactStackEnd();
	  }
	};

	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(6);

	var ReactPropTypeLocationNames = __webpack_require__(26);
	var ReactPropTypesSecret = __webpack_require__(27);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(24);
	}

	var loggedTypeFailures = {};

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var componentStackInfo = '';

	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(24);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }

	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}

	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactPropTypeLocationNames = {};

	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}

	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _require = __webpack_require__(16),
	    isValidElement = _require.isValidElement;

	var factory = __webpack_require__(29);

	module.exports = factory(isValidElement);

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	// React 15.5 references this module, and assumes PropTypes are still callable in production.
	// Therefore we re-export development-only version with all the PropTypes checks here.
	// However if one is migrating to the `prop-types` npm library, they will go through the
	// `index.js` entry point, and it will branch depending on the environment.
	var factory = __webpack_require__(30);
	module.exports = function(isValidElement) {
	  // It is still allowed in 15.5.
	  var throwOnDirectAccess = false;
	  return factory(isValidElement, throwOnDirectAccess);
	};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	var emptyFunction = __webpack_require__(9);
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	var ReactPropTypesSecret = __webpack_require__(31);
	var checkPropTypes = __webpack_require__(32);

	module.exports = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    if (process.env.NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          invariant(
	            false,
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            warning(
	              false,
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `%s` prop on `%s`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
	              propFullName,
	              componentName
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues);
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (propValue.hasOwnProperty(key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        warning(
	          false,
	          'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' +
	          'received %s at index %s.',
	          getPostfixForTypeWarning(checker),
	          i
	        );
	        return emptyFunction.thatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	          return null;
	        }
	      }

	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 31 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	if (process.env.NODE_ENV !== 'production') {
	  var invariant = __webpack_require__(12);
	  var warning = __webpack_require__(8);
	  var ReactPropTypesSecret = __webpack_require__(31);
	  var loggedTypeFailures = {};
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (process.env.NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (typeSpecs.hasOwnProperty(typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
	        }
	      }
	    }
	  }
	}

	module.exports = checkPropTypes;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 33 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	module.exports = '15.6.1';

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _require = __webpack_require__(5),
	    Component = _require.Component;

	var _require2 = __webpack_require__(16),
	    isValidElement = _require2.isValidElement;

	var ReactNoopUpdateQueue = __webpack_require__(7);
	var factory = __webpack_require__(35);

	module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue);

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var emptyObject = __webpack_require__(11);
	var _invariant = __webpack_require__(12);

	if (process.env.NODE_ENV !== 'production') {
	  var warning = __webpack_require__(8);
	}

	var MIXINS_KEY = 'mixins';

	// Helper function to allow the creation of anonymous functions which do not
	// have .name set to the name of the variable being assigned to.
	function identity(fn) {
	  return fn;
	}

	var ReactPropTypeLocationNames;
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	} else {
	  ReactPropTypeLocationNames = {};
	}

	function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
	  /**
	   * Policies that describe methods in `ReactClassInterface`.
	   */

	  var injectedMixins = [];

	  /**
	   * Composite components are higher-level components that compose other composite
	   * or host components.
	   *
	   * To create a new type of `ReactClass`, pass a specification of
	   * your new class to `React.createClass`. The only requirement of your class
	   * specification is that you implement a `render` method.
	   *
	   *   var MyComponent = React.createClass({
	   *     render: function() {
	   *       return <div>Hello World</div>;
	   *     }
	   *   });
	   *
	   * The class specification supports a specific protocol of methods that have
	   * special meaning (e.g. `render`). See `ReactClassInterface` for
	   * more the comprehensive protocol. Any other properties and methods in the
	   * class specification will be available on the prototype.
	   *
	   * @interface ReactClassInterface
	   * @internal
	   */
	  var ReactClassInterface = {
	    /**
	     * An array of Mixin objects to include when defining your component.
	     *
	     * @type {array}
	     * @optional
	     */
	    mixins: 'DEFINE_MANY',

	    /**
	     * An object containing properties and methods that should be defined on
	     * the component's constructor instead of its prototype (static methods).
	     *
	     * @type {object}
	     * @optional
	     */
	    statics: 'DEFINE_MANY',

	    /**
	     * Definition of prop types for this component.
	     *
	     * @type {object}
	     * @optional
	     */
	    propTypes: 'DEFINE_MANY',

	    /**
	     * Definition of context types for this component.
	     *
	     * @type {object}
	     * @optional
	     */
	    contextTypes: 'DEFINE_MANY',

	    /**
	     * Definition of context types this component sets for its children.
	     *
	     * @type {object}
	     * @optional
	     */
	    childContextTypes: 'DEFINE_MANY',

	    // ==== Definition methods ====

	    /**
	     * Invoked when the component is mounted. Values in the mapping will be set on
	     * `this.props` if that prop is not specified (i.e. using an `in` check).
	     *
	     * This method is invoked before `getInitialState` and therefore cannot rely
	     * on `this.state` or use `this.setState`.
	     *
	     * @return {object}
	     * @optional
	     */
	    getDefaultProps: 'DEFINE_MANY_MERGED',

	    /**
	     * Invoked once before the component is mounted. The return value will be used
	     * as the initial value of `this.state`.
	     *
	     *   getInitialState: function() {
	     *     return {
	     *       isOn: false,
	     *       fooBaz: new BazFoo()
	     *     }
	     *   }
	     *
	     * @return {object}
	     * @optional
	     */
	    getInitialState: 'DEFINE_MANY_MERGED',

	    /**
	     * @return {object}
	     * @optional
	     */
	    getChildContext: 'DEFINE_MANY_MERGED',

	    /**
	     * Uses props from `this.props` and state from `this.state` to render the
	     * structure of the component.
	     *
	     * No guarantees are made about when or how often this method is invoked, so
	     * it must not have side effects.
	     *
	     *   render: function() {
	     *     var name = this.props.name;
	     *     return <div>Hello, {name}!</div>;
	     *   }
	     *
	     * @return {ReactComponent}
	     * @required
	     */
	    render: 'DEFINE_ONCE',

	    // ==== Delegate methods ====

	    /**
	     * Invoked when the component is initially created and about to be mounted.
	     * This may have side effects, but any external subscriptions or data created
	     * by this method must be cleaned up in `componentWillUnmount`.
	     *
	     * @optional
	     */
	    componentWillMount: 'DEFINE_MANY',

	    /**
	     * Invoked when the component has been mounted and has a DOM representation.
	     * However, there is no guarantee that the DOM node is in the document.
	     *
	     * Use this as an opportunity to operate on the DOM when the component has
	     * been mounted (initialized and rendered) for the first time.
	     *
	     * @param {DOMElement} rootNode DOM element representing the component.
	     * @optional
	     */
	    componentDidMount: 'DEFINE_MANY',

	    /**
	     * Invoked before the component receives new props.
	     *
	     * Use this as an opportunity to react to a prop transition by updating the
	     * state using `this.setState`. Current props are accessed via `this.props`.
	     *
	     *   componentWillReceiveProps: function(nextProps, nextContext) {
	     *     this.setState({
	     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	     *     });
	     *   }
	     *
	     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	     * transition may cause a state change, but the opposite is not true. If you
	     * need it, you are probably looking for `componentWillUpdate`.
	     *
	     * @param {object} nextProps
	     * @optional
	     */
	    componentWillReceiveProps: 'DEFINE_MANY',

	    /**
	     * Invoked while deciding if the component should be updated as a result of
	     * receiving new props, state and/or context.
	     *
	     * Use this as an opportunity to `return false` when you're certain that the
	     * transition to the new props/state/context will not require a component
	     * update.
	     *
	     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	     *     return !equal(nextProps, this.props) ||
	     *       !equal(nextState, this.state) ||
	     *       !equal(nextContext, this.context);
	     *   }
	     *
	     * @param {object} nextProps
	     * @param {?object} nextState
	     * @param {?object} nextContext
	     * @return {boolean} True if the component should update.
	     * @optional
	     */
	    shouldComponentUpdate: 'DEFINE_ONCE',

	    /**
	     * Invoked when the component is about to update due to a transition from
	     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	     * and `nextContext`.
	     *
	     * Use this as an opportunity to perform preparation before an update occurs.
	     *
	     * NOTE: You **cannot** use `this.setState()` in this method.
	     *
	     * @param {object} nextProps
	     * @param {?object} nextState
	     * @param {?object} nextContext
	     * @param {ReactReconcileTransaction} transaction
	     * @optional
	     */
	    componentWillUpdate: 'DEFINE_MANY',

	    /**
	     * Invoked when the component's DOM representation has been updated.
	     *
	     * Use this as an opportunity to operate on the DOM when the component has
	     * been updated.
	     *
	     * @param {object} prevProps
	     * @param {?object} prevState
	     * @param {?object} prevContext
	     * @param {DOMElement} rootNode DOM element representing the component.
	     * @optional
	     */
	    componentDidUpdate: 'DEFINE_MANY',

	    /**
	     * Invoked when the component is about to be removed from its parent and have
	     * its DOM representation destroyed.
	     *
	     * Use this as an opportunity to deallocate any external resources.
	     *
	     * NOTE: There is no `componentDidUnmount` since your component will have been
	     * destroyed by that point.
	     *
	     * @optional
	     */
	    componentWillUnmount: 'DEFINE_MANY',

	    // ==== Advanced methods ====

	    /**
	     * Updates the component's currently mounted DOM representation.
	     *
	     * By default, this implements React's rendering and reconciliation algorithm.
	     * Sophisticated clients may wish to override this.
	     *
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     * @overridable
	     */
	    updateComponent: 'OVERRIDE_BASE'
	  };

	  /**
	   * Mapping from class specification keys to special processing functions.
	   *
	   * Although these are declared like instance properties in the specification
	   * when defining classes using `React.createClass`, they are actually static
	   * and are accessible on the constructor instead of the prototype. Despite
	   * being static, they must be defined outside of the "statics" key under
	   * which all other static methods are defined.
	   */
	  var RESERVED_SPEC_KEYS = {
	    displayName: function(Constructor, displayName) {
	      Constructor.displayName = displayName;
	    },
	    mixins: function(Constructor, mixins) {
	      if (mixins) {
	        for (var i = 0; i < mixins.length; i++) {
	          mixSpecIntoComponent(Constructor, mixins[i]);
	        }
	      }
	    },
	    childContextTypes: function(Constructor, childContextTypes) {
	      if (process.env.NODE_ENV !== 'production') {
	        validateTypeDef(Constructor, childContextTypes, 'childContext');
	      }
	      Constructor.childContextTypes = _assign(
	        {},
	        Constructor.childContextTypes,
	        childContextTypes
	      );
	    },
	    contextTypes: function(Constructor, contextTypes) {
	      if (process.env.NODE_ENV !== 'production') {
	        validateTypeDef(Constructor, contextTypes, 'context');
	      }
	      Constructor.contextTypes = _assign(
	        {},
	        Constructor.contextTypes,
	        contextTypes
	      );
	    },
	    /**
	     * Special case getDefaultProps which should move into statics but requires
	     * automatic merging.
	     */
	    getDefaultProps: function(Constructor, getDefaultProps) {
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps = createMergedResultFunction(
	          Constructor.getDefaultProps,
	          getDefaultProps
	        );
	      } else {
	        Constructor.getDefaultProps = getDefaultProps;
	      }
	    },
	    propTypes: function(Constructor, propTypes) {
	      if (process.env.NODE_ENV !== 'production') {
	        validateTypeDef(Constructor, propTypes, 'prop');
	      }
	      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
	    },
	    statics: function(Constructor, statics) {
	      mixStaticSpecIntoComponent(Constructor, statics);
	    },
	    autobind: function() {}
	  };

	  function validateTypeDef(Constructor, typeDef, location) {
	    for (var propName in typeDef) {
	      if (typeDef.hasOwnProperty(propName)) {
	        // use a warning instead of an _invariant so components
	        // don't show up in prod but only in __DEV__
	        if (process.env.NODE_ENV !== 'production') {
	          warning(
	            typeof typeDef[propName] === 'function',
	            '%s: %s type `%s` is invalid; it must be a function, usually from ' +
	              'React.PropTypes.',
	            Constructor.displayName || 'ReactClass',
	            ReactPropTypeLocationNames[location],
	            propName
	          );
	        }
	      }
	    }
	  }

	  function validateMethodOverride(isAlreadyDefined, name) {
	    var specPolicy = ReactClassInterface.hasOwnProperty(name)
	      ? ReactClassInterface[name]
	      : null;

	    // Disallow overriding of base class methods unless explicitly allowed.
	    if (ReactClassMixin.hasOwnProperty(name)) {
	      _invariant(
	        specPolicy === 'OVERRIDE_BASE',
	        'ReactClassInterface: You are attempting to override ' +
	          '`%s` from your class specification. Ensure that your method names ' +
	          'do not overlap with React methods.',
	        name
	      );
	    }

	    // Disallow defining methods more than once unless explicitly allowed.
	    if (isAlreadyDefined) {
	      _invariant(
	        specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',
	        'ReactClassInterface: You are attempting to define ' +
	          '`%s` on your component more than once. This conflict may be due ' +
	          'to a mixin.',
	        name
	      );
	    }
	  }

	  /**
	   * Mixin helper which handles policy validation and reserved
	   * specification keys when building React classes.
	   */
	  function mixSpecIntoComponent(Constructor, spec) {
	    if (!spec) {
	      if (process.env.NODE_ENV !== 'production') {
	        var typeofSpec = typeof spec;
	        var isMixinValid = typeofSpec === 'object' && spec !== null;

	        if (process.env.NODE_ENV !== 'production') {
	          warning(
	            isMixinValid,
	            "%s: You're attempting to include a mixin that is either null " +
	              'or not an object. Check the mixins included by the component, ' +
	              'as well as any mixins they include themselves. ' +
	              'Expected object but got %s.',
	            Constructor.displayName || 'ReactClass',
	            spec === null ? null : typeofSpec
	          );
	        }
	      }

	      return;
	    }

	    _invariant(
	      typeof spec !== 'function',
	      "ReactClass: You're attempting to " +
	        'use a component class or function as a mixin. Instead, just use a ' +
	        'regular object.'
	    );
	    _invariant(
	      !isValidElement(spec),
	      "ReactClass: You're attempting to " +
	        'use a component as a mixin. Instead, just use a regular object.'
	    );

	    var proto = Constructor.prototype;
	    var autoBindPairs = proto.__reactAutoBindPairs;

	    // By handling mixins before any other properties, we ensure the same
	    // chaining order is applied to methods with DEFINE_MANY policy, whether
	    // mixins are listed before or after these methods in the spec.
	    if (spec.hasOwnProperty(MIXINS_KEY)) {
	      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	    }

	    for (var name in spec) {
	      if (!spec.hasOwnProperty(name)) {
	        continue;
	      }

	      if (name === MIXINS_KEY) {
	        // We have already handled mixins in a special case above.
	        continue;
	      }

	      var property = spec[name];
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      validateMethodOverride(isAlreadyDefined, name);

	      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	        RESERVED_SPEC_KEYS[name](Constructor, property);
	      } else {
	        // Setup methods on prototype:
	        // The following member methods should not be automatically bound:
	        // 1. Expected ReactClass methods (in the "interface").
	        // 2. Overridden methods (that were mixed in).
	        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	        var isFunction = typeof property === 'function';
	        var shouldAutoBind =
	          isFunction &&
	          !isReactClassMethod &&
	          !isAlreadyDefined &&
	          spec.autobind !== false;

	        if (shouldAutoBind) {
	          autoBindPairs.push(name, property);
	          proto[name] = property;
	        } else {
	          if (isAlreadyDefined) {
	            var specPolicy = ReactClassInterface[name];

	            // These cases should already be caught by validateMethodOverride.
	            _invariant(
	              isReactClassMethod &&
	                (specPolicy === 'DEFINE_MANY_MERGED' ||
	                  specPolicy === 'DEFINE_MANY'),
	              'ReactClass: Unexpected spec policy %s for key %s ' +
	                'when mixing in component specs.',
	              specPolicy,
	              name
	            );

	            // For methods which are defined more than once, call the existing
	            // methods before calling the new property, merging if appropriate.
	            if (specPolicy === 'DEFINE_MANY_MERGED') {
	              proto[name] = createMergedResultFunction(proto[name], property);
	            } else if (specPolicy === 'DEFINE_MANY') {
	              proto[name] = createChainedFunction(proto[name], property);
	            }
	          } else {
	            proto[name] = property;
	            if (process.env.NODE_ENV !== 'production') {
	              // Add verbose displayName to the function, which helps when looking
	              // at profiling tools.
	              if (typeof property === 'function' && spec.displayName) {
	                proto[name].displayName = spec.displayName + '_' + name;
	              }
	            }
	          }
	        }
	      }
	    }
	  }

	  function mixStaticSpecIntoComponent(Constructor, statics) {
	    if (!statics) {
	      return;
	    }
	    for (var name in statics) {
	      var property = statics[name];
	      if (!statics.hasOwnProperty(name)) {
	        continue;
	      }

	      var isReserved = name in RESERVED_SPEC_KEYS;
	      _invariant(
	        !isReserved,
	        'ReactClass: You are attempting to define a reserved ' +
	          'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
	          'as an instance property instead; it will still be accessible on the ' +
	          'constructor.',
	        name
	      );

	      var isInherited = name in Constructor;
	      _invariant(
	        !isInherited,
	        'ReactClass: You are attempting to define ' +
	          '`%s` on your component more than once. This conflict may be ' +
	          'due to a mixin.',
	        name
	      );
	      Constructor[name] = property;
	    }
	  }

	  /**
	   * Merge two objects, but throw if both contain the same key.
	   *
	   * @param {object} one The first object, which is mutated.
	   * @param {object} two The second object
	   * @return {object} one after it has been mutated to contain everything in two.
	   */
	  function mergeIntoWithNoDuplicateKeys(one, two) {
	    _invariant(
	      one && two && typeof one === 'object' && typeof two === 'object',
	      'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
	    );

	    for (var key in two) {
	      if (two.hasOwnProperty(key)) {
	        _invariant(
	          one[key] === undefined,
	          'mergeIntoWithNoDuplicateKeys(): ' +
	            'Tried to merge two objects with the same key: `%s`. This conflict ' +
	            'may be due to a mixin; in particular, this may be caused by two ' +
	            'getInitialState() or getDefaultProps() methods returning objects ' +
	            'with clashing keys.',
	          key
	        );
	        one[key] = two[key];
	      }
	    }
	    return one;
	  }

	  /**
	   * Creates a function that invokes two functions and merges their return values.
	   *
	   * @param {function} one Function to invoke first.
	   * @param {function} two Function to invoke second.
	   * @return {function} Function that invokes the two argument functions.
	   * @private
	   */
	  function createMergedResultFunction(one, two) {
	    return function mergedResult() {
	      var a = one.apply(this, arguments);
	      var b = two.apply(this, arguments);
	      if (a == null) {
	        return b;
	      } else if (b == null) {
	        return a;
	      }
	      var c = {};
	      mergeIntoWithNoDuplicateKeys(c, a);
	      mergeIntoWithNoDuplicateKeys(c, b);
	      return c;
	    };
	  }

	  /**
	   * Creates a function that invokes two functions and ignores their return vales.
	   *
	   * @param {function} one Function to invoke first.
	   * @param {function} two Function to invoke second.
	   * @return {function} Function that invokes the two argument functions.
	   * @private
	   */
	  function createChainedFunction(one, two) {
	    return function chainedFunction() {
	      one.apply(this, arguments);
	      two.apply(this, arguments);
	    };
	  }

	  /**
	   * Binds a method to the component.
	   *
	   * @param {object} component Component whose method is going to be bound.
	   * @param {function} method Method to be bound.
	   * @return {function} The bound method.
	   */
	  function bindAutoBindMethod(component, method) {
	    var boundMethod = method.bind(component);
	    if (process.env.NODE_ENV !== 'production') {
	      boundMethod.__reactBoundContext = component;
	      boundMethod.__reactBoundMethod = method;
	      boundMethod.__reactBoundArguments = null;
	      var componentName = component.constructor.displayName;
	      var _bind = boundMethod.bind;
	      boundMethod.bind = function(newThis) {
	        for (
	          var _len = arguments.length,
	            args = Array(_len > 1 ? _len - 1 : 0),
	            _key = 1;
	          _key < _len;
	          _key++
	        ) {
	          args[_key - 1] = arguments[_key];
	        }

	        // User is trying to bind() an autobound method; we effectively will
	        // ignore the value of "this" that the user is trying to use, so
	        // let's warn.
	        if (newThis !== component && newThis !== null) {
	          if (process.env.NODE_ENV !== 'production') {
	            warning(
	              false,
	              'bind(): React component methods may only be bound to the ' +
	                'component instance. See %s',
	              componentName
	            );
	          }
	        } else if (!args.length) {
	          if (process.env.NODE_ENV !== 'production') {
	            warning(
	              false,
	              'bind(): You are binding a component method to the component. ' +
	                'React does this for you automatically in a high-performance ' +
	                'way, so you can safely remove this call. See %s',
	              componentName
	            );
	          }
	          return boundMethod;
	        }
	        var reboundMethod = _bind.apply(boundMethod, arguments);
	        reboundMethod.__reactBoundContext = component;
	        reboundMethod.__reactBoundMethod = method;
	        reboundMethod.__reactBoundArguments = args;
	        return reboundMethod;
	      };
	    }
	    return boundMethod;
	  }

	  /**
	   * Binds all auto-bound methods in a component.
	   *
	   * @param {object} component Component whose method is going to be bound.
	   */
	  function bindAutoBindMethods(component) {
	    var pairs = component.__reactAutoBindPairs;
	    for (var i = 0; i < pairs.length; i += 2) {
	      var autoBindKey = pairs[i];
	      var method = pairs[i + 1];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }

	  var IsMountedPreMixin = {
	    componentDidMount: function() {
	      this.__isMounted = true;
	    }
	  };

	  var IsMountedPostMixin = {
	    componentWillUnmount: function() {
	      this.__isMounted = false;
	    }
	  };

	  /**
	   * Add more to the ReactClass base class. These are all legacy features and
	   * therefore not already part of the modern ReactComponent.
	   */
	  var ReactClassMixin = {
	    /**
	     * TODO: This will be deprecated because state should always keep a consistent
	     * type signature and the only use case for this, is to avoid that.
	     */
	    replaceState: function(newState, callback) {
	      this.updater.enqueueReplaceState(this, newState, callback);
	    },

	    /**
	     * Checks whether or not this composite component is mounted.
	     * @return {boolean} True if mounted, false otherwise.
	     * @protected
	     * @final
	     */
	    isMounted: function() {
	      if (process.env.NODE_ENV !== 'production') {
	        warning(
	          this.__didWarnIsMounted,
	          '%s: isMounted is deprecated. Instead, make sure to clean up ' +
	            'subscriptions and pending requests in componentWillUnmount to ' +
	            'prevent memory leaks.',
	          (this.constructor && this.constructor.displayName) ||
	            this.name ||
	            'Component'
	        );
	        this.__didWarnIsMounted = true;
	      }
	      return !!this.__isMounted;
	    }
	  };

	  var ReactClassComponent = function() {};
	  _assign(
	    ReactClassComponent.prototype,
	    ReactComponent.prototype,
	    ReactClassMixin
	  );

	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  function createClass(spec) {
	    // To keep our warnings more understandable, we'll use a little hack here to
	    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
	    // unnecessarily identify a class without displayName as 'Constructor'.
	    var Constructor = identity(function(props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.

	      if (process.env.NODE_ENV !== 'production') {
	        warning(
	          this instanceof Constructor,
	          'Something is calling a React component directly. Use a factory or ' +
	            'JSX instead. See: https://fb.me/react-legacyfactory'
	        );
	      }

	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }

	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;

	      this.state = null;

	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.

	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (
	          initialState === undefined &&
	          this.getInitialState._isMockFunction
	        ) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      _invariant(
	        typeof initialState === 'object' && !Array.isArray(initialState),
	        '%s.getInitialState(): must return an object or null',
	        Constructor.displayName || 'ReactCompositeComponent'
	      );

	      this.state = initialState;
	    });
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];

	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

	    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
	    mixSpecIntoComponent(Constructor, spec);
	    mixSpecIntoComponent(Constructor, IsMountedPostMixin);

	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }

	    _invariant(
	      Constructor.prototype.render,
	      'createClass(...): Class specification must implement a `render` method.'
	    );

	    if (process.env.NODE_ENV !== 'production') {
	      warning(
	        !Constructor.prototype.componentShouldUpdate,
	        '%s has a method called ' +
	          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
	          'The name is phrased as a question because the function is ' +
	          'expected to return a value.',
	        spec.displayName || 'A component'
	      );
	      warning(
	        !Constructor.prototype.componentWillRecieveProps,
	        '%s has a method called ' +
	          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
	        spec.displayName || 'A component'
	      );
	    }

	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }

	    return Constructor;
	  }

	  return createClass;
	}

	module.exports = factory;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	'use strict';

	var _prodInvariant = __webpack_require__(6);

	var ReactElement = __webpack_require__(16);

	var invariant = __webpack_require__(12);

	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}

	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(38);


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

	'use strict';

	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactDefaultInjection = __webpack_require__(43);
	var ReactMount = __webpack_require__(172);
	var ReactReconciler = __webpack_require__(64);
	var ReactUpdates = __webpack_require__(61);
	var ReactVersion = __webpack_require__(177);

	var findDOMNode = __webpack_require__(178);
	var getHostComponentFromComposite = __webpack_require__(179);
	var renderSubtreeIntoContainer = __webpack_require__(180);
	var warning = __webpack_require__(8);

	ReactDefaultInjection.inject();

	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,

	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	  /* eslint-enable camelcase */
	};

	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function (inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}

	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(53);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }

	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, "It looks like you're using a minified copy of the development build " + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];

	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}

	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(67);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(181);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(182);
	  var ReactDOMInvalidARIAHook = __webpack_require__(183);

	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
	}

	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var DOMProperty = __webpack_require__(41);
	var ReactDOMComponentFlags = __webpack_require__(42);

	var invariant = __webpack_require__(12);

	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;

	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

	/**
	 * Check if a given node should be cached.
	 */
	function shouldPrecacheNode(node, nodeID) {
	  return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
	}

	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}

	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}

	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}

	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (shouldPrecacheNode(childNode, childID)) {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}

	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }

	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }

	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }

	  return closest;
	}

	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}

	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

	  if (inst._hostNode) {
	    return inst._hostNode;
	  }

	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }

	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }

	  return inst._hostNode;
	}

	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};

	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';

	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */

	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;

	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }

	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

	  throw error;
	}

	module.exports = reactProdInvariant;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}

	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }

	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];

	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,

	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;

	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }

	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }

	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }

	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }

	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }

	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};

	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */

	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},

	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   *
	   * autofocus is predefined, because adding it to the property whitelist
	   * causes unintended side effects.
	   *
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? { autofocus: 'autoFocus' } : null,

	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],

	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },

	  injection: DOMPropertyInjection
	};

	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};

	module.exports = ReactDOMComponentFlags;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ARIADOMPropertyConfig = __webpack_require__(44);
	var BeforeInputEventPlugin = __webpack_require__(45);
	var ChangeEventPlugin = __webpack_require__(60);
	var DefaultEventPluginOrder = __webpack_require__(78);
	var EnterLeaveEventPlugin = __webpack_require__(79);
	var HTMLDOMPropertyConfig = __webpack_require__(84);
	var ReactComponentBrowserEnvironment = __webpack_require__(85);
	var ReactDOMComponent = __webpack_require__(98);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactDOMEmptyComponent = __webpack_require__(143);
	var ReactDOMTreeTraversal = __webpack_require__(144);
	var ReactDOMTextComponent = __webpack_require__(145);
	var ReactDefaultBatchingStrategy = __webpack_require__(146);
	var ReactEventListener = __webpack_require__(147);
	var ReactInjection = __webpack_require__(150);
	var ReactReconcileTransaction = __webpack_require__(151);
	var SVGDOMPropertyConfig = __webpack_require__(159);
	var SelectEventPlugin = __webpack_require__(160);
	var SimpleEventPlugin = __webpack_require__(161);

	var alreadyInjected = false;

	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;

	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });

	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

	  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });

	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}

	module.exports = {
	  inject: inject
	};

/***/ }),
/* 44 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ARIADOMPropertyConfig = {
	  Properties: {
	    // Global States and Properties
	    'aria-current': 0, // state
	    'aria-details': 0,
	    'aria-disabled': 0, // state
	    'aria-hidden': 0, // state
	    'aria-invalid': 0, // state
	    'aria-keyshortcuts': 0,
	    'aria-label': 0,
	    'aria-roledescription': 0,
	    // Widget Attributes
	    'aria-autocomplete': 0,
	    'aria-checked': 0,
	    'aria-expanded': 0,
	    'aria-haspopup': 0,
	    'aria-level': 0,
	    'aria-modal': 0,
	    'aria-multiline': 0,
	    'aria-multiselectable': 0,
	    'aria-orientation': 0,
	    'aria-placeholder': 0,
	    'aria-pressed': 0,
	    'aria-readonly': 0,
	    'aria-required': 0,
	    'aria-selected': 0,
	    'aria-sort': 0,
	    'aria-valuemax': 0,
	    'aria-valuemin': 0,
	    'aria-valuenow': 0,
	    'aria-valuetext': 0,
	    // Live Region Attributes
	    'aria-atomic': 0,
	    'aria-busy': 0,
	    'aria-live': 0,
	    'aria-relevant': 0,
	    // Drag-and-Drop Attributes
	    'aria-dropeffect': 0,
	    'aria-grabbed': 0,
	    // Relationship Attributes
	    'aria-activedescendant': 0,
	    'aria-colcount': 0,
	    'aria-colindex': 0,
	    'aria-colspan': 0,
	    'aria-controls': 0,
	    'aria-describedby': 0,
	    'aria-errormessage': 0,
	    'aria-flowto': 0,
	    'aria-labelledby': 0,
	    'aria-owns': 0,
	    'aria-posinset': 0,
	    'aria-rowcount': 0,
	    'aria-rowindex': 0,
	    'aria-rowspan': 0,
	    'aria-setsize': 0
	  },
	  DOMAttributeNames: {},
	  DOMPropertyNames: {}
	};

	module.exports = ARIADOMPropertyConfig;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var EventPropagators = __webpack_require__(46);
	var ExecutionEnvironment = __webpack_require__(53);
	var FallbackCompositionState = __webpack_require__(54);
	var SyntheticCompositionEvent = __webpack_require__(57);
	var SyntheticInputEvent = __webpack_require__(59);

	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;

	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}

	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}

	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: 'onBeforeInput',
	      captured: 'onBeforeInputCapture'
	    },
	    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionEnd',
	      captured: 'onCompositionEndCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionStart',
	      captured: 'onCompositionStartCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionUpdate',
	      captured: 'onCompositionUpdateCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  }
	};

	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;

	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}

	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case 'topCompositionStart':
	      return eventTypes.compositionStart;
	    case 'topCompositionEnd':
	      return eventTypes.compositionEnd;
	    case 'topCompositionUpdate':
	      return eventTypes.compositionUpdate;
	  }
	}

	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
	}

	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topKeyUp':
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case 'topKeyDown':
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case 'topKeyPress':
	    case 'topMouseDown':
	    case 'topBlur':
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}

	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}

	// Track the current IME composition fallback object, if any.
	var currentComposition = null;

	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;

	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }

	  if (!eventType) {
	    return null;
	  }

	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }

	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }

	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}

	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topCompositionEnd':
	      return getDataFromCustomEvent(nativeEvent);
	    case 'topKeyPress':
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }

	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;

	    case 'topTextInput':
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;

	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }

	      return chars;

	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}

	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  // If composition event is available, we extract a string only at
	  // compositionevent, otherwise extract it at fallback events.
	  if (currentComposition) {
	    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }

	  switch (topLevelType) {
	    case 'topPaste':
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case 'topKeyPress':
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case 'topCompositionEnd':
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}

	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;

	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }

	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }

	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}

	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	  eventTypes: eventTypes,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};

	module.exports = BeforeInputEventPlugin;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var EventPluginHub = __webpack_require__(47);
	var EventPluginUtils = __webpack_require__(49);

	var accumulateInto = __webpack_require__(51);
	var forEachAccumulated = __webpack_require__(52);
	var warning = __webpack_require__(8);

	var getListener = EventPluginHub.getListener;

	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}

	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, phase, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}

	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}

	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}

	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}

	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}

	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}

	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}

	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}

	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}

	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};

	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var EventPluginRegistry = __webpack_require__(48);
	var EventPluginUtils = __webpack_require__(49);
	var ReactErrorUtils = __webpack_require__(50);

	var accumulateInto = __webpack_require__(51);
	var forEachAccumulated = __webpack_require__(52);
	var invariant = __webpack_require__(12);

	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};

	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;

	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);

	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};

	var getDictionaryKey = function (inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};

	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}

	function shouldPreventMouseEvent(name, type, props) {
	  switch (name) {
	    case 'onClick':
	    case 'onClickCapture':
	    case 'onDoubleClick':
	    case 'onDoubleClickCapture':
	    case 'onMouseDown':
	    case 'onMouseDownCapture':
	    case 'onMouseMove':
	    case 'onMouseMoveCapture':
	    case 'onMouseUp':
	    case 'onMouseUpCapture':
	      return !!(props.disabled && isInteractive(type));
	    default:
	      return false;
	  }
	}

	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	  },

	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function (inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;

	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;

	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },

	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (inst, registrationName) {
	    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
	    // live here; needs to be moved to a better place soon
	    var bankForRegistrationName = listenerBank[registrationName];
	    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
	      return null;
	    }
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },

	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }

	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },

	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function (inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }

	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }

	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }

	      delete listenerBank[registrationName][key];
	    }
	  },

	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },

	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },

	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },

	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },

	  __getListenerBank: function () {
	    return listenerBank;
	  }
	};

	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	/**
	 * Injectable ordering of event plugins.
	 */
	var eventPluginOrder = null;

	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};

	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!eventPluginOrder) {
	    // Wait until an `eventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var pluginModule = namesToPlugins[pluginName];
	    var pluginIndex = eventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
	    var publishedEvents = pluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}

	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
	    return true;
	  }
	  return false;
	}

	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, pluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}

	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],

	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},

	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},

	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},

	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	  // Trust the developer to only use possibleRegistrationNames in __DEV__

	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (injectedEventPluginOrder) {
	    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
	    recomputePluginOrdering();
	  },

	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var pluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = pluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },

	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    if (dispatchConfig.phasedRegistrationNames !== undefined) {
	      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
	      // that it is not undefined.
	      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

	      for (var phase in phasedRegistrationNames) {
	        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
	          continue;
	        }
	        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
	        if (pluginModule) {
	          return pluginModule;
	        }
	      }
	    }
	    return null;
	  },

	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    eventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;

	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }

	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	};

	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactErrorUtils = __webpack_require__(50);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	/**
	 * Injected dependencies:
	 */

	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function (Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function (Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};

	function isEndish(topLevelType) {
	  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
	}

	function isMoveish(topLevelType) {
	  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
	}
	function isStartish(topLevelType) {
	  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
	}

	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;

	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}

	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}

	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}

	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}

	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}

	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}

	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}

	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,

	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,

	  getInstanceFromNode: function (node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function (node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function (a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function (a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function (inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function (target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },

	  injection: injection
	};

	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var caughtError = null;

	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a) {
	  try {
	    func(a);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	  }
	}

	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,

	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};

	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
	      var boundFunc = func.bind(null, a);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}

	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */

	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;

	  if (current == null) {
	    return next;
	  }

	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }

	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }

	  return [current, next];
	}

	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 52 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */

	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}

	module.exports = forEachAccumulated;

/***/ }),
/* 53 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {

	  canUseDOM: canUseDOM,

	  canUseWorkers: typeof Worker !== 'undefined',

	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

	  canUseViewport: canUseDOM && !!window.screen,

	  isInWorker: !canUseDOM // For now, this is true - might change in the future.

	};

	module.exports = ExecutionEnvironment;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var PooledClass = __webpack_require__(55);

	var getTextContentAccessor = __webpack_require__(56);

	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}

	_assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },

	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },

	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }

	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;

	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }

	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }

	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});

	PooledClass.addPoolingTo(FallbackCompositionState);

	module.exports = FallbackCompositionState;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};

	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};

	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};

	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};

	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};

	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;

	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};

	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler
	};

	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);

	var contentKey = null;

	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}

	module.exports = getTextContentAccessor;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(58);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

	module.exports = SyntheticCompositionEvent;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var PooledClass = __webpack_require__(55);

	var emptyFunction = __webpack_require__(9);
	var warning = __webpack_require__(8);

	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';

	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};

	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }

	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;

	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }

	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}

	_assign(SyntheticEvent.prototype, {
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }

	    if (event.preventDefault) {
	      event.preventDefault();
	      // eslint-disable-next-line valid-typeof
	    } else if (typeof event.returnValue !== 'unknown') {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },

	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }

	    if (event.stopPropagation) {
	      event.stopPropagation();
	      // eslint-disable-next-line valid-typeof
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }

	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },

	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },

	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,

	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	});

	SyntheticEvent.Interface = EventInterface;

	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function (target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function (constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function (target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;

	  var E = function () {};
	  E.prototype = Super.prototype;
	  var prototype = new E();

	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;

	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;

	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};

	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

	module.exports = SyntheticEvent;

	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };

	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }

	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }

	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(58);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

	module.exports = SyntheticInputEvent;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var EventPluginHub = __webpack_require__(47);
	var EventPropagators = __webpack_require__(46);
	var ExecutionEnvironment = __webpack_require__(53);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactUpdates = __webpack_require__(61);
	var SyntheticEvent = __webpack_require__(58);

	var inputValueTracking = __webpack_require__(74);
	var getEventTarget = __webpack_require__(75);
	var isEventSupported = __webpack_require__(76);
	var isTextInputElement = __webpack_require__(77);

	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: 'onChange',
	      captured: 'onChangeCapture'
	    },
	    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
	  }
	};

	function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);
	  event.type = 'change';
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;

	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}

	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
	}

	function manualDispatchChangeEvent(nativeEvent) {
	  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}

	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}

	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}

	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}

	function getInstIfValueChanged(targetInst, nativeEvent) {
	  var updated = inputValueTracking.updateValueIfChanged(targetInst);
	  var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;

	  if (updated || simulated) {
	    return targetInst;
	  }
	}

	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topChange') {
	    return targetInst;
	  }
	}

	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForChangeEventIE8();
	  }
	}

	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.

	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
	}

	/**
	 * (For IE <=9) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}

	/**
	 * (For IE <=9) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);

	  activeElement = null;
	  activeElementInst = null;
	}

	/**
	 * (For IE <=9) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  if (getInstIfValueChanged(activeElementInst, nativeEvent)) {
	    manualDispatchChangeEvent(nativeEvent);
	  }
	}

	function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForValueChange();
	  }
	}

	// For IE8 and IE9.
	function getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {
	  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    return getInstIfValueChanged(activeElementInst, nativeEvent);
	  }
	}

	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  var nodeName = elem.nodeName;
	  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}

	function getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {
	  if (topLevelType === 'topClick') {
	    return getInstIfValueChanged(targetInst, nativeEvent);
	  }
	}

	function getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {
	  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
	    return getInstIfValueChanged(targetInst, nativeEvent);
	  }
	}

	function handleControlledInputBlur(inst, node) {
	  // TODO: In IE, inst is occasionally null. Why?
	  if (inst == null) {
	    return;
	  }

	  // Fiber and ReactDOM keep wrapper state in separate places
	  var state = inst._wrapperState || node._wrapperState;

	  if (!state || !state.controlled || node.type !== 'number') {
	    return;
	  }

	  // If controlled, assign the value attribute to the current value on blur
	  var value = '' + node.value;
	  if (node.getAttribute('value') !== value) {
	    node.setAttribute('value', value);
	  }
	}

	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	  eventTypes: eventTypes,

	  _allowSimulatedPassThrough: true,
	  _isInputEventSupported: isInputEventSupported,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventPolyfill;
	        handleEventFunc = handleEventsForInputEventPolyfill;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }

	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);
	      if (inst) {
	        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
	        return event;
	      }
	    }

	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }

	    // When blurring, set the value attribute for number inputs
	    if (topLevelType === 'topBlur') {
	      handleControlledInputBlur(targetInst, targetNode);
	    }
	  }
	};

	module.exports = ChangeEventPlugin;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(55);
	var ReactFeatureFlags = __webpack_require__(63);
	var ReactReconciler = __webpack_require__(64);
	var Transaction = __webpack_require__(73);

	var invariant = __webpack_require__(12);

	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;

	var batchingStrategy = null;

	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}

	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};

	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};

	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}

	_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },

	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});

	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}

	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}

	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;

	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);

	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;

	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];

	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;

	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.type.isReactTopLevelWrapper) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }

	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

	    if (markerName) {
	      console.timeEnd(markerName);
	    }

	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}

	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }

	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};

	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();

	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)

	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }

	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}

	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}

	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },

	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};

	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,

	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};

	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var PooledClass = __webpack_require__(55);

	var invariant = __webpack_require__(12);

	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */

	var CallbackQueue = function () {
	  function CallbackQueue(arg) {
	    _classCallCheck(this, CallbackQueue);

	    this._callbacks = null;
	    this._contexts = null;
	    this._arg = arg;
	  }

	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */


	  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._callbacks.push(callback);
	    this._contexts = this._contexts || [];
	    this._contexts.push(context);
	  };

	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */


	  CallbackQueue.prototype.notifyAll = function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    var arg = this._arg;
	    if (callbacks && contexts) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i], arg);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  };

	  CallbackQueue.prototype.checkpoint = function checkpoint() {
	    return this._callbacks ? this._callbacks.length : 0;
	  };

	  CallbackQueue.prototype.rollback = function rollback(len) {
	    if (this._callbacks && this._contexts) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  };

	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */


	  CallbackQueue.prototype.reset = function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  };

	  /**
	   * `PooledClass` looks for this.
	   */


	  CallbackQueue.prototype.destructor = function destructor() {
	    this.reset();
	  };

	  return CallbackQueue;
	}();

	module.exports = PooledClass.addPoolingTo(CallbackQueue);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 63 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};

	module.exports = ReactFeatureFlags;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactRef = __webpack_require__(65);
	var ReactInstrumentation = __webpack_require__(67);

	var warning = __webpack_require__(8);

	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}

	var ReactReconciler = {
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID) // 0 in production and for roots
	  {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },

	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function (internalInstance) {
	    return internalInstance.getHostNode();
	  },

	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },

	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;

	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.

	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }

	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }

	    internalInstance.receiveComponent(nextElement, transaction, context);

	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },

	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	};

	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactOwner = __webpack_require__(66);

	var ReactRef = {};

	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}

	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}

	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || typeof element !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};

	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.

	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.

	  var prevRef = null;
	  var prevOwner = null;
	  if (prevElement !== null && typeof prevElement === 'object') {
	    prevRef = prevElement.ref;
	    prevOwner = prevElement._owner;
	  }

	  var nextRef = null;
	  var nextOwner = null;
	  if (nextElement !== null && typeof nextElement === 'object') {
	    nextRef = nextElement.ref;
	    nextOwner = nextElement._owner;
	  }

	  return prevRef !== nextRef ||
	  // If owner changes but we have an unchanged function ref, don't update refs
	  typeof nextRef === 'string' && nextOwner !== prevOwner;
	};

	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || typeof element !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};

	module.exports = ReactRef;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid owner.
	 * @final
	 */
	function isValidOwner(object) {
	  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	}

	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },

	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	};

	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	// Trust the developer to only use ReactInstrumentation with a __DEV__ check

	var debugTool = null;

	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(68);
	  debugTool = ReactDebugTool;
	}

	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactInvalidSetStateWarningHook = __webpack_require__(69);
	var ReactHostOperationHistoryHook = __webpack_require__(70);
	var ReactComponentTreeHook = __webpack_require__(24);
	var ExecutionEnvironment = __webpack_require__(53);

	var performanceNow = __webpack_require__(71);
	var warning = __webpack_require__(8);

	var hooks = [];
	var didHookThrowForEvent = {};

	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}

	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}

	var isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = [];
	var currentFlushStartTime = 0;
	var currentTimerDebugID = null;
	var currentTimerStartTime = 0;
	var currentTimerNestedFlushDuration = 0;
	var currentTimerType = null;

	var lifeCycleTimerHasWarned = false;

	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}

	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}

	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements;
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();

	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = 0;
	    currentFlushMeasurements = [];
	    clearHistory();
	    return;
	  }

	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }

	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}

	function checkDebugID(debugID) {
	  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}

	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}

	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}

	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}

	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
	      startTime = _lifeCycleTimerStack$.startTime,
	      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
	      debugID = _lifeCycleTimerStack$.debugID,
	      timerType = _lifeCycleTimerStack$.timerType;

	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}

	var lastMarkTimeStamp = 0;
	var canUsePerformanceMeasure = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

	function shouldMark(debugID) {
	  if (!isProfiling || !canUsePerformanceMeasure) {
	    return false;
	  }
	  var element = ReactComponentTreeHook.getElement(debugID);
	  if (element == null || typeof element !== 'object') {
	    return false;
	  }
	  var isHostElement = typeof element.type === 'string';
	  if (isHostElement) {
	    return false;
	  }
	  return true;
	}

	function markBegin(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }

	  var markName = debugID + '::' + markType;
	  lastMarkTimeStamp = performanceNow();
	  performance.mark(markName);
	}

	function markEnd(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }

	  var markName = debugID + '::' + markType;
	  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';

	  // Chrome has an issue of dropping markers recorded too fast:
	  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
	  // To work around this, we will not report very small measurements.
	  // I determined the magic number by tweaking it back and forth.
	  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
	  // When the bug is fixed, we can `measure()` unconditionally if we want to.
	  var timeStamp = performanceNow();
	  if (timeStamp - lastMarkTimeStamp > 0.1) {
	    var measurementName = displayName + ' [' + markType + ']';
	    performance.measure(measurementName, markName);
	  }

	  performance.clearMarks(markName);
	  if (measurementName) {
	    performance.clearMeasures(measurementName);
	  }
	}

	var ReactDebugTool = {
	  addHook: function (hook) {
	    hooks.push(hook);
	  },
	  removeHook: function (hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function () {
	    return isProfiling;
	  },
	  beginProfiling: function () {
	    if (isProfiling) {
	      return;
	    }

	    isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function () {
	    if (!isProfiling) {
	      return;
	    }

	    isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function () {
	    return flushHistory;
	  },
	  onBeginFlush: function () {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function () {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    markBegin(debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    markEnd(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onBeginProcessingChildContext: function () {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function () {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function (operation) {
	    checkDebugID(operation.instanceID);
	    emitEvent('onHostOperation', operation);
	  },
	  onSetState: function () {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function (debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function (debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	    markBegin(debugID, 'mount');
	  },
	  onMountComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'mount');
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	    markBegin(debugID, 'update');
	  },
	  onUpdateComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'update');
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	    markBegin(debugID, 'unmount');
	  },
	  onUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'unmount');
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function () {
	    emitEvent('onTestEvent');
	  }
	};

	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}

	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var warning = __webpack_require__(8);

	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;

	  var warnInvalidSetState = function () {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}

	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function () {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function () {
	    processingChildContext = false;
	  },
	  onSetState: function () {
	    warnInvalidSetState();
	  }
	};

	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 70 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var history = [];

	var ReactHostOperationHistoryHook = {
	  onHostOperation: function (operation) {
	    history.push(operation);
	  },
	  clearHistory: function () {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }

	    history = [];
	  },
	  getHistory: function () {
	    return history;
	  }
	};

	module.exports = ReactHostOperationHistoryHook;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	var performance = __webpack_require__(72);

	var performanceNow;

	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}

	module.exports = performanceNow;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);

	var performance;

	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}

	module.exports = performance || {};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	var OBSERVED_ERROR = {};

	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var TransactionImpl = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },

	  _isInTransaction: false,

	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,

	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },

	  /* eslint-disable space-before-function-paren */

	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    /* eslint-enable space-before-function-paren */
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },

	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },

	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};

	module.exports = TransactionImpl;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactDOMComponentTree = __webpack_require__(39);

	function isCheckable(elem) {
	  var type = elem.type;
	  var nodeName = elem.nodeName;
	  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
	}

	function getTracker(inst) {
	  return inst._wrapperState.valueTracker;
	}

	function attachTracker(inst, tracker) {
	  inst._wrapperState.valueTracker = tracker;
	}

	function detachTracker(inst) {
	  delete inst._wrapperState.valueTracker;
	}

	function getValueFromNode(node) {
	  var value;
	  if (node) {
	    value = isCheckable(node) ? '' + node.checked : node.value;
	  }
	  return value;
	}

	var inputValueTracking = {
	  // exposed for testing
	  _getTrackerFromNode: function (node) {
	    return getTracker(ReactDOMComponentTree.getInstanceFromNode(node));
	  },


	  track: function (inst) {
	    if (getTracker(inst)) {
	      return;
	    }

	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var valueField = isCheckable(node) ? 'checked' : 'value';
	    var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

	    var currentValue = '' + node[valueField];

	    // if someone has already defined a value or Safari, then bail
	    // and don't track value will cause over reporting of changes,
	    // but it's better then a hard failure
	    // (needed for certain tests that spyOn input values and Safari)
	    if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
	      return;
	    }

	    Object.defineProperty(node, valueField, {
	      enumerable: descriptor.enumerable,
	      configurable: true,
	      get: function () {
	        return descriptor.get.call(this);
	      },
	      set: function (value) {
	        currentValue = '' + value;
	        descriptor.set.call(this, value);
	      }
	    });

	    attachTracker(inst, {
	      getValue: function () {
	        return currentValue;
	      },
	      setValue: function (value) {
	        currentValue = '' + value;
	      },
	      stopTracking: function () {
	        detachTracker(inst);
	        delete node[valueField];
	      }
	    });
	  },

	  updateValueIfChanged: function (inst) {
	    if (!inst) {
	      return false;
	    }
	    var tracker = getTracker(inst);

	    if (!tracker) {
	      inputValueTracking.track(inst);
	      return true;
	    }

	    var lastValue = tracker.getValue();
	    var nextValue = getValueFromNode(ReactDOMComponentTree.getNodeFromInstance(inst));

	    if (nextValue !== lastValue) {
	      tracker.setValue(nextValue);
	      return true;
	    }

	    return false;
	  },
	  stopTracking: function (inst) {
	    var tracker = getTracker(inst);
	    if (tracker) {
	      tracker.stopTracking();
	    }
	  }
	};

	module.exports = inputValueTracking;

/***/ }),
/* 75 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */

	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;

	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }

	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}

	module.exports = getEventTarget;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);

	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}

	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }

	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;

	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }

	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }

	  return isSupported;
	}

	module.exports = isEventSupported;

/***/ }),
/* 77 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */

	var supportedInputTypes = {
	  color: true,
	  date: true,
	  datetime: true,
	  'datetime-local': true,
	  email: true,
	  month: true,
	  number: true,
	  password: true,
	  range: true,
	  search: true,
	  tel: true,
	  text: true,
	  time: true,
	  url: true,
	  week: true
	};

	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }

	  if (nodeName === 'textarea') {
	    return true;
	  }

	  return false;
	}

	module.exports = isTextInputElement;

/***/ }),
/* 78 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */

	var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

	module.exports = DefaultEventPluginOrder;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var EventPropagators = __webpack_require__(46);
	var ReactDOMComponentTree = __webpack_require__(39);
	var SyntheticMouseEvent = __webpack_require__(80);

	var eventTypes = {
	  mouseEnter: {
	    registrationName: 'onMouseEnter',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  },
	  mouseLeave: {
	    registrationName: 'onMouseLeave',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  }
	};

	var EnterLeaveEventPlugin = {
	  eventTypes: eventTypes,

	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }

	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }

	    var from;
	    var to;
	    if (topLevelType === 'topMouseOut') {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }

	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }

	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;

	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;

	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

	    return [leave, enter];
	  }
	};

	module.exports = EnterLeaveEventPlugin;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(81);
	var ViewportMetrics = __webpack_require__(82);

	var getEventModifierState = __webpack_require__(83);

	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

	module.exports = SyntheticMouseEvent;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(58);

	var getEventTarget = __webpack_require__(75);

	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }

	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }

	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

	module.exports = SyntheticUIEvent;

/***/ }),
/* 82 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ViewportMetrics = {
	  currentScrollLeft: 0,

	  currentScrollTop: 0,

	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	};

	module.exports = ViewportMetrics;

/***/ }),
/* 83 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */

	var modifierKeyToProp = {
	  Alt: 'altKey',
	  Control: 'ctrlKey',
	  Meta: 'metaKey',
	  Shift: 'shiftKey'
	};

	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}

	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}

	module.exports = getEventModifierState;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(41);

	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    // specifies target context for links with `preload` type
	    as: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    playsInline: HAS_BOOLEAN_VALUE,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,

	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,

	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {},
	  DOMMutationMethods: {
	    value: function (node, value) {
	      if (value == null) {
	        return node.removeAttribute('value');
	      }

	      // Number inputs get special treatment due to some edge cases in
	      // Chrome. Let everything else assign the value attribute as normal.
	      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
	      if (node.type !== 'number' || node.hasAttribute('value') === false) {
	        node.setAttribute('value', '' + value);
	      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
	        // Don't assign an attribute if validation reports bad
	        // input. Chrome will clear the value. Additionally, don't
	        // operate on inputs that have focus, otherwise Chrome might
	        // strip off trailing decimal places and cause the user's
	        // cursor position to jump to the beginning of the input.
	        //
	        // In ReactDOMInput, we have an onBlur event that will trigger
	        // this function again when focus is lost.
	        node.setAttribute('value', '' + value);
	      }
	    }
	  }
	};

	module.exports = HTMLDOMPropertyConfig;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMChildrenOperations = __webpack_require__(86);
	var ReactDOMIDOperations = __webpack_require__(97);

	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	};

	module.exports = ReactComponentBrowserEnvironment;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMLazyTree = __webpack_require__(87);
	var Danger = __webpack_require__(93);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactInstrumentation = __webpack_require__(67);

	var createMicrosoftUnsafeLocalFunction = __webpack_require__(90);
	var setInnerHTML = __webpack_require__(89);
	var setTextContent = __webpack_require__(91);

	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}

	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});

	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}

	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}

	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}

	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}

	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}

	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }

	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation({
	      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
	      type: 'replace text',
	      payload: stringText
	    });
	  }
	}

	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: prevInstance._debugID,
	        type: 'replace with',
	        payload: markup.toString()
	      });
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: nextInstance._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  };
	}

	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

	  replaceDelimitedText: replaceDelimitedText,

	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function (parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }

	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case 'INSERT_MARKUP':
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'insert child',
	              payload: {
	                toIndex: update.toIndex,
	                content: update.content.toString()
	              }
	            });
	          }
	          break;
	        case 'MOVE_EXISTING':
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'move child',
	              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
	            });
	          }
	          break;
	        case 'SET_MARKUP':
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace children',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'TEXT_CONTENT':
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace text',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'REMOVE_NODE':
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'remove child',
	              payload: { fromIndex: update.fromIndex }
	            });
	          }
	          break;
	      }
	    }
	  }
	};

	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMNamespaces = __webpack_require__(88);
	var setInnerHTML = __webpack_require__(89);

	var createMicrosoftUnsafeLocalFunction = __webpack_require__(90);
	var setTextContent = __webpack_require__(91);

	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}

	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});

	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}

	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}

	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}

	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}

	function toString() {
	  return this.node.nodeName;
	}

	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}

	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;

	module.exports = DOMLazyTree;

/***/ }),
/* 88 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};

	module.exports = DOMNamespaces;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);
	var DOMNamespaces = __webpack_require__(88);

	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

	var createMicrosoftUnsafeLocalFunction = __webpack_require__(90);

	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;

	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var svgNode = reusableSVGContainer.firstChild;
	    while (svgNode.firstChild) {
	      node.appendChild(svgNode.firstChild);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});

	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }

	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xfeff) + html;

	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}

	module.exports = setInnerHTML;

/***/ }),
/* 90 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	/* globals MSApp */

	'use strict';

	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */

	var createMicrosoftUnsafeLocalFunction = function (func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};

	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);
	var escapeTextContentForBrowser = __webpack_require__(92);
	var setInnerHTML = __webpack_require__(89);

	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  if (text) {
	    var firstChild = node.firstChild;

	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};

	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      if (node.nodeType === 3) {
	        node.nodeValue = text;
	        return;
	      }
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}

	module.exports = setTextContent;

/***/ }),
/* 92 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */

	'use strict';

	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */

	var matchHtmlRegExp = /["'&<>]/;

	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */

	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);

	  if (!match) {
	    return str;
	  }

	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;

	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }

	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }

	    lastIndex = index + 1;
	    html += escape;
	  }

	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html

	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}

	module.exports = escapeTextContentForBrowser;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var DOMLazyTree = __webpack_require__(87);
	var ExecutionEnvironment = __webpack_require__(53);

	var createNodesFromMarkup = __webpack_require__(94);
	var emptyFunction = __webpack_require__(9);
	var invariant = __webpack_require__(12);

	var Danger = {
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	};

	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	/*eslint-disable fb-www/unsafe-html*/

	var ExecutionEnvironment = __webpack_require__(53);

	var createArrayFromMixed = __webpack_require__(95);
	var getMarkupWrap = __webpack_require__(96);
	var invariant = __webpack_require__(12);

	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;

	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}

	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);

	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];

	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }

	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }

	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}

	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	var invariant = __webpack_require__(12);

	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;

	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }

	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}

	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}

	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}

	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	/*eslint-disable fb-www/unsafe-html */

	var ExecutionEnvironment = __webpack_require__(53);

	var invariant = __webpack_require__(12);

	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */

	var shouldWrap = {};

	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],

	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],

	  'optgroup': selectWrap,
	  'option': selectWrap,

	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,

	  'td': trWrap,
	  'th': trWrap
	};

	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});

	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}

	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMChildrenOperations = __webpack_require__(86);
	var ReactDOMComponentTree = __webpack_require__(39);

	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};

	module.exports = ReactDOMIDOperations;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	/* global hasOwnProperty:true */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var AutoFocusUtils = __webpack_require__(99);
	var CSSPropertyOperations = __webpack_require__(101);
	var DOMLazyTree = __webpack_require__(87);
	var DOMNamespaces = __webpack_require__(88);
	var DOMProperty = __webpack_require__(41);
	var DOMPropertyOperations = __webpack_require__(109);
	var EventPluginHub = __webpack_require__(47);
	var EventPluginRegistry = __webpack_require__(48);
	var ReactBrowserEventEmitter = __webpack_require__(111);
	var ReactDOMComponentFlags = __webpack_require__(42);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactDOMInput = __webpack_require__(114);
	var ReactDOMOption = __webpack_require__(117);
	var ReactDOMSelect = __webpack_require__(118);
	var ReactDOMTextarea = __webpack_require__(119);
	var ReactInstrumentation = __webpack_require__(67);
	var ReactMultiChild = __webpack_require__(120);
	var ReactServerRenderingTransaction = __webpack_require__(139);

	var emptyFunction = __webpack_require__(9);
	var escapeTextContentForBrowser = __webpack_require__(92);
	var invariant = __webpack_require__(12);
	var isEventSupported = __webpack_require__(76);
	var shallowEqual = __webpack_require__(129);
	var inputValueTracking = __webpack_require__(74);
	var validateDOMNesting = __webpack_require__(142);
	var warning = __webpack_require__(8);

	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;

	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { string: true, number: true };

	var STYLE = 'style';
	var HTML = '__html';
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};

	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;

	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}

	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}

	var styleMutationWarning = {};

	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }

	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }

	  var hash = ownerName + '|' + componentName;

	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }

	  styleMutationWarning[hash] = true;

	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}

	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}

	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), "This browser doesn't support the `onScroll` event") : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}

	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}

	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}

	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}

	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}

	var setAndValidateContentChildDev = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setAndValidateContentChildDev = function (content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;

	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }

	    validateDOMNesting(null, String(content), this, this._ancestorInfo);
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}

	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};

	function trackInputValue() {
	  inputValueTracking.track(this);
	}

	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
	      break;
	  }
	}

	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}

	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.

	var omittedCloseTags = {
	  area: true,
	  base: true,
	  br: true,
	  col: true,
	  embed: true,
	  hr: true,
	  img: true,
	  input: true,
	  keygen: true,
	  link: true,
	  meta: true,
	  param: true,
	  source: true,
	  track: true,
	  wbr: true
	  // NOTE: menuitem's close tag should be omitted, but that causes problems.
	};

	var newlineEatingTags = {
	  listing: true,
	  pre: true,
	  textarea: true
	};

	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.

	var voidElementTags = _assign({
	  menuitem: true
	}, omittedCloseTags);

	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name

	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;

	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}

	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}

	var globalIdCounter = 1;

	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setAndValidateContentChildDev.call(this, null);
	  }
	}

	ReactDOMComponent.displayName = 'ReactDOMComponent';

	ReactDOMComponent.Mixin = {
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;

	    var props = this._currentElement.props;

	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trackInputValue, this);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trackInputValue, this);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }

	    assertValidProps(this, props);

	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;

	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, null, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }

	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }

	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }

	    return mountImage;
	  },

	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;

	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }

	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }

	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },

	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';

	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },

	  _createInitialChildren: function (transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      // TODO: Validate that text is allowed as a child of this node
	      if (contentToUse != null) {
	        // Avoid setting textContent when the text is empty. In IE11 setting
	        // textContent on a text area will cause the placeholder to not
	        // show within the textarea until it has been focused and blurred again.
	        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
	        if (contentToUse !== '') {
	          if (process.env.NODE_ENV !== 'production') {
	            setAndValidateContentChildDev.call(this, contentToUse);
	          }
	          DOMLazyTree.queueText(lazyTree, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },

	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },

	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;

	    switch (this._tag) {
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }

	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);

	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },

	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },

	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;

	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }

	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setAndValidateContentChildDev.call(this, null);
	      }

	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },

	  getHostNode: function () {
	    return getNode(this);
	  },

	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	      case 'textarea':
	        inputValueTracking.stopTracking(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }

	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;

	    if (process.env.NODE_ENV !== 'production') {
	      setAndValidateContentChildDev.call(this, null);
	    }
	  },

	  getPublicInstance: function () {
	    return getNode(this);
	  }
	};

	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactDOMComponentTree = __webpack_require__(39);

	var focusNode = __webpack_require__(100);

	var AutoFocusUtils = {
	  focusDOMComponent: function () {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};

	module.exports = AutoFocusUtils;

/***/ }),
/* 100 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * @param {DOMElement} node input/textarea to focus
	 */

	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}

	module.exports = focusNode;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var CSSProperty = __webpack_require__(102);
	var ExecutionEnvironment = __webpack_require__(53);
	var ReactInstrumentation = __webpack_require__(67);

	var camelizeStyleName = __webpack_require__(103);
	var dangerousStyleValue = __webpack_require__(105);
	var hyphenateStyleName = __webpack_require__(106);
	var memoizeStringOnly = __webpack_require__(108);
	var warning = __webpack_require__(8);

	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});

	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}

	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;

	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;

	  var warnHyphenatedStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }

	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };

	  var warnBadVendoredStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }

	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };

	  var warnStyleValueWithSemicolon = function (name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }

	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, "Style property values shouldn't contain a semicolon.%s " + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };

	  var warnStyleValueIsNaN = function (name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }

	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };

	  var checkRenderMessage = function (owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };

	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function (name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }

	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}

	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var isCustomProperty = styleName.indexOf('--') === 0;
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        if (!isCustomProperty) {
	          warnValidStyle(styleName, styleValue, component);
	        }
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component, isCustomProperty) + ';';
	      }
	    }
	    return serialized || null;
	  },

	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function (node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: component._debugID,
	        type: 'update styles',
	        payload: styles
	      });
	    }

	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var isCustomProperty = styleName.indexOf('--') === 0;
	      if (process.env.NODE_ENV !== 'production') {
	        if (!isCustomProperty) {
	          warnValidStyle(styleName, styles[styleName], component);
	        }
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component, isCustomProperty);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (isCustomProperty) {
	        style.setProperty(styleName, styleValue);
	      } else if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	};

	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 102 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */

	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridRowEnd: true,
	  gridRowSpan: true,
	  gridRowStart: true,
	  gridColumn: true,
	  gridColumnEnd: true,
	  gridColumnSpan: true,
	  gridColumnStart: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,

	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};

	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}

	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});

	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};

	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};

	module.exports = CSSProperty;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	'use strict';

	var camelize = __webpack_require__(104);

	var msPattern = /^-ms-/;

	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}

	module.exports = camelizeStyleName;

/***/ }),
/* 104 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	var _hyphenPattern = /-(.)/g;

	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}

	module.exports = camelize;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var CSSProperty = __webpack_require__(102);
	var warning = __webpack_require__(8);

	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};

	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component, isCustomProperty) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901

	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }

	  var isNonNumeric = isNaN(value);
	  if (isCustomProperty || isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }

	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}

	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	'use strict';

	var hyphenate = __webpack_require__(107);

	var msPattern = /^ms-/;

	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}

	module.exports = hyphenateStyleName;

/***/ }),
/* 107 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	var _uppercasePattern = /([A-Z])/g;

	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}

	module.exports = hyphenate;

/***/ }),
/* 108 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */

	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}

	module.exports = memoizeStringOnly;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(41);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactInstrumentation = __webpack_require__(67);

	var quoteAttributeValueForBrowser = __webpack_require__(110);
	var warning = __webpack_require__(8);

	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};

	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}

	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}

	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },

	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },

	  createMarkupForRoot: function () {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },

	  setAttributeForRoot: function (node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },

	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },

	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },

	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },

	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },

	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function (node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  },

	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  }
	};

	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var escapeTextContentForBrowser = __webpack_require__(92);

	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}

	module.exports = quoteAttributeValueForBrowser;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var EventPluginRegistry = __webpack_require__(48);
	var ReactEventEmitterMixin = __webpack_require__(112);
	var ViewportMetrics = __webpack_require__(82);

	var getVendorPrefixedEventName = __webpack_require__(113);
	var isEventSupported = __webpack_require__(76);

	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */

	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;

	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};

	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}

	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,

	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },

	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },

	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },

	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === 'topWheel') {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === 'topScroll') {
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === 'topFocus' || dependency === 'topBlur') {
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
	          }

	          // to make sure blur and focus event listeners are only attached once
	          isListening.topBlur = true;
	          isListening.topFocus = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }

	        isListening[dependency] = true;
	      }
	    }
	  },

	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },

	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },

	  /**
	   * Protect against document.createEvent() returning null
	   * Some popup blocker extensions appear to do this:
	   * https://github.com/facebook/react/issues/6887
	   */
	  supportsEventPageXY: function () {
	    if (!document.createEvent) {
	      return false;
	    }
	    var ev = document.createEvent('MouseEvent');
	    return ev != null && 'pageX' in ev;
	  },

	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	});

	module.exports = ReactBrowserEventEmitter;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var EventPluginHub = __webpack_require__(47);

	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}

	var ReactEventEmitterMixin = {
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};

	module.exports = ReactEventEmitterMixin;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);

	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};

	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

	  return prefixes;
	}

	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};

	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};

	/**
	 * Element to check for prefixes on.
	 */
	var style = {};

	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;

	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }

	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}

	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }

	  var prefixMap = vendorPrefixes[eventName];

	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }

	  return '';
	}

	module.exports = getVendorPrefixedEventName;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var DOMPropertyOperations = __webpack_require__(109);
	var LinkedValueUtils = __webpack_require__(115);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactUpdates = __webpack_require__(61);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;

	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}

	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked != null : props.value != null;
	}

	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function (inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);

	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });

	    return hostProps;
	  },

	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

	      var owner = inst._currentElement._owner;

	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }

	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      controlled: isControlled(props)
	    };
	  },

	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;

	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }

	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }

	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      if (value === 0 && node.value === '') {
	        node.value = '0';
	        // Note: IE9 reports a number inputs as 'text', so check props instead.
	      } else if (props.type === 'number') {
	        // Simulate `input.valueAsNumber`. IE9 does not support it
	        var valueAsNumber = parseFloat(node.value, 10) || 0;

	        if (
	        // eslint-disable-next-line
	        value != valueAsNumber ||
	        // eslint-disable-next-line
	        value == valueAsNumber && node.value != value) {
	          // Cast `value` to a string to ensure the value is set correctly. While
	          // browsers typically do this as necessary, jsdom doesn't.
	          node.value = '' + value;
	        }
	      } else if (node.value !== '' + value) {
	        // Cast `value` to a string to ensure the value is set correctly. While
	        // browsers typically do this as necessary, jsdom doesn't.
	        node.value = '' + value;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        // In Chrome, assigning defaultValue to certain input types triggers input validation.
	        // For number inputs, the display value loses trailing decimal points. For email inputs,
	        // Chrome raises "The specified value <x> is not a valid email address".
	        //
	        // Here we check to see if the defaultValue has actually changed, avoiding these problems
	        // when the user is inputting text
	        //
	        // https://github.com/facebook/react/issues/7253
	        if (node.defaultValue !== '' + props.defaultValue) {
	          node.defaultValue = '' + props.defaultValue;
	        }
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },

	  postMountWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.

	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }

	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;

	  var returnValue = LinkedValueUtils.executeOnChange(props, event);

	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);

	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;

	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }

	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }

	  return returnValue;
	}

	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactPropTypesSecret = __webpack_require__(116);
	var propTypesFactory = __webpack_require__(29);

	var React = __webpack_require__(2);
	var PropTypes = propTypesFactory(React.isValidElement);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	var hasReadOnlyValue = {
	  button: true,
	  checkbox: true,
	  image: true,
	  hidden: true,
	  radio: true,
	  reset: true,
	  submit: true
	};

	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}

	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}

	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: PropTypes.func
	};

	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};

	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 116 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var React = __webpack_require__(2);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactDOMSelect = __webpack_require__(118);

	var warning = __webpack_require__(8);
	var didWarnInvalidOptionChildren = false;

	function flattenChildren(children) {
	  var content = '';

	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  React.Children.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });

	  return content;
	}

	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }

	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;

	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }

	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }

	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }

	    inst._wrapperState = { selected: selected };
	  },

	  postMountWrapper: function (inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },

	  getHostProps: function (inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);

	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }

	    var content = flattenChildren(props.children);

	    if (content) {
	      hostProps.children = content;
	    }

	    return hostProps;
	  }
	};

	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var LinkedValueUtils = __webpack_require__(115);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactUpdates = __webpack_require__(61);

	var warning = __webpack_require__(8);

	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;

	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;

	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);

	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}

	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	var valuePropNames = ['value', 'defaultValue'];

	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);

	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }

	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}

	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}

	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function (inst, props) {
	    return _assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },

	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }

	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };

	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },

	  getSelectValueContext: function (inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },

	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;

	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);

	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);

	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}

	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var LinkedValueUtils = __webpack_require__(115);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactUpdates = __webpack_require__(61);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;

	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}

	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function (inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;

	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, props, {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });

	    return hostProps;
	  },

	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }

	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;

	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }

	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }

	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },

	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;

	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },

	  postMountWrapper: function (inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var textContent = node.textContent;

	    // Only set node.value if textContent is equal to the expected
	    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
	    // will populate textContent as well.
	    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
	    if (textContent === inst._wrapperState.initialValue) {
	      node.value = textContent;
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}

	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactComponentEnvironment = __webpack_require__(121);
	var ReactInstanceMap = __webpack_require__(122);
	var ReactInstrumentation = __webpack_require__(67);

	var ReactCurrentOwner = __webpack_require__(17);
	var ReactReconciler = __webpack_require__(64);
	var ReactChildReconciler = __webpack_require__(123);

	var emptyFunction = __webpack_require__(9);
	var flattenChildren = __webpack_require__(138);
	var invariant = __webpack_require__(12);

	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'INSERT_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}

	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'MOVE_EXISTING',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}

	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'REMOVE_NODE',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}

	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'SET_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}

	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'TEXT_CONTENT',
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}

	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}

	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}

	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function (inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function (children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}

	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },

	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },

	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;

	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }

	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }

	      return mountImages;
	    },

	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },

	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },

	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },

	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;

	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },

	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function (safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },

	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },

	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },

	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child, node) {
	      return makeRemove(child, node);
	    },

	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },

	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	  }
	};

	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	var injected = false;

	var ReactComponentEnvironment = {
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,

	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,

	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	};

	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 122 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */

	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

	var ReactInstanceMap = {
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },

	  get: function (key) {
	    return key._reactInternalInstance;
	  },

	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },

	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	};

	module.exports = ReactInstanceMap;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactReconciler = __webpack_require__(64);

	var instantiateReactComponent = __webpack_require__(124);
	var KeyEscapeUtils = __webpack_require__(134);
	var shouldUpdateReactComponent = __webpack_require__(130);
	var traverseAllChildren = __webpack_require__(135);
	var warning = __webpack_require__(8);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(24);
	}

	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(24);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}

	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID) // 0 in production and for roots
	  {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};

	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },

	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) // 0 in production and for roots
	  {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },

	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	};

	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var ReactCompositeComponent = __webpack_require__(125);
	var ReactEmptyComponent = __webpack_require__(131);
	var ReactHostComponent = __webpack_require__(132);

	var getNextDebugID = __webpack_require__(133);
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function (element) {
	  this.construct(element);
	};

	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}

	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;

	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    var type = element.type;
	    if (typeof type !== 'function' && typeof type !== 'string') {
	      var info = '';
	      if (process.env.NODE_ENV !== 'production') {
	        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
	          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
	        }
	      }
	      info += getDeclarationErrorAddendum(element._owner);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
	    }

	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);

	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
	  }

	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }

	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;

	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
	  }

	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }

	  return instance;
	}

	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
	  _instantiateReactComponent: instantiateReactComponent
	});

	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var React = __webpack_require__(2);
	var ReactComponentEnvironment = __webpack_require__(121);
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactErrorUtils = __webpack_require__(50);
	var ReactInstanceMap = __webpack_require__(122);
	var ReactInstrumentation = __webpack_require__(67);
	var ReactNodeTypes = __webpack_require__(126);
	var ReactReconciler = __webpack_require__(64);

	if (process.env.NODE_ENV !== 'production') {
	  var checkReactTypeSpec = __webpack_require__(127);
	}

	var emptyObject = __webpack_require__(11);
	var invariant = __webpack_require__(12);
	var shallowEqual = __webpack_require__(129);
	var shouldUpdateReactComponent = __webpack_require__(130);
	var warning = __webpack_require__(8);

	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};

	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};

	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}

	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}

	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}

	// Separated into a function to contain deoptimizations caused by try/finally.
	function measureLifeCyclePerf(fn, debugID, timerType) {
	  if (debugID === 0) {
	    // Top-level wrappers (see ReactMount) and empty components (see
	    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
	    // Both are implementation details that should go away in the future.
	    return fn();
	  }

	  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
	  try {
	    return fn();
	  } finally {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
	  }
	}

	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */

	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;

	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponent = {
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;

	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;

	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;

	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;

	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;

	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },

	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var _this = this;

	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;

	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);

	    var Component = this._currentElement.type;

	    var updateQueue = transaction.getUpdateQueue();

	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;

	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }

	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';

	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", componentName, componentName) : void 0;
	    }

	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;

	    this._instance = inst;

	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);

	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }

	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;

	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;

	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }

	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(function () {
	            return inst.componentDidMount();
	          }, _this._debugID, 'componentDidMount');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }

	    return markup;
	  },

	  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },

	  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;

	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        return measureLifeCyclePerf(function () {
	          return new Component(publicProps, publicContext, updateQueue);
	        }, this._debugID, 'ctor');
	      } else {
	        return new Component(publicProps, publicContext, updateQueue);
	      }
	    }

	    // This can still be an instance in case of factory components
	    // but we'll count this as time spent rendering as the more common case.
	    if (process.env.NODE_ENV !== 'production') {
	      return measureLifeCyclePerf(function () {
	        return Component(publicProps, publicContext, updateQueue);
	      }, this._debugID, 'render');
	    } else {
	      return Component(publicProps, publicContext, updateQueue);
	    }
	  },

	  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();

	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);

	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },

	  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;

	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }

	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillMount();
	        }, debugID, 'componentWillMount');
	      } else {
	        inst.componentWillMount();
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }

	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }

	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;

	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

	    if (process.env.NODE_ENV !== 'production') {
	      if (debugID !== 0) {
	        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	      }
	    }

	    return markup;
	  },

	  getHostNode: function () {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },

	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    if (!this._renderedComponent) {
	      return;
	    }

	    var inst = this._instance;

	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;

	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          measureLifeCyclePerf(function () {
	            return inst.componentWillUnmount();
	          }, this._debugID, 'componentWillUnmount');
	        } else {
	          inst.componentWillUnmount();
	        }
	      }
	    }

	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }

	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;

	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;

	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);

	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },

	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },

	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
	      }
	    }
	    return maskedContext;
	  },

	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext;

	    if (inst.getChildContext) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	        try {
	          childContext = inst.getChildContext();
	        } finally {
	          ReactInstrumentation.debugTool.onEndProcessingChildContext();
	        }
	      } else {
	        childContext = inst.getChildContext();
	      }
	    }

	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, 'child context');
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },

	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function (typeSpecs, values, location) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	    }
	  },

	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;

	    this._pendingElement = null;

	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },

	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },

	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;

	    var willReceive = false;
	    var nextContext;

	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }

	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;

	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }

	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillReceiveProps(nextProps, nextContext);
	        }, this._debugID, 'componentWillReceiveProps');
	      } else {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }

	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;

	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          shouldUpdate = measureLifeCyclePerf(function () {
	            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	          }, this._debugID, 'shouldComponentUpdate');
	        } else {
	          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }

	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },

	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;

	    if (!queue) {
	      return inst.state;
	    }

	    if (replace && queue.length === 1) {
	      return queue[0];
	    }

	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }

	    return nextState;
	  },

	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var _this2 = this;

	    var inst = this._instance;

	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }

	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillUpdate(nextProps, nextState, nextContext);
	        }, this._debugID, 'componentWillUpdate');
	      } else {
	        inst.componentWillUpdate(nextProps, nextState, nextContext);
	      }
	    }

	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;

	    this._updateRenderedComponent(transaction, unmaskedContext);

	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },

	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();

	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }

	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);

	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;

	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

	      if (process.env.NODE_ENV !== 'production') {
	        if (debugID !== 0) {
	          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	        }
	      }

	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },

	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },

	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	    var renderedElement;

	    if (process.env.NODE_ENV !== 'production') {
	      renderedElement = measureLifeCyclePerf(function () {
	        return inst.render();
	      }, this._debugID, 'render');
	    } else {
	      renderedElement = inst.render();
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedElement === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedElement = null;
	      }
	    }

	    return renderedElement;
	  },

	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedElement;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;

	    return renderedElement;
	  },

	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },

	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },

	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },

	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },

	  // Stub
	  _instantiateReactComponent: null
	};

	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var React = __webpack_require__(2);

	var invariant = __webpack_require__(12);

	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,

	  getType: function (node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (React.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};

	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactPropTypeLocationNames = __webpack_require__(128);
	var ReactPropTypesSecret = __webpack_require__(116);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(24);
	}

	var loggedTypeFailures = {};

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var componentStackInfo = '';

	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(24);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }

	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}

	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var ReactPropTypeLocationNames = {};

	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}

	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 129 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */

	/*eslint-disable no-self-compare */

	'use strict';

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}

	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }

	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }

	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);

	  if (keysA.length !== keysB.length) {
	    return false;
	  }

	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }

	  return true;
	}

	module.exports = shallowEqual;

/***/ }),
/* 130 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */

	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }

	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}

	module.exports = shouldUpdateReactComponent;

/***/ }),
/* 131 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var emptyComponentFactory;

	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function (factory) {
	    emptyComponentFactory = factory;
	  }
	};

	var ReactEmptyComponent = {
	  create: function (instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};

	ReactEmptyComponent.injection = ReactEmptyComponentInjection;

	module.exports = ReactEmptyComponent;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	var genericComponentClass = null;
	var textComponentClass = null;

	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  }
	};

	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}

	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}

	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}

	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};

	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 133 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var nextDebugID = 1;

	function getNextDebugID() {
	  return nextDebugID++;
	}

	module.exports = getNextDebugID;

/***/ }),
/* 134 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */

	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });

	  return '$' + escapedString;
	}

	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}

	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};

	module.exports = KeyEscapeUtils;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactCurrentOwner = __webpack_require__(17);
	var REACT_ELEMENT_TYPE = __webpack_require__(136);

	var getIteratorFn = __webpack_require__(137);
	var invariant = __webpack_require__(12);
	var KeyEscapeUtils = __webpack_require__(134);
	var warning = __webpack_require__(8);

	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';

	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */

	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */

	var didWarnAboutMaps = false;

	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}

	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;

	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }

	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }

	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }

	  return subtreeCount;
	}

	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }

	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}

	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 136 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.

	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

	module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 137 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	/* global Symbol */

	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}

	module.exports = getIteratorFn;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var KeyEscapeUtils = __webpack_require__(134);
	var traverseAllChildren = __webpack_require__(135);
	var warning = __webpack_require__(8);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(24);
	}

	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && typeof traverseContext === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(24);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}

	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};

	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}

	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var PooledClass = __webpack_require__(55);
	var Transaction = __webpack_require__(73);
	var ReactInstrumentation = __webpack_require__(67);
	var ReactServerUpdateQueue = __webpack_require__(140);

	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];

	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}

	var noopCallbackQueue = {
	  enqueue: function () {}
	};

	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}

	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return noopCallbackQueue;
	  },

	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return this.updateQueue;
	  },

	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {},

	  checkpoint: function () {},

	  rollback: function () {}
	};

	_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

	PooledClass.addPoolingTo(ReactServerRenderingTransaction);

	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ReactUpdateQueue = __webpack_require__(141);

	var warning = __webpack_require__(8);

	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}

	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */

	var ReactServerUpdateQueue = function () {
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);

	    this.transaction = transaction;
	  }

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */


	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */


	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */


	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */


	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */


	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };

	  return ReactServerUpdateQueue;
	}();

	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactCurrentOwner = __webpack_require__(17);
	var ReactInstanceMap = __webpack_require__(122);
	var ReactInstrumentation = __webpack_require__(67);
	var ReactUpdates = __webpack_require__(61);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}

	function formatUnexpectedArgument(arg) {
	  var type = typeof arg;
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}

	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }

	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + "within `render` or another component's constructor). Render methods " + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }

	  return internalInstance;
	}

	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }

	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },

	  enqueueCallbackInternal: function (internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

	    if (!internalInstance) {
	      return;
	    }

	    internalInstance._pendingForceUpdate = true;

	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState, callback) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

	    if (!internalInstance) {
	      return;
	    }

	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;

	    // Future-proof 15.5
	    if (callback !== undefined && callback !== null) {
	      ReactUpdateQueue.validateCallback(callback, 'replaceState');
	      if (internalInstance._pendingCallbacks) {
	        internalInstance._pendingCallbacks.push(callback);
	      } else {
	        internalInstance._pendingCallbacks = [callback];
	      }
	    }

	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }

	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

	    if (!internalInstance) {
	      return;
	    }

	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);

	    enqueueUpdate(internalInstance);
	  },

	  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },

	  validateCallback: function (callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	};

	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var emptyFunction = __webpack_require__(9);
	var warning = __webpack_require__(8);

	var validateDOMNesting = emptyFunction;

	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.

	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];

	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);

	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

	  var emptyAncestorInfo = {
	    current: null,

	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,

	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };

	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };

	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }

	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }

	    ancestorInfo.current = info;

	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }

	    return ancestorInfo;
	  };

	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }

	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;

	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }

	    return true;
	  };

	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	      case 'pre':
	      case 'listing':
	      case 'table':
	      case 'hr':
	      case 'xmp':
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;

	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;

	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;

	      case 'button':
	        return ancestorInfo.buttonTagInScope;

	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;

	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }

	    return null;
	  };

	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }

	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };

	  var didWarn = {};

	  validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;

	    if (childText != null) {
	      process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
	      childTag = '#text';
	    }

	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;

	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;

	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);

	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;

	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }

	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;

	      var tagDisplayName = childTag;
	      var whitespaceInfo = '';
	      if (childTag === '#text') {
	        if (/\S/.test(childText)) {
	          tagDisplayName = 'Text nodes';
	        } else {
	          tagDisplayName = 'Whitespace text nodes';
	          whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
	        }
	      } else {
	        tagDisplayName = '<' + childTag + '>';
	      }

	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };

	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}

	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var DOMLazyTree = __webpack_require__(87);
	var ReactDOMComponentTree = __webpack_require__(39);

	var ReactDOMEmptyComponent = function (instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;

	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function () {},
	  getHostNode: function () {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function () {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});

	module.exports = ReactDOMEmptyComponent;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }

	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }

	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }

	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}

	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;

	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}

	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;

	  return inst._hostParent;
	}

	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], 'captured', arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], 'bubbled', arg);
	  }
	}

	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], 'bubbled', argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], 'captured', argTo);
	  }
	}

	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var DOMChildrenOperations = __webpack_require__(86);
	var DOMLazyTree = __webpack_require__(87);
	var ReactDOMComponentTree = __webpack_require__(39);

	var escapeTextContentForBrowser = __webpack_require__(92);
	var invariant = __webpack_require__(12);
	var validateDOMNesting = __webpack_require__(142);

	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;

	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};

	_assign(ReactDOMTextComponent.prototype, {
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(null, this._stringText, this, parentInfo);
	      }
	    }

	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);

	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }

	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },

	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },

	  getHostNode: function () {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },

	  unmountComponent: function () {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});

	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var ReactUpdates = __webpack_require__(61);
	var Transaction = __webpack_require__(73);

	var emptyFunction = __webpack_require__(9);

	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};

	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};

	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}

	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});

	var transaction = new ReactDefaultBatchingStrategyTransaction();

	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,

	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      return callback(a, b, c, d, e);
	    } else {
	      return transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};

	module.exports = ReactDefaultBatchingStrategy;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var EventListener = __webpack_require__(148);
	var ExecutionEnvironment = __webpack_require__(53);
	var PooledClass = __webpack_require__(55);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactUpdates = __webpack_require__(61);

	var getEventTarget = __webpack_require__(75);
	var getUnboundedScrollPosition = __webpack_require__(149);

	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}

	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);

	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}

	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}

	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,

	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },

	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },

	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },

	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },

	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },

	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },

	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }

	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};

	module.exports = ReactEventListener;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */

	var emptyFunction = __webpack_require__(9);

	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },

	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },

	  registerDefault: function registerDefault() {}
	};

	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 149 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	'use strict';

	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */

	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable.Window && scrollable instanceof scrollable.Window) {
	    return {
	      x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
	      y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}

	module.exports = getUnboundedScrollPosition;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(41);
	var EventPluginHub = __webpack_require__(47);
	var EventPluginUtils = __webpack_require__(49);
	var ReactComponentEnvironment = __webpack_require__(121);
	var ReactEmptyComponent = __webpack_require__(131);
	var ReactBrowserEventEmitter = __webpack_require__(111);
	var ReactHostComponent = __webpack_require__(132);
	var ReactUpdates = __webpack_require__(61);

	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};

	module.exports = ReactInjection;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(55);
	var ReactBrowserEventEmitter = __webpack_require__(111);
	var ReactInputSelection = __webpack_require__(152);
	var ReactInstrumentation = __webpack_require__(67);
	var Transaction = __webpack_require__(73);
	var ReactUpdateQueue = __webpack_require__(141);

	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};

	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },

	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};

	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },

	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};

	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}

	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}

	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },

	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return ReactUpdateQueue;
	  },

	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function () {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },

	  rollback: function (checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },

	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};

	_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

	PooledClass.addPoolingTo(ReactReconcileTransaction);

	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactDOMSelection = __webpack_require__(153);

	var containsNode = __webpack_require__(155);
	var focusNode = __webpack_require__(100);
	var getActiveElement = __webpack_require__(158);

	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}

	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },

	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },

	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },

	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;

	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }

	    return selection || { start: 0, end: 0 };
	  },

	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }

	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};

	module.exports = ReactInputSelection;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);

	var getNodeForCharacterOffset = __webpack_require__(154);
	var getTextContentAccessor = __webpack_require__(56);

	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}

	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;

	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);

	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;

	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}

	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();

	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }

	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;

	  var currentRange = selection.getRangeAt(0);

	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }

	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;

	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;

	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}

	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;

	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }

	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}

	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }

	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }

	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);

	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();

	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}

	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};

	module.exports = ReactDOMSelection;

/***/ }),
/* 154 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */

	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}

	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}

	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;

	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;

	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }

	      nodeStart = nodeEnd;
	    }

	    node = getLeafNode(getSiblingNode(node));
	  }
	}

	module.exports = getNodeForCharacterOffset;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	var isTextNode = __webpack_require__(156);

	/*eslint-disable no-bitwise */

	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}

	module.exports = containsNode;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	var isNode = __webpack_require__(157);

	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}

	module.exports = isTextNode;

/***/ }),
/* 157 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  var doc = object ? object.ownerDocument || object : document;
	  var defaultView = doc.defaultView || window;
	  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}

	module.exports = isNode;

/***/ }),
/* 158 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */

	/* eslint-disable fb-www/typeof-undefined */

	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 *
	 * @param {?DOMDocument} doc Defaults to current document.
	 * @return {?DOMElement}
	 */
	function getActiveElement(doc) /*?DOMElement*/{
	  doc = doc || (typeof document !== 'undefined' ? document : undefined);
	  if (typeof doc === 'undefined') {
	    return null;
	  }
	  try {
	    return doc.activeElement || doc.body;
	  } catch (e) {
	    return doc.body;
	  }
	}

	module.exports = getActiveElement;

/***/ }),
/* 159 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};

	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};

	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};

	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});

	module.exports = SVGDOMPropertyConfig;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var EventPropagators = __webpack_require__(46);
	var ExecutionEnvironment = __webpack_require__(53);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactInputSelection = __webpack_require__(152);
	var SyntheticEvent = __webpack_require__(58);

	var getActiveElement = __webpack_require__(158);
	var isTextInputElement = __webpack_require__(77);
	var shallowEqual = __webpack_require__(129);

	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: 'onSelect',
	      captured: 'onSelectCapture'
	    },
	    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
	  }
	};

	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;

	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;

	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}

	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }

	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;

	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;

	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

	    return syntheticEvent;
	  }

	  return null;
	}

	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	  eventTypes: eventTypes,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }

	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case 'topFocus':
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case 'topBlur':
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case 'topMouseDown':
	        mouseDown = true;
	        break;
	      case 'topContextMenu':
	      case 'topMouseUp':
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case 'topSelectionChange':
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case 'topKeyDown':
	      case 'topKeyUp':
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }

	    return null;
	  },

	  didPutListener: function (inst, registrationName, listener) {
	    if (registrationName === 'onSelect') {
	      hasListener = true;
	    }
	  }
	};

	module.exports = SelectEventPlugin;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var EventListener = __webpack_require__(148);
	var EventPropagators = __webpack_require__(46);
	var ReactDOMComponentTree = __webpack_require__(39);
	var SyntheticAnimationEvent = __webpack_require__(162);
	var SyntheticClipboardEvent = __webpack_require__(163);
	var SyntheticEvent = __webpack_require__(58);
	var SyntheticFocusEvent = __webpack_require__(164);
	var SyntheticKeyboardEvent = __webpack_require__(165);
	var SyntheticMouseEvent = __webpack_require__(80);
	var SyntheticDragEvent = __webpack_require__(168);
	var SyntheticTouchEvent = __webpack_require__(169);
	var SyntheticTransitionEvent = __webpack_require__(170);
	var SyntheticUIEvent = __webpack_require__(81);
	var SyntheticWheelEvent = __webpack_require__(171);

	var emptyFunction = __webpack_require__(9);
	var getEventCharCode = __webpack_require__(166);
	var invariant = __webpack_require__(12);

	/**
	 * Turns
	 * ['abort', ...]
	 * into
	 * eventTypes = {
	 *   'abort': {
	 *     phasedRegistrationNames: {
	 *       bubbled: 'onAbort',
	 *       captured: 'onAbortCapture',
	 *     },
	 *     dependencies: ['topAbort'],
	 *   },
	 *   ...
	 * };
	 * topLevelEventsToDispatchConfig = {
	 *   'topAbort': { sameConfig }
	 * };
	 */
	var eventTypes = {};
	var topLevelEventsToDispatchConfig = {};
	['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
	  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
	  var onEvent = 'on' + capitalizedEvent;
	  var topEvent = 'top' + capitalizedEvent;

	  var type = {
	    phasedRegistrationNames: {
	      bubbled: onEvent,
	      captured: onEvent + 'Capture'
	    },
	    dependencies: [topEvent]
	  };
	  eventTypes[event] = type;
	  topLevelEventsToDispatchConfig[topEvent] = type;
	});

	var onClickListeners = {};

	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}

	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}

	var SimpleEventPlugin = {
	  eventTypes: eventTypes,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case 'topAbort':
	      case 'topCanPlay':
	      case 'topCanPlayThrough':
	      case 'topDurationChange':
	      case 'topEmptied':
	      case 'topEncrypted':
	      case 'topEnded':
	      case 'topError':
	      case 'topInput':
	      case 'topInvalid':
	      case 'topLoad':
	      case 'topLoadedData':
	      case 'topLoadedMetadata':
	      case 'topLoadStart':
	      case 'topPause':
	      case 'topPlay':
	      case 'topPlaying':
	      case 'topProgress':
	      case 'topRateChange':
	      case 'topReset':
	      case 'topSeeked':
	      case 'topSeeking':
	      case 'topStalled':
	      case 'topSubmit':
	      case 'topSuspend':
	      case 'topTimeUpdate':
	      case 'topVolumeChange':
	      case 'topWaiting':
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case 'topKeyPress':
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case 'topKeyDown':
	      case 'topKeyUp':
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case 'topBlur':
	      case 'topFocus':
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case 'topClick':
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case 'topDoubleClick':
	      case 'topMouseDown':
	      case 'topMouseMove':
	      case 'topMouseUp':
	      // TODO: Disabled elements should not respond to mouse events
	      /* falls through */
	      case 'topMouseOut':
	      case 'topMouseOver':
	      case 'topContextMenu':
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case 'topDrag':
	      case 'topDragEnd':
	      case 'topDragEnter':
	      case 'topDragExit':
	      case 'topDragLeave':
	      case 'topDragOver':
	      case 'topDragStart':
	      case 'topDrop':
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case 'topTouchCancel':
	      case 'topTouchEnd':
	      case 'topTouchMove':
	      case 'topTouchStart':
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case 'topAnimationEnd':
	      case 'topAnimationIteration':
	      case 'topAnimationStart':
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case 'topTransitionEnd':
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case 'topScroll':
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case 'topWheel':
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case 'topCopy':
	      case 'topCut':
	      case 'topPaste':
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },

	  didPutListener: function (inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },

	  willDeleteListener: function (inst, registrationName) {
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	};

	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(58);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

	module.exports = SyntheticAnimationEvent;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(58);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

	module.exports = SyntheticClipboardEvent;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(81);

	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

	module.exports = SyntheticFocusEvent;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(81);

	var getEventCharCode = __webpack_require__(166);
	var getEventKey = __webpack_require__(167);
	var getEventModifierState = __webpack_require__(83);

	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.

	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.

	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

	module.exports = SyntheticKeyboardEvent;

/***/ }),
/* 166 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */

	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;

	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;

	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }

	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }

	  return 0;
	}

	module.exports = getEventCharCode;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var getEventCharCode = __webpack_require__(166);

	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  Esc: 'Escape',
	  Spacebar: ' ',
	  Left: 'ArrowLeft',
	  Up: 'ArrowUp',
	  Right: 'ArrowRight',
	  Down: 'ArrowDown',
	  Del: 'Delete',
	  Win: 'OS',
	  Menu: 'ContextMenu',
	  Apps: 'ContextMenu',
	  Scroll: 'ScrollLock',
	  MozPrintableKey: 'Unidentified'
	};

	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1',
	  113: 'F2',
	  114: 'F3',
	  115: 'F4',
	  116: 'F5',
	  117: 'F6',
	  118: 'F7',
	  119: 'F8',
	  120: 'F9',
	  121: 'F10',
	  122: 'F11',
	  123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};

	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.

	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }

	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);

	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}

	module.exports = getEventKey;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticMouseEvent = __webpack_require__(80);

	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

	module.exports = SyntheticDragEvent;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(81);

	var getEventModifierState = __webpack_require__(83);

	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

	module.exports = SyntheticTouchEvent;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(58);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

	module.exports = SyntheticTransitionEvent;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var SyntheticMouseEvent = __webpack_require__(80);

	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,

	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

	module.exports = SyntheticWheelEvent;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var DOMLazyTree = __webpack_require__(87);
	var DOMProperty = __webpack_require__(41);
	var React = __webpack_require__(2);
	var ReactBrowserEventEmitter = __webpack_require__(111);
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactDOMContainerInfo = __webpack_require__(173);
	var ReactDOMFeatureFlags = __webpack_require__(174);
	var ReactFeatureFlags = __webpack_require__(63);
	var ReactInstanceMap = __webpack_require__(122);
	var ReactInstrumentation = __webpack_require__(67);
	var ReactMarkupChecksum = __webpack_require__(175);
	var ReactReconciler = __webpack_require__(64);
	var ReactUpdateQueue = __webpack_require__(141);
	var ReactUpdates = __webpack_require__(61);

	var emptyObject = __webpack_require__(11);
	var instantiateReactComponent = __webpack_require__(124);
	var invariant = __webpack_require__(12);
	var setInnerHTML = __webpack_require__(89);
	var shouldUpdateReactComponent = __webpack_require__(130);
	var warning = __webpack_require__(8);

	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

	var instancesByReactRootID = {};

	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}

	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }

	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}

	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}

	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props.child;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }

	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );

	  if (markerName) {
	    console.timeEnd(markerName);
	  }

	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}

	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}

	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }

	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }

	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}

	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}

	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}

	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}

	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}

	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}

	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}

	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function () {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  return this.props.child;
	};
	TopLevelWrapper.isReactTopLevelWrapper = true;

	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	  TopLevelWrapper: TopLevelWrapper,

	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,

	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },

	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });

	    return prevComponent;
	  },

	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);

	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.

	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;

	    return componentInstance;
	  },

	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },

	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

	    var nextWrappedElement = React.createElement(TopLevelWrapper, {
	      child: nextElement
	    });

	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }

	    var prevComponent = getTopLevelWrapperInContainer(container);

	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props.child;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }

	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }

	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },

	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },

	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.') : void 0;
	    }

	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);

	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }

	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },

	  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }

	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }

	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: hostNode._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  }
	};

	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var validateDOMNesting = __webpack_require__(142);

	var DOC_NODE_TYPE = 9;

	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}

	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 174 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactDOMFeatureFlags = {
	  useCreateElement: true,
	  useFiber: false
	};

	module.exports = ReactDOMFeatureFlags;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var adler32 = __webpack_require__(176);

	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;

	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',

	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);

	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },

	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};

	module.exports = ReactMarkupChecksum;

/***/ }),
/* 176 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	'use strict';

	var MOD = 65521;

	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}

	module.exports = adler32;

/***/ }),
/* 177 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	module.exports = '15.6.1';

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactCurrentOwner = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactInstanceMap = __webpack_require__(122);

	var getHostComponentFromComposite = __webpack_require__(179);
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }

	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }

	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}

	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactNodeTypes = __webpack_require__(126);

	function getHostComponentFromComposite(inst) {
	  var type;

	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }

	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}

	module.exports = getHostComponentFromComposite;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactMount = __webpack_require__(172);

	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(41);
	var EventPluginRegistry = __webpack_require__(48);
	var ReactComponentTreeHook = __webpack_require__(24);

	var warning = __webpack_require__(8);

	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,

	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};

	  var validateProperty = function (tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();

	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}

	var warnUnknownProperties = function (debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }

	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');

	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};

	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}

	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};

	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var ReactComponentTreeHook = __webpack_require__(24);

	var warning = __webpack_require__(8);

	var didWarnValueNull = false;

	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

	    didWarnValueNull = true;
	  }
	}

	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};

	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(41);
	var ReactComponentTreeHook = __webpack_require__(24);

	var warning = __webpack_require__(8);

	var warnedProperties = {};
	var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

	function validateProperty(tagName, name, debugID) {
	  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	    return true;
	  }

	  if (rARIA.test(name)) {
	    var lowerCasedName = name.toLowerCase();
	    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

	    // If this is an aria-* attribute, but is not listed in the known DOM
	    // DOM properties, then it is an invalid aria-* attribute.
	    if (standardName == null) {
	      warnedProperties[name] = true;
	      return false;
	    }
	    // aria-* attributes should be lowercase; suggest the lowercase version.
	    if (name !== standardName) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      warnedProperties[name] = true;
	      return true;
	    }
	  }

	  return true;
	}

	function warnInvalidARIAProps(debugID, element) {
	  var invalidProps = [];

	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      invalidProps.push(key);
	    }
	  }

	  var unknownPropString = invalidProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');

	  if (invalidProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (invalidProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}

	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }

	  warnInvalidARIAProps(debugID, element);
	}

	var ReactDOMInvalidARIAHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  }
	};

	module.exports = ReactDOMInvalidARIAHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _server = __webpack_require__(185);

	var _server2 = _interopRequireDefault(_server);

	var _List = __webpack_require__(189);

	var _List2 = _interopRequireDefault(_List);

	var _DragItem = __webpack_require__(197);

	var _DragItem2 = _interopRequireDefault(_DragItem);

	var _Paint = __webpack_require__(198);

	var _Paint2 = _interopRequireDefault(_Paint);

	var _reactImmutableRenderMixin = __webpack_require__(191);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Canvas = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(Canvas, _Component);

	    function Canvas(props) {
	        _classCallCheck(this, Canvas);

	        var _this = _possibleConstructorReturn(this, (Canvas.__proto__ || Object.getPrototypeOf(Canvas)).call(this, props));

	        _this.state = {
	            deleteComponentId: []
	        };
	        return _this;
	    }

	    _createClass(Canvas, [{
	        key: 'mouseMove',
	        value: function mouseMove(event) {
	            if (this.isMove) {
	                var offset = {
	                    left: event.clientX - 22,
	                    top: event.clientY - 28
	                };
	                _server2.default.emit('listItem:drag_move', offset);
	            }
	            var param = {
	                clientX: event.clientX,
	                clientY: event.clientY
	            };
	            if (this.move) {

	                if (this.resizeEvents) {
	                    this.resizeEvents.move(param);
	                } else {
	                    _server2.default.emit('listItem:resize_move', param);
	                }
	            }
	            if (this.boxMove) {
	                if (this.boxEvents) {
	                    this.boxEvents.move(param);
	                } else {
	                    _server2.default.emit('listItem:box_move', param);
	                }
	            }
	        }
	    }, {
	        key: 'mouseUp',
	        value: function mouseUp(event) {
	            if (this.isMove) {
	                var offset = {
	                    left: event.clientX - 200,
	                    top: event.clientY - 35
	                };
	                var canvas = document.querySelector('#canvas'),
	                    canvasW = canvas.offsetWidth,
	                    canvasH = canvas.offsetHeight,
	                    isDrop = false;
	                if (canvasW >= offset.left && offset.left >= 0 && canvasH >= offset.top && offset.top >= 0) {
	                    _server2.default.emit('listItem:drag_end', offset, this.currentIcon);
	                }
	                _server2.default.emit('listItem:drag_end2');
	                this.isMove = false;
	                this.currentIcon = null;
	            }
	            var param = {
	                clientX: event.clientX,
	                clientY: event.clientY
	            };
	            if (this.move) {
	                if (this.resizeEvents) {
	                    this.resizeEvents.up(param);
	                } else {
	                    _server2.default.emit('listItem:resize_end', param);
	                }
	                this.move = false;
	            }
	            if (this.boxMove) {
	                if (this.boxEvents) {
	                    this.boxEvents.up(param);
	                } else {
	                    _server2.default.emit('listItem:box_up', param);
	                }
	                this.boxMove = false;
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { className: 'content', onMouseMove: this.mouseMove.bind(this), onMouseUp: this.mouseUp.bind(this) },
	                _react2.default.createElement(
	                    'div',
	                    { id: 'drag_list', className: 'left_content' },
	                    _react2.default.createElement(_List2.default, null)
	                ),
	                _react2.default.createElement(
	                    'div',
	                    { id: 'paint', className: 'canvas' },
	                    _react2.default.createElement(_Paint2.default, { id: 'canvas', deleteComponent: this.state.deleteComponentId })
	                ),
	                _react2.default.createElement('div', { id: 'attrEditor' }),
	                _react2.default.createElement(_DragItem2.default, null)
	            );
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this2 = this;

	            var canvas = document.getElementById('canvas');
	            _server2.default.on('listItem:drag_start', function (param) {
	                _this2.isMove = true;
	                _this2.currentIcon = param.icon.icon;
	            });
	            _server2.default.on('listItem:resize_start', function (type, resizeEvents) {
	                _this2.move = true;
	                resizeEvents && (_this2.resizeEvents = resizeEvents);
	            });
	            _server2.default.on('listItem:box_start', function (boxEvents) {
	                _this2.boxMove = true;
	                boxEvents && (_this2.boxEvents = boxEvents);
	            });
	        }
	    }]);

	    return Canvas;
	}(_react.Component)) || _class;

	exports.default = Canvas;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * server
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * i hate react
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _componentManage = __webpack_require__(186);

	var _componentManage2 = _interopRequireDefault(_componentManage);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var manage = new _componentManage2.default([]);

	var Server = function () {
	    function Server() {
	        _classCallCheck(this, Server);

	        if (!Server.created) {
	            Server.instance = this;
	            Server.created = true;
	            Server.instance.manage = manage;
	        }
	        return Server.instance;
	    }

	    _createClass(Server, [{
	        key: 'on',
	        value: function on(eventList, callback) {
	            var cache = void 0,
	                event = void 0,
	                list = void 0;
	            if (!callback) return;
	            eventList = eventList.split(/,/);
	            cache = this._eventList || (this._eventList = {});
	            while (event = eventList.shift()) {
	                list = cache[event] || (cache[event] = []);
	                list.push({
	                    f: callback
	                });
	            }
	            return this;
	        }
	    }, {
	        key: 'off',
	        value: function off(evt, func) {
	            if (!arguments.length) return;
	            var event = arguments[0],
	                cache = this._eventList;
	            if (!cache || !cache[event]) return;
	            if (!func) {
	                delete cache[event];return;
	            }
	            var list = cache[event];
	            for (var i = 0; i < list.length; i++) {
	                if (list[i].f === func) {
	                    list.splice(i, 1);
	                }
	            }
	        }
	    }, {
	        key: 'emit',
	        value: function emit() {
	            if (!arguments.length) return;
	            var event = arguments[0],
	                param = Array.prototype.slice.call(arguments, 1),
	                cache = this._eventList,
	                callback = arguments[1];
	            if (!cache || !cache[event]) return;
	            if (callback === Object.prototype.toString.call(callback) === '[object Function]') {
	                param = Array.prototype.slice.call(arguments, 2);
	            } else {
	                callback = null;
	            }
	            var list = cache[event].slice();
	            for (var i = 0, len = list.length; i < len; i++) {
	                if (callback) {
	                    if (list[i].f == callback) {
	                        list[i].f.apply(list[i].c || this, param);
	                        return;
	                    }
	                } else {
	                    list[i].f.apply(list[i].c || this, param);
	                }
	            }
	        }
	    }]);

	    return Server;
	}();

	var server = new Server();
	exports.default = server;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _immutable = __webpack_require__(187);

	var _immutable2 = _interopRequireDefault(_immutable);

	var _utils = __webpack_require__(188);

	var _utils2 = _interopRequireDefault(_utils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var maxHistory = 10;

	var componentManage = function () {
	    function componentManage(components) {
	        _classCallCheck(this, componentManage);

	        if (components) {
	            var componentMap = {};
	            components.map(function (e, i) {
	                if (!componentMap[e.id]) {
	                    componentMap[e.id] = e;
	                }
	            });
	            this.$$componetMap = _immutable2.default.Map(componentMap); //fromJS 
	            this.$$components = _immutable2.default.List(components);
	            this.history = [this.$$components];
	            this.mapHistory = [this.$$componetMap];
	            this.historyIndex = 0;
	        }
	    }

	    _createClass(componentManage, [{
	        key: 'getCurrentComponnets',
	        value: function getCurrentComponnets() {
	            return this.$$components;
	        }
	    }, {
	        key: 'undo',
	        value: function undo() {
	            if (this.historyIndex) {
	                this.$$components = this.history[--this.historyIndex];
	                this.$$componetMap = this.mapHistory[this.historyIndex];
	                this.updatePaint && this.updatePaint();
	                return this.$$components;
	            }
	            return null;
	        }
	    }, {
	        key: 'redo',
	        value: function redo() {
	            if (this.history.length - 1 > this.historyIndex) {
	                this.$$components = this.history[++this.historyIndex];
	                this.$$componetMap = this.mapHistory[this.historyIndex];
	                this.updatePaint && this.updatePaint();
	                return this.$$components;
	            }
	            return null;
	        }
	    }, {
	        key: 'updateComponentImmutable',
	        value: function updateComponentImmutable() {}
	        /**
	         *  @method _hasComponent ,
	         *  @param object/string /ID
	         * */

	    }, {
	        key: '_hasComponent',
	        value: function _hasComponent(component) {
	            var id = _utils2.default.isObject(component) ? component.id : component;
	            return this.$$componetMap.get(id);
	        }
	    }, {
	        key: '_add',
	        value: function _add(component, parentComponentId) {
	            if (component && !this._hasComponent(component)) {
	                var parentComponent = this._hasComponent(parentComponentId);
	                if (parentComponent) {
	                    if (!parentComponent.get("children")) {
	                        this._update(parentComponent.path + ".children", _immutable2.default.List([]));
	                    }
	                    component.parentId = parentComponent.id;
	                    component.path = parentComponent.path + ".children." + parentComponent.children.size;
	                } else {
	                    component.path = '' + this.$$components.size;
	                }
	                this._update(component.path, component);
	            }
	        }
	    }, {
	        key: '_update',
	        value: function _update(path, component) {
	            if (_utils2.default.isObject(path)) {
	                component = path;
	                path = this.$$components.size + '';
	            }
	            this.$$components = this.$$components.updateIn(path.split('.'), function () {
	                return component;
	            });
	        }
	    }, {
	        key: '_delete',
	        value: function _delete(component) {
	            var _this = this;

	            if (component && this.$$componetMap.get(component.id)) {
	                var currentIndex = void 0;
	                if (component.parentId) {
	                    var parentCom = this.$$componetMap.get(component.parentId);
	                    parentCom.children.forEach(function (e, i) {
	                        if (e === component) {
	                            currentIndex = i;
	                        } else if (currentIndex !== undefined && currentIndex < i) {
	                            var com = parentCom.children.get(i);
	                            com.path = com.path.slice(0, -1) + --i;
	                        }
	                    });
	                } else {
	                    this.$$components.forEach(function (e, i) {
	                        if (e === component) {
	                            currentIndex = i;
	                        } else if (currentIndex !== undefined && currentIndex < i) {
	                            var com = _this.$$components.get(i);
	                            com.path = com.path.slice(0, -1) + --i;
	                        }
	                    });
	                }
	                this.$$components = this.$$components.deleteIn(component.path.split('.'));
	                this.$$componetMap = this.$$componetMap.delete(component.id);
	            }
	        }
	        /**
	         *  @methods update 
	         * */

	    }, {
	        key: 'update',
	        value: function update(component, noUpdateHistory) {
	            if (!component || !this._hasComponent(component)) {
	                return false;
	            }
	            this._update(component.path, component);
	            this.$$componetMap = this.$$componetMap.set(component.id, component);
	            !noUpdateHistory && this.updateHistory();
	            this.updatePaint && this.updatePaint();
	            return this.$$components;
	        }
	    }, {
	        key: 'change',
	        value: function change(component, parentComponentId) {
	            var _this2 = this;

	            if (!component) {
	                return;
	            }

	            // 
	            if (_utils2.default.isArray(component)) {
	                component.forEach(function (e) {
	                    _this2._hasComponent(e) && _this2._delete(e);
	                    _this2._add(e, parentComponentId);
	                });
	            } else {
	                this._hasComponent(component) && this._delete(component);
	                this._add(component, parentComponentId);
	            }

	            this.$$componetMap = this.$$componetMap.set(component.id, component);
	            this.updateHistory();
	            this.updatePaint && this.updatePaint();
	            return this.$$components;
	        }
	    }, {
	        key: 'remove',
	        value: function remove(componentId) {
	            if (!componentId) {
	                componentId = this.currentId;
	            }
	            if (componentId) {
	                var com = this.$$componetMap.get(componentId);
	                this._delete(com);
	                this.updateHistory();
	                this.updatePaint && this.updatePaint();
	            }
	            return this.$$components;
	        }
	    }, {
	        key: 'add',
	        value: function add(component, parentComponentId) {
	            if (!component || this.$$componetMap.get(component.id)) {
	                return;
	            }
	            this.change(component, parentComponentId);
	            return this.$$components;
	        }
	    }, {
	        key: 'updateHistory',
	        value: function updateHistory() {
	            this.historyIndex++;
	            this.history.splice(this.historyIndex);
	            this.history.push(this.$$components);
	            this.mapHistory.splice(this.historyIndex);
	            this.mapHistory.push(this.$$componetMap);
	            if (this.historyIndex > maxHistory - 1) {
	                this.historyIndex = maxHistory - 1;
	                this.history.shift();
	                this.mapHistory.shift();
	            }
	        }
	    }, {
	        key: 'setPaintUpdate',
	        value: function setPaintUpdate(fn) {
	            var _this3 = this;

	            if (_utils2.default.isFunction(fn)) {
	                this.updatePaint = function () {
	                    fn(_this3.$$components);
	                };
	            }
	        }
	    }]);

	    return componentManage;
	}();

	exports.default = componentManage;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	(function (global, factory) {
	  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.Immutable = global.Immutable || {});
	})(undefined, function (exports) {
	  'use strict';

	  // Used for setting prototype methods that IE8 chokes on.

	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^321.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    // Sanitize indices using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    return index === undefined ? defaultIndex : index < 0 ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === undefined || size === index ? index : Math.min(size, index) | 0;
	  }

	  function isImmutable(maybeImmutable) {
	    return (isCollection(maybeImmutable) || isRecord(maybeImmutable)) && !maybeImmutable.__ownerID;
	  }

	  function isCollection(maybeCollection) {
	    return !!(maybeCollection && maybeCollection[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  function isRecord(maybeRecord) {
	    return !!(maybeRecord && maybeRecord[IS_RECORD_SENTINEL]);
	  }

	  function isValueObject(maybeValue) {
	    return !!(maybeValue && typeof maybeValue.equals === 'function' && typeof maybeValue.hashCode === 'function');
	  }

	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	  var IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@';

	  var Collection = function Collection(value) {
	    return isCollection(value) ? value : Seq(value);
	  };

	  var KeyedCollection = function (Collection) {
	    function KeyedCollection(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }

	    if (Collection) KeyedCollection.__proto__ = Collection;
	    KeyedCollection.prototype = Object.create(Collection && Collection.prototype);
	    KeyedCollection.prototype.constructor = KeyedCollection;

	    return KeyedCollection;
	  }(Collection);

	  var IndexedCollection = function (Collection) {
	    function IndexedCollection(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }

	    if (Collection) IndexedCollection.__proto__ = Collection;
	    IndexedCollection.prototype = Object.create(Collection && Collection.prototype);
	    IndexedCollection.prototype.constructor = IndexedCollection;

	    return IndexedCollection;
	  }(Collection);

	  var SetCollection = function (Collection) {
	    function SetCollection(value) {
	      return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
	    }

	    if (Collection) SetCollection.__proto__ = Collection;
	    SetCollection.prototype = Object.create(Collection && Collection.prototype);
	    SetCollection.prototype.constructor = SetCollection;

	    return SetCollection;
	  }(Collection);

	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;

	  var Iterator = function Iterator(next) {
	    this.next = next;
	  };

	  Iterator.prototype.toString = function toString() {
	    return '[Iterator]';
	  };

	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
	    return this.toString();
	  };
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };

	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? iteratorResult.value = value : iteratorResult = {
	      value: value,
	      done: false
	    };
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  var Seq = function (Collection$$1) {
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() : isCollection(value) || isRecord(value) ? value.toSeq() : seqFromValue(value);
	    }

	    if (Collection$$1) Seq.__proto__ = Collection$$1;
	    Seq.prototype = Object.create(Collection$$1 && Collection$$1.prototype);
	    Seq.prototype.constructor = Seq;

	    Seq.of = function of() /*...values*/{
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function toSeq() {
	      return this;
	    };

	    Seq.prototype.toString = function toString() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function cacheResult() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var cache = this._cache;
	      if (cache) {
	        var size = cache.length;
	        var i = 0;
	        while (i !== size) {
	          var entry = cache[reverse ? size - ++i : i++];
	          if (fn(entry[1], entry[0], this$1) === false) {
	            break;
	          }
	        }
	        return i;
	      }
	      return this.__iterateUncached(fn, reverse);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function __iterator(type, reverse) {
	      var cache = this._cache;
	      if (cache) {
	        var size = cache.length;
	        var i = 0;
	        return new Iterator(function () {
	          if (i === size) {
	            return iteratorDone();
	          }
	          var entry = cache[reverse ? size - ++i : i++];
	          return iteratorValue(type, entry[0], entry[1]);
	        });
	      }
	      return this.__iteratorUncached(type, reverse);
	    };

	    return Seq;
	  }(Collection);

	  var KeyedSeq = function (Seq) {
	    function KeyedSeq(value) {
	      return value === null || value === undefined ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
	    }

	    if (Seq) KeyedSeq.__proto__ = Seq;
	    KeyedSeq.prototype = Object.create(Seq && Seq.prototype);
	    KeyedSeq.prototype.constructor = KeyedSeq;

	    KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {
	      return this;
	    };

	    return KeyedSeq;
	  }(Seq);

	  var IndexedSeq = function (Seq) {
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
	    }

	    if (Seq) IndexedSeq.__proto__ = Seq;
	    IndexedSeq.prototype = Object.create(Seq && Seq.prototype);
	    IndexedSeq.prototype.constructor = IndexedSeq;

	    IndexedSeq.of = function of() /*...values*/{
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function toString() {
	      return this.__toString('Seq [', ']');
	    };

	    return IndexedSeq;
	  }(Seq);

	  var SetSeq = function (Seq) {
	    function SetSeq(value) {
	      return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
	    }

	    if (Seq) SetSeq.__proto__ = Seq;
	    SetSeq.prototype = Object.create(Seq && Seq.prototype);
	    SetSeq.prototype.constructor = SetSeq;

	    SetSeq.of = function of() /*...values*/{
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function toSetSeq() {
	      return this;
	    };

	    return SetSeq;
	  }(Seq);

	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;

	  // #pragma Root Sequences

	  var ArraySeq = function (IndexedSeq) {
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    if (IndexedSeq) ArraySeq.__proto__ = IndexedSeq;
	    ArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
	    ArraySeq.prototype.constructor = ArraySeq;

	    ArraySeq.prototype.get = function get(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var array = this._array;
	      var size = array.length;
	      var i = 0;
	      while (i !== size) {
	        var ii = reverse ? size - ++i : i++;
	        if (fn(array[ii], ii, this$1) === false) {
	          break;
	        }
	      }
	      return i;
	    };

	    ArraySeq.prototype.__iterator = function __iterator(type, reverse) {
	      var array = this._array;
	      var size = array.length;
	      var i = 0;
	      return new Iterator(function () {
	        if (i === size) {
	          return iteratorDone();
	        }
	        var ii = reverse ? size - ++i : i++;
	        return iteratorValue(type, ii, array[ii]);
	      });
	    };

	    return ArraySeq;
	  }(IndexedSeq);

	  var ObjectSeq = function (KeyedSeq) {
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    if (KeyedSeq) ObjectSeq.__proto__ = KeyedSeq;
	    ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
	    ObjectSeq.prototype.constructor = ObjectSeq;

	    ObjectSeq.prototype.get = function get(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function has(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var object = this._object;
	      var keys = this._keys;
	      var size = keys.length;
	      var i = 0;
	      while (i !== size) {
	        var key = keys[reverse ? size - ++i : i++];
	        if (fn(object[key], key, this$1) === false) {
	          break;
	        }
	      }
	      return i;
	    };

	    ObjectSeq.prototype.__iterator = function __iterator(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var size = keys.length;
	      var i = 0;
	      return new Iterator(function () {
	        if (i === size) {
	          return iteratorDone();
	        }
	        var key = keys[reverse ? size - ++i : i++];
	        return iteratorValue(type, key, object[key]);
	      });
	    };

	    return ObjectSeq;
	  }(KeyedSeq);
	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;

	  var CollectionSeq = function (IndexedSeq) {
	    function CollectionSeq(collection) {
	      this._collection = collection;
	      this.size = collection.length || collection.size;
	    }

	    if (IndexedSeq) CollectionSeq.__proto__ = IndexedSeq;
	    CollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
	    CollectionSeq.prototype.constructor = CollectionSeq;

	    CollectionSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var collection = this._collection;
	      var iterator = getIterator(collection);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this$1) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var collection = this._collection;
	      var iterator = getIterator(collection);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function () {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };

	    return CollectionSeq;
	  }(IndexedSeq);

	  var IteratorSeq = function (IndexedSeq) {
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    if (IndexedSeq) IteratorSeq.__proto__ = IndexedSeq;
	    IteratorSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
	    IteratorSeq.prototype.constructor = IteratorSeq;

	    IteratorSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this$1) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this$1) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function () {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };

	    return IteratorSeq;
	  }(IndexedSeq);

	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq = Array.isArray(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;
	    if (seq) {
	      return seq.fromEntrySeq();
	    }
	    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	      return new ObjectSeq(value);
	    }
	    throw new TypeError('Expected Array or collection object of [k, v] entries, or keyed object: ' + value);
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (seq) {
	      return seq;
	    }
	    throw new TypeError('Expected Array or collection object of values: ' + value);
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (seq) {
	      return seq;
	    }
	    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	      return new ObjectSeq(value);
	    }
	    throw new TypeError('Expected Array or collection object of values, or keyed object: ' + value);
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections are Value Objects: they implement `equals()`
	   * and `hashCode()`.
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
	  }

	  function fromJS(value, converter) {
	    return fromJSWith([], converter || defaultConverter, value, '', converter && converter.length > 2 ? [] : undefined, { '': value });
	  }

	  function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
	    var toSeq = Array.isArray(value) ? IndexedSeq : isPlainObj(value) ? KeyedSeq : null;
	    if (toSeq) {
	      if (~stack.indexOf(value)) {
	        throw new TypeError('Cannot convert circular structure to Immutable');
	      }
	      stack.push(value);
	      keyPath && key !== '' && keyPath.push(key);
	      var converted = converter.call(parentValue, key, toSeq(value).map(function (v, k) {
	        return fromJSWith(stack, converter, v, k, keyPath, value);
	      }), keyPath && keyPath.slice());
	      stack.pop();
	      keyPath && keyPath.pop();
	      return converted;
	    }
	    return value;
	  }

	  function defaultConverter(k, v) {
	    return isKeyed(v) ? v.toMap() : v.toList();
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
	    a |= 0; // int
	    b |= 0; // int
	    var c = a & 0xffff;
	    var d = b & 0xffff;
	    // Shift by 0 fixes the sign on the high part.
	    return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
	  };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o === 'undefined' ? 'undefined' : _typeof(o);
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xffffffff;
	      }
	      while (o > 0xffffffff) {
	        o /= 0xffffffff;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        enumerable: false,
	        configurable: false,
	        writable: false,
	        value: hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function () {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = function () {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }();

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1:
	          // Element
	          return node.uniqueID;
	        case 9:
	          // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  var ToKeyedSequence = function (KeyedSeq$$1) {
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    if (KeyedSeq$$1) ToKeyedSequence.__proto__ = KeyedSeq$$1;
	    ToKeyedSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);
	    ToKeyedSequence.prototype.constructor = ToKeyedSequence;

	    ToKeyedSequence.prototype.get = function get(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function has(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function valueSeq() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function reverse() {
	      var this$1 = this;

	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function () {
	          return this$1._iter.toSeq().reverse();
	        };
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function map(mapper, context) {
	      var this$1 = this;

	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function () {
	          return this$1._iter.toSeq().map(mapper, context);
	        };
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      return this._iter.__iterate(function (v, k) {
	        return fn(v, k, this$1);
	      }, reverse);
	    };

	    ToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {
	      return this._iter.__iterator(type, reverse);
	    };

	    return ToKeyedSequence;
	  }(KeyedSeq);
	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;

	  var ToIndexedSequence = function (IndexedSeq$$1) {
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    if (IndexedSeq$$1) ToIndexedSequence.__proto__ = IndexedSeq$$1;
	    ToIndexedSequence.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
	    ToIndexedSequence.prototype.constructor = ToIndexedSequence;

	    ToIndexedSequence.prototype.includes = function includes(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var i = 0;
	      reverse && ensureSize(this);
	      return this._iter.__iterate(function (v) {
	        return fn(v, reverse ? this$1.size - ++i : i++, this$1);
	      }, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {
	      var this$1 = this;

	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var i = 0;
	      reverse && ensureSize(this);
	      return new Iterator(function () {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, reverse ? this$1.size - ++i : i++, step.value, step);
	      });
	    };

	    return ToIndexedSequence;
	  }(IndexedSeq);

	  var ToSetSequence = function (SetSeq$$1) {
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    if (SetSeq$$1) ToSetSequence.__proto__ = SetSeq$$1;
	    ToSetSequence.prototype = Object.create(SetSeq$$1 && SetSeq$$1.prototype);
	    ToSetSequence.prototype.constructor = ToSetSequence;

	    ToSetSequence.prototype.has = function has(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      return this._iter.__iterate(function (v) {
	        return fn(v, v, this$1);
	      }, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function __iterator(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function () {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, step.value, step.value, step);
	      });
	    };

	    return ToSetSequence;
	  }(SetSeq);

	  var FromEntriesSequence = function (KeyedSeq$$1) {
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    if (KeyedSeq$$1) FromEntriesSequence.__proto__ = KeyedSeq$$1;
	    FromEntriesSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);
	    FromEntriesSequence.prototype.constructor = FromEntriesSequence;

	    FromEntriesSequence.prototype.entrySeq = function entrySeq() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      return this._iter.__iterate(function (entry) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedCollection = isCollection(entry);
	          return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1);
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function __iterator(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function () {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedCollection = isCollection(entry);
	            return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);
	          }
	        }
	      });
	    };

	    return FromEntriesSequence;
	  }(KeyedSeq);

	  ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;

	  function flipFactory(collection) {
	    var flipSequence = makeSequence(collection);
	    flipSequence._iter = collection;
	    flipSequence.size = collection.size;
	    flipSequence.flip = function () {
	      return collection;
	    };
	    flipSequence.reverse = function () {
	      var reversedSequence = collection.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function () {
	        return collection.reverse();
	      };
	      return reversedSequence;
	    };
	    flipSequence.has = function (key) {
	      return collection.includes(key);
	    };
	    flipSequence.includes = function (key) {
	      return collection.has(key);
	    };
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      return collection.__iterate(function (v, k) {
	        return fn(k, v, this$1) !== false;
	      }, reverse);
	    };
	    flipSequence.__iteratorUncached = function (type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = collection.__iterator(type, reverse);
	        return new Iterator(function () {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
	    };
	    return flipSequence;
	  }

	  function mapFactory(collection, mapper, context) {
	    var mappedSequence = makeSequence(collection);
	    mappedSequence.size = collection.size;
	    mappedSequence.has = function (key) {
	      return collection.has(key);
	    };
	    mappedSequence.get = function (key, notSetValue) {
	      var v = collection.get(key, NOT_SET);
	      return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      return collection.__iterate(function (v, k, c) {
	        return fn(mapper.call(context, v, k, c), k, this$1) !== false;
	      }, reverse);
	    };
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function () {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);
	      });
	    };
	    return mappedSequence;
	  }

	  function reverseFactory(collection, useKeys) {
	    var this$1 = this;

	    var reversedSequence = makeSequence(collection);
	    reversedSequence._iter = collection;
	    reversedSequence.size = collection.size;
	    reversedSequence.reverse = function () {
	      return collection;
	    };
	    if (collection.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(collection);
	        flipSequence.reverse = function () {
	          return collection.flip();
	        };
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function (key, notSetValue) {
	      return collection.get(useKeys ? key : -1 - key, notSetValue);
	    };
	    reversedSequence.has = function (key) {
	      return collection.has(useKeys ? key : -1 - key);
	    };
	    reversedSequence.includes = function (value) {
	      return collection.includes(value);
	    };
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {
	      var this$1 = this;

	      var i = 0;
	      reverse && ensureSize(collection);
	      return collection.__iterate(function (v, k) {
	        return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1);
	      }, !reverse);
	    };
	    reversedSequence.__iterator = function (type, reverse) {
	      var i = 0;
	      reverse && ensureSize(collection);
	      var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
	      return new Iterator(function () {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        return iteratorValue(type, useKeys ? entry[0] : reverse ? this$1.size - ++i : i++, entry[1], step);
	      });
	    };
	    return reversedSequence;
	  }

	  function filterFactory(collection, predicate, context, useKeys) {
	    var filterSequence = makeSequence(collection);
	    if (useKeys) {
	      filterSequence.has = function (key) {
	        var v = collection.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, collection);
	      };
	      filterSequence.get = function (key, notSetValue) {
	        var v = collection.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      var iterations = 0;
	      collection.__iterate(function (v, k, c) {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$1);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function () {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, collection)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    };
	    return filterSequence;
	  }

	  function countByFactory(collection, grouper, context) {
	    var groups = Map().asMutable();
	    collection.__iterate(function (v, k) {
	      groups.update(grouper.call(context, v, k, collection), 0, function (a) {
	        return a + 1;
	      });
	    });
	    return groups.asImmutable();
	  }

	  function groupByFactory(collection, grouper, context) {
	    var isKeyedIter = isKeyed(collection);
	    var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();
	    collection.__iterate(function (v, k) {
	      groups.update(grouper.call(context, v, k, collection), function (a) {
	        return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
	      });
	    });
	    var coerce = collectionClass(collection);
	    return groups.map(function (arr) {
	      return reify(collection, coerce(arr));
	    });
	  }

	  function sliceFactory(collection, begin, end, useKeys) {
	    var originalSize = collection.size;

	    if (wholeSlice(begin, end, originalSize)) {
	      return collection;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this collection's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(collection);

	    // If collection.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || undefined;

	    if (!useKeys && isSeq(collection) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
	      };
	    }

	    sliceSeq.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      collection.__iterate(function (v, k) {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$1) !== false && iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function (type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && collection.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function () {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        }
	        if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        }
	        return iteratorValue(type, iterations - 1, step.value[1], step);
	      });
	    };

	    return sliceSeq;
	  }

	  function takeWhileFactory(collection, predicate, context) {
	    var takeSequence = makeSequence(collection);
	    takeSequence.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      collection.__iterate(function (v, k, c) {
	        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1);
	      });
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function (type, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function () {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$1)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }

	  function skipWhileFactory(collection, predicate, context, useKeys) {
	    var skipSequence = makeSequence(collection);
	    skipSequence.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      collection.__iterate(function (v, k, c) {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$1);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function (type, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function () {
	        var step;
	        var k;
	        var v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            }
	            if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            }
	            return iteratorValue(type, iterations++, step.value[1], step);
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$1));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }

	  function concatFactory(collection, values) {
	    var isKeyedCollection = isKeyed(collection);
	    var iters = [collection].concat(values).map(function (v) {
	      if (!isCollection(v)) {
	        v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedCollection) {
	        v = KeyedCollection(v);
	      }
	      return v;
	    }).filter(function (v) {
	      return v.size !== 0;
	    });

	    if (iters.length === 0) {
	      return collection;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedCollection) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(collection)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(function (sum, seq) {
	      if (sum !== undefined) {
	        var size = seq.size;
	        if (size !== undefined) {
	          return sum + size;
	        }
	      }
	    }, 0);
	    return concatSeq;
	  }

	  function flattenFactory(collection, depth, useKeys) {
	    var flatSequence = makeSequence(collection);
	    flatSequence.__iterateUncached = function (fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {
	        iter.__iterate(function (v, k) {
	          if ((!depth || currentDepth < depth) && isCollection(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else {
	            iterations++;
	            if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
	              stopped = true;
	            }
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(collection, 0);
	      return iterations;
	    };
	    flatSequence.__iteratorUncached = function (type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = collection.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function () {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isCollection(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    };
	    return flatSequence;
	  }

	  function flatMapFactory(collection, mapper, context) {
	    var coerce = collectionClass(collection);
	    return collection.toSeq().map(function (v, k) {
	      return coerce(mapper.call(context, v, k, collection));
	    }).flatten(true);
	  }

	  function interposeFactory(collection, separator) {
	    var interposedSequence = makeSequence(collection);
	    interposedSequence.size = collection.size && collection.size * 2 - 1;
	    interposedSequence.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      var iterations = 0;
	      collection.__iterate(function (v) {
	        return (!iterations || fn(separator, iterations++, this$1) !== false) && fn(v, iterations++, this$1) !== false;
	      }, reverse);
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = collection.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function () {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }

	  function sortFactory(collection, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedCollection = isKeyed(collection);
	    var index = 0;
	    var entries = collection.toSeq().map(function (v, k) {
	      return [k, v, index++, mapper ? mapper(v, k, collection) : v];
	    }).toArray();
	    entries.sort(function (a, b) {
	      return comparator(a[3], b[3]) || a[2] - b[2];
	    }).forEach(isKeyedCollection ? function (v, i) {
	      entries[i].length = 2;
	    } : function (v, i) {
	      entries[i] = v[1];
	    });
	    return isKeyedCollection ? KeyedSeq(entries) : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);
	  }

	  function maxFactory(collection, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = collection.toSeq().map(function (v, k) {
	        return [v, mapper(v, k, collection)];
	      }).reduce(function (a, b) {
	        return maxCompare(comparator, a[1], b[1]) ? b : a;
	      });
	      return entry && entry[0];
	    }
	    return collection.reduce(function (a, b) {
	      return maxCompare(comparator, a, b) ? b : a;
	    });
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
	  }

	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function (i) {
	      return i.size;
	    }).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function (fn, reverse) {
	      var this$1 = this;

	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this$1) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function (type, reverse) {
	      var iterators = iters.map(function (i) {
	        return i = Collection(i), getIterator(reverse ? i.reverse() : i);
	      });
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function () {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function (i) {
	            return i.next();
	          });
	          isDone = steps.some(function (s) {
	            return s.done;
	          });
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
	          return s.value;
	        })));
	      });
	    };
	    return zipSequence;
	  }

	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function collectionClass(collection) {
	    return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
	  }

	  function makeSequence(collection) {
	    return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    }
	    return Seq.prototype.cacheResult.call(this);
	  }

	  function defaultComparator(a, b) {
	    if (a === undefined && b === undefined) {
	      return 0;
	    }

	    if (a === undefined) {
	      return 1;
	    }

	    if (b === undefined) {
	      return -1;
	    }

	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function coerceKeyPath(keyPath) {
	    if (isArrayLike(keyPath) && typeof keyPath !== 'string') {
	      return keyPath;
	    }
	    if (isOrdered(keyPath)) {
	      return keyPath.toArray();
	    }
	    throw new TypeError('Invalid keyPath: expected Ordered Collection or Array: ' + keyPath);
	  }

	  function invariant(condition, error) {
	    if (!condition) {
	      throw new Error(error);
	    }
	  }

	  function assertNotInfinite(size) {
	    invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');
	  }

	  /**
	   * Converts a value to a string, adding quotes if a string was provided.
	   */
	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }

	  var Map = function (KeyedCollection$$1) {
	    function Map(value) {
	      return value === null || value === undefined ? emptyMap.bind(this)() : isMap(value) && !isOrdered(value) ? value : emptyMap.bind(this)().withMutations(function (map) {
	        var iter = KeyedCollection$$1(value);
	        assertNotInfinite(iter.size);
	        iter.forEach(function (v, k) {
	          return map.set(k, v);
	        });
	      });
	    }

	    if (KeyedCollection$$1) Map.__proto__ = KeyedCollection$$1;
	    Map.prototype = Object.create(KeyedCollection$$1 && KeyedCollection$$1.prototype);
	    Map.prototype.constructor = Map;

	    Map.of = function of() {
	      var keyValues = [],
	          len = arguments.length;
	      while (len--) {
	        keyValues[len] = arguments[len];
	      }return emptyMap.bind(this)().withMutations(function (map) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };

	    Map.prototype.toString = function toString() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function get(k, notSetValue) {
	      return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function set(k, v) {
	      return updateMap.bind(this)(this, k, v);
	    };

	    Map.prototype.setIn = function setIn(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function () {
	        return v;
	      });
	    };

	    Map.prototype.remove = function remove(k) {
	      return updateMap.bind(this)(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function deleteIn(keyPath) {
	      keyPath = [].concat(coerceKeyPath(keyPath));
	      if (keyPath.length) {
	        var lastKey = keyPath.pop();
	        return this.updateIn(keyPath, function (c) {
	          return c && c.remove(lastKey);
	        });
	      }
	    };

	    Map.prototype.deleteAll = function deleteAll(keys) {
	      var collection = Collection(keys);

	      if (collection.size === 0) {
	        return this;
	      }

	      return this.withMutations(function (map) {
	        collection.forEach(function (key) {
	          return map.remove(key);
	        });
	      });
	    };

	    Map.prototype.update = function update(k, notSetValue, updater) {
	      return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function updateIn(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(this, coerceKeyPath(keyPath), 0, notSetValue, updater);
	      return updatedValue === NOT_SET ? notSetValue : updatedValue;
	    };

	    Map.prototype.clear = function clear() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap.bind(this)();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function merge() /*...iters*/{
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function mergeWith(merger) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function mergeIn(keyPath) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return this.updateIn(keyPath, emptyMap.bind(this)(), function (m) {
	        return typeof m.merge === 'function' ? m.merge.apply(m, iters) : iters[iters.length - 1];
	      });
	    };

	    Map.prototype.mergeDeep = function mergeDeep() /*...iters*/{
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function mergeDeepWith(merger) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function mergeDeepIn(keyPath) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return this.updateIn(keyPath, emptyMap.bind(this)(), function (m) {
	        return typeof m.mergeDeep === 'function' ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];
	      });
	    };

	    Map.prototype.sort = function sort(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function sortBy(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function withMutations(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function asMutable() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function asImmutable() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function wasAltered() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function __iterator(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var iterations = 0;
	      this._root && this._root.iterate(function (entry) {
	        iterations++;
	        return fn(entry[1], entry[0], this$1);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        if (this.size === 0) {
	          return emptyMap.bind(this)();
	        }
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap.bind(this)(this.size, this._root, ownerID, this.__hash);
	    };

	    return Map;
	  }(KeyedCollection);

	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;
	  MapPrototype.removeAll = MapPrototype.deleteAll;

	  // #pragma Trie Nodes

	  var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
	    this.ownerID = ownerID;
	    this.entries = entries;
	  };

	  ArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
	    var entries = this.entries;
	    for (var ii = 0, len = entries.length; ii < len; ii++) {
	      if (is(key, entries[ii][0])) {
	        return entries[ii][1];
	      }
	    }
	    return notSetValue;
	  };

	  ArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    var removed = value === NOT_SET;

	    var entries = this.entries;
	    var idx = 0;
	    var len = entries.length;
	    for (; idx < len; idx++) {
	      if (is(key, entries[idx][0])) {
	        break;
	      }
	    }
	    var exists = idx < len;

	    if (exists ? entries[idx][1] === value : removed) {
	      return this;
	    }

	    SetRef(didAlter);
	    (removed || !exists) && SetRef(didChangeSize);

	    if (removed && entries.length === 1) {
	      return; // undefined
	    }

	    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	      return createNodes(ownerID, entries, key, value);
	    }

	    var isEditable = ownerID && ownerID === this.ownerID;
	    var newEntries = isEditable ? entries : arrCopy(entries);

	    if (exists) {
	      if (removed) {
	        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
	      } else {
	        newEntries[idx] = [key, value];
	      }
	    } else {
	      newEntries.push([key, value]);
	    }

	    if (isEditable) {
	      this.entries = newEntries;
	      return this;
	    }

	    return new ArrayMapNode(ownerID, newEntries);
	  };

	  var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
	    this.ownerID = ownerID;
	    this.bitmap = bitmap;
	    this.nodes = nodes;
	  };

	  BitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
	    var bitmap = this.bitmap;
	    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
	  };

	  BitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	    var bit = 1 << keyHashFrag;
	    var bitmap = this.bitmap;
	    var exists = (bitmap & bit) !== 0;

	    if (!exists && value === NOT_SET) {
	      return this;
	    }

	    var idx = popCount(bitmap & bit - 1);
	    var nodes = this.nodes;
	    var node = exists ? nodes[idx] : undefined;
	    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	    if (newNode === node) {
	      return this;
	    }

	    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	    }

	    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	      return nodes[idx ^ 1];
	    }

	    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	      return newNode;
	    }

	    var isEditable = ownerID && ownerID === this.ownerID;
	    var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	    var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);

	    if (isEditable) {
	      this.bitmap = newBitmap;
	      this.nodes = newNodes;
	      return this;
	    }

	    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	  };

	  var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
	    this.ownerID = ownerID;
	    this.count = count;
	    this.nodes = nodes;
	  };

	  HashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	    var node = this.nodes[idx];
	    return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	  };

	  HashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	    var removed = value === NOT_SET;
	    var nodes = this.nodes;
	    var node = nodes[idx];

	    if (removed && !node) {
	      return this;
	    }

	    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	    if (newNode === node) {
	      return this;
	    }

	    var newCount = this.count;
	    if (!node) {
	      newCount++;
	    } else if (!newNode) {
	      newCount--;
	      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	        return packNodes(ownerID, nodes, newCount, idx);
	      }
	    }

	    var isEditable = ownerID && ownerID === this.ownerID;
	    var newNodes = setIn(nodes, idx, newNode, isEditable);

	    if (isEditable) {
	      this.count = newCount;
	      this.nodes = newNodes;
	      return this;
	    }

	    return new HashArrayMapNode(ownerID, newCount, newNodes);
	  };

	  var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
	    this.ownerID = ownerID;
	    this.keyHash = keyHash;
	    this.entries = entries;
	  };

	  HashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
	    var entries = this.entries;
	    for (var ii = 0, len = entries.length; ii < len; ii++) {
	      if (is(key, entries[ii][0])) {
	        return entries[ii][1];
	      }
	    }
	    return notSetValue;
	  };

	  HashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }

	    var removed = value === NOT_SET;

	    if (keyHash !== this.keyHash) {
	      if (removed) {
	        return this;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	    }

	    var entries = this.entries;
	    var idx = 0;
	    var len = entries.length;
	    for (; idx < len; idx++) {
	      if (is(key, entries[idx][0])) {
	        break;
	      }
	    }
	    var exists = idx < len;

	    if (exists ? entries[idx][1] === value : removed) {
	      return this;
	    }

	    SetRef(didAlter);
	    (removed || !exists) && SetRef(didChangeSize);

	    if (removed && len === 2) {
	      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	    }

	    var isEditable = ownerID && ownerID === this.ownerID;
	    var newEntries = isEditable ? entries : arrCopy(entries);

	    if (exists) {
	      if (removed) {
	        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
	      } else {
	        newEntries[idx] = [key, value];
	      }
	    } else {
	      newEntries.push([key, value]);
	    }

	    if (isEditable) {
	      this.entries = newEntries;
	      return this;
	    }

	    return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	  };

	  var ValueNode = function ValueNode(ownerID, keyHash, entry) {
	    this.ownerID = ownerID;
	    this.keyHash = keyHash;
	    this.entry = entry;
	  };

	  ValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
	    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	  };

	  ValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    var removed = value === NOT_SET;
	    var keyMatch = is(key, this.entry[0]);
	    if (keyMatch ? value === this.entry[1] : removed) {
	      return this;
	    }

	    SetRef(didAlter);

	    if (removed) {
	      SetRef(didChangeSize);
	      return; // undefined
	    }

	    if (keyMatch) {
	      if (ownerID && ownerID === this.ownerID) {
	        this.entry[1] = value;
	        return this;
	      }
	      return new ValueNode(ownerID, this.keyHash, [key, value]);
	    }

	    SetRef(didChangeSize);
	    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	  };

	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  };

	  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  };

	  // eslint-disable-next-line no-unused-vars
	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  };

	  var MapIterator = function (Iterator$$1) {
	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    if (Iterator$$1) MapIterator.__proto__ = Iterator$$1;
	    MapIterator.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
	    MapIterator.prototype.constructor = MapIterator;

	    MapIterator.prototype.next = function next() {
	      var this$1 = this;

	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex = void 0;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this$1._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this$1._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this$1._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this$1._stack = this$1._stack.__prev;
	      }
	      return iteratorDone();
	    };

	    return MapIterator;
	  }(Iterator);

	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash$$1) {
	    var map,
	        prototype = MapPrototype;
	    if (this && this.__proto__) {
	      if (this.constructor && this.constructor !== Object) prototype = this.__proto__;
	    }
	    map = Object.create(prototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash$$1;
	    map.__altered = false;
	    map.recoveryData && map.recoveryData(this);
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap.bind(this)(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap.bind(this)(newSize, newRoot) : emptyMap.bind(this)();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, collections) {
	    var iters = [];
	    for (var ii = 0; ii < collections.length; ii++) {
	      var value = collections[ii];
	      var iter = KeyedCollection(value);
	      if (!isCollection(value)) {
	        iter = iter.map(function (v) {
	          return fromJS(v);
	        });
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(oldVal, newVal) {
	    return oldVal && oldVal.mergeDeep && isCollection(newVal) ? oldVal.mergeDeep(newVal) : is(oldVal, newVal) ? oldVal : newVal;
	  }

	  function deepMergerWith(merger) {
	    return function (oldVal, newVal, key) {
	      if (oldVal && oldVal.mergeDeepWith && isCollection(newVal)) {
	        return oldVal.mergeDeepWith(merger, newVal);
	      }
	      var nextValue = merger(oldVal, newVal, key);
	      return is(oldVal, nextValue) ? oldVal : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function (x) {
	      return x.size !== 0;
	    });
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function (collection) {
	      var mergeIntoMap = merger ? function (value, key) {
	        collection.update(key, NOT_SET, function (oldVal) {
	          return oldVal === NOT_SET ? value : merger(oldVal, value, key);
	        });
	      } : function (value, key) {
	        collection.set(key, value);
	      };
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPath, i, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    if (i === keyPath.length) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    if (!(isNotSet || existing && existing.set)) {
	      throw new TypeError('Invalid keyPath: Value at [' + keyPath.slice(0, i).map(quoteString) + '] does not have a .set() method and cannot be updated: ' + existing);
	    }
	    var key = keyPath[i];
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(nextExisting, keyPath, i + 1, notSetValue, updater);
	    return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap.bind(this)() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x -= x >> 1 & 0x55555555;
	    x = (x & 0x33333333) + (x >> 2 & 0x33333333);
	    x = x + (x >> 4) & 0x0f0f0f0f;
	    x += x >> 8;
	    x += x >> 16;
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  var List = function (IndexedCollection$$1) {
	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedCollection$$1(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function (list) {
	        list.setSize(size);
	        iter.forEach(function (v, i) {
	          return list.set(i, v);
	        });
	      });
	    }

	    if (IndexedCollection$$1) List.__proto__ = IndexedCollection$$1;
	    List.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);
	    List.prototype.constructor = List;

	    List.of = function of() /*...values*/{
	      return this(arguments);
	    };

	    List.prototype.toString = function toString() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function get(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function set(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function remove(index) {
	      return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
	    };

	    List.prototype.insert = function insert(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function clear() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function push() /*...values*/{
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function (list) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function pop() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function unshift() /*...values*/{
	      var values = arguments;
	      return this.withMutations(function (list) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function shift() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function merge() /*...iters*/{
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function mergeWith(merger) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function mergeDeep() /*...iters*/{
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function mergeDeepWith(merger) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function setSize(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function slice(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
	    };

	    List.prototype.__iterator = function __iterator(type, reverse) {
	      var index = reverse ? this.size : 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function () {
	        var value = values();
	        return value === DONE ? iteratorDone() : iteratorValue(type, reverse ? --index : index++, value);
	      });
	    };

	    List.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var index = reverse ? this.size : 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, reverse ? --index : index++, this$1) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function __ensureOwner(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        if (this.size === 0) {
	          return emptyList();
	        }
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };

	    return List;
	  }(IndexedCollection);

	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;

	  var VNode = function VNode(array, ownerID) {
	    this.array = array;
	    this.ownerID = ownerID;
	  };

	  // TODO: seems like these methods are very similar

	  VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
	    if (index === level ? 1 << level : 0 || this.array.length === 0) {
	      return this;
	    }
	    var originIndex = index >>> level & MASK;
	    if (originIndex >= this.array.length) {
	      return new VNode([], ownerID);
	    }
	    var removingFirst = originIndex === 0;
	    var newChild;
	    if (level > 0) {
	      var oldChild = this.array[originIndex];
	      newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	      if (newChild === oldChild && removingFirst) {
	        return this;
	      }
	    }
	    if (removingFirst && !newChild) {
	      return this;
	    }
	    var editable = editableVNode(this, ownerID);
	    if (!removingFirst) {
	      for (var ii = 0; ii < originIndex; ii++) {
	        editable.array[ii] = undefined;
	      }
	    }
	    if (newChild) {
	      editable.array[originIndex] = newChild;
	    }
	    return editable;
	  };

	  VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
	    if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	      return this;
	    }
	    var sizeIndex = index - 1 >>> level & MASK;
	    if (sizeIndex >= this.array.length) {
	      return this;
	    }

	    var newChild;
	    if (level > 0) {
	      var oldChild = this.array[sizeIndex];
	      newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	      if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	        return this;
	      }
	    }

	    var editable = editableVNode(this, ownerID);
	    editable.array.splice(sizeIndex + 1);
	    if (newChild) {
	      editable.array[sizeIndex] = newChild;
	    }
	    return editable;
	  };

	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function () {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : left - offset >> level;
	      var to = (right - offset >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function () {
	        while (true) {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
	        }
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function (list) {
	        index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = index >>> level & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << list._level + SHIFT) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[rawIndex >>> level & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin |= 0;
	    }
	    if (end !== undefined) {
	      end |= 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << newLevel + SHIFT) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = oldTailOffset >>> level & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	      // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = newOrigin >>> newLevel & MASK;
	        if (beginIndex !== newTailOffset >>> newLevel & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, collections) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < collections.length; ii++) {
	      var value = collections[ii];
	      var iter = IndexedCollection(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isCollection(value)) {
	        iter = iter.map(function (v) {
	          return fromJS(v);
	        });
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
	  }

	  var OrderedMap = function (Map$$1) {
	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
	        var iter = KeyedCollection(value);
	        assertNotInfinite(iter.size);
	        iter.forEach(function (v, k) {
	          return map.set(k, v);
	        });
	      });
	    }

	    if (Map$$1) OrderedMap.__proto__ = Map$$1;
	    OrderedMap.prototype = Object.create(Map$$1 && Map$$1.prototype);
	    OrderedMap.prototype.constructor = OrderedMap;

	    OrderedMap.of = function of() /*...values*/{
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function toString() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function get(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function clear() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function set(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function remove(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function wasAltered() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      return this._list.__iterate(function (entry) {
	        return entry && fn(entry[1], entry[0], this$1);
	      }, reverse);
	    };

	    OrderedMap.prototype.__iterator = function __iterator(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        if (this.size === 0) {
	          return emptyOrderedMap();
	        }
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };

	    return OrderedMap;
	  }(Map);

	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;

	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) {
	      // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function (entry, idx) {
	          return entry !== undefined && i !== idx;
	        });
	        newMap = newList.toKeyedSeq().map(function (entry) {
	          return entry[0];
	        }).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else if (has) {
	      if (v === list.get(i)[1]) {
	        return omap;
	      }
	      newMap = map;
	      newList = list.set(i, [k, v]);
	    } else {
	      newMap = map.set(k, list.size);
	      newList = list.set(list.size, [k, v]);
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  var Stack = function (IndexedCollection$$1) {
	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
	    }

	    if (IndexedCollection$$1) Stack.__proto__ = IndexedCollection$$1;
	    Stack.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);
	    Stack.prototype.constructor = Stack;

	    Stack.of = function of() /*...values*/{
	      return this(arguments);
	    };

	    Stack.prototype.toString = function toString() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function get(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function peek() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function push() /*...values*/{
	      var arguments$1 = arguments;

	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments$1[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function pushAll(iter) {
	      iter = IndexedCollection$$1(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      if (this.size === 0 && isStack(iter)) {
	        return iter;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.__iterate(function (value) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      },
	      /* reverse */true);
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function pop() {
	      return this.slice(1);
	    };

	    Stack.prototype.clear = function clear() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function slice(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection$$1.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        if (this.size === 0) {
	          return emptyStack();
	        }
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return new ArraySeq(this.toArray()).__iterate(function (v, k) {
	          return fn(v, k, this$1);
	        }, reverse);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this$1) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function __iterator(type, reverse) {
	      if (reverse) {
	        return new ArraySeq(this.toArray()).__iterator(type, reverse);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function () {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };

	    return Stack;
	  }(IndexedCollection);

	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;
	  StackPrototype.shift = StackPrototype.pop;
	  StackPrototype.unshift = StackPrototype.push;
	  StackPrototype.unshiftAll = StackPrototype.pushAll;

	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (!isCollection(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function (v, k) {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function (v, k) {
	      if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function keyCopier(key) {
	      ctor.prototype[key] = methods[key];
	    };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  var Set = function (SetCollection$$1) {
	    function Set(value) {
	      return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
	        var iter = SetCollection$$1(value);
	        assertNotInfinite(iter.size);
	        iter.forEach(function (v) {
	          return set.add(v);
	        });
	      });
	    }

	    if (SetCollection$$1) Set.__proto__ = SetCollection$$1;
	    Set.prototype = Object.create(SetCollection$$1 && SetCollection$$1.prototype);
	    Set.prototype.constructor = Set;

	    Set.of = function of() /*...values*/{
	      return this(arguments);
	    };

	    Set.fromKeys = function fromKeys(value) {
	      return this(KeyedCollection(value).keySeq());
	    };

	    Set.intersect = function intersect(sets) {
	      sets = Collection(sets).toArray();
	      return sets.length ? SetPrototype.intersect.apply(Set(sets.pop()), sets) : emptySet();
	    };

	    Set.union = function union(sets) {
	      sets = Collection(sets).toArray();
	      return sets.length ? SetPrototype.union.apply(Set(sets.pop()), sets) : emptySet();
	    };

	    Set.prototype.toString = function toString() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function has(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function add(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function remove(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function clear() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function union() {
	      var iters = [],
	          len = arguments.length;
	      while (len--) {
	        iters[len] = arguments[len];
	      }iters = iters.filter(function (x) {
	        return x.size !== 0;
	      });
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function (set) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetCollection$$1(iters[ii]).forEach(function (value) {
	            return set.add(value);
	          });
	        }
	      });
	    };

	    Set.prototype.intersect = function intersect() {
	      var iters = [],
	          len = arguments.length;
	      while (len--) {
	        iters[len] = arguments[len];
	      }if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function (iter) {
	        return SetCollection$$1(iter);
	      });
	      var toRemove = [];
	      this.forEach(function (value) {
	        if (!iters.every(function (iter) {
	          return iter.includes(value);
	        })) {
	          toRemove.push(value);
	        }
	      });
	      return this.withMutations(function (set) {
	        toRemove.forEach(function (value) {
	          set.remove(value);
	        });
	      });
	    };

	    Set.prototype.subtract = function subtract() {
	      var iters = [],
	          len = arguments.length;
	      while (len--) {
	        iters[len] = arguments[len];
	      }if (iters.length === 0) {
	        return this;
	      }
	      var toRemove = [];
	      this.forEach(function (value) {
	        if (iters.some(function (iter) {
	          return iter.includes(value);
	        })) {
	          toRemove.push(value);
	        }
	      });
	      return this.withMutations(function (set) {
	        toRemove.forEach(function (value) {
	          set.remove(value);
	        });
	      });
	    };

	    Set.prototype.merge = function merge() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function mergeWith(merger) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function sort(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function sortBy(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function wasAltered() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      return this._map.__iterate(function (_, k) {
	        return fn(k, k, this$1);
	      }, reverse);
	    };

	    Set.prototype.__iterator = function __iterator(type, reverse) {
	      return this._map.map(function (_, k) {
	        return k;
	      }).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        if (this.size === 0) {
	          return emptySet();
	        }
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };

	    return Set;
	  }(SetCollection);

	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  /**
	   * Returns a lazy seq of nums from start (inclusive) to end
	   * (exclusive), by step, where start defaults to 0, step to 1, and end to
	   * infinity. When start is equal to end, returns empty list.
	   */
	  var Range = function (IndexedSeq$$1) {
	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    if (IndexedSeq$$1) Range.__proto__ = IndexedSeq$$1;
	    Range.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
	    Range.prototype.constructor = Range;

	    Range.prototype.toString = function toString() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';
	    };

	    Range.prototype.get = function get(index, notSetValue) {
	      return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
	    };

	    Range.prototype.includes = function includes(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function slice(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function indexOf(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index;
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var size = this.size;
	      var step = this._step;
	      var value = reverse ? this._start + (size - 1) * step : this._start;
	      var i = 0;
	      while (i !== size) {
	        if (fn(value, reverse ? size - ++i : i++, this$1) === false) {
	          break;
	        }
	        value += reverse ? -step : step;
	      }
	      return i;
	    };

	    Range.prototype.__iterator = function __iterator(type, reverse) {
	      var size = this.size;
	      var step = this._step;
	      var value = reverse ? this._start + (size - 1) * step : this._start;
	      var i = 0;
	      return new Iterator(function () {
	        if (i === size) {
	          return iteratorDone();
	        }
	        var v = value;
	        value += reverse ? -step : step;
	        return iteratorValue(type, reverse ? size - ++i : i++, v);
	      });
	    };

	    Range.prototype.equals = function equals(other) {
	      return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
	    };

	    return Range;
	  }(IndexedSeq);

	  var EMPTY_RANGE;

	  // Note: all of these methods are deprecated.
	  Collection.isIterable = isCollection;
	  Collection.isKeyed = isKeyed;
	  Collection.isIndexed = isIndexed;
	  Collection.isAssociative = isAssociative;
	  Collection.isOrdered = isOrdered;

	  Collection.Iterator = Iterator;

	  mixin(Collection, {
	    // ### Conversion to other types

	    toArray: function toArray() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function (v, i) {
	        array[i] = v;
	      });
	      return array;
	    },

	    toIndexedSeq: function toIndexedSeq() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function toJS$1() {
	      return this.toSeq().map(toJS).toJSON();
	    },

	    toKeyedSeq: function toKeyedSeq() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function toMap() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function toObject() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function (v, k) {
	        object[k] = v;
	      });
	      return object;
	    },

	    toOrderedMap: function toOrderedMap() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function toOrderedSet() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function toSet() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function toSetSeq() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function toSeq() {
	      return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
	    },

	    toStack: function toStack() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function toList() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },

	    // ### Common JavaScript methods and properties

	    toString: function toString() {
	      return '[Collection]';
	    },

	    __toString: function __toString(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },

	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function concat() {
	      var values = [],
	          len = arguments.length;
	      while (len--) {
	        values[len] = arguments[len];
	      }return reify(this, concatFactory(this, values));
	    },

	    includes: function includes(searchValue) {
	      return this.some(function (value) {
	        return is(value, searchValue);
	      });
	    },

	    entries: function entries() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function every(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function (v, k, c) {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function filter(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function find(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    forEach: function forEach(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function join(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function (v) {
	        isFirst ? isFirst = false : joined += separator;
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function keys() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function map(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function reduce$1(reducer, initialReduction, context) {
	      return reduce(this, reducer, initialReduction, context, arguments.length < 2, false);
	    },

	    reduceRight: function reduceRight(reducer, initialReduction, context) {
	      return reduce(this, reducer, initialReduction, context, arguments.length < 2, true);
	    },

	    reverse: function reverse() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function slice(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function some(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function sort(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function values() {
	      return this.__iterator(ITERATE_VALUES);
	    },

	    // ### More sequential methods

	    butLast: function butLast() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function isEmpty() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function () {
	        return true;
	      });
	    },

	    count: function count(predicate, context) {
	      return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
	    },

	    countBy: function countBy(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function equals(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function entrySeq() {
	      var collection = this;
	      if (collection._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(collection._cache);
	      }
	      var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function () {
	        return collection.toSeq();
	      };

	      // Entries are plain Array, which do not define toJS, so it must
	      // manually converts keys and values before conversion.
	      entriesSequence.toJS = function () {
	        return this.map(function (entry) {
	          return [toJS(entry[0]), toJS(entry[1])];
	        }).toJSON();
	      };

	      return entriesSequence;
	    },

	    filterNot: function filterNot(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findEntry: function findEntry(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function (v, k, c) {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findKey: function findKey(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLast: function findLast(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    findLastEntry: function findLastEntry(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },

	    findLastKey: function findLastKey(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },

	    first: function first() {
	      return this.find(returnTrue);
	    },

	    flatMap: function flatMap(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function flatten(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function fromEntrySeq() {
	      return new FromEntriesSequence(this);
	    },

	    get: function get(searchKey, notSetValue) {
	      return this.find(function (_, key) {
	        return is(key, searchKey);
	      }, undefined, notSetValue);
	    },

	    getIn: function getIn(searchKeyPath, notSetValue) {
	      var nested = this;
	      var keyPath = coerceKeyPath(searchKeyPath);
	      var i = 0;
	      while (i !== keyPath.length) {
	        if (!nested || !nested.get) {
	          throw new TypeError('Invalid keyPath: Value at [' + keyPath.slice(0, i).map(quoteString) + '] does not have a .get() method: ' + nested);
	        }
	        nested = nested.get(keyPath[i++], NOT_SET);
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	      // var step;
	      // while (!(step = iter.next()).done) {
	      //   var key = step.value;
	      //   nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	      //   if (nested === NOT_SET) {
	      //     return notSetValue;
	      //   }
	      // }
	      // return nested;
	    },

	    groupBy: function groupBy(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function has(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function hasIn(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function isSubset(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Collection(iter);
	      return this.every(function (value) {
	        return iter.includes(value);
	      });
	    },

	    isSuperset: function isSuperset(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);
	      return iter.isSubset(this);
	    },

	    keyOf: function keyOf(searchValue) {
	      return this.findKey(function (value) {
	        return is(value, searchValue);
	      });
	    },

	    keySeq: function keySeq() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function last() {
	      return this.toSeq().reverse().first();
	    },

	    lastKeyOf: function lastKeyOf(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },

	    max: function max(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function maxBy(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function min(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function minBy(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function rest() {
	      return this.slice(1);
	    },

	    skip: function skip(amount) {
	      return amount === 0 ? this : this.slice(Math.max(0, amount));
	    },

	    skipLast: function skipLast(amount) {
	      return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
	    },

	    skipWhile: function skipWhile(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function skipUntil(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function sortBy(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function take(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function takeLast(amount) {
	      return this.slice(-Math.max(0, amount));
	    },

	    takeWhile: function takeWhile(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function takeUntil(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    update: function update(fn) {
	      return fn(this);
	    },

	    valueSeq: function valueSeq() {
	      return this.toIndexedSeq();
	    },

	    // ### Hashable Object

	    hashCode: function hashCode() {
	      return this.__hash || (this.__hash = hashCollection(this));
	    }

	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  var CollectionPrototype = Collection.prototype;
	  CollectionPrototype[IS_ITERABLE_SENTINEL] = true;
	  CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
	  CollectionPrototype.toJSON = CollectionPrototype.toArray;
	  CollectionPrototype.__toStringMapper = quoteString;
	  CollectionPrototype.inspect = CollectionPrototype.toSource = function () {
	    return this.toString();
	  };
	  CollectionPrototype.chain = CollectionPrototype.flatMap;
	  CollectionPrototype.contains = CollectionPrototype.includes;

	  mixin(KeyedCollection, {
	    // ### More sequential methods

	    flip: function flip() {
	      return reify(this, flipFactory(this));
	    },

	    mapEntries: function mapEntries(mapper, context) {
	      var this$1 = this;

	      var iterations = 0;
	      return reify(this, this.toSeq().map(function (v, k) {
	        return mapper.call(context, [k, v], iterations++, this$1);
	      }).fromEntrySeq());
	    },

	    mapKeys: function mapKeys(mapper, context) {
	      var this$1 = this;

	      return reify(this, this.toSeq().flip().map(function (k, v) {
	        return mapper.call(context, k, v, this$1);
	      }).flip());
	    }
	  });

	  var KeyedCollectionPrototype = KeyedCollection.prototype;
	  KeyedCollectionPrototype[IS_KEYED_SENTINEL] = true;
	  KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
	  KeyedCollectionPrototype.toJSON = CollectionPrototype.toObject;
	  KeyedCollectionPrototype.__toStringMapper = function (v, k) {
	    return quoteString(k) + ': ' + quoteString(v);
	  };

	  mixin(IndexedCollection, {
	    // ### Conversion to other types

	    toKeyedSeq: function toKeyedSeq() {
	      return new ToKeyedSequence(this, false);
	    },

	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function filter(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function findIndex(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function indexOf(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function lastIndexOf(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    reverse: function reverse() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function slice(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function splice(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum || 0, 0);
	      if (numArgs === 0 || numArgs === 2 && !removeNum) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
	    },

	    // ### More collection methods

	    findLastIndex: function findLastIndex(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    first: function first() {
	      return this.get(0);
	    },

	    flatten: function flatten(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function get(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {
	        return key === index;
	      }, undefined, notSetValue);
	    },

	    has: function has(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
	    },

	    interpose: function interpose(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function interleave() /*...collections*/{
	      var collections = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * collections.length;
	      }
	      return reify(this, interleaved);
	    },

	    keySeq: function keySeq() {
	      return Range(0, this.size);
	    },

	    last: function last() {
	      return this.get(-1);
	    },

	    skipWhile: function skipWhile(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function zip() /*, ...collections */{
	      var collections = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, collections));
	    },

	    zipWith: function zipWith(zipper /*, ...collections */) {
	      var collections = arrCopy(arguments);
	      collections[0] = this;
	      return reify(this, zipWithFactory(this, zipper, collections));
	    }
	  });

	  var IndexedCollectionPrototype = IndexedCollection.prototype;
	  IndexedCollectionPrototype[IS_INDEXED_SENTINEL] = true;
	  IndexedCollectionPrototype[IS_ORDERED_SENTINEL] = true;

	  mixin(SetCollection, {
	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function get(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function includes(value) {
	      return this.has(value);
	    },

	    // ### More sequential methods

	    keySeq: function keySeq() {
	      return this.valueSeq();
	    }
	  });

	  SetCollection.prototype.has = CollectionPrototype.includes;
	  SetCollection.prototype.contains = SetCollection.prototype.includes;

	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedCollection.prototype);
	  mixin(IndexedSeq, IndexedCollection.prototype);
	  mixin(SetSeq, SetCollection.prototype);

	  // #pragma Helper functions

	  function reduce(collection, reducer, reduction, context, useFirst, reverse) {
	    assertNotInfinite(collection.size);
	    collection.__iterate(function (v, k, c) {
	      if (useFirst) {
	        useFirst = false;
	        reduction = v;
	      } else {
	        reduction = reducer.call(context, reduction, v, k, c);
	      }
	    }, reverse);
	    return reduction;
	  }

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function toJS(value) {
	    return value && typeof value.toJS === 'function' ? value.toJS() : value;
	  }

	  function not(predicate) {
	    return function () {
	      return !predicate.apply(this, arguments);
	    };
	  }

	  function neg(predicate) {
	    return function () {
	      return -predicate.apply(this, arguments);
	    };
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashCollection(collection) {
	    if (collection.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(collection);
	    var keyed = isKeyed(collection);
	    var h = ordered ? 1 : 0;
	    var size = collection.__iterate(keyed ? ordered ? function (v, k) {
	      h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
	    } : function (v, k) {
	      h = h + hashMerge(hash(v), hash(k)) | 0;
	    } : ordered ? function (v) {
	      h = 31 * h + hash(v) | 0;
	    } : function (v) {
	      h = h + hash(v) | 0;
	    });
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xcc9e2d51);
	    h = imul(h << 15 | h >>> -15, 0x1b873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xe6546b64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85ebca6b);
	    h = imul(h ^ h >>> 13, 0xc2b2ae35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var OrderedSet = function (Set$$1) {
	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
	        var iter = SetCollection(value);
	        assertNotInfinite(iter.size);
	        iter.forEach(function (v) {
	          return set.add(v);
	        });
	      });
	    }

	    if (Set$$1) OrderedSet.__proto__ = Set$$1;
	    OrderedSet.prototype = Object.create(Set$$1 && Set$$1.prototype);
	    OrderedSet.prototype.constructor = OrderedSet;

	    OrderedSet.of = function of() /*...values*/{
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function fromKeys(value) {
	      return this(KeyedCollection(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function toString() {
	      return this.__toString('OrderedSet {', '}');
	    };

	    return OrderedSet;
	  }(Set);

	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
	  OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
	  OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  var Record = function Record(defaultValues, name) {
	    var hasInitialized;

	    var RecordType = function Record(values) {
	      var this$1 = this;

	      if (values instanceof RecordType) {
	        return values;
	      }
	      if (!(this instanceof RecordType)) {
	        return new RecordType(values);
	      }
	      if (!hasInitialized) {
	        hasInitialized = true;
	        var keys = Object.keys(defaultValues);
	        var indices = RecordTypePrototype._indices = {};
	        RecordTypePrototype._name = name;
	        RecordTypePrototype._keys = keys;
	        RecordTypePrototype._defaultValues = defaultValues;
	        for (var i = 0; i < keys.length; i++) {
	          var propName = keys[i];
	          indices[propName] = i;
	          if (RecordTypePrototype[propName]) {
	            /* eslint-disable no-console */
	            (typeof console === 'undefined' ? 'undefined' : _typeof(console)) === 'object' && console.warn && console.warn('Cannot define ' + recordName(this$1) + ' with property "' + propName + '" since that property name is part of the Record API.');
	            /* eslint-enable no-console */
	          } else {
	            setProp(RecordTypePrototype, propName);
	          }
	        }
	      }
	      this.__ownerID = undefined;
	      this._values = List().withMutations(function (l) {
	        l.setSize(this$1._keys.length);
	        KeyedCollection(values).forEach(function (v, k) {
	          l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);
	        });
	      });
	    };

	    var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	    RecordTypePrototype.constructor = RecordType;

	    return RecordType;
	  };

	  Record.prototype.toString = function toString() {
	    var this$1 = this;

	    var str = recordName(this) + ' { ';
	    var keys = this._keys;
	    var k;
	    for (var i = 0, l = keys.length; i !== l; i++) {
	      k = keys[i];
	      str += (i ? ', ' : '') + k + ': ' + quoteString(this$1.get(k));
	    }
	    return str + ' }';
	  };

	  Record.prototype.equals = function equals(other) {
	    return this === other || this._keys === other._keys && recordSeq(this).equals(recordSeq(other));
	  };

	  Record.prototype.hashCode = function hashCode() {
	    return recordSeq(this).hashCode();
	  };

	  // @pragma Access

	  Record.prototype.has = function has(k) {
	    return this._indices.hasOwnProperty(k);
	  };

	  Record.prototype.get = function get(k, notSetValue) {
	    if (!this.has(k)) {
	      return notSetValue;
	    }
	    var index = this._indices[k];
	    var value = this._values.get(index);
	    return value === undefined ? this._defaultValues[k] : value;
	  };

	  // @pragma Modification

	  Record.prototype.set = function set(k, v) {
	    if (this.has(k)) {
	      var newValues = this._values.set(this._indices[k], v === this._defaultValues[k] ? undefined : v);
	      if (newValues !== this._values && !this.__ownerID) {
	        return makeRecord(this, newValues);
	      }
	    }
	    return this;
	  };

	  Record.prototype.remove = function remove(k) {
	    return this.set(k);
	  };

	  Record.prototype.clear = function clear() {
	    var newValues = this._values.clear().setSize(this._keys.length);
	    return this.__ownerID ? this : makeRecord(this, newValues);
	  };

	  Record.prototype.wasAltered = function wasAltered() {
	    return this._values.wasAltered();
	  };

	  Record.prototype.toSeq = function toSeq() {
	    return recordSeq(this);
	  };

	  Record.prototype.toJS = function toJS() {
	    return recordSeq(this).toJS();
	  };

	  Record.prototype.__iterator = function __iterator(type, reverse) {
	    return recordSeq(this).__iterator(type, reverse);
	  };

	  Record.prototype.__iterate = function __iterate(fn, reverse) {
	    return recordSeq(this).__iterate(fn, reverse);
	  };

	  Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
	    if (ownerID === this.__ownerID) {
	      return this;
	    }
	    var newValues = this._values.__ensureOwner(ownerID);
	    if (!ownerID) {
	      this.__ownerID = ownerID;
	      this._values = newValues;
	      return this;
	    }
	    return makeRecord(this, newValues, ownerID);
	  };

	  Record.isRecord = isRecord;
	  Record.getDescriptiveName = recordName;
	  var RecordPrototype = Record.prototype;
	  RecordPrototype[IS_RECORD_SENTINEL] = true;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.getIn = CollectionPrototype.getIn;
	  RecordPrototype.hasIn = CollectionPrototype.hasIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;
	  RecordPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
	  RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
	  RecordPrototype.inspect = RecordPrototype.toSource = CollectionPrototype.toSource;

	  function makeRecord(likeRecord, values, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._values = values;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function recordSeq(record) {
	    return keyedSeqFromValue(record._keys.map(function (k) {
	      return [k, record.get(k)];
	    }));
	  }

	  function setProp(prototype, name) {
	    try {
	      Object.defineProperty(prototype, name, {
	        get: function get() {
	          return this.get(name);
	        },
	        set: function set(value) {
	          invariant(this.__ownerID, 'Cannot set on an immutable record.');
	          this.set(name, value);
	        }
	      });
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  /**
	   * Returns a lazy Seq of `value` repeated `times` times. When `times` is
	   * undefined, returns an infinite sequence of `value`.
	   */
	  var Repeat = function (IndexedSeq$$1) {
	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    if (IndexedSeq$$1) Repeat.__proto__ = IndexedSeq$$1;
	    Repeat.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
	    Repeat.prototype.constructor = Repeat;

	    Repeat.prototype.toString = function toString() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function get(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function includes(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function slice(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function reverse() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function indexOf(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var size = this.size;
	      var i = 0;
	      while (i !== size) {
	        if (fn(this$1._value, reverse ? size - ++i : i++, this$1) === false) {
	          break;
	        }
	      }
	      return i;
	    };

	    Repeat.prototype.__iterator = function __iterator(type, reverse) {
	      var this$1 = this;

	      var size = this.size;
	      var i = 0;
	      return new Iterator(function () {
	        return i === size ? iteratorDone() : iteratorValue(type, reverse ? size - ++i : i++, this$1._value);
	      });
	    };

	    Repeat.prototype.equals = function equals(other) {
	      return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);
	    };

	    return Repeat;
	  }(IndexedSeq);

	  var EMPTY_REPEAT;

	  var Immutable = {
	    Collection: Collection,
	    // Note: Iterable is deprecated
	    Iterable: Collection,

	    Seq: Seq,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS,
	    hash: hash,

	    isImmutable: isImmutable,
	    isCollection: isCollection,
	    isKeyed: isKeyed,
	    isIndexed: isIndexed,
	    isAssociative: isAssociative,
	    isOrdered: isOrdered,
	    isValueObject: isValueObject
	  };

	  // Note: Iterable is deprecated
	  var Iterable = Collection;

	  exports['default'] = Immutable;
	  exports.Collection = Collection;
	  exports.Iterable = Iterable;
	  exports.Seq = Seq;
	  exports.Map = Map;
	  exports.OrderedMap = OrderedMap;
	  exports.List = List;
	  exports.Stack = Stack;
	  exports.Set = Set;
	  exports.OrderedSet = OrderedSet;
	  exports.Record = Record;
	  exports.Range = Range;
	  exports.Repeat = Repeat;
	  exports.is = is;
	  exports.fromJS = fromJS;
	  exports.hash = hash;
	  exports.isImmutable = isImmutable;
	  exports.isCollection = isCollection;
	  exports.isKeyed = isKeyed;
	  exports.isIndexed = isIndexed;
	  exports.isAssociative = isAssociative;
	  exports.isOrdered = isOrdered;
	  exports.isValueObject = isValueObject;

	  Object.defineProperty(exports, '__esModule', { value: true });
	});

/***/ }),
/* 188 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var _typeof2 = function _typeof2(arg) {
	    return Object.prototype.toString.call(arg);
	};

	var isArray = function isArray(arg) {
	    return _typeof2(arg) === '[object Array]';
	};

	var isDate = function isDate(arg) {
	    return _typeof2(arg) === '[object Date]';
	};

	var isRegExp = function isRegExp(arg) {
	    return _typeof2(arg) === '[object RegExp]';
	};

	var isObject = function isObject(arg) {
	    return _typeof2(arg) === '[object Object]';
	};

	var isFunction = function isFunction(arg) {
	    return _typeof2(arg) === '[object Function]';
	};

	var _copy = function _copy(source, destination, stackSource, stackDest) {

	    if (!destination) {
	        destination = source;
	        if (source) {
	            if (isArray(source)) {
	                destination = _copy(source, [], stackSource, stackDest);
	            } else if (isDate(source)) {
	                destination = new Date(source.getTime());
	            } else if (isRegExp(source)) {
	                destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
	                destination.lastIndex = source.lastIndex;
	            } else if (isObject(source)) {
	                var emptyObject = Object.create(Object.getPrototypeOf(source));
	                destination = _copy(source, emptyObject, stackSource, stackDest);
	            }
	        }
	    } else {
	        if (source === destination) throw new Error("Can't copy! Source and destination are identical.");
	        stackSource = stackSource || [];
	        stackDest = stackDest || [];
	        if (isObject(source)) {
	            var index = stackSource.indexOf(source);
	            if (index !== -1) return stackDest[index];
	            stackSource.push(source);
	            stackDest.push(destination);
	        }
	        var result;
	        if (isArray(source)) {
	            destination.length = 0;
	            for (var i = 0; i < source.length; i++) {
	                result = _copy(source[i], null, stackSource, stackDest);
	                if (isObject(source[i])) {
	                    stackSource.push(source[i]);
	                    stackDest.push(result);
	                }
	                destination.push(result);
	            }
	        } else {
	            if (isArray(destination)) {
	                destination.length = 0;
	            } else {
	                for (var key in destination) {
	                    delete destination[key];
	                }
	            }
	            for (var key in source) {
	                if (source.hasOwnProperty(key)) {
	                    result = _copy(source[key], null, stackSource, stackDest);
	                    if (isObject(source[key])) {
	                        stackSource.push(source[key]);
	                        stackDest.push(result);
	                    }
	                    destination[key] = result;
	                }
	            }
	        }
	    }
	    return destination;
	};

	var getCode = function getCode() {
	    return (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
	};

	var offset = function offset(ele) {
	    var top = ele.offsetTop;
	    var left = ele.offsetLeft;
	    while (ele.offsetParent) {
	        ele = ele.offsetParent;
	        if (window.navigator.userAgent.indexOf('MSTE 8') > -1) {
	            top += ele.offsetTop;
	            left += ele.offsetLeft;
	        } else {
	            top += ele.offsetTop + ele.clientTop;
	            left += ele.offsetLeft + ele.clientLeft;
	        }
	    }
	    return {
	        left: left,
	        top: top
	    };
	};

	exports.default = {
	    isArray: isArray,

	    isDate: isDate,

	    isRegExp: isRegExp,

	    isObject: isObject,

	    offset: offset,

	    isFunction: isFunction,

	    /**
	     *   objectfunction
	     **/
	    copy: function copy(arg) {
	        return _copy.call(this, arg);
	    },

	    /**
	     * 
	     **/
	    typeof: function _typeof(arg) {
	        return _typeof2.call(this, arg);
	    },

	    guid: function guid() {
	        return getCode() + getCode() + '-' + getCode() + '-' + getCode() + '-' + getCode() + '-' + getCode() + getCode() + getCode();
	    }
	};

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _ListItem = __webpack_require__(190);

	var _ListItem2 = _interopRequireDefault(_ListItem);

	var _reactImmutableRenderMixin = __webpack_require__(191);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var List = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(List, _Component);

	    function List(props) {
	        _classCallCheck(this, List);

	        var _this = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, props));

	        _this.state = {
	            list: [{
	                name: '',
	                icon: [{ icon: 'row', name: '' }, { icon: 'column', name: '' }]
	            }, {
	                name: '',
	                icon: [{ icon: 'div', name: 'div' }, { icon: 'link', name: '' }, { icon: 'pieChart', name: '' }]
	            }]
	        };
	        return _this;
	    }

	    _createClass(List, [{
	        key: 'render',
	        value: function render() {
	            var childrens = this.state.list.map(function (val, i) {
	                return _react2.default.createElement(
	                    'li',
	                    { key: 'list_' + val.name + i, style: { width: '100%', marginTop: i ? '20px' : '0' } },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'list_title' },
	                        val.name
	                    ),
	                    _react2.default.createElement(_ListItem2.default, { icons: val.icon })
	                );
	            });
	            return _react2.default.createElement(
	                'ul',
	                null,
	                childrens
	            );
	        }
	    }]);

	    return List;
	}(_react.Component)) || _class;

	exports.default = List;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _utils = __webpack_require__(188);

	var _utils2 = _interopRequireDefault(_utils);

	var _server = __webpack_require__(185);

	var _server2 = _interopRequireDefault(_server);

	var _reactImmutableRenderMixin = __webpack_require__(191);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ListItem = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(ListItem, _Component);

	    function ListItem(props) {
	        _classCallCheck(this, ListItem);

	        return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).call(this, props));
	    }

	    _createClass(ListItem, [{
	        key: 'mouseDown',
	        value: function mouseDown(iconItem, event) {
	            var offset = _utils2.default.offset(event.target),
	                icon = event._targetInst._currentElement.props.icon,
	                param = {
	                offset: offset,
	                icon: iconItem
	            };
	            _server2.default.emit('listItem:drag_start', param);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this2 = this;

	            var icons = this.props.icons;

	            icons = icons.map(function (val, index) {
	                return _react2.default.createElement(
	                    'li',
	                    { className: 'list_item', key: 'list_item_' + val.icon },
	                    _react2.default.createElement('div', { className: "drag-item iconfont icon-" + val.icon, icon: val.icon, onMouseDown: _this2.mouseDown.bind(_this2, val) }),
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'icon_info' },
	                        val.name
	                    )
	                );
	            });
	            return _react2.default.createElement(
	                'ul',
	                { className: 'list_block' },
	                icons
	            );
	        }
	    }]);

	    return ListItem;
	}(_react.Component)) || _class;

	exports.default = ListItem;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.shallowEqualImmutable = exports.shouldComponentUpdate = exports.immutableRenderDecorator = exports.default = undefined;

	var _shouldComponentUpdate = __webpack_require__(192);

	var _shouldComponentUpdate2 = _interopRequireDefault(_shouldComponentUpdate);

	var _shallowEqualImmutable = __webpack_require__(193);

	var _shallowEqualImmutable2 = _interopRequireDefault(_shallowEqualImmutable);

	var _immutableRenderMixin = __webpack_require__(195);

	var _immutableRenderMixin2 = _interopRequireDefault(_immutableRenderMixin);

	var _immutableRenderDecorator = __webpack_require__(196);

	var _immutableRenderDecorator2 = _interopRequireDefault(_immutableRenderDecorator);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _immutableRenderMixin2.default;
	exports.immutableRenderDecorator = _immutableRenderDecorator2.default;
	exports.shouldComponentUpdate = _shouldComponentUpdate2.default;
	exports.shallowEqualImmutable = _shallowEqualImmutable2.default;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = shouldComponentUpdate;

	var _shallowEqualImmutable = __webpack_require__(193);

	var _shallowEqualImmutable2 = _interopRequireDefault(_shallowEqualImmutable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function shouldComponentUpdate(nextProps, nextState) {
	  return !(0, _shallowEqualImmutable2.default)(this.props, nextProps) || !(0, _shallowEqualImmutable2.default)(this.state, nextState);
	}

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.default = shallowEqualImmutable;

	var _immutable = __webpack_require__(194);

	var _immutable2 = _interopRequireDefault(_immutable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var is = _immutable2.default.is.bind(_immutable2.default);

	function shallowEqualImmutable(objA, objB) {
	  if (objA === objB || is(objA, objB)) {
	    return true;
	  }

	  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	    return false;
	  }

	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);

	  if (keysA.length !== keysB.length) {
	    return false;
	  }

	  // Test for A's keys different from B.
	  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }

	  return true;
	}

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^321.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function Iterator(next) {
	      this.next = next;
	    }

	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(Map, KeyedCollection);

	    // @pragma Construction

	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };

	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }

	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }

	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }

	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  createClass(Set, SetCollection);

	    // @pragma Construction

	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },

	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;

	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    keySeq: function() {
	      return Range(0, this.size);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    }

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS

	  };

	  return Immutable;

	}));

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _shouldComponentUpdate = __webpack_require__(192);

	var _shouldComponentUpdate2 = _interopRequireDefault(_shouldComponentUpdate);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  shouldComponentUpdate: _shouldComponentUpdate2.default
	};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = immutableRenderDecorator;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _shouldComponentUpdate = __webpack_require__(192);

	var _shouldComponentUpdate2 = _interopRequireDefault(_shouldComponentUpdate);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Makes the given component "pure".
	 *
	 * @param object Target Component.
	 */
	function immutableRenderDecorator(Target) {
	  var Wrapper = function (_Component) {
	    _inherits(Wrapper, _Component);

	    function Wrapper() {
	      _classCallCheck(this, Wrapper);

	      return _possibleConstructorReturn(this, Object.getPrototypeOf(Wrapper).apply(this, arguments));
	    }

	    _createClass(Wrapper, [{
	      key: 'render',
	      value: function render() {
	        return _react2.default.createElement(Target, this.props, this.props.children);
	      }
	    }]);

	    return Wrapper;
	  }(_react.Component);

	  Wrapper.prototype.shouldComponentUpdate = _shouldComponentUpdate2.default;

	  return Wrapper;
	}

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _utils = __webpack_require__(188);

	var _utils2 = _interopRequireDefault(_utils);

	var _server = __webpack_require__(185);

	var _server2 = _interopRequireDefault(_server);

	var _reactImmutableRenderMixin = __webpack_require__(191);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var DragItem = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(DragItem, _Component);

	    function DragItem(props) {
	        _classCallCheck(this, DragItem);

	        var _this = _possibleConstructorReturn(this, (DragItem.__proto__ || Object.getPrototypeOf(DragItem)).call(this, props));

	        _this.state = {
	            currentIcon: {},
	            isShow: false,
	            offset: {
	                left: 0,
	                top: 0
	            }
	        };
	        return _this;
	    }

	    _createClass(DragItem, [{
	        key: 'mouseMove',
	        value: function mouseMove(event) {
	            if (this.state.isShow) {
	                var offset = {
	                    left: event.clientX - 22,
	                    top: event.clientY - 28
	                };
	                this.setState({ offset: offset });
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var currentIcon = this.state.currentIcon;
	            return _react2.default.createElement(
	                'div',
	                { className: 'list_item drag_item', style: { display: this.state.isShow ? 'block' : 'none', left: this.state.offset.left, top: this.state.offset.top - 35 } },
	                _react2.default.createElement('div', { className: "drag-item iconfont icon-" + currentIcon.icon, icon: currentIcon.icon }),
	                _react2.default.createElement(
	                    'div',
	                    { className: 'icon_info' },
	                    currentIcon.name
	                )
	            );
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this2 = this;

	            var instance = this;
	            _server2.default.on('listItem:drag_start', function (param) {
	                _this2.setState({
	                    isShow: true,
	                    currentIcon: param.icon,
	                    offset: param.offset
	                });
	            });
	            _server2.default.on('listItem:drag_move', function (offset) {
	                _this2.setState({
	                    offset: offset
	                });
	            });
	            _server2.default.on('listItem:drag_end2', function (offset) {
	                _this2.setState({
	                    isShow: false
	                });
	            });
	        }
	    }]);

	    return DragItem;
	}(_react.Component)) || _class;

	exports.default = DragItem;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _server = __webpack_require__(185);

	var _server2 = _interopRequireDefault(_server);

	var _component = __webpack_require__(199);

	var _component2 = _interopRequireDefault(_component);

	var _reactImmutableRenderMixin = __webpack_require__(191);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var manage = _server2.default.manage;

	var Paint = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(Paint, _Component);

	    function Paint(props) {
	        _classCallCheck(this, Paint);

	        var _this = _possibleConstructorReturn(this, (Paint.__proto__ || Object.getPrototypeOf(Paint)).call(this, props));

	        _this.state = {
	            components: manage.$$components
	        };
	        return _this;
	    }

	    _createClass(Paint, [{
	        key: 'render',
	        value: function render() {
	            var components = [];
	            this.state.components.forEach(function (e, i) {
	                var Component = e.getReactComponent();
	                components.push(_react2.default.createElement(Component, { component: e, key: e.id }));
	            });
	            return _react2.default.createElement(
	                'div',
	                { id: 'canvas' },
	                components
	            );
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this2 = this;

	            var instance = this;

	            manage.setPaintUpdate(function (components) {
	                components && _this2.setState({
	                    components: components
	                });
	            });

	            _server2.default.on('listItem:drag_end', function (offset, icon) {
	                manage.add(new _component2.default(offset, icon));
	            });

	            window.addEventListener && window.addEventListener('keyup', function (e) {
	                var components = void 0;
	                switch (e.key) {
	                    case 'Delete':
	                        {
	                            manage.remove();
	                            break;
	                        }
	                    case 'z':
	                        {
	                            if (e.ctrlKey) {
	                                manage.undo();
	                                break;
	                            }
	                        }
	                    case 'y':
	                        {
	                            if (e.ctrlKey) {
	                                manage.redo();
	                                break;
	                            }
	                        }
	                    case 'c':
	                        {
	                            if (e.ctrlKey) {}
	                        }
	                    default:
	                        break;
	                }
	            });
	        }
	    }]);

	    return Paint;
	}(_react.Component)) || _class;

	exports.default = Paint;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _style2 = __webpack_require__(200);

	var _style3 = _interopRequireDefault(_style2);

	var _immutable = __webpack_require__(187);

	var _immutable2 = _interopRequireDefault(_immutable);

	var _utils = __webpack_require__(188);

	var _utils2 = _interopRequireDefault(_utils);

	var _componentMap = __webpack_require__(201);

	var _componentMap2 = _interopRequireDefault(_componentMap);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *    @class component immutableMap
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * immutable
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  @constructor offseticon
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                **/

	function OwnerID() {};

	function makeComponent(size, root, ownerID, hash) {
	    var component = Object.create(ComponentPrototype);
	    component.size = size;
	    component._root = root;
	    component.__ownerID = ownerID;
	    component.__hash = hash;
	    component.__altered = false;
	    return component;
	}

	var Component = function (_Immutable$Map) {
	    _inherits(Component, _Immutable$Map);

	    function Component(offset, icon) {
	        _classCallCheck(this, Component);

	        var style = new _style3.default({
	            left: offset.left,
	            top: offset.top,
	            position: 'absolute',
	            width: 300,
	            height: 200
	        }),
	            _attrs = _immutable2.default.Map({ className: "component" });

	        var _this = _possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).call(this, { style: style, _attrs: _attrs, children: _immutable2.default.List([]) }));

	        if (_this.__proto__ !== Component.prototype) {
	            _this.__proto__ = Component.prototype;
	        }
	        _this.icon = icon;
	        _this.id = _utils2.default.guid();
	        _this.style = _this.get("style"); //
	        _this.children = _this.get("children"); //
	        return _this;
	    }
	    /**
	     * @method getNewCom component
	     * */


	    _createClass(Component, [{
	        key: 'getNewCom',
	        value: function getNewCom() {
	            var _this2 = this;

	            var newCom = makeComponent(this.size, this._root, new OwnerID(), this.__hash),
	                methods = void 0;
	            methods = Object.keys(this);
	            methods.map(function (e) {
	                if (!newCom[e]) {
	                    newCom[e] = _this2[e];
	                }
	            });
	            return newCom;
	        }
	    }, {
	        key: 'copy',
	        value: function copy() {
	            //
	            var component = Object.create(Component.prototype);
	            component.size = this.size;
	            component.__ownerID = new OwnerID();
	            component.__altered = false;
	        }
	        /**
	         * @method Map
	         * */

	    }, {
	        key: 'recoveryData',
	        value: function recoveryData(prevData) {
	            if (prevData && prevData.constructor === Component) {
	                this.icon = prevData.icon;
	                this.id = prevData.id;
	                this.path = prevData.path;
	                this.parentId = prevData.parentId;
	                this.style = this.get("style");
	                this.children = this.get("children");
	            }
	        }
	    }, {
	        key: 'commonStyle',
	        value: function commonStyle() {
	            return {
	                'box-sizing': 'border-box'
	            };
	        }
	    }, {
	        key: 'getStyle',
	        value: function getStyle() {
	            return this.style.toObject();
	        }
	        /**
	         * style
	         * */

	    }, {
	        key: 'getNoPosStyle',
	        value: function getNoPosStyle() {
	            return this.style.getNoPosStyle();
	        }
	        /**
	         * style 
	         * */

	    }, {
	        key: 'getPosStyle',
	        value: function getPosStyle() {
	            return this.style.getPosStyle();
	        }
	    }, {
	        key: 'setStyle',
	        value: function setStyle(_style) {}
	        /**
	         * REACTDOM
	         * */

	    }, {
	        key: 'getReactComponent',
	        value: function getReactComponent() {
	            if (this.icon) {
	                var comName = this.icon[0].toUpperCase() + this.icon.slice(1),
	                    reactComponent = _componentMap2.default[comName];
	                if (!reactComponent) {
	                    throw new Error('no find reactComponent named ' + comName + ',make sure add ' + comName + ' code');
	                    //reactComponent = componentMap.ComponentBase;
	                }
	                return reactComponent;
	            }
	        }
	    }, {
	        key: 'attrs',
	        set: function set(val) {
	            if (_immutable2.default.Map.isMap(val)) {
	                this.set("_attrs", val);
	            }
	        },
	        get: function get() {
	            return this.get("_attrs").toObject();
	        }
	    }]);

	    return Component;
	}(_immutable2.default.Map);

	var ComponentPrototype = Component.prototype;
	exports.default = Component;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _immutable = __webpack_require__(187);

	var _immutable2 = _interopRequireDefault(_immutable);

	var _utils = __webpack_require__(188);

	var _utils2 = _interopRequireDefault(_utils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var posStyle = ['left', 'top', 'right', 'bottom', 'margin', 'marginLeft', 'marginTOP', 'marginRight', 'marginBottom', 'position', 'zIndex'];
	var comStyle = ['width', 'height'];

	var Style = function (_Immutable$Map) {
	    _inherits(Style, _Immutable$Map);

	    function Style(_style) {
	        _classCallCheck(this, Style);

	        var _this = _possibleConstructorReturn(this, (Style.__proto__ || Object.getPrototypeOf(Style)).call(this, _style));

	        if (_this.__proto__ !== Style.prototype) {
	            _this.__proto__ = Style.prototype;
	        }
	        var instance = _this;
	        if (_style && _typeof(_utils2.default.isObject(_style))) {
	            instance.styleKeys = Object.keys(_style);

	            var _loop = function _loop(name) {
	                Object.defineProperty(_this, name, {
	                    get: function get() {
	                        return instance.get(name);
	                    },
	                    set: function set(val) {
	                        var newStyle = instance.set(name, val);
	                        //
	                        instance.styleChange && instance.styleChange.apply(instance, [name, val]);
	                        return newStyle;
	                    }
	                });
	            };

	            for (var name in _style) {
	                _loop(name);
	            }
	        } else {
	            instance._style = _immutable2.default.Map({});
	        }
	        return _this;
	    }

	    _createClass(Style, [{
	        key: 'recoveryData',
	        value: function recoveryData(prevData) {
	            var _this2 = this;

	            if (prevData && prevData.constructor === Style) {
	                var instance = this;
	                if (prevData.styleKeys) {
	                    this.styleKeys = prevData.styleKeys;
	                    prevData.styleKeys.map(function (name, i) {
	                        Object.defineProperty(_this2, name, {
	                            get: function get() {
	                                return instance.get(name);
	                            },
	                            set: function set(val) {
	                                var newStyle = instance.set(name, val);
	                                //
	                                instance.styleChange && instance.styleChange.apply(instance, [name, val]);
	                                return newStyle;
	                            }
	                        });
	                    });
	                }
	            }
	        }
	        /**
	         * style
	         * */

	    }, {
	        key: 'getNoPosStyle',
	        value: function getNoPosStyle() {
	            var $$noPosStyle = this.toObject();
	            posStyle.forEach(function (e, i) {
	                if ($$noPosStyle[e] !== undefined) {
	                    delete $$noPosStyle[e];
	                }
	            });
	            return $$noPosStyle;
	        }
	        /**
	         * style 
	         * */

	    }, {
	        key: 'getPosStyle',
	        value: function getPosStyle() {
	            var $$noPosStyle = this,
	                style = {};
	            posStyle.forEach(function (e, i) {
	                if ($$noPosStyle.get(e)) {
	                    style[e] = $$noPosStyle.get(e);
	                }
	            });
	            comStyle.forEach(function (e, i) {
	                if ($$noPosStyle.get(e)) {
	                    style[e] = $$noPosStyle.get(e);
	                }
	            });
	            return style;
	        }
	    }, {
	        key: 'addStyle',
	        value: function addStyle(name, val) {
	            var instance = this;
	            if (this.hasOwnProperty(name)) {
	                return;
	            }
	            Object.defineProperty(this, name, {
	                get: function get() {
	                    return instance._style.get(name);
	                },
	                set: function set(val) {
	                    instance._style = instance._style.set(name, val);
	                    instance.styleChange && instance.styleChange.apply(instance, [name, val]);
	                }
	            });
	            if (val) {
	                instance[name] = val;
	            }
	        }
	    }, {
	        key: 'styleChange',
	        value: function styleChange() {}
	    }]);

	    return Style;
	}(_immutable2.default.Map);

	exports.default = Style;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _div = __webpack_require__(202);

	var _div2 = _interopRequireDefault(_div);

	var _ComponentBase = __webpack_require__(205);

	var _ComponentBase2 = _interopRequireDefault(_ComponentBase);

	var _pieChart = __webpack_require__(206);

	var _pieChart2 = _interopRequireDefault(_pieChart);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	    Div: _div2.default,
	    PieChart: _pieChart2.default,
	    ComponentBase: _ComponentBase2.default
	};

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _componentBase = __webpack_require__(203);

	var _componentBase2 = _interopRequireDefault(_componentBase);

	var _editDecorator = __webpack_require__(204);

	var _editDecorator2 = _interopRequireDefault(_editDecorator);

	var _reactImmutableRenderMixin = __webpack_require__(191);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Div = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = (0, _editDecorator2.default)(_class = function (_ComponentBase) {
	    _inherits(Div, _ComponentBase);

	    function Div(props) {
	        _classCallCheck(this, Div);

	        return _possibleConstructorReturn(this, (Div.__proto__ || Object.getPrototypeOf(Div)).call(this, props));
	    }

	    return Div;
	}(_componentBase2.default)) || _class) || _class;

	exports.default = Div;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ComponentBase = function (_Component) {
	    _inherits(ComponentBase, _Component);

	    function ComponentBase(props) {
	        _classCallCheck(this, ComponentBase);

	        var _this = _possibleConstructorReturn(this, (ComponentBase.__proto__ || Object.getPrototypeOf(ComponentBase)).call(this, props));

	        _this.initComponent(props);
	        _this.state = {
	            id: _this.props.component.id,
	            component: _this.props.component
	        };
	        return _this;
	    }

	    _createClass(ComponentBase, [{
	        key: 'getProps',
	        value: function getProps() {
	            return _extends({
	                id: this.state.id,
	                name: this.props.component.name
	            }, this.props.component.attrs, {
	                style: this.props.component.getNoPosStyle()
	            });
	        }
	    }, {
	        key: 'template',
	        value: function template() {
	            // 
	            var props = this.getProps(),
	                dom = _react2.default.createElement('div', props, this.props.children);
	            return dom;
	        }
	    }, {
	        key: 'initComponent',
	        value: function initComponent(props) {
	            if (!props.component) {
	                console.error('component init error by constructor');
	                return false;
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var template = this.template();
	            return template;
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            if (this.props.component.style.styleChange) {
	                /*this.props.component.style.styleChange = (name,val)=>{
	                    this.setState()
	                }*/
	            }
	        }
	    }]);

	    return ComponentBase;
	}(_react.Component);

	exports.default = ComponentBase;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = editDecorator;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(37);

	var _server = __webpack_require__(185);

	var _server2 = _interopRequireDefault(_server);

	var _utils = __webpack_require__(188);

	var _utils2 = _interopRequireDefault(_utils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   editDecorator.js  
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * **/


	var manage = _server2.default.manage;

	function editDecorator(Target) {
	    var editBox = function (_Component) {
	        _inherits(editBox, _Component);

	        function editBox(props) {
	            _classCallCheck(this, editBox);

	            var _this = _possibleConstructorReturn(this, (editBox.__proto__ || Object.getPrototypeOf(editBox)).call(this, props));

	            _this.state = {
	                drag: false,
	                n: 0,
	                active: true
	            };
	            _this.style = _this.props.component.style.getPosStyle();
	            _this.component = _this.props.component;
	            _this.changePos = _this.changePos.bind(_this);
	            _this.boxMouseUp = _this.boxMouseUp.bind(_this);
	            _this.boxMouseMove = _this.boxMouseMove.bind(_this);
	            _this.boxMouseDown = _this.boxMouseDown.bind(_this);
	            _this.boxMouseOut = _this.boxMouseOut.bind(_this);
	            _this.borderMouseMove = _this.borderMouseMove.bind(_this);
	            _this.borderMouseUp = _this.borderMouseUp.bind(_this);

	            return _this;
	        }

	        _createClass(editBox, [{
	            key: 'changePos',
	            value: function changePos() {
	                this.setState({ n: ++this.state.n });
	            }
	        }, {
	            key: 'borderMouseDown',
	            value: function borderMouseDown(type, evt) {
	                if (evt.target.parentElement.className.indexOf("resizeBox") > -1) {
	                    evt.stopPropagation();
	                    this.move = true;
	                    this.x = evt.clientX;
	                    this.y = evt.clientY;
	                    this.type = type;
	                    _server2.default.emit('listItem:resize_start', type, { up: this.borderMouseUp, move: this.borderMouseMove });
	                    !this.state.active && this.setState({ active: true });
	                    manage.currentId = this.component.id;
	                }
	            }
	        }, {
	            key: 'borderMouseMove',
	            value: function borderMouseMove(evt) {
	                if (this.move) {
	                    var dx = void 0,
	                        dy = void 0,
	                        style = this.style;
	                    switch (this.type) {
	                        case 'n':
	                            {
	                                dy = evt.clientY - this.y;
	                                if (dy <= style.height) {
	                                    style.height -= dy;
	                                    style.top += dy;
	                                }
	                                break;
	                            }
	                        case 'e':
	                            {
	                                dx = evt.clientX - this.x;
	                                if (-dx <= style.width) {
	                                    style.width += dx;
	                                }
	                                break;
	                            }
	                        case 's':
	                            {
	                                dy = this.y - evt.clientY;
	                                if (dy <= style.height) {
	                                    style.height -= dy;
	                                }
	                                break;
	                            }
	                        case 'w':
	                            {
	                                dx = evt.clientX - this.x;
	                                if (dx <= style.width) {
	                                    style.width -= dx;
	                                    style.left += dx;
	                                }
	                                break;
	                            }
	                        case 'se':
	                            {
	                                dx = this.x - evt.clientX;
	                                dy = this.y - evt.clientY;
	                                if (dx <= style.width && dy <= style.height) {
	                                    style.width -= dx;
	                                    style.height -= dy;
	                                }
	                                break;
	                            }
	                        default:
	                            break;
	                    }
	                    manage.update(this.component.mergeIn(['style'], this.style), true);
	                    this.x = evt.clientX;
	                    this.y = evt.clientY;
	                }
	            }
	        }, {
	            key: 'borderMouseUp',
	            value: function borderMouseUp(evt) {
	                this.move = false;
	                this.type = "";
	                manage.update(this.component.mergeIn(['style'], this.style));
	            }
	        }, {
	            key: 'getDropTarget',
	            value: function getDropTarget(evt) {
	                var _this2 = this;

	                var drops = document.querySelectorAll('#canvas .component'),
	                    currentZindex = void 0,
	                    target = void 0;
	                drops.forEach(function (e, i) {
	                    if (e.parentElement === _this2.boxDom) {
	                        return;
	                    }
	                    var left = _utils2.default.offset(e).left,
	                        top = _utils2.default.offset(e).top;
	                    if (evt.clientX > left && evt.clientX < left + e.offsetWidth && evt.clientY > top && evt.clientY < top + e.offsetHeight) {
	                        if (e.parentElement.style.zIndex !== "") {
	                            if (currentZindex === undefined) {
	                                currentZindex = ~~e.parentElement.style.zIndex;
	                                target = e;
	                            } else if (e.parentElement.style.zIndex - currentZindex >= 0) {
	                                currentZindex = ~~e.parentElement.style.zIndex;
	                                target = e;
	                            }
	                        } else if (currentZindex === undefined || currentZindex < 0) {
	                            target = e;
	                        }
	                    }
	                });
	                target && console.log(target.getAttribute('id') + ' can drop');
	            }
	        }, {
	            key: 'boxMouseMove',
	            value: function boxMouseMove(evt) {
	                if (this.isMove) {
	                    var _x = evt.clientX - this.x,
	                        _y = evt.clientY - this.y;
	                    this.style.left = this.startLeft + _x + this.boxParentDom.scrollLeft - this.parentScrollLeft;
	                    this.style.top = this.startTop + _y + this.boxParentDom.scrollTop - this.parentScrollTop;
	                    manage.update(this.component.mergeIn(['style'], this.style), true);
	                }
	            }
	        }, {
	            key: 'boxMouseUp',
	            value: function boxMouseUp(evt) {
	                this.isMove = false;
	                this.setState({ drag: false });
	                this.getDropTarget(evt);
	                manage.update(this.component.mergeIn(['style'], this.style));
	            }
	        }, {
	            key: 'boxMouseDown',
	            value: function boxMouseDown(evt) {
	                if (!this.isMove) {
	                    this.isMove = true;
	                    //
	                    this.x = evt.clientX;
	                    this.y = evt.clientY;
	                    this.parentScrollLeft = this.boxParentDom.scrollLeft;
	                    this.parentScrollTop = this.boxParentDom.scrollTop;
	                    this.startLeft = this.style.left;
	                    this.startTop = this.style.top;
	                    _server2.default.emit('listItem:box_start', { up: this.boxMouseUp, move: this.boxMouseMove, id: this.props.component.id });
	                    _server2.default.emit('listItem:clear_active', this.component.id);
	                    this.setState({ drag: true, active: true });
	                    manage.currentId = this.component.id;
	                }
	            }
	        }, {
	            key: 'boxMouseOut',
	            value: function boxMouseOut() {
	                this.isMove = false;
	                this.setState({ drag: false });
	            }
	        }, {
	            key: 'render',
	            value: function render() {
	                var posStyle = this.style;
	                return _react2.default.createElement(
	                    'div',
	                    { className: (this.state.drag ? "resizeBox drag" : "resizeBox") + (this.state.active ? ' active' : ''), onMouseDown: this.boxMouseDown, style: _extends({}, posStyle) },
	                    _react2.default.createElement(
	                        Target,
	                        _extends({}, this.props, { isDrag: this.state.drag }),
	                        this.props.children
	                    ),
	                    _react2.default.createElement('div', { className: 'n', onMouseDown: this.borderMouseDown.bind(this, 'n'), style: { width: posStyle.width, left: 0, top: -2 } }),
	                    _react2.default.createElement('div', { className: 'e', onMouseDown: this.borderMouseDown.bind(this, 'e'), style: { height: posStyle.height, right: -2, top: 0 } }),
	                    _react2.default.createElement('div', { className: 's', onMouseDown: this.borderMouseDown.bind(this, 's'), style: { width: posStyle.width, left: 0, bottom: -2 } }),
	                    _react2.default.createElement('div', { className: 'w', onMouseDown: this.borderMouseDown.bind(this, 'w'), style: { height: posStyle.height, left: -2, top: 0 } }),
	                    _react2.default.createElement('div', { className: 'se', onMouseDown: this.borderMouseDown.bind(this, 'se'), style: { right: -2, bottom: -2 } })
	                );
	            }
	        }, {
	            key: 'componentWillUpdate',
	            value: function componentWillUpdate(nextProps, nextState, nextContent) {
	                this.style = nextProps.component.style.getPosStyle();
	                this.component = nextProps.component;
	            }
	        }, {
	            key: 'componentDidMount',
	            value: function componentDidMount() {
	                var _this3 = this;

	                this.boxDom = (0, _reactDom.findDOMNode)(this);
	                this.boxParentDom = this.boxDom.parentElement;

	                _server2.default.emit('listItem:clear_active', this.component.id);
	                manage.currentId = this.component.id;

	                _server2.default.on('listItem:resize_move', this.borderMouseMove);
	                _server2.default.on('listItem:resize_end', this.borderMouseUp);
	                _server2.default.on('listItem:box_move', this.boxMouseMove);
	                _server2.default.on('listItem:box_end', this.boxMouseUp);
	                _server2.default.on('listItem:clear_active', this.clearActive = function (currentActiveId) {
	                    if (currentActiveId === _this3.component.id) {
	                        return;
	                    }
	                    _this3.state.active && _this3.setState({ active: false });
	                });
	            }
	        }, {
	            key: 'componentWillUnmount',
	            value: function componentWillUnmount() {
	                _server2.default.off('listItem:resize_move', this.borderMouseMove);
	                _server2.default.off('listItem:resize_end', this.borderMouseUp);
	                _server2.default.off('listItem:box_move', this.boxMouseMove);
	                _server2.default.off('listItem:box_end', this.boxMouseUp);
	                _server2.default.off('listItem:clear_active', this.clearActive);
	            }
	        }]);

	        return editBox;
	    }(_react.Component);

	    return editBox;
	}

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ComponentBase = function (_Component) {
	    _inherits(ComponentBase, _Component);

	    function ComponentBase(props) {
	        _classCallCheck(this, ComponentBase);

	        var _this = _possibleConstructorReturn(this, (ComponentBase.__proto__ || Object.getPrototypeOf(ComponentBase)).call(this, props));

	        _this.initComponent(props);
	        _this.state = {
	            id: _this.props.component.id,
	            component: _this.props.component
	        };
	        return _this;
	    }

	    _createClass(ComponentBase, [{
	        key: 'getProps',
	        value: function getProps() {
	            return _extends({
	                id: this.state.id,
	                name: this.props.component.name
	            }, this.props.component.attrs, {
	                style: this.props.component.getNoPosStyle()
	            });
	        }
	    }, {
	        key: 'template',
	        value: function template() {
	            // 
	            var props = this.getProps(),
	                dom = _react2.default.createElement('div', props, this.props.children);
	            return dom;
	        }
	    }, {
	        key: 'initComponent',
	        value: function initComponent(props) {
	            if (!props.component) {
	                console.error('component init error by constructor');
	                return false;
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var template = this.template();
	            return template;
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            if (this.props.component.style.styleChange) {
	                /*this.props.component.style.styleChange = (name,val)=>{
	                    this.setState()
	                }*/
	            }
	        }
	    }]);

	    return ComponentBase;
	}(_react.Component);

	exports.default = ComponentBase;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _chartBase = __webpack_require__(207);

	var _chartBase2 = _interopRequireDefault(_chartBase);

	var _editDecorator = __webpack_require__(204);

	var _editDecorator2 = _interopRequireDefault(_editDecorator);

	var _reactImmutableRenderMixin = __webpack_require__(191);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var PieChart = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = (0, _editDecorator2.default)(_class = function (_ChartBase) {
	    _inherits(PieChart, _ChartBase);

	    function PieChart(props) {
	        _classCallCheck(this, PieChart);

	        return _possibleConstructorReturn(this, (PieChart.__proto__ || Object.getPrototypeOf(PieChart)).call(this, props));
	    }

	    _createClass(PieChart, [{
	        key: 'getDefaultOption',
	        value: function getDefaultOption() {
	            return {
	                backgroundColor: '#2c343c',

	                title: {
	                    text: 'Customized Pie',
	                    left: 'center',
	                    top: 20,
	                    textStyle: {
	                        color: '#ccc'
	                    }
	                },

	                tooltip: {
	                    trigger: 'item',
	                    formatter: "{a} <br/>{b} : {c} ({d}%)"
	                },

	                visualMap: {
	                    show: false,
	                    min: 80,
	                    max: 600,
	                    inRange: {
	                        colorLightness: [0, 1]
	                    }
	                },
	                series: [{
	                    name: '',
	                    type: 'pie',
	                    radius: '55%',
	                    center: ['50%', '50%'],
	                    data: [{ value: 335, name: '' }, { value: 310, name: '' }, { value: 274, name: '' }, { value: 235, name: '' }, { value: 400, name: '' }].sort(function (a, b) {
	                        return a.value - b.value;
	                    }),
	                    roseType: 'angle',
	                    label: {
	                        normal: {
	                            textStyle: {
	                                color: 'rgba(255, 255, 255, 0.3)'
	                            }
	                        }
	                    },
	                    labelLine: {
	                        normal: {
	                            lineStyle: {
	                                color: 'rgba(255, 255, 255, 0.3)'
	                            },
	                            smooth: 0.2,
	                            length: 10,
	                            length2: 20
	                        }
	                    },
	                    itemStyle: {
	                        normal: {
	                            color: '#c23531',
	                            shadowBlur: 200,
	                            shadowColor: 'rgba(0, 0, 0, 0.5)'
	                        }
	                    },
	                    animationType: 'scale',
	                    animationEasing: 'elasticOut',
	                    animationDelay: function animationDelay(idx) {
	                        return Math.random() * 200;
	                    }
	                }]
	            };
	        }
	    }]);

	    return PieChart;
	}(_chartBase2.default)) || _class) || _class;

	exports.default = PieChart;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _componentBase = __webpack_require__(203);

	var _componentBase2 = _interopRequireDefault(_componentBase);

	var _echarts = __webpack_require__(208);

	var _echarts2 = _interopRequireDefault(_echarts);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	//let echarts = require('../../lib/echarts.min');

	var ChartBase = function (_ComponentBase) {
	    _inherits(ChartBase, _ComponentBase);

	    function ChartBase(props) {
	        _classCallCheck(this, ChartBase);

	        return _possibleConstructorReturn(this, (ChartBase.__proto__ || Object.getPrototypeOf(ChartBase)).call(this, props));
	    }

	    _createClass(ChartBase, [{
	        key: 'getDefaultOption',
	        value: function getDefaultOption() {
	            return {
	                backgroundColor: '#2c343c',

	                title: {
	                    text: 'Customized Pie',
	                    left: 'center',
	                    top: 20,
	                    textStyle: {
	                        color: '#ccc'
	                    }
	                },

	                tooltip: {
	                    trigger: 'item',
	                    formatter: "{a} <br/>{b} : {c} ({d}%)"
	                },

	                visualMap: {
	                    show: false,
	                    min: 80,
	                    max: 600,
	                    inRange: {
	                        colorLightness: [0, 1]
	                    }
	                },
	                series: [{
	                    name: '',
	                    type: 'pie',
	                    radius: '55%',
	                    center: ['50%', '50%'],
	                    data: [{ value: 335, name: '' }, { value: 310, name: '' }, { value: 274, name: '' }, { value: 235, name: '' }, { value: 400, name: '' }].sort(function (a, b) {
	                        return a.value - b.value;
	                    }),
	                    roseType: 'angle',
	                    label: {
	                        normal: {
	                            textStyle: {
	                                color: 'rgba(255, 255, 255, 0.3)'
	                            }
	                        }
	                    },
	                    labelLine: {
	                        normal: {
	                            lineStyle: {
	                                color: 'rgba(255, 255, 255, 0.3)'
	                            },
	                            smooth: 0.2,
	                            length: 10,
	                            length2: 20
	                        }
	                    },
	                    itemStyle: {
	                        normal: {
	                            color: '#c23531',
	                            shadowBlur: 200,
	                            shadowColor: 'rgba(0, 0, 0, 0.5)'
	                        }
	                    },
	                    animationType: 'scale',
	                    animationEasing: 'elasticOut',
	                    animationDelay: function animationDelay(idx) {
	                        return Math.random() * 200;
	                    }
	                }]
	            };
	        }
	    }, {
	        key: 'refresh',
	        value: function refresh() {
	            if (this.props.isDrag) {
	                return;
	            }
	            var option = this.props.option;

	            if (!this.chart) {
	                this.chart = _echarts2.default.init(this.refs.chart);
	            }
	            if (!option) {
	                option = this.getDefaultOption();
	            }
	            this.chart.setOption(option, true);
	            this.chart.resize();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var props = _get(ChartBase.prototype.__proto__ || Object.getPrototypeOf(ChartBase.prototype), 'getProps', this).call(this);
	            return _react2.default.createElement('div', _extends({ ref: 'chart' }, props));
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.refresh();
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            this.refresh();
	        }
	    }]);

	    return ChartBase;
	}(_componentBase2.default);

	exports.default = ChartBase;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	!function (t, e) {
		"object" == ( false ? "undefined" : _typeof(exports)) && "object" == ( false ? "undefined" : _typeof(module)) ? module.exports = e() :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.echarts = e() : t.echarts = e();
	}(undefined, function () {
		return function (t) {
			function e(n) {
				if (i[n]) return i[n].exports;var a = i[n] = { exports: {}, id: n, loaded: !1 };return t[n].call(a.exports, a, a.exports, e), a.loaded = !0, a.exports;
			}var i = {};return e.m = t, e.c = i, e.p = "", e(0);
		}([function (t, e, i) {
			t.exports = i(2), i(108), i(102), i(112), i(191), i(331), i(319), i(346), i(293), i(289), i(285), i(326), i(336), i(270), i(275), i(282), i(314), i(306), i(330), i(341), i(281), i(207), i(208), i(209), i(232), i(55), i(373), i(370), i(251), i(252), i(361), i(368), i(223), i(197), i(387), i(216), i(215), i(214), i(377), i(224), i(239);
		}, function (t, e) {
			function i(t) {
				if (null == t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t))) return t;var e = t,
				    n = N.call(t);if ("[object Array]" === n) {
					e = [];for (var a = 0, o = t.length; a < o; a++) {
						e[a] = i(t[a]);
					}
				} else if (R[n]) e = t.constructor.from(t);else if (!E[n] && !P(t) && !I(t)) {
					e = {};for (var r in t) {
						t.hasOwnProperty(r) && (e[r] = i(t[r]));
					}
				}return e;
			}function n(t, e, a) {
				if (!S(e) || !S(t)) return a ? i(e) : t;for (var o in e) {
					if (e.hasOwnProperty(o)) {
						var r = t[o],
						    s = e[o];!S(s) || !S(r) || _(s) || _(r) || I(s) || I(r) || M(s) || M(r) || P(s) || P(r) ? !a && o in t || (t[o] = i(e[o], !0)) : n(r, s, a);
					}
				}return t;
			}function a(t, e) {
				for (var i = t[0], a = 1, o = t.length; a < o; a++) {
					i = n(i, t[a], e);
				}return i;
			}function o(t, e) {
				for (var i in e) {
					e.hasOwnProperty(i) && (t[i] = e[i]);
				}return t;
			}function r(t, e, i) {
				for (var n in e) {
					e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
				}return t;
			}function s() {
				return document.createElement("canvas");
			}function l() {
				return z || (z = U.createCanvas().getContext("2d")), z;
			}function u(t, e) {
				if (t) {
					if (t.indexOf) return t.indexOf(e);for (var i = 0, n = t.length; i < n; i++) {
						if (t[i] === e) return i;
					}
				}return -1;
			}function c(t, e) {
				function i() {}var n = t.prototype;i.prototype = e.prototype, t.prototype = new i();for (var a in n) {
					t.prototype[a] = n[a];
				}t.prototype.constructor = t, t.superClass = e;
			}function h(t, e, i) {
				t = "prototype" in t ? t.prototype : t, e = "prototype" in e ? e.prototype : e, r(t, e, i);
			}function d(t) {
				if (t) return "string" != typeof t && "number" == typeof t.length;
			}function f(t, e, i) {
				if (t && e) if (t.forEach && t.forEach === B) t.forEach(e, i);else if (t.length === +t.length) for (var n = 0, a = t.length; n < a; n++) {
					e.call(i, t[n], n, t);
				} else for (var o in t) {
					t.hasOwnProperty(o) && e.call(i, t[o], o, t);
				}
			}function p(t, e, i) {
				if (t && e) {
					if (t.map && t.map === F) return t.map(e, i);for (var n = [], a = 0, o = t.length; a < o; a++) {
						n.push(e.call(i, t[a], a, t));
					}return n;
				}
			}function g(t, e, i, n) {
				if (t && e) {
					if (t.reduce && t.reduce === W) return t.reduce(e, i, n);for (var a = 0, o = t.length; a < o; a++) {
						i = e.call(n, i, t[a], a, t);
					}return i;
				}
			}function m(t, e, i) {
				if (t && e) {
					if (t.filter && t.filter === G) return t.filter(e, i);for (var n = [], a = 0, o = t.length; a < o; a++) {
						e.call(i, t[a], a, t) && n.push(t[a]);
					}return n;
				}
			}function v(t, e, i) {
				if (t && e) for (var n = 0, a = t.length; n < a; n++) {
					if (e.call(i, t[n], n, t)) return t[n];
				}
			}function y(t, e) {
				var i = H.call(arguments, 2);return function () {
					return t.apply(e, i.concat(H.call(arguments)));
				};
			}function x(t) {
				var e = H.call(arguments, 1);return function () {
					return t.apply(this, e.concat(H.call(arguments)));
				};
			}function _(t) {
				return "[object Array]" === N.call(t);
			}function b(t) {
				return "function" == typeof t;
			}function w(t) {
				return "[object String]" === N.call(t);
			}function S(t) {
				var e = typeof t === "undefined" ? "undefined" : _typeof(t);return "function" === e || !!t && "object" == e;
			}function M(t) {
				return !!E[N.call(t)];
			}function I(t) {
				return "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && "number" == typeof t.nodeType && "object" == _typeof(t.ownerDocument);
			}function T(t) {
				return t !== t;
			}function A(t) {
				for (var e = 0, i = arguments.length; e < i; e++) {
					if (null != arguments[e]) return arguments[e];
				}
			}function C() {
				return Function.call.apply(H, arguments);
			}function L(t, e) {
				if (!t) throw new Error(e);
			}function D(t) {
				t[Z] = !0;
			}function P(t) {
				return t[Z];
			}function k(t) {
				t && f(t, function (t, e) {
					this.set(e, t);
				}, this);
			}function O(t) {
				return new k(t);
			}var z,
			    E = { "[object Function]": 1, "[object RegExp]": 1, "[object Date]": 1, "[object Error]": 1, "[object CanvasGradient]": 1, "[object CanvasPattern]": 1, "[object Image]": 1, "[object Canvas]": 1 },
			    R = { "[object Int8Array]": 1, "[object Uint8Array]": 1, "[object Uint8ClampedArray]": 1, "[object Int16Array]": 1, "[object Uint16Array]": 1, "[object Int32Array]": 1, "[object Uint32Array]": 1, "[object Float32Array]": 1, "[object Float64Array]": 1 },
			    N = Object.prototype.toString,
			    V = Array.prototype,
			    B = V.forEach,
			    G = V.filter,
			    H = V.slice,
			    F = V.map,
			    W = V.reduce,
			    Z = "__ec_primitive__",
			    q = "_ec_",
			    j = 4;k.prototype = { constructor: k, get: function get(t) {
					return this[q + t];
				}, set: function set(t, e) {
					return this[q + t] = e, e;
				}, each: function each(t, e) {
					void 0 !== e && (t = y(t, e));for (var i in this) {
						this.hasOwnProperty(i) && t(this[i], i.slice(j));
					}
				}, removeKey: function removeKey(t) {
					delete this[t];
				} };var U = { inherits: c, mixin: h, clone: i, merge: n, mergeAll: a, extend: o, defaults: r, getContext: l, createCanvas: s, indexOf: u, slice: C, find: v, isArrayLike: d, each: f, map: p, reduce: g, filter: m, bind: y, curry: x, isArray: _, isString: w, isObject: S, isFunction: b, isBuiltInObject: M, isDom: I, eqNaN: T, retrieve: A, assert: L, setAsPrimitive: D, createHashMap: O, noop: function noop() {} };t.exports = U;
		}, function (t, e, i) {
			function n(t) {
				return function (e, i, n) {
					e = e && e.toLowerCase(), V.prototype[t].call(this, e, i, n);
				};
			}function a() {
				V.call(this);
			}function o(t, e, i) {
				function n(t, e) {
					return t.prio - e.prio;
				}i = i || {}, "string" == typeof e && (e = lt[e]), this.id, this.group, this._dom = t;var o = this._zr = E.init(t, { renderer: i.renderer || "canvas", devicePixelRatio: i.devicePixelRatio, width: i.width, height: i.height });this._throttledZrFlush = z.throttle(R.bind(o.flush, o), 17), this._theme = R.clone(e), this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._coordSysMgr = new T(), this._api = b(this), V.call(this), this._messageCenter = new a(), this._initEvents(), this.resize = R.bind(this.resize, this), this._pendingActions = [], B(st, n), B(at, n), o.animation.on("frame", this._onframe, this), R.setAsPrimitive(this);
			}function r(t, e, i) {
				var n,
				    a = this._model,
				    o = this._coordSysMgr.getCoordinateSystems();e = O.parseFinder(a, e);for (var r = 0; r < o.length; r++) {
					var s = o[r];if (s[t] && null != (n = s[t](a, e, i))) return n;
				}
			}function s(t, e, i, n, a) {
				function o(n) {
					n && n.__alive && n[e] && n[e](n.__model, r, t._api, i);
				}var r = t._model;if (!n) return void G(t._componentsViews.concat(t._chartsViews), o);var s = {};s[n + "Id"] = i[n + "Id"], s[n + "Index"] = i[n + "Index"], s[n + "Name"] = i[n + "Name"];var l = { mainType: n, query: s };a && (l.subType = a), r && r.eachComponent(l, function (e, i) {
					o(t["series" === n ? "_chartsMap" : "_componentsMap"][e.__viewId]);
				}, t);
			}function l(t, e) {
				var i = t.type,
				    n = t.escapeConnect,
				    a = it[i],
				    o = a.actionInfo,
				    r = (o.update || "update").split(":"),
				    l = r.pop();r = null != r[0] && H(r[0]), this[Y] = !0;var u = [t],
				    c = !1;t.batch && (c = !0, u = R.map(t.batch, function (e) {
					return e = R.defaults(R.extend({}, e), t), e.batch = null, e;
				}));var h,
				    d = [],
				    f = "highlight" === i || "downplay" === i;G(u, function (t) {
					h = a.action(t, this._model, this._api), h = h || R.extend({}, t), h.type = o.event || h.type, d.push(h), f ? s(this, l, t, "series") : r && s(this, l, t, r.main, r.sub);
				}, this), "none" === l || f || r || (this[K] ? (tt.prepareAndUpdate.call(this, t), this[K] = !1) : tt[l].call(this, t)), h = c ? { type: o.event || i, escapeConnect: n, batch: d } : d[0], this[Y] = !1, !e && this._messageCenter.trigger(h.type, h);
			}function u(t) {
				for (var e = this._pendingActions; e.length;) {
					var i = e.shift();l.call(this, i, t);
				}
			}function c(t) {
				!t && this.trigger("updated");
			}function h(t, e, i) {
				var n = this._api;G(this._componentsViews, function (a) {
					var o = a.__model;a[t](o, e, n, i), _(o, a);
				}, this), e.eachSeries(function (a, o) {
					var r = this._chartsMap[a.__viewId];r[t](a, e, n, i), _(a, r), x(a, r);
				}, this), y(this._zr, e), G(rt, function (t) {
					t(e, n);
				});
			}function d(t, e) {
				for (var i = "component" === t, n = i ? this._componentsViews : this._chartsViews, a = i ? this._componentsMap : this._chartsMap, o = this._zr, r = 0; r < n.length; r++) {
					n[r].__alive = !1;
				}e[i ? "eachComponent" : "eachSeries"](function (t, r) {
					if (i) {
						if ("series" === t) return;
					} else r = t;var s = "_ec_" + r.id + "_" + r.type,
					    l = a[s];if (!l) {
						var u = H(r.type),
						    c = i ? D.getClass(u.main, u.sub) : P.getClass(u.sub);if (!c) return;l = new c(), l.init(e, this._api), a[s] = l, n.push(l), o.add(l.group);
					}r.__viewId = l.__id = s, l.__alive = !0, l.__model = r, l.group.__ecComponentInfo = { mainType: r.mainType, index: r.componentIndex };
				}, this);for (var r = 0; r < n.length;) {
					var s = n[r];s.__alive ? r++ : (o.remove(s.group), s.dispose(e, this._api), n.splice(r, 1), delete a[s.__id], s.__id = s.group.__ecComponentInfo = null);
				}
			}function f(t, e) {
				G(at, function (i) {
					i.func(t, e);
				});
			}function p(t) {
				var e = {};t.eachSeries(function (t) {
					var i = t.get("stack"),
					    n = t.getData();if (i && "list" === n.type) {
						var a = e[i];e.hasOwnProperty(i) && a && (n.stackedOn = a), e[i] = n;
					}
				});
			}function g(t, e) {
				var i = this._api;G(st, function (n) {
					n.isLayout && n.func(t, i, e);
				});
			}function m(t, e, i) {
				var n = this._api;t.clearColorPalette(), t.eachSeries(function (t) {
					t.clearColorPalette();
				}), G(st, function (a) {
					(!i || !a.isLayout) && a.func(t, n, e);
				});
			}function v(t, e) {
				var i = this._api;G(this._componentsViews, function (n) {
					var a = n.__model;n.render(a, t, i, e), _(a, n);
				}, this), G(this._chartsViews, function (t) {
					t.__alive = !1;
				}, this), t.eachSeries(function (n, a) {
					var o = this._chartsMap[n.__viewId];o.__alive = !0, o.render(n, t, i, e), o.group.silent = !!n.get("silent"), _(n, o), x(n, o);
				}, this), y(this._zr, t), G(this._chartsViews, function (e) {
					e.__alive || e.remove(t, i);
				}, this);
			}function y(t, e) {
				var i = t.storage,
				    n = 0;i.traverse(function (t) {
					t.isGroup || n++;
				}), n > e.get("hoverLayerThreshold") && !S.node && i.traverse(function (t) {
					t.isGroup || (t.useHoverLayer = !0);
				});
			}function x(t, e) {
				var i = 0;e.group.traverse(function (t) {
					"group" === t.type || t.ignore || i++;
				});var n = +t.get("progressive"),
				    a = i > t.get("progressiveThreshold") && n && !S.node;a && e.group.traverse(function (t) {
					t.isGroup || (t.progressive = a ? Math.floor(i++ / n) : -1, a && t.stopAnimation(!0));
				});var o = t.get("blendMode") || null;e.group.traverse(function (t) {
					t.isGroup || t.setStyle("blend", o);
				});
			}function _(t, e) {
				var i = t.get("z"),
				    n = t.get("zlevel");e.group.traverse(function (t) {
					"group" !== t.type && (null != i && (t.z = i), null != n && (t.zlevel = n));
				});
			}function b(t) {
				var e = t._coordSysMgr;return R.extend(new I(t), { getCoordinateSystems: R.bind(e.getCoordinateSystems, e), getComponentByElement: function getComponentByElement(e) {
						for (; e;) {
							var i = e.__ecComponentInfo;if (null != i) return t._model.getComponent(i.mainType, i.index);e = e.parent;
						}
					} });
			}function w(t) {
				function e(t, e) {
					for (var i = 0; i < t.length; i++) {
						var n = t[i];n[o] = e;
					}
				}var i = 0,
				    n = 1,
				    a = 2,
				    o = "__connectUpdateStatus";R.each(nt, function (r, s) {
					t._messageCenter.on(s, function (r) {
						if (ht[t.group] && t[o] !== i) {
							if (r && r.escapeConnect) return;var s = t.makeActionFromEvent(r),
							    l = [];R.each(ct, function (e) {
								e !== t && e.group === t.group && l.push(e);
							}), e(l, i), G(l, function (t) {
								t[o] !== n && t.dispatchAction(s);
							}), e(l, a);
						}
					});
				});
			} /*!
	    * ECharts, a javascript interactive chart library.
	    *
	    * Copyright (c) 2015, Baidu Inc.
	    * All rights reserved.
	    *
	    * LICENSE
	    * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt
	    */
			var S = i(9),
			    M = i(137),
			    I = i(101),
			    T = i(26),
			    A = i(138),
			    C = i(13),
			    L = i(17),
			    D = i(65),
			    P = i(30),
			    k = i(3),
			    O = i(5),
			    z = i(37),
			    E = i(88),
			    R = i(1),
			    N = i(22),
			    V = i(23),
			    B = i(51),
			    G = R.each,
			    H = C.parseClassType,
			    F = 1e3,
			    W = 5e3,
			    Z = 1e3,
			    q = 2e3,
			    j = 3e3,
			    U = 4e3,
			    X = 5e3,
			    Y = "__flagInMainProcess",
			    $ = "__hasGradientOrPatternBg",
			    K = "__optionUpdated",
			    J = /^[a-zA-Z0-9_]+$/;a.prototype.on = n("on"), a.prototype.off = n("off"), a.prototype.one = n("one"), R.mixin(a, V);var Q = o.prototype;Q._onframe = function () {
				if (this[K]) {
					var t = this[K].silent;this[Y] = !0, tt.prepareAndUpdate.call(this), this[Y] = !1, this[K] = !1, u.call(this, t), c.call(this, t);
				}
			}, Q.getDom = function () {
				return this._dom;
			}, Q.getZr = function () {
				return this._zr;
			}, Q.setOption = function (t, e, i) {
				var n;if (R.isObject(e) && (i = e.lazyUpdate, n = e.silent, e = e.notMerge), this[Y] = !0, !this._model || e) {
					var a = new A(this._api),
					    o = this._theme,
					    r = this._model = new M(null, null, o, a);r.init(null, null, o, a);
				}this._model.setOption(t, ot), i ? (this[K] = { silent: n }, this[Y] = !1) : (tt.prepareAndUpdate.call(this), this._zr.flush(), this[K] = !1, this[Y] = !1, u.call(this, n), c.call(this, n));
			}, Q.setTheme = function () {
				console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
			}, Q.getModel = function () {
				return this._model;
			}, Q.getOption = function () {
				return this._model && this._model.getOption();
			}, Q.getWidth = function () {
				return this._zr.getWidth();
			}, Q.getHeight = function () {
				return this._zr.getHeight();
			}, Q.getDevicePixelRatio = function () {
				return this._zr.painter.dpr || window.devicePixelRatio || 1;
			}, Q.getRenderedCanvas = function (t) {
				if (S.canvasSupported) {
					t = t || {}, t.pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor");var e = this._zr,
					    i = e.storage.getDisplayList();return R.each(i, function (t) {
						t.stopAnimation(!0);
					}), e.painter.getRenderedCanvas(t);
				}
			}, Q.getDataURL = function (t) {
				t = t || {};var e = t.excludeComponents,
				    i = this._model,
				    n = [],
				    a = this;G(e, function (t) {
					i.eachComponent({ mainType: t }, function (t) {
						var e = a._componentsMap[t.__viewId];e.group.ignore || (n.push(e), e.group.ignore = !0);
					});
				});var o = this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));return G(n, function (t) {
					t.group.ignore = !1;
				}), o;
			}, Q.getConnectedDataURL = function (t) {
				if (S.canvasSupported) {
					var e = this.group,
					    i = Math.min,
					    n = Math.max,
					    a = 1 / 0;if (ht[e]) {
						var o = a,
						    r = a,
						    s = -a,
						    l = -a,
						    u = [],
						    c = t && t.pixelRatio || 1;R.each(ct, function (a, c) {
							if (a.group === e) {
								var h = a.getRenderedCanvas(R.clone(t)),
								    d = a.getDom().getBoundingClientRect();o = i(d.left, o), r = i(d.top, r), s = n(d.right, s), l = n(d.bottom, l), u.push({ dom: h, left: d.left, top: d.top });
							}
						}), o *= c, r *= c, s *= c, l *= c;var h = s - o,
						    d = l - r,
						    f = R.createCanvas();f.width = h, f.height = d;var p = E.init(f);return G(u, function (t) {
							var e = new k.Image({ style: { x: t.left * c - o, y: t.top * c - r, image: t.dom } });p.add(e);
						}), p.refreshImmediately(), f.toDataURL("image/" + (t && t.type || "png"));
					}return this.getDataURL(t);
				}
			}, Q.convertToPixel = R.curry(r, "convertToPixel"), Q.convertFromPixel = R.curry(r, "convertFromPixel"), Q.containPixel = function (t, e) {
				var i,
				    n = this._model;return t = O.parseFinder(n, t), R.each(t, function (t, n) {
					n.indexOf("Models") >= 0 && R.each(t, function (t) {
						var a = t.coordinateSystem;if (a && a.containPoint) i |= !!a.containPoint(e);else if ("seriesModels" === n) {
							var o = this._chartsMap[t.__viewId];o && o.containPoint && (i |= o.containPoint(e, t));
						}
					}, this);
				}, this), !!i;
			}, Q.getVisual = function (t, e) {
				var i = this._model;t = O.parseFinder(i, t, { defaultMainType: "series" });var n = t.seriesModel,
				    a = n.getData(),
				    o = t.hasOwnProperty("dataIndexInside") ? t.dataIndexInside : t.hasOwnProperty("dataIndex") ? a.indexOfRawIndex(t.dataIndex) : null;return null != o ? a.getItemVisual(o, e) : a.getVisual(e);
			}, Q.getViewOfComponentModel = function (t) {
				return this._componentsMap[t.__viewId];
			}, Q.getViewOfSeriesModel = function (t) {
				return this._chartsMap[t.__viewId];
			};var tt = { update: function update(t) {
					var e = this._model,
					    i = this._api,
					    n = this._coordSysMgr,
					    a = this._zr;if (e) {
						e.restoreData(), n.create(this._model, this._api), f.call(this, e, i), p.call(this, e), n.update(e, i), m.call(this, e, t), v.call(this, e, t);var o = e.get("backgroundColor") || "transparent",
						    r = a.painter;if (r.isSingleCanvas && r.isSingleCanvas()) a.configLayer(0, { clearColor: o });else {
							if (!S.canvasSupported) {
								var s = N.parse(o);o = N.stringify(s, "rgb"), 0 === s[3] && (o = "transparent");
							}o.colorStops || o.image ? (a.configLayer(0, { clearColor: o }), this[$] = !0, this._dom.style.background = "transparent") : (this[$] && a.configLayer(0, { clearColor: null }), this[$] = !1, this._dom.style.background = o);
						}G(rt, function (t) {
							t(e, i);
						});
					}
				}, updateView: function updateView(t) {
					var e = this._model;e && (e.eachSeries(function (t) {
						t.getData().clearAllVisual();
					}), m.call(this, e, t), h.call(this, "updateView", e, t));
				}, updateVisual: function updateVisual(t) {
					var e = this._model;e && (e.eachSeries(function (t) {
						t.getData().clearAllVisual();
					}), m.call(this, e, t, !0), h.call(this, "updateVisual", e, t));
				}, updateLayout: function updateLayout(t) {
					var e = this._model;e && (g.call(this, e, t), h.call(this, "updateLayout", e, t));
				}, prepareAndUpdate: function prepareAndUpdate(t) {
					var e = this._model;d.call(this, "component", e), d.call(this, "chart", e), tt.update.call(this, t);
				} };Q.resize = function (t) {
				this[Y] = !0, this._zr.resize(t);var e = this._model && this._model.resetOption("media"),
				    i = e ? "prepareAndUpdate" : "update";tt[i].call(this), this._loadingFX && this._loadingFX.resize(), this[Y] = !1;var n = t && t.silent;u.call(this, n), c.call(this, n);
			}, Q.showLoading = function (t, e) {
				if (R.isObject(t) && (e = t, t = ""), t = t || "default", this.hideLoading(), ut[t]) {
					var i = ut[t](this._api, e),
					    n = this._zr;this._loadingFX = i, n.add(i);
				}
			}, Q.hideLoading = function () {
				this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
			}, Q.makeActionFromEvent = function (t) {
				var e = R.extend({}, t);return e.type = nt[t.type], e;
			}, Q.dispatchAction = function (t, e) {
				if (R.isObject(e) || (e = { silent: !!e }), it[t.type]) {
					if (this[Y]) return void this._pendingActions.push(t);l.call(this, t, e.silent), e.flush ? this._zr.flush(!0) : e.flush !== !1 && S.browser.weChat && this._throttledZrFlush(), u.call(this, e.silent), c.call(this, e.silent);
				}
			}, Q.on = n("on"), Q.off = n("off"), Q.one = n("one");var et = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];Q._initEvents = function () {
				G(et, function (t) {
					this._zr.on(t, function (e) {
						var i,
						    n = this.getModel(),
						    a = e.target;if ("globalout" === t) i = {};else if (a && null != a.dataIndex) {
							var o = a.dataModel || n.getSeriesByIndex(a.seriesIndex);i = o && o.getDataParams(a.dataIndex, a.dataType) || {};
						} else a && a.eventData && (i = R.extend({}, a.eventData));i && (i.event = e, i.type = t, this.trigger(t, i));
					}, this);
				}, this), G(nt, function (t, e) {
					this._messageCenter.on(e, function (t) {
						this.trigger(e, t);
					}, this);
				}, this);
			}, Q.isDisposed = function () {
				return this._disposed;
			}, Q.clear = function () {
				this.setOption({ series: [] }, !0);
			}, Q.dispose = function () {
				if (!this._disposed) {
					this._disposed = !0;var t = this._api,
					    e = this._model;G(this._componentsViews, function (i) {
						i.dispose(e, t);
					}), G(this._chartsViews, function (i) {
						i.dispose(e, t);
					}), this._zr.dispose(), delete ct[this.id];
				}
			}, R.mixin(o, V);var it = {},
			    nt = {},
			    at = [],
			    ot = [],
			    rt = [],
			    st = [],
			    lt = {},
			    ut = {},
			    ct = {},
			    ht = {},
			    dt = new Date() - 0,
			    ft = new Date() - 0,
			    pt = "_echarts_instance_",
			    gt = { version: "3.6.1", dependencies: { zrender: "3.5.1" } };gt.init = function (t, e, i) {
				var n = gt.getInstanceByDom(t);if (n) return n;var a = new o(t, e, i);return a.id = "ec_" + dt++, ct[a.id] = a, t.setAttribute ? t.setAttribute(pt, a.id) : t[pt] = a.id, w(a), a;
			}, gt.connect = function (t) {
				if (R.isArray(t)) {
					var e = t;t = null, R.each(e, function (e) {
						null != e.group && (t = e.group);
					}), t = t || "g_" + ft++, R.each(e, function (e) {
						e.group = t;
					});
				}return ht[t] = !0, t;
			}, gt.disConnect = function (t) {
				ht[t] = !1;
			}, gt.disconnect = gt.disConnect, gt.dispose = function (t) {
				"string" == typeof t ? t = ct[t] : t instanceof o || (t = gt.getInstanceByDom(t)), t instanceof o && !t.isDisposed() && t.dispose();
			}, gt.getInstanceByDom = function (t) {
				var e;return e = t.getAttribute ? t.getAttribute(pt) : t[pt], ct[e];
			}, gt.getInstanceById = function (t) {
				return ct[t];
			}, gt.registerTheme = function (t, e) {
				lt[t] = e;
			}, gt.registerPreprocessor = function (t) {
				ot.push(t);
			}, gt.registerProcessor = function (t, e) {
				"function" == typeof t && (e = t, t = F), at.push({ prio: t, func: e });
			}, gt.registerPostUpdate = function (t) {
				rt.push(t);
			}, gt.registerAction = function (t, e, i) {
				"function" == typeof e && (i = e, e = "");var n = R.isObject(t) ? t.type : [t, t = { event: e }][0];t.event = (t.event || n).toLowerCase(), e = t.event, R.assert(J.test(n) && J.test(e)), it[n] || (it[n] = { action: i, actionInfo: t }), nt[e] = n;
			}, gt.registerCoordinateSystem = function (t, e) {
				T.register(t, e);
			}, gt.registerLayout = function (t, e) {
				"function" == typeof t && (e = t, t = Z), st.push({ prio: t, func: e, isLayout: !0 });
			}, gt.registerVisual = function (t, e) {
				"function" == typeof t && (e = t, t = j), st.push({ prio: t, func: e });
			}, gt.registerLoading = function (t, e) {
				ut[t] = e;
			}, gt.extendComponentModel = function (t) {
				return C.extend(t);
			}, gt.extendComponentView = function (t) {
				return D.extend(t);
			}, gt.extendSeriesModel = function (t) {
				return L.extend(t);
			}, gt.extendChartView = function (t) {
				return P.extend(t);
			}, gt.setCanvasCreator = function (t) {
				R.createCanvas = t;
			}, gt.registerVisual(q, i(151)), gt.registerPreprocessor(i(145)), gt.registerLoading("default", i(136)), gt.registerAction({ type: "highlight", event: "highlight", update: "highlight" }, R.noop), gt.registerAction({ type: "downplay", event: "downplay", update: "downplay" }, R.noop), gt.zrender = E, gt.List = i(14), gt.Model = i(10), gt.Axis = i(33), gt.graphic = i(3), gt.number = i(4), gt.format = i(7), gt.throttle = z.throttle, gt.matrix = i(19), gt.vector = i(6), gt.color = i(22), gt.util = {}, G(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], function (t) {
				gt.util[t] = R[t];
			}), gt.helper = i(135), gt.PRIORITY = { PROCESSOR: { FILTER: F, STATISTIC: W }, VISUAL: { LAYOUT: Z, GLOBAL: q, CHART: j, COMPONENT: U, BRUSH: X } }, t.exports = gt;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return null != t && "none" != t;
			}function a(t) {
				return "string" == typeof t ? x.lift(t, -.1) : t;
			}function o(t) {
				if (t.__hoverStlDirty) {
					var e = t.style.stroke,
					    i = t.style.fill,
					    o = t.__hoverStl;o.fill = o.fill || (n(i) ? a(i) : null), o.stroke = o.stroke || (n(e) ? a(e) : null);var r = {};for (var s in o) {
						o.hasOwnProperty(s) && (r[s] = t.style[s]);
					}t.__normalStl = r, t.__hoverStlDirty = !1;
				}
			}function r(t) {
				t.__isHover || (o(t), t.useHoverLayer ? t.__zr && t.__zr.addHover(t, t.__hoverStl) : (t.setStyle(t.__hoverStl), t.z2 += 1), t.__isHover = !0);
			}function s(t) {
				if (t.__isHover) {
					var e = t.__normalStl;t.useHoverLayer ? t.__zr && t.__zr.removeHover(t) : (e && t.setStyle(e), t.z2 -= 1), t.__isHover = !1;
				}
			}function l(t) {
				"group" === t.type ? t.traverse(function (t) {
					"group" !== t.type && r(t);
				}) : r(t);
			}function u(t) {
				"group" === t.type ? t.traverse(function (t) {
					"group" !== t.type && s(t);
				}) : s(t);
			}function c(t, e) {
				t.__hoverStl = t.hoverStyle || e || {}, t.__hoverStlDirty = !0, t.__isHover && o(t);
			}function h(t) {
				this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasis && l(this);
			}function d(t) {
				this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasis && u(this);
			}function f() {
				this.__isEmphasis = !0, l(this);
			}function p() {
				this.__isEmphasis = !1, u(this);
			}function g(t, e, i, n, a, o) {
				"function" == typeof a && (o = a, a = null);var r = n && n.isAnimationEnabled();if (r) {
					var s = t ? "Update" : "",
					    l = n.getShallow("animationDuration" + s),
					    u = n.getShallow("animationEasing" + s),
					    c = n.getShallow("animationDelay" + s);"function" == typeof c && (c = c(a, n.getAnimationDelayParams ? n.getAnimationDelayParams(e, a) : null)), "function" == typeof l && (l = l(a)), l > 0 ? e.animateTo(i, l, c || 0, u, o) : (e.stopAnimation(), e.attr(i), o && o());
				} else e.stopAnimation(), e.attr(i), o && o();
			}var m = i(1),
			    v = i(180),
			    y = i(8),
			    x = i(22),
			    _ = i(19),
			    b = i(6),
			    w = i(58),
			    S = i(11),
			    M = Math.round,
			    I = Math.max,
			    T = Math.min,
			    A = {};A.Group = i(36), A.Image = i(53), A.Text = i(86), A.Circle = i(171), A.Sector = i(177), A.Ring = i(176), A.Polygon = i(173), A.Polyline = i(174), A.Rect = i(175), A.Line = i(172), A.BezierCurve = i(170), A.Arc = i(169), A.CompoundPath = i(164), A.LinearGradient = i(100), A.RadialGradient = i(165), A.BoundingRect = S, A.extendShape = function (t) {
				return y.extend(t);
			}, A.extendPath = function (t, e) {
				return v.extendFromString(t, e);
			}, A.makePath = function (t, e, i, n) {
				var a = v.createFromString(t, e),
				    o = a.getBoundingRect();if (i) {
					var r = o.width / o.height;if ("center" === n) {
						var s,
						    l = i.height * r;l <= i.width ? s = i.height : (l = i.width, s = l / r);var u = i.x + i.width / 2,
						    c = i.y + i.height / 2;i.x = u - l / 2, i.y = c - s / 2, i.width = l, i.height = s;
					}A.resizePath(a, i);
				}return a;
			}, A.mergePath = v.mergePath, A.resizePath = function (t, e) {
				if (t.applyTransform) {
					var i = t.getBoundingRect(),
					    n = i.calculateTransform(e);t.applyTransform(n);
				}
			}, A.subPixelOptimizeLine = function (t) {
				var e = A.subPixelOptimize,
				    i = t.shape,
				    n = t.style.lineWidth;return M(2 * i.x1) === M(2 * i.x2) && (i.x1 = i.x2 = e(i.x1, n, !0)), M(2 * i.y1) === M(2 * i.y2) && (i.y1 = i.y2 = e(i.y1, n, !0)), t;
			}, A.subPixelOptimizeRect = function (t) {
				var e = A.subPixelOptimize,
				    i = t.shape,
				    n = t.style.lineWidth,
				    a = i.x,
				    o = i.y,
				    r = i.width,
				    s = i.height;return i.x = e(i.x, n, !0), i.y = e(i.y, n, !0), i.width = Math.max(e(a + r, n, !1) - i.x, 0 === r ? 0 : 1), i.height = Math.max(e(o + s, n, !1) - i.y, 0 === s ? 0 : 1), t;
			}, A.subPixelOptimize = function (t, e, i) {
				var n = M(2 * t);return (n + M(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2;
			}, A.setHoverStyle = function (t, e, i) {
				t.__hoverSilentOnTouch = i && i.hoverSilentOnTouch, "group" === t.type ? t.traverse(function (t) {
					"group" !== t.type && c(t, e);
				}) : c(t, e), t.on("mouseover", h).on("mouseout", d), t.on("emphasis", f).on("normal", p);
			}, A.setText = function (t, e, i) {
				var n = e.getShallow("position") || "inside",
				    a = e.getShallow("offset"),
				    o = n.indexOf("inside") >= 0 ? "white" : i,
				    r = e.getModel("textStyle");m.extend(t, { textDistance: e.getShallow("distance") || 5, textFont: r.getFont(), textPosition: n, textOffset: a, textFill: r.getTextColor() || o });
			}, A.getFont = function (t, e) {
				var i = e && e.getModel("textStyle");return [t.fontStyle || i && i.getShallow("fontStyle") || "", t.fontWeight || i && i.getShallow("fontWeight") || "", (t.fontSize || i && i.getShallow("fontSize") || 12) + "px", t.fontFamily || i && i.getShallow("fontFamily") || "sans-serif"].join(" ");
			}, A.updateProps = function (t, e, i, n, a) {
				g(!0, t, e, i, n, a);
			}, A.initProps = function (t, e, i, n, a) {
				g(!1, t, e, i, n, a);
			}, A.getTransform = function (t, e) {
				for (var i = _.identity([]); t && t !== e;) {
					_.mul(i, t.getLocalTransform(), i), t = t.parent;
				}return i;
			}, A.applyTransform = function (t, e, i) {
				return e && !m.isArrayLike(e) && (e = w.getLocalTransform(e)), i && (e = _.invert([], e)), b.applyTransform([], t, e);
			}, A.transformDirection = function (t, e, i) {
				var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]),
				    a = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]),
				    o = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -a : "bottom" === t ? a : 0];return o = A.applyTransform(o, e, i), Math.abs(o[0]) > Math.abs(o[1]) ? o[0] > 0 ? "right" : "left" : o[1] > 0 ? "bottom" : "top";
			}, A.groupTransition = function (t, e, i, n) {
				function a(t) {
					var e = {};return t.traverse(function (t) {
						!t.isGroup && t.anid && (e[t.anid] = t);
					}), e;
				}function o(t) {
					var e = { position: b.clone(t.position), rotation: t.rotation };return t.shape && (e.shape = m.extend({}, t.shape)), e;
				}if (t && e) {
					var r = a(t);e.traverse(function (t) {
						if (!t.isGroup && t.anid) {
							var e = r[t.anid];if (e) {
								var n = o(t);t.attr(o(e)), A.updateProps(t, n, i, t.dataIndex);
							}
						}
					});
				}
			}, A.clipPointsByRect = function (t, e) {
				return m.map(t, function (t) {
					var i = t[0];i = I(i, e.x), i = T(i, e.x + e.width);var n = t[1];return n = I(n, e.y), n = T(n, e.y + e.height), [i, n];
				});
			}, A.clipRectByRect = function (t, e) {
				var i = I(t.x, e.x),
				    n = T(t.x + t.width, e.x + e.width),
				    a = I(t.y, e.y),
				    o = T(t.y + t.height, e.y + e.height);if (n >= i && o >= a) return { x: i, y: a, width: n - i, height: o - a };
			}, t.exports = A;
		}, function (t, e) {
			function i(t) {
				return t.replace(/^\s+/, "").replace(/\s+$/, "");
			}function n(t) {
				return Math.floor(Math.log(t) / Math.LN10);
			}var a = {},
			    o = 1e-4;a.linearMap = function (t, e, i, n) {
				var a = e[1] - e[0],
				    o = i[1] - i[0];if (0 === a) return 0 === o ? i[0] : (i[0] + i[1]) / 2;if (n) {
					if (a > 0) {
						if (t <= e[0]) return i[0];if (t >= e[1]) return i[1];
					} else {
						if (t >= e[0]) return i[0];if (t <= e[1]) return i[1];
					}
				} else {
					if (t === e[0]) return i[0];if (t === e[1]) return i[1];
				}return (t - e[0]) / a * o + i[0];
			}, a.parsePercent = function (t, e) {
				switch (t) {case "center":case "middle":
						t = "50%";break;case "left":case "top":
						t = "0%";break;case "right":case "bottom":
						t = "100%";}return "string" == typeof t ? i(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : null == t ? NaN : +t;
			}, a.round = function (t, e, i) {
				return null == e && (e = 10), e = Math.min(Math.max(0, e), 20), t = (+t).toFixed(e), i ? t : +t;
			}, a.asc = function (t) {
				return t.sort(function (t, e) {
					return t - e;
				}), t;
			}, a.getPrecision = function (t) {
				if (t = +t, isNaN(t)) return 0;for (var e = 1, i = 0; Math.round(t * e) / e !== t;) {
					e *= 10, i++;
				}return i;
			}, a.getPrecisionSafe = function (t) {
				var e = t.toString(),
				    i = e.indexOf("e");if (i > 0) {
					var n = +e.slice(i + 1);return n < 0 ? -n : 0;
				}var a = e.indexOf(".");return a < 0 ? 0 : e.length - 1 - a;
			}, a.getPixelPrecision = function (t, e) {
				var i = Math.log,
				    n = Math.LN10,
				    a = Math.floor(i(t[1] - t[0]) / n),
				    o = Math.round(i(Math.abs(e[1] - e[0])) / n),
				    r = Math.min(Math.max(-a + o, 0), 20);return isFinite(r) ? r : 20;
			}, a.MAX_SAFE_INTEGER = 9007199254740991, a.remRadian = function (t) {
				var e = 2 * Math.PI;return (t % e + e) % e;
			}, a.isRadianAroundZero = function (t) {
				return t > -o && t < o;
			};var r = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;a.getTimezoneOffset = function () {
				return new Date().getTimezoneOffset();
			}, a.parseDate = function (t) {
				if (t instanceof Date) return t;if ("string" == typeof t) {
					var e = r.exec(t);if (!e) return new Date(NaN);var i = a.getTimezoneOffset(),
					    n = e[8] ? "Z" === e[8].toUpperCase() ? i : 60 * +e[8].slice(0, 3) + i : 0;return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0) - n, +e[6] || 0, +e[7] || 0);
				}return null == t ? new Date(NaN) : new Date(Math.round(t));
			}, a.quantity = function (t) {
				return Math.pow(10, n(t));
			}, a.nice = function (t, e) {
				var i,
				    a = n(t),
				    o = Math.pow(10, a),
				    r = t / o;return i = e ? r < 1.5 ? 1 : r < 2.5 ? 2 : r < 4 ? 3 : r < 7 ? 5 : 10 : r < 1 ? 1 : r < 2 ? 2 : r < 3 ? 3 : r < 5 ? 5 : 10, t = i * o, a >= -20 ? +t.toFixed(a < 0 ? -a : 0) : t;
			}, a.reformIntervals = function (t) {
				function e(t, i, n) {
					return t.interval[n] < i.interval[n] || t.interval[n] === i.interval[n] && (t.close[n] - i.close[n] === (n ? -1 : 1) || !n && e(t, i, 1));
				}t.sort(function (t, i) {
					return e(t, i, 0) ? -1 : 1;
				});for (var i = -(1 / 0), n = 1, a = 0; a < t.length;) {
					for (var o = t[a].interval, r = t[a].close, s = 0; s < 2; s++) {
						o[s] <= i && (o[s] = i, r[s] = s ? 1 : 1 - n), i = o[s], n = r[s];
					}o[0] === o[1] && r[0] * r[1] !== 1 ? t.splice(a, 1) : a++;
				}return t;
			}, a.isNumeric = function (t) {
				return t - parseFloat(t) >= 0;
			}, t.exports = a;
		}, function (t, e, i) {
			function n(t, e) {
				return t && t.hasOwnProperty(e);
			}var a = i(7),
			    o = i(4),
			    r = i(10),
			    s = i(1),
			    l = s.each,
			    u = s.isObject,
			    c = {};c.normalizeToArray = function (t) {
				return t instanceof Array ? t : null == t ? [] : [t];
			}, c.defaultEmphasis = function (t, e) {
				if (t) {
					var i = t.emphasis = t.emphasis || {},
					    n = t.normal = t.normal || {};l(e, function (t) {
						var e = s.retrieve(i[t], n[t]);null != e && (i[t] = e);
					});
				}
			}, c.LABEL_OPTIONS = ["position", "offset", "show", "textStyle", "distance", "formatter"], c.getDataItemValue = function (t) {
				return t && (null == t.value ? t : t.value);
			}, c.isDataItemOption = function (t) {
				return u(t) && !(t instanceof Array);
			}, c.converDataValue = function (t, e) {
				var i = e && e.type;return "ordinal" === i ? t : ("time" === i && "number" != typeof t && null != t && "-" !== t && (t = +o.parseDate(t)), null == t || "" === t ? NaN : +t);
			}, c.createDataFormatModel = function (t, e) {
				var i = new r();return s.mixin(i, c.dataFormatMixin), i.seriesIndex = e.seriesIndex, i.name = e.name || "", i.mainType = e.mainType, i.subType = e.subType, i.getData = function () {
					return t;
				}, i;
			}, c.dataFormatMixin = { getDataParams: function getDataParams(t, e) {
					var i = this.getData(e),
					    n = this.getRawValue(t, e),
					    o = i.getRawIndex(t),
					    r = i.getName(t, !0),
					    s = i.getRawDataItem(t),
					    l = i.getItemVisual(t, "color");return { componentType: this.mainType, componentSubType: this.subType, seriesType: "series" === this.mainType ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: this.id, seriesName: this.name, name: r, dataIndex: o, data: s, dataType: e, value: n, color: l, marker: a.getTooltipMarker(l), $vars: ["seriesName", "name", "value"] };
				}, getFormattedLabel: function getFormattedLabel(t, e, i, n) {
					e = e || "normal";var o = this.getData(i),
					    r = o.getItemModel(t),
					    s = this.getDataParams(t, i);null != n && s.value instanceof Array && (s.value = s.value[n]);var l = r.get(["label", e, "formatter"]);return "function" == typeof l ? (s.status = e, l(s)) : "string" == typeof l ? a.formatTpl(l, s) : void 0;
				}, getRawValue: function getRawValue(t, e) {
					var i = this.getData(e),
					    n = i.getRawDataItem(t);if (null != n) return !u(n) || n instanceof Array ? n : n.value;
				}, formatTooltip: s.noop }, c.mappingToExists = function (t, e) {
				e = (e || []).slice();var i = s.map(t || [], function (t, e) {
					return { exist: t };
				});return l(e, function (t, n) {
					if (u(t)) {
						for (var a = 0; a < i.length; a++) {
							if (!i[a].option && null != t.id && i[a].exist.id === t.id + "") return i[a].option = t, void (e[n] = null);
						}for (var a = 0; a < i.length; a++) {
							var o = i[a].exist;if (!(i[a].option || null != o.id && null != t.id || null == t.name || c.isIdInner(t) || c.isIdInner(o) || o.name !== t.name + "")) return i[a].option = t, void (e[n] = null);
						}
					}
				}), l(e, function (t, e) {
					if (u(t)) {
						for (var n = 0; n < i.length; n++) {
							var a = i[n].exist;if (!i[n].option && !c.isIdInner(a) && null == t.id) {
								i[n].option = t;break;
							}
						}n >= i.length && i.push({ option: t });
					}
				}), i;
			}, c.makeIdAndName = function (t) {
				var e = s.createHashMap();l(t, function (t, i) {
					var n = t.exist;n && e.set(n.id, t);
				}), l(t, function (t, i) {
					var n = t.option;s.assert(!n || null == n.id || !e.get(n.id) || e.get(n.id) === t, "id duplicates: " + (n && n.id)), n && null != n.id && e.set(n.id, t), !t.keyInfo && (t.keyInfo = {});
				}), l(t, function (t, i) {
					var n = t.exist,
					    a = t.option,
					    o = t.keyInfo;if (u(a)) {
						if (o.name = null != a.name ? a.name + "" : n ? n.name : "\0-", n) o.id = n.id;else if (null != a.id) o.id = a.id + "";else {
							var r = 0;do {
								o.id = "\0" + o.name + "\0" + r++;
							} while (e.get(o.id));
						}e.set(o.id, t);
					}
				});
			}, c.isIdInner = function (t) {
				return u(t) && t.id && 0 === (t.id + "").indexOf("\0_ec_\0");
			}, c.compressBatches = function (t, e) {
				function i(t, e, i) {
					for (var n = 0, a = t.length; n < a; n++) {
						for (var o = t[n].seriesId, r = c.normalizeToArray(t[n].dataIndex), s = i && i[o], l = 0, u = r.length; l < u; l++) {
							var h = r[l];s && s[h] ? s[h] = null : (e[o] || (e[o] = {}))[h] = 1;
						}
					}
				}function n(t, e) {
					var i = [];for (var a in t) {
						if (t.hasOwnProperty(a) && null != t[a]) if (e) i.push(+a);else {
							var o = n(t[a], !0);o.length && i.push({ seriesId: a, dataIndex: o });
						}
					}return i;
				}var a = {},
				    o = {};return i(t || [], a), i(e || [], o, a), [n(a), n(o)];
			}, c.queryDataIndex = function (t, e) {
				return null != e.dataIndexInside ? e.dataIndexInside : null != e.dataIndex ? s.isArray(e.dataIndex) ? s.map(e.dataIndex, function (e) {
					return t.indexOfRawIndex(e);
				}) : t.indexOfRawIndex(e.dataIndex) : null != e.name ? s.isArray(e.name) ? s.map(e.name, function (e) {
					return t.indexOfName(e);
				}) : t.indexOfName(e.name) : void 0;
			}, c.makeGetter = function () {
				var t = 0;return function () {
					var e = "\0__ec_prop_getter_" + t++;return function (t) {
						return t[e] || (t[e] = {});
					};
				};
			}(), c.parseFinder = function (t, e, i) {
				if (s.isString(e)) {
					var a = {};a[e + "Index"] = 0, e = a;
				}var o = i && i.defaultMainType;!o || n(e, o + "Index") || n(e, o + "Id") || n(e, o + "Name") || (e[o + "Index"] = 0);var r = {};return l(e, function (n, a) {
					var n = e[a];if ("dataIndex" === a || "dataIndexInside" === a) return void (r[a] = n);var o = a.match(/^(\w+)(Index|Id|Name)$/) || [],
					    l = o[1],
					    u = (o[2] || "").toLowerCase();if (!(!l || !u || null == n || "index" === u && "none" === n || i && i.includeMainTypes && s.indexOf(i.includeMainTypes, l) < 0)) {
						var c = { mainType: l };"index" === u && "all" === n || (c[u] = n);var h = t.queryComponents(c);r[l + "Models"] = h, r[l + "Model"] = h[0];
					}
				}), r;
			}, c.dataDimToCoordDim = function (t, e) {
				var i = t.dimensions;e = t.getDimension(e);for (var n = 0; n < i.length; n++) {
					var a = t.getDimensionInfo(i[n]);if (a.name === e) return a.coordDim;
				}
			}, c.coordDimToDataDim = function (t, e) {
				var i = [];return l(t.dimensions, function (n) {
					var a = t.getDimensionInfo(n);a.coordDim === e && (i[a.coordDimIndex] = a.name);
				}), i;
			}, c.otherDimToDataDim = function (t, e) {
				var i = [];return l(t.dimensions, function (n) {
					var a = t.getDimensionInfo(n),
					    o = a.otherDims,
					    r = o[e];null != r && r !== !1 && (i[r] = a.name);
				}), i;
			}, t.exports = c;
		}, function (t, e) {
			var i = "undefined" == typeof Float32Array ? Array : Float32Array,
			    n = { create: function create(t, e) {
					var n = new i(2);return null == t && (t = 0), null == e && (e = 0), n[0] = t, n[1] = e, n;
				}, copy: function copy(t, e) {
					return t[0] = e[0], t[1] = e[1], t;
				}, clone: function clone(t) {
					var e = new i(2);return e[0] = t[0], e[1] = t[1], e;
				}, set: function set(t, e, i) {
					return t[0] = e, t[1] = i, t;
				}, add: function add(t, e, i) {
					return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t;
				}, scaleAndAdd: function scaleAndAdd(t, e, i, n) {
					return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t;
				}, sub: function sub(t, e, i) {
					return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t;
				}, len: function len(t) {
					return Math.sqrt(this.lenSquare(t));
				}, lenSquare: function lenSquare(t) {
					return t[0] * t[0] + t[1] * t[1];
				}, mul: function mul(t, e, i) {
					return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t;
				}, div: function div(t, e, i) {
					return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t;
				}, dot: function dot(t, e) {
					return t[0] * e[0] + t[1] * e[1];
				}, scale: function scale(t, e, i) {
					return t[0] = e[0] * i, t[1] = e[1] * i, t;
				}, normalize: function normalize(t, e) {
					var i = n.len(e);return 0 === i ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / i, t[1] = e[1] / i), t;
				}, distance: function distance(t, e) {
					return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]));
				}, distanceSquare: function distanceSquare(t, e) {
					return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]);
				}, negate: function negate(t, e) {
					return t[0] = -e[0], t[1] = -e[1], t;
				}, lerp: function lerp(t, e, i, n) {
					return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t;
				}, applyTransform: function applyTransform(t, e, i) {
					var n = e[0],
					    a = e[1];return t[0] = i[0] * n + i[2] * a + i[4], t[1] = i[1] * n + i[3] * a + i[5], t;
				}, min: function min(t, e, i) {
					return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t;
				}, max: function max(t, e, i) {
					return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t;
				} };n.length = n.len, n.lengthSquare = n.lenSquare, n.dist = n.distance, n.distSquare = n.distanceSquare, t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(4),
			    o = i(16),
			    r = {};r.addCommas = function (t) {
				return isNaN(t) ? "-" : (t = (t + "").split("."), t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : ""));
			}, r.toCamelCase = function (t, e) {
				return t = (t || "").toLowerCase().replace(/-(.)/g, function (t, e) {
					return e.toUpperCase();
				}), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t;
			}, r.normalizeCssArray = function (t) {
				var e = t.length;return "number" == typeof t ? [t, t, t, t] : 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t;
			};var s = r.encodeHTML = function (t) {
				return String(t).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
			},
			    l = ["a", "b", "c", "d", "e", "f", "g"],
			    u = function u(t, e) {
				return "{" + t + (null == e ? "" : e) + "}";
			};r.formatTpl = function (t, e, i) {
				n.isArray(e) || (e = [e]);var a = e.length;if (!a) return "";for (var o = e[0].$vars || [], r = 0; r < o.length; r++) {
					var c = l[r],
					    h = u(c, 0);t = t.replace(u(c), i ? s(h) : h);
				}for (var d = 0; d < a; d++) {
					for (var f = 0; f < o.length; f++) {
						var h = e[d][o[f]];t = t.replace(u(l[f], d), i ? s(h) : h);
					}
				}return t;
			}, r.formatTplSimple = function (t, e, i) {
				return n.each(e, function (e, n) {
					t = t.replace("{" + n + "}", i ? s(e) : e);
				}), t;
			}, r.getTooltipMarker = function (t, e) {
				return t ? '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + r.encodeHTML(t) + ";" + (e || "") + '"></span>' : "";
			};var c = function c(t) {
				return t < 10 ? "0" + t : t;
			};r.formatTime = function (t, e, i) {
				"week" !== t && "month" !== t && "quarter" !== t && "half-year" !== t && "year" !== t || (t = "MM-dd\nyyyy");var n = a.parseDate(e),
				    o = i ? "UTC" : "",
				    r = n["get" + o + "FullYear"](),
				    s = n["get" + o + "Month"]() + 1,
				    l = n["get" + o + "Date"](),
				    u = n["get" + o + "Hours"](),
				    h = n["get" + o + "Minutes"](),
				    d = n["get" + o + "Seconds"]();return t = t.replace("MM", c(s)).toLowerCase().replace("yyyy", r).replace("yy", r % 100).replace("dd", c(l)).replace("d", l).replace("hh", c(u)).replace("h", u).replace("mm", c(h)).replace("m", h).replace("ss", c(d)).replace("s", d);
			}, r.capitalFirst = function (t) {
				return t ? t.charAt(0).toUpperCase() + t.substr(1) : t;
			}, r.truncateText = o.truncateText, t.exports = r;
		}, function (t, e, i) {
			function n(t) {
				a.call(this, t), this.path = null;
			}var a = i(38),
			    o = i(1),
			    r = i(27),
			    s = i(161),
			    l = i(72),
			    u = l.prototype.getCanvasPattern,
			    c = Math.abs,
			    h = new r(!0);n.prototype = { constructor: n, type: "path", __dirtyPath: !0, strokeContainThreshold: 5, brush: function brush(t, e) {
					var i = this.style,
					    n = this.path || h,
					    a = i.hasStroke(),
					    o = i.hasFill(),
					    r = i.fill,
					    s = i.stroke,
					    l = o && !!r.colorStops,
					    c = a && !!s.colorStops,
					    d = o && !!r.image,
					    f = a && !!s.image;if (i.bind(t, this, e), this.setTransform(t), this.__dirty) {
						var p;l && (p = p || this.getBoundingRect(), this._fillGradient = i.getGradient(t, r, p)), c && (p = p || this.getBoundingRect(), this._strokeGradient = i.getGradient(t, s, p));
					}l ? t.fillStyle = this._fillGradient : d && (t.fillStyle = u.call(r, t)), c ? t.strokeStyle = this._strokeGradient : f && (t.strokeStyle = u.call(s, t));var g = i.lineDash,
					    m = i.lineDashOffset,
					    v = !!t.setLineDash,
					    y = this.getGlobalScale();n.setScale(y[0], y[1]), this.__dirtyPath || g && !v && a ? (n.beginPath(t), g && !v && (n.setLineDash(g), n.setLineDashOffset(m)), this.buildPath(n, this.shape, !1), this.path && (this.__dirtyPath = !1)) : (t.beginPath(), this.path.rebuildPath(t)), o && n.fill(t), g && v && (t.setLineDash(g), t.lineDashOffset = m), a && n.stroke(t), g && v && t.setLineDash([]), this.restoreTransform(t), null != i.text && this.drawRectText(t, this.getBoundingRect());
				}, buildPath: function buildPath(t, e, i) {}, createPathProxy: function createPathProxy() {
					this.path = new r();
				}, getBoundingRect: function getBoundingRect() {
					var t = this._rect,
					    e = this.style,
					    i = !t;if (i) {
						var n = this.path;n || (n = this.path = new r()), this.__dirtyPath && (n.beginPath(), this.buildPath(n, this.shape, !1)), t = n.getBoundingRect();
					}if (this._rect = t, e.hasStroke()) {
						var a = this._rectWithStroke || (this._rectWithStroke = t.clone());if (this.__dirty || i) {
							a.copy(t);var o = e.lineWidth,
							    s = e.strokeNoScale ? this.getLineScale() : 1;e.hasFill() || (o = Math.max(o, this.strokeContainThreshold || 4)), s > 1e-10 && (a.width += o / s, a.height += o / s, a.x -= o / s / 2, a.y -= o / s / 2);
						}return a;
					}return t;
				}, contain: function contain(t, e) {
					var i = this.transformCoordToLocal(t, e),
					    n = this.getBoundingRect(),
					    a = this.style;if (t = i[0], e = i[1], n.contain(t, e)) {
						var o = this.path.data;if (a.hasStroke()) {
							var r = a.lineWidth,
							    l = a.strokeNoScale ? this.getLineScale() : 1;if (l > 1e-10 && (a.hasFill() || (r = Math.max(r, this.strokeContainThreshold)), s.containStroke(o, r / l, t, e))) return !0;
						}if (a.hasFill()) return s.contain(o, t, e);
					}return !1;
				}, dirty: function dirty(t) {
					null == t && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty();
				}, animateShape: function animateShape(t) {
					return this.animate("shape", t);
				}, attrKV: function attrKV(t, e) {
					"shape" === t ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : a.prototype.attrKV.call(this, t, e);
				}, setShape: function setShape(t, e) {
					var i = this.shape;if (i) {
						if (o.isObject(t)) for (var n in t) {
							t.hasOwnProperty(n) && (i[n] = t[n]);
						} else i[t] = e;this.dirty(!0);
					}return this;
				}, getLineScale: function getLineScale() {
					var t = this.transform;return t && c(t[0] - 1) > 1e-10 && c(t[3] - 1) > 1e-10 ? Math.sqrt(c(t[0] * t[3] - t[2] * t[1])) : 1;
				} }, n.extend = function (t) {
				var e = function e(_e) {
					n.call(this, _e), t.style && this.style.extendFrom(t.style, !1);var i = t.shape;if (i) {
						this.shape = this.shape || {};var a = this.shape;for (var o in i) {
							!a.hasOwnProperty(o) && i.hasOwnProperty(o) && (a[o] = i[o]);
						}
					}t.init && t.init.call(this, _e);
				};o.inherits(e, n);for (var i in t) {
					"style" !== i && "shape" !== i && (e.prototype[i] = t[i]);
				}return e;
			}, o.inherits(n, a), t.exports = n;
		}, function (t, e) {
			function i(t) {
				var e = {},
				    i = {},
				    n = t.match(/Firefox\/([\d.]+)/),
				    a = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/),
				    o = t.match(/Edge\/([\d.]+)/),
				    r = /micromessenger/i.test(t);return n && (i.firefox = !0, i.version = n[1]), a && (i.ie = !0, i.version = a[1]), o && (i.edge = !0, i.version = o[1]), r && (i.weChat = !0), { browser: i, os: e, node: !1, canvasSupported: !!document.createElement("canvas").getContext, touchEventsSupported: "ontouchstart" in window && !i.ie && !i.edge, pointerEventsSupported: "onpointerdown" in window && (i.edge || i.ie && i.version >= 11) };
			}var n = {};n = "undefined" == typeof navigator ? { browser: {}, os: {}, node: !0, canvasSupported: !0 } : i(navigator.userAgent), t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i) {
				this.parentModel = e, this.ecModel = i, this.option = t;
			}function a(t, e, i) {
				for (var n = 0; n < e.length && (!e[n] || (t = t && "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) ? t[e[n]] : null, null != t)); n++) {}return null == t && i && (t = i.get(e)), t;
			}function o(t, e) {
				var i = s.get(t, "getParent");return i ? i.call(t, e) : t.parentModel;
			}var r = i(1),
			    s = i(15),
			    l = i(9);n.prototype = { constructor: n, init: null, mergeOption: function mergeOption(t) {
					r.merge(this.option, t, !0);
				}, get: function get(t, e) {
					return null == t ? this.option : a(this.option, this.parsePath(t), !e && o(this, t));
				}, getShallow: function getShallow(t, e) {
					var i = this.option,
					    n = null == i ? i : i[t],
					    a = !e && o(this, t);return null == n && a && (n = a.getShallow(t)), n;
				}, getModel: function getModel(t, e) {
					var i,
					    r = null == t ? this.option : a(this.option, t = this.parsePath(t));return e = e || (i = o(this, t)) && i.getModel(t), new n(r, e, this.ecModel);
				}, isEmpty: function isEmpty() {
					return null == this.option;
				}, restoreData: function restoreData() {}, clone: function clone() {
					var t = this.constructor;return new t(r.clone(this.option));
				}, setReadOnly: function setReadOnly(t) {
					s.setReadOnly(this, t);
				}, parsePath: function parsePath(t) {
					return "string" == typeof t && (t = t.split(".")), t;
				}, customizeGetParent: function customizeGetParent(t) {
					s.set(this, "getParent", t);
				}, isAnimationEnabled: function isAnimationEnabled() {
					if (!l.node) {
						if (null != this.option.animation) return !!this.option.animation;if (this.parentModel) return this.parentModel.isAnimationEnabled();
					}
				} }, s.enableClassExtend(n);var u = r.mixin;u(n, i(143)), u(n, i(140)), u(n, i(144)), u(n, i(142)), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i, n) {
				i < 0 && (t += i, i = -i), n < 0 && (e += n, n = -n), this.x = t, this.y = e, this.width = i, this.height = n;
			}var a = i(6),
			    o = i(19),
			    r = a.applyTransform,
			    s = Math.min,
			    l = Math.max;n.prototype = { constructor: n, union: function union(t) {
					var e = s(t.x, this.x),
					    i = s(t.y, this.y);this.width = l(t.x + t.width, this.x + this.width) - e, this.height = l(t.y + t.height, this.y + this.height) - i, this.x = e, this.y = i;
				}, applyTransform: function () {
					var t = [],
					    e = [],
					    i = [],
					    n = [];return function (a) {
						if (a) {
							t[0] = i[0] = this.x, t[1] = n[1] = this.y, e[0] = n[0] = this.x + this.width, e[1] = i[1] = this.y + this.height, r(t, t, a), r(e, e, a), r(i, i, a), r(n, n, a), this.x = s(t[0], e[0], i[0], n[0]), this.y = s(t[1], e[1], i[1], n[1]);var o = l(t[0], e[0], i[0], n[0]),
							    u = l(t[1], e[1], i[1], n[1]);this.width = o - this.x, this.height = u - this.y;
						}
					};
				}(), calculateTransform: function calculateTransform(t) {
					var e = this,
					    i = t.width / e.width,
					    n = t.height / e.height,
					    a = o.create();return o.translate(a, a, [-e.x, -e.y]), o.scale(a, a, [i, n]), o.translate(a, a, [t.x, t.y]), a;
				}, intersect: function intersect(t) {
					if (!t) return !1;t instanceof n || (t = n.create(t));var e = this,
					    i = e.x,
					    a = e.x + e.width,
					    o = e.y,
					    r = e.y + e.height,
					    s = t.x,
					    l = t.x + t.width,
					    u = t.y,
					    c = t.y + t.height;return !(a < s || l < i || r < u || c < o);
				}, contain: function contain(t, e) {
					var i = this;return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i.height;
				}, clone: function clone() {
					return new n(this.x, this.y, this.width, this.height);
				}, copy: function copy(t) {
					this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height;
				}, plain: function plain() {
					return { x: this.x, y: this.y, width: this.width, height: this.height };
				} }, n.create = function (t) {
				return new n(t.x, t.y, t.width, t.height);
			}, t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i, n, a) {
				var o = 0,
				    r = 0;null == n && (n = 1 / 0), null == a && (a = 1 / 0);var s = 0;e.eachChild(function (l, u) {
					var c,
					    h,
					    d = l.position,
					    f = l.getBoundingRect(),
					    p = e.childAt(u + 1),
					    g = p && p.getBoundingRect();if ("horizontal" === t) {
						var m = f.width + (g ? -g.x + f.x : 0);c = o + m, c > n || l.newline ? (o = 0, c = m, r += s + i, s = f.height) : s = Math.max(s, f.height);
					} else {
						var v = f.height + (g ? -g.y + f.y : 0);h = r + v, h > a || l.newline ? (o += s + i, r = 0, h = v, s = f.width) : s = Math.max(s, f.width);
					}l.newline || (d[0] = o, d[1] = r, "horizontal" === t ? o = c + i : r = h + i);
				});
			}var a = i(1),
			    o = i(11),
			    r = i(4),
			    s = i(7),
			    l = r.parsePercent,
			    u = a.each,
			    c = {},
			    h = c.LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"],
			    d = c.HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];c.box = n, c.vbox = a.curry(n, "vertical"), c.hbox = a.curry(n, "horizontal"), c.getAvailableSize = function (t, e, i) {
				var n = e.width,
				    a = e.height,
				    o = l(t.x, n),
				    r = l(t.y, a),
				    u = l(t.x2, n),
				    c = l(t.y2, a);return (isNaN(o) || isNaN(parseFloat(t.x))) && (o = 0), (isNaN(u) || isNaN(parseFloat(t.x2))) && (u = n), (isNaN(r) || isNaN(parseFloat(t.y))) && (r = 0), (isNaN(c) || isNaN(parseFloat(t.y2))) && (c = a), i = s.normalizeCssArray(i || 0), { width: Math.max(u - o - i[1] - i[3], 0), height: Math.max(c - r - i[0] - i[2], 0) };
			}, c.getLayoutRect = function (t, e, i) {
				i = s.normalizeCssArray(i || 0);var n = e.width,
				    a = e.height,
				    r = l(t.left, n),
				    u = l(t.top, a),
				    c = l(t.right, n),
				    h = l(t.bottom, a),
				    d = l(t.width, n),
				    f = l(t.height, a),
				    p = i[2] + i[0],
				    g = i[1] + i[3],
				    m = t.aspect;switch (isNaN(d) && (d = n - c - g - r), isNaN(f) && (f = a - h - p - u), isNaN(d) && isNaN(f) && (m > n / a ? d = .8 * n : f = .8 * a), null != m && (isNaN(d) && (d = m * f), isNaN(f) && (f = d / m)), isNaN(r) && (r = n - c - d - g), isNaN(u) && (u = a - h - f - p), t.left || t.right) {case "center":
						r = n / 2 - d / 2 - i[3];break;case "right":
						r = n - d - g;}switch (t.top || t.bottom) {case "middle":case "center":
						u = a / 2 - f / 2 - i[0];break;case "bottom":
						u = a - f - p;}r = r || 0, u = u || 0, isNaN(d) && (d = n - r - (c || 0)), isNaN(f) && (f = a - u - (h || 0));var v = new o(r + i[3], u + i[0], d, f);return v.margin = i, v;
			}, c.positionElement = function (t, e, i, n, r) {
				var s = !r || !r.hv || r.hv[0],
				    l = !r || !r.hv || r.hv[1],
				    u = r && r.boundingMode || "all";if (s || l) {
					var h;if ("raw" === u) h = "group" === t.type ? new o(0, 0, +e.width || 0, +e.height || 0) : t.getBoundingRect();else if (h = t.getBoundingRect(), t.needLocalTransform()) {
						var d = t.getLocalTransform();h = h.clone(), h.applyTransform(d);
					}e = c.getLayoutRect(a.defaults({ width: h.width, height: h.height }, e), i, n);var f = t.position,
					    p = s ? e.x - h.x : 0,
					    g = l ? e.y - h.y : 0;t.attr("position", "raw" === u ? [p, g] : [f[0] + p, f[1] + g]);
				}
			}, c.sizeCalculable = function (t, e) {
				return null != t[d[e][0]] || null != t[d[e][1]] && null != t[d[e][2]];
			}, c.mergeLayoutParam = function (t, e, i) {
				function n(i, n) {
					var a = {},
					    s = 0,
					    c = {},
					    h = 0,
					    d = 2;if (u(i, function (e) {
						c[e] = t[e];
					}), u(i, function (t) {
						o(e, t) && (a[t] = c[t] = e[t]), r(a, t) && s++, r(c, t) && h++;
					}), l[n]) return r(e, i[1]) ? c[i[2]] = null : r(e, i[2]) && (c[i[1]] = null), c;if (h !== d && s) {
						if (s >= d) return a;for (var f = 0; f < i.length; f++) {
							var p = i[f];if (!o(a, p) && o(t, p)) {
								a[p] = t[p];break;
							}
						}return a;
					}return c;
				}function o(t, e) {
					return t.hasOwnProperty(e);
				}function r(t, e) {
					return null != t[e] && "auto" !== t[e];
				}function s(t, e, i) {
					u(t, function (t) {
						e[t] = i[t];
					});
				}!a.isObject(i) && (i = {});var l = i.ignoreSize;!a.isArray(l) && (l = [l, l]);var c = n(d[0], 0),
				    h = n(d[1], 1);s(d[0], t, c), s(d[1], t, h);
			}, c.getLayoutParams = function (t) {
				return c.copyLayoutParams({}, t);
			}, c.copyLayoutParams = function (t, e) {
				return e && t && u(h, function (i) {
					e.hasOwnProperty(i) && (t[i] = e[i]);
				}), t;
			}, t.exports = c;
		}, function (t, e, i) {
			function n(t) {
				var e = [];return o.each(c.getClassesByMainType(t), function (t) {
					r.apply(e, t.prototype.dependencies || []);
				}), o.map(e, function (t) {
					return l.parseClassType(t).main;
				});
			}var a = i(10),
			    o = i(1),
			    r = Array.prototype.push,
			    s = i(49),
			    l = i(15),
			    u = i(12),
			    c = a.extend({ type: "component", id: "", name: "", mainType: "", subType: "", componentIndex: 0, defaultOption: null, ecModel: null, dependentModels: [], uid: null, layoutMode: null, $constructor: function $constructor(t, e, i, n) {
					a.call(this, t, e, i, n), this.uid = s.getUID("componentModel");
				}, init: function init(t, e, i, n) {
					this.mergeDefaultAndTheme(t, i);
				}, mergeDefaultAndTheme: function mergeDefaultAndTheme(t, e) {
					var i = this.layoutMode,
					    n = i ? u.getLayoutParams(t) : {},
					    a = e.getTheme();o.merge(t, a.get(this.mainType)), o.merge(t, this.getDefaultOption()), i && u.mergeLayoutParam(t, n, i);
				}, mergeOption: function mergeOption(t, e) {
					o.merge(this.option, t, !0);var i = this.layoutMode;i && u.mergeLayoutParam(this.option, t, i);
				}, optionUpdated: function optionUpdated(t, e) {}, getDefaultOption: function getDefaultOption() {
					if (!l.hasOwn(this, "__defaultOption")) {
						for (var t = [], e = this.constructor; e;) {
							var i = e.prototype.defaultOption;i && t.push(i), e = e.superClass;
						}for (var n = {}, a = t.length - 1; a >= 0; a--) {
							n = o.merge(n, t[a], !0);
						}l.set(this, "__defaultOption", n);
					}return l.get(this, "__defaultOption");
				}, getReferringComponents: function getReferringComponents(t) {
					return this.ecModel.queryComponents({ mainType: t, index: this.get(t + "Index", !0), id: this.get(t + "Id", !0) });
				} });l.enableClassManagement(c, { registerWhenExtend: !0 }), s.enableSubTypeDefaulter(c), s.enableTopologicalTravel(c, n), o.mixin(c, i(141)), t.exports = c;
		}, function (t, e, i) {
			(function (e) {
				function n(t, e) {
					p.each(v.concat(e.__wrappedMethods || []), function (i) {
						e.hasOwnProperty(i) && (t[i] = e[i]);
					}), t.__wrappedMethods = e.__wrappedMethods;
				}function a(t) {
					this._array = t || [];
				}function o(t) {
					return p.isArray(t) || (t = [t]), t;
				}function r(t, e) {
					var i = t.dimensions,
					    a = new y(p.map(i, t.getDimensionInfo, t), t.hostModel);n(a, t);for (var o = a._storage = {}, r = t._storage, s = 0; s < i.length; s++) {
						var l = i[s],
						    u = r[l];p.indexOf(e, l) >= 0 ? o[l] = new u.constructor(r[l].length) : o[l] = r[l];
					}return a;
				}var s = "undefined",
				    l = "undefined" == typeof window ? e : window,
				    u = _typeof(l.Float64Array) === s ? Array : l.Float64Array,
				    c = _typeof(l.Int32Array) === s ? Array : l.Int32Array,
				    h = { "float": u, "int": c, ordinal: Array, number: Array, time: Array },
				    d = i(10),
				    f = i(48),
				    p = i(1),
				    g = i(5),
				    m = p.isObject,
				    v = ["stackedOn", "hasItemOption", "_nameList", "_idList", "_rawData"];a.prototype.pure = !1, a.prototype.count = function () {
					return this._array.length;
				}, a.prototype.getItem = function (t) {
					return this._array[t];
				};var y = function y(t, e) {
					t = t || ["x", "y"];for (var i = {}, n = [], a = 0; a < t.length; a++) {
						var o,
						    r = {};"string" == typeof t[a] ? (o = t[a], r = { name: o, coordDim: o, coordDimIndex: 0, stackable: !1, type: "number" }) : (r = t[a], o = r.name, r.type = r.type || "number", r.coordDim || (r.coordDim = o, r.coordDimIndex = 0)), r.otherDims = r.otherDims || {}, n.push(o), i[o] = r;
					}this.dimensions = n, this._dimensionInfos = i, this.hostModel = e, this.dataType, this.indices = [], this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this.stackedOn = null, this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._rawData, this._extent;
				},
				    x = y.prototype;x.type = "list", x.hasItemOption = !0, x.getDimension = function (t) {
					return isNaN(t) || (t = this.dimensions[t] || t), t;
				}, x.getDimensionInfo = function (t) {
					return p.clone(this._dimensionInfos[this.getDimension(t)]);
				}, x.initData = function (t, e, i) {
					t = t || [];var n = p.isArray(t);n && (t = new a(t)), this._rawData = t;var o,
					    r = this._storage = {},
					    s = this.indices = [],
					    l = this.dimensions,
					    u = this._dimensionInfos,
					    c = t.count(),
					    d = [],
					    f = {};e = e || [];for (var m = 0; m < l.length; m++) {
						var v = u[l[m]];0 === v.otherDims.itemName && (o = m);var y = h[v.type];r[l[m]] = new y(c);
					}var x = this;i || (x.hasItemOption = !1), i = i || function (t, e, i, n) {
						var a = g.getDataItemValue(t);return g.isDataItemOption(t) && (x.hasItemOption = !0), g.converDataValue(a instanceof Array ? a[n] : a, u[e]);
					};for (var m = 0; m < c; m++) {
						for (var _ = t.getItem(m), b = 0; b < l.length; b++) {
							var w = l[b],
							    S = r[w];S[m] = i(_, w, m, b);
						}s.push(m);
					}for (var m = 0; m < c; m++) {
						var _ = t.getItem(m);!e[m] && _ && (null != _.name ? e[m] = _.name : null != o && (e[m] = r[l[o]][m]));var M = e[m] || "",
						    I = _ && _.id;!I && M && (f[M] = f[M] || 0, I = M, f[M] > 0 && (I += "__ec__" + f[M]), f[M]++), I && (d[m] = I);
					}this._nameList = e, this._idList = d;
				}, x.count = function () {
					return this.indices.length;
				}, x.get = function (t, e, i) {
					var n = this._storage,
					    a = this.indices[e];if (null == a || !n[t]) return NaN;var o = n[t][a];if (i) {
						var r = this._dimensionInfos[t];if (r && r.stackable) for (var s = this.stackedOn; s;) {
							var l = s.get(t, e);(o >= 0 && l > 0 || o <= 0 && l < 0) && (o += l), s = s.stackedOn;
						}
					}return o;
				}, x.getValues = function (t, e, i) {
					var n = [];p.isArray(t) || (i = e, e = t, t = this.dimensions);for (var a = 0, o = t.length; a < o; a++) {
						n.push(this.get(t[a], e, i));
					}return n;
				}, x.hasValue = function (t) {
					for (var e = this.dimensions, i = this._dimensionInfos, n = 0, a = e.length; n < a; n++) {
						if ("ordinal" !== i[e[n]].type && isNaN(this.get(e[n], t))) return !1;
					}return !0;
				}, x.getDataExtent = function (t, e, i) {
					t = this.getDimension(t);var n = this._storage[t],
					    a = this.getDimensionInfo(t);e = a && a.stackable && e;var o,
					    r = (this._extent || (this._extent = {}))[t + !!e];if (r) return r;if (n) {
						for (var s = 1 / 0, l = -(1 / 0), u = 0, c = this.count(); u < c; u++) {
							o = this.get(t, u, e), i && !i(o, t, u) || (o < s && (s = o), o > l && (l = o));
						}return this._extent[t + !!e] = [s, l];
					}return [1 / 0, -(1 / 0)];
				}, x.getSum = function (t, e) {
					var i = this._storage[t],
					    n = 0;if (i) for (var a = 0, o = this.count(); a < o; a++) {
						var r = this.get(t, a, e);isNaN(r) || (n += r);
					}return n;
				}, x.indexOf = function (t, e) {
					var i = this._storage,
					    n = i[t],
					    a = this.indices;if (n) for (var o = 0, r = a.length; o < r; o++) {
						var s = a[o];if (n[s] === e) return o;
					}return -1;
				}, x.indexOfName = function (t) {
					for (var e = this.indices, i = this._nameList, n = 0, a = e.length; n < a; n++) {
						var o = e[n];if (i[o] === t) return n;
					}return -1;
				}, x.indexOfRawIndex = function (t) {
					var e = this.indices,
					    i = e[t];if (null != i && i === t) return t;for (var n = 0, a = e.length - 1; n <= a;) {
						var o = (n + a) / 2 | 0;if (e[o] < t) n = o + 1;else {
							if (!(e[o] > t)) return o;a = o - 1;
						}
					}return -1;
				}, x.indicesOfNearest = function (t, e, i, n) {
					var a = this._storage,
					    o = a[t],
					    r = [];if (!o) return r;null == n && (n = 1 / 0);for (var s = Number.MAX_VALUE, l = -1, u = 0, c = this.count(); u < c; u++) {
						var h = e - this.get(t, u, i),
						    d = Math.abs(h);h <= n && d <= s && ((d < s || h >= 0 && l < 0) && (s = d, l = h, r.length = 0), r.push(u));
					}return r;
				}, x.getRawIndex = function (t) {
					var e = this.indices[t];return null == e ? -1 : e;
				}, x.getRawDataItem = function (t) {
					return this._rawData.getItem(this.getRawIndex(t));
				}, x.getName = function (t) {
					return this._nameList[this.indices[t]] || "";
				}, x.getId = function (t) {
					return this._idList[this.indices[t]] || this.getRawIndex(t) + "";
				}, x.each = function (t, e, i, n) {
					"function" == typeof t && (n = i, i = e, e = t, t = []), t = p.map(o(t), this.getDimension, this);var a = [],
					    r = t.length,
					    s = this.indices;n = n || this;for (var l = 0; l < s.length; l++) {
						switch (r) {case 0:
								e.call(n, l);break;case 1:
								e.call(n, this.get(t[0], l, i), l);break;case 2:
								e.call(n, this.get(t[0], l, i), this.get(t[1], l, i), l);break;default:
								for (var u = 0; u < r; u++) {
									a[u] = this.get(t[u], l, i);
								}a[u] = l, e.apply(n, a);}
					}
				}, x.filterSelf = function (t, e, i, n) {
					"function" == typeof t && (n = i, i = e, e = t, t = []), t = p.map(o(t), this.getDimension, this);var a = [],
					    r = [],
					    s = t.length,
					    l = this.indices;n = n || this;for (var u = 0; u < l.length; u++) {
						var c;if (s) {
							if (1 === s) c = e.call(n, this.get(t[0], u, i), u);else {
								for (var h = 0; h < s; h++) {
									r[h] = this.get(t[h], u, i);
								}r[h] = u, c = e.apply(n, r);
							}
						} else c = e.call(n, u);c && a.push(l[u]);
					}return this.indices = a, this._extent = {}, this;
				}, x.mapArray = function (t, e, i, n) {
					"function" == typeof t && (n = i, i = e, e = t, t = []);var a = [];return this.each(t, function () {
						a.push(e && e.apply(this, arguments));
					}, i, n), a;
				}, x.map = function (t, e, i, n) {
					t = p.map(o(t), this.getDimension, this);var a = r(this, t),
					    s = a.indices = this.indices,
					    l = a._storage,
					    u = [];return this.each(t, function () {
						var i = arguments[arguments.length - 1],
						    n = e && e.apply(this, arguments);if (null != n) {
							"number" == typeof n && (u[0] = n, n = u);for (var a = 0; a < n.length; a++) {
								var o = t[a],
								    r = l[o],
								    c = s[i];r && (r[c] = n[a]);
							}
						}
					}, i, n), a;
				}, x.downSample = function (t, e, i, n) {
					for (var a = r(this, [t]), o = this._storage, s = a._storage, l = this.indices, u = a.indices = [], c = [], h = [], d = Math.floor(1 / e), f = s[t], p = this.count(), g = 0; g < o[t].length; g++) {
						s[t][g] = o[t][g];
					}for (var g = 0; g < p; g += d) {
						d > p - g && (d = p - g, c.length = d);for (var m = 0; m < d; m++) {
							var v = l[g + m];c[m] = f[v], h[m] = v;
						}var y = i(c),
						    v = h[n(c, y) || 0];f[v] = y, u.push(v);
					}return a;
				}, x.getItemModel = function (t) {
					var e = this.hostModel;return t = this.indices[t], new d(this._rawData.getItem(t), e, e && e.ecModel);
				}, x.diff = function (t) {
					var e,
					    i = this._idList,
					    n = t && t._idList,
					    a = "e\0\0";return new f(t ? t.indices : [], this.indices, function (t) {
						return null != (e = n[t]) ? e : a + t;
					}, function (t) {
						return null != (e = i[t]) ? e : a + t;
					});
				}, x.getVisual = function (t) {
					var e = this._visual;return e && e[t];
				}, x.setVisual = function (t, e) {
					if (m(t)) for (var i in t) {
						t.hasOwnProperty(i) && this.setVisual(i, t[i]);
					} else this._visual = this._visual || {}, this._visual[t] = e;
				}, x.setLayout = function (t, e) {
					if (m(t)) for (var i in t) {
						t.hasOwnProperty(i) && this.setLayout(i, t[i]);
					} else this._layout[t] = e;
				}, x.getLayout = function (t) {
					return this._layout[t];
				}, x.getItemLayout = function (t) {
					return this._itemLayouts[t];
				}, x.setItemLayout = function (t, e, i) {
					this._itemLayouts[t] = i ? p.extend(this._itemLayouts[t] || {}, e) : e;
				}, x.clearItemLayouts = function () {
					this._itemLayouts.length = 0;
				}, x.getItemVisual = function (t, e, i) {
					var n = this._itemVisuals[t],
					    a = n && n[e];return null != a || i ? a : this.getVisual(e);
				}, x.setItemVisual = function (t, e, i) {
					var n = this._itemVisuals[t] || {};if (this._itemVisuals[t] = n, m(e)) for (var a in e) {
						e.hasOwnProperty(a) && (n[a] = e[a]);
					} else n[e] = i;
				}, x.clearAllVisual = function () {
					this._visual = {}, this._itemVisuals = [];
				};var _ = function _(t) {
					t.seriesIndex = this.seriesIndex, t.dataIndex = this.dataIndex, t.dataType = this.dataType;
				};x.setItemGraphicEl = function (t, e) {
					var i = this.hostModel;e && (e.dataIndex = t, e.dataType = this.dataType, e.seriesIndex = i && i.seriesIndex, "group" === e.type && e.traverse(_, e)), this._graphicEls[t] = e;
				}, x.getItemGraphicEl = function (t) {
					return this._graphicEls[t];
				}, x.eachItemGraphicEl = function (t, e) {
					p.each(this._graphicEls, function (i, n) {
						i && t && t.call(e, i, n);
					});
				}, x.cloneShallow = function () {
					var t = p.map(this.dimensions, this.getDimensionInfo, this),
					    e = new y(t, this.hostModel);return e._storage = this._storage, n(e, this), e.indices = this.indices.slice(), this._extent && (e._extent = p.extend({}, this._extent)), e;
				}, x.wrapMethod = function (t, e) {
					var i = this[t];"function" == typeof i && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function () {
						var t = i.apply(this, arguments);return e.apply(this, [t].concat(p.slice(arguments)));
					});
				}, x.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], x.CHANGABLE_METHODS = ["filterSelf"], t.exports = y;
			}).call(e, function () {
				return this;
			}());
		}, function (t, e, i) {
			function n(t) {
				r.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), 'componentType "' + t + '" illegal');
			}function a(t, e) {
				var i = r.slice(arguments, 2);return this.superClass.prototype[e].apply(t, i);
			}function o(t, e, i) {
				return this.superClass.prototype[e].apply(t, i);
			}var r = i(1),
			    s = {},
			    l = ".",
			    u = "___EC__COMPONENT__CONTAINER___",
			    c = "\0ec_\0";s.set = function (t, e, i) {
				return t[c + e] = i;
			}, s.get = function (t, e) {
				return t[c + e];
			}, s.hasOwn = function (t, e) {
				return t.hasOwnProperty(c + e);
			};var h = s.parseClassType = function (t) {
				var e = { main: "", sub: "" };return t && (t = t.split(l), e.main = t[0] || "", e.sub = t[1] || ""), e;
			};s.enableClassExtend = function (t, e) {
				t.$constructor = t, t.extend = function (t) {
					var e = this,
					    i = function i() {
						t.$constructor ? t.$constructor.apply(this, arguments) : e.apply(this, arguments);
					};return r.extend(i.prototype, t), i.extend = this.extend, i.superCall = a, i.superApply = o, r.inherits(i, this), i.superClass = e, i;
				};
			}, s.enableClassManagement = function (t, e) {
				function i(t) {
					var e = a[t.main];return e && e[u] || (e = a[t.main] = {}, e[u] = !0), e;
				}e = e || {};var a = {};if (t.registerClass = function (t, e) {
					if (e) if (n(e), e = h(e), e.sub) {
						if (e.sub !== u) {
							var o = i(e);o[e.sub] = t;
						}
					} else a[e.main] = t;return t;
				}, t.getClass = function (t, e, i) {
					var n = a[t];if (n && n[u] && (n = e ? n[e] : null), i && !n) throw new Error(e ? "Component " + t + "." + (e || "") + " not exists. Load it first." : t + ".type should be specified.");return n;
				}, t.getClassesByMainType = function (t) {
					t = h(t);var e = [],
					    i = a[t.main];return i && i[u] ? r.each(i, function (t, i) {
						i !== u && e.push(t);
					}) : e.push(i), e;
				}, t.hasClass = function (t) {
					return t = h(t), !!a[t.main];
				}, t.getAllClassMainTypes = function () {
					var t = [];return r.each(a, function (e, i) {
						t.push(i);
					}), t;
				}, t.hasSubTypes = function (t) {
					t = h(t);var e = a[t.main];return e && e[u];
				}, t.parseClassType = h, e.registerWhenExtend) {
					var o = t.extend;o && (t.extend = function (e) {
						var i = o.call(this, e);return t.registerClass(i, e.type);
					});
				}return t;
			}, s.setReadOnly = function (t, e) {}, t.exports = s;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t + ":" + e;if (l[i]) return l[i];for (var n = (t + "").split("\n"), a = 0, o = 0, r = n.length; o < r; o++) {
					a = Math.max(p.measureText(n[o], e).width, a);
				}return u > c && (u = 0, l = {}), u++, l[i] = a, a;
			}function a(t, e, i, a) {
				var o = ((t || "") + "").split("\n").length,
				    r = n(t, e),
				    s = n("", e),
				    l = o * s,
				    u = new d(0, 0, r, l);switch (u.lineHeight = s, a) {case "bottom":case "alphabetic":
						u.y -= s;break;case "middle":
						u.y -= s / 2;}switch (i) {case "end":case "right":
						u.x -= u.width;break;case "center":
						u.x -= u.width / 2;}return u;
			}function o(t, e, i, n) {
				var a = e.x,
				    o = e.y,
				    r = e.height,
				    s = e.width,
				    l = i.height,
				    u = i.lineHeight,
				    c = r / 2 - l / 2 + u,
				    h = "left";switch (t) {case "left":
						a -= n, o += c, h = "right";break;case "right":
						a += n + s, o += c, h = "left";break;case "top":
						a += s / 2, o -= n + l - u, h = "center";break;case "bottom":
						a += s / 2, o += r + n + u, h = "center";break;case "inside":
						a += s / 2, o += c, h = "center";break;case "insideLeft":
						a += n, o += c, h = "left";break;case "insideRight":
						a += s - n, o += c, h = "right";break;case "insideTop":
						a += s / 2, o += n + u, h = "center";break;case "insideBottom":
						a += s / 2, o += r - l - n + u, h = "center";break;case "insideTopLeft":
						a += n, o += n + u, h = "left";break;case "insideTopRight":
						a += s - n, o += n + u, h = "right";break;case "insideBottomLeft":
						a += n, o += r - l - n + u;break;case "insideBottomRight":
						a += s - n, o += r - l - n + u, h = "right";}return { x: a, y: o, textAlign: h, textBaseline: "alphabetic" };
			}function r(t, e, i, a, o) {
				if (!e) return "";o = o || {}, a = f(a, "...");for (var r = f(o.maxIterations, 2), l = f(o.minChar, 0), u = n("", i), c = n("a", i), h = f(o.placeholder, ""), d = e = Math.max(0, e - 1), p = 0; p < l && d >= c; p++) {
					d -= c;
				}var g = n(a);g > d && (a = "", g = 0), d = e - g;for (var m = (t + "").split("\n"), p = 0, v = m.length; p < v; p++) {
					var y = m[p],
					    x = n(y, i);if (!(x <= e)) {
						for (var _ = 0;; _++) {
							if (x <= d || _ >= r) {
								y += a;break;
							}var b = 0 === _ ? s(y, d, c, u) : x > 0 ? Math.floor(y.length * d / x) : 0;y = y.substr(0, b), x = n(y, i);
						}"" === y && (y = h), m[p] = y;
					}
				}return m.join("\n");
			}function s(t, e, i, n) {
				for (var a = 0, o = 0, r = t.length; o < r && a < e; o++) {
					var s = t.charCodeAt(o);a += 0 <= s && s <= 127 ? i : n;
				}return o;
			}var l = {},
			    u = 0,
			    c = 5e3,
			    h = i(1),
			    d = i(11),
			    f = h.retrieve,
			    p = { getWidth: n, getBoundingRect: a, adjustTextPositionOnRect: o, truncateText: r, measureText: function measureText(t, e) {
					var i = h.getContext();return i.font = e || "12px sans-serif", i.measureText(t);
				} };t.exports = p;
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(7),
			    o = i(15),
			    r = i(5),
			    s = i(13),
			    l = i(62),
			    u = i(9),
			    c = i(12),
			    h = o.set,
			    d = o.get,
			    f = a.encodeHTML,
			    p = a.addCommas,
			    g = s.extend({ type: "series.__base__", seriesIndex: 0, coordinateSystem: null, defaultOption: null, legendDataProvider: null, visualColorAccessPath: "itemStyle.normal.color", layoutMode: null, init: function init(t, e, i, n) {
					this.seriesIndex = this.componentIndex, this.mergeDefaultAndTheme(t, i);var a = this.getInitialData(t, i);h(this, "dataBeforeProcessed", a), this.restoreData();
				}, mergeDefaultAndTheme: function mergeDefaultAndTheme(t, e) {
					var i = this.layoutMode,
					    a = i ? c.getLayoutParams(t) : {};n.merge(t, e.getTheme().get(this.subType)), n.merge(t, this.getDefaultOption()), r.defaultEmphasis(t.label, r.LABEL_OPTIONS), this.fillDataTextStyle(t.data), i && c.mergeLayoutParam(t, a, i);
				}, mergeOption: function mergeOption(t, e) {
					t = n.merge(this.option, t, !0), this.fillDataTextStyle(t.data);var i = this.layoutMode;i && c.mergeLayoutParam(this.option, t, i);var a = this.getInitialData(t, e);a && (h(this, "data", a), h(this, "dataBeforeProcessed", a.cloneShallow()));
				}, fillDataTextStyle: function fillDataTextStyle(t) {
					if (t) for (var e = 0; e < t.length; e++) {
						t[e] && t[e].label && r.defaultEmphasis(t[e].label, r.LABEL_OPTIONS);
					}
				}, getInitialData: function getInitialData() {}, getData: function getData(t) {
					var e = d(this, "data");return null == t ? e : e.getLinkedData(t);
				}, setData: function setData(t) {
					h(this, "data", t);
				}, getRawData: function getRawData() {
					return d(this, "dataBeforeProcessed");
				}, coordDimToDataDim: function coordDimToDataDim(t) {
					return r.coordDimToDataDim(this.getData(), t);
				}, dataDimToCoordDim: function dataDimToCoordDim(t) {
					return r.dataDimToCoordDim(this.getData(), t);
				}, getBaseAxis: function getBaseAxis() {
					var t = this.coordinateSystem;return t && t.getBaseAxis && t.getBaseAxis();
				}, formatTooltip: function formatTooltip(t, e, i) {
					function o(i) {
						function o(t, i) {
							var n = s.getDimensionInfo(i);if (n && n.otherDims.tooltip !== !1) {
								var o = n.type,
								    r = (l ? "- " + (n.tooltipName || n.name) + ": " : "") + ("ordinal" === o ? t + "" : "time" === o ? e ? "" : a.formatTime("yyyy/MM/dd hh:mm:ss", t) : p(t));r && u.push(f(r));
							}
						}var l = n.reduce(i, function (t, e, i) {
							var n = s.getDimensionInfo(i);return t |= n.tooltip !== !1 && null != n.tooltipName;
						}, 0),
						    u = [],
						    c = r.otherDimToDataDim(s, "tooltip");return c.length ? n.each(c, function (e) {
							o(s.get(e, t), e);
						}) : n.each(i, o), (l ? "<br/>" : "") + u.join(l ? "<br/>" : ", ");
					}var s = d(this, "data"),
					    l = this.getRawValue(t),
					    u = n.isArray(l) ? o(l) : f(p(l)),
					    c = s.getName(t),
					    h = s.getItemVisual(t, "color");n.isObject(h) && h.colorStops && (h = (h.colorStops[0] || {}).color), h = h || "transparent";var g = a.getTooltipMarker(h),
					    m = this.name;return "\0-" === m && (m = ""), m = m ? f(m) + (e ? ": " : "<br/>") : "", e ? g + m + u : m + g + (c ? f(c) + ": " + u : u);
				}, isAnimationEnabled: function isAnimationEnabled() {
					if (u.node) return !1;var t = this.getShallow("animation");return t && this.getData().count() > this.getShallow("animationThreshold") && (t = !1), t;
				}, restoreData: function restoreData() {
					h(this, "data", d(this, "dataBeforeProcessed").cloneShallow());
				}, getColorFromPalette: function getColorFromPalette(t, e) {
					var i = this.ecModel,
					    n = l.getColorFromPalette.call(this, t, e);return n || (n = i.getColorFromPalette(t, e)), n;
				}, getAxisTooltipData: null, getTooltipPosition: null });n.mixin(g, r.dataFormatMixin), n.mixin(g, l), t.exports = g;
		}, function (t, e, i) {
			var n = i(149),
			    a = i(43);i(150), i(148);var o = i(34),
			    r = i(4),
			    s = i(1),
			    l = i(16),
			    u = {};u.getScaleExtent = function (t, e) {
				var i,
				    n,
				    a,
				    o = t.type,
				    l = e.getMin(),
				    u = e.getMax(),
				    c = null != l,
				    h = null != u,
				    d = t.getExtent();return "ordinal" === o ? i = (e.get("data") || []).length : (n = e.get("boundaryGap"), s.isArray(n) || (n = [n || 0, n || 0]), "boolean" == typeof n[0] && (n = [0, 0]), n[0] = r.parsePercent(n[0], 1), n[1] = r.parsePercent(n[1], 1), a = d[1] - d[0] || Math.abs(d[0])), null == l && (l = "ordinal" === o ? i ? 0 : NaN : d[0] - n[0] * a), null == u && (u = "ordinal" === o ? i ? i - 1 : NaN : d[1] + n[1] * a), "dataMin" === l && (l = d[0]), "dataMax" === u && (u = d[1]), (null == l || !isFinite(l)) && (l = NaN), (null == u || !isFinite(u)) && (u = NaN), t.setBlank(s.eqNaN(l) || s.eqNaN(u)), e.getNeedCrossZero() && (l > 0 && u > 0 && !c && (l = 0), l < 0 && u < 0 && !h && (u = 0)), [l, u];
			}, u.niceScaleExtent = function (t, e) {
				var i = u.getScaleExtent(t, e),
				    n = null != e.getMin(),
				    a = null != e.getMax(),
				    o = e.get("splitNumber");"log" === t.type && (t.base = e.get("logBase")), t.setExtent(i[0], i[1]), t.niceExtent({ splitNumber: o, fixMin: n, fixMax: a, minInterval: "interval" === t.type ? e.get("minInterval") : null });var r = e.get("interval");null != r && t.setInterval && t.setInterval(r);
			}, u.createScaleByModel = function (t, e) {
				if (e = e || t.get("type")) switch (e) {case "category":
						return new n(t.getCategories(), [1 / 0, -(1 / 0)]);case "value":
						return new a();default:
						return (o.getClass(e) || a).create(t);}
			}, u.ifAxisCrossZero = function (t) {
				var e = t.scale.getExtent(),
				    i = e[0],
				    n = e[1];return !(i > 0 && n > 0 || i < 0 && n < 0);
			}, u.getAxisLabelInterval = function (t, e, i, n) {
				var a,
				    o = 0,
				    r = 0,
				    s = 1;e.length > 40 && (s = Math.floor(e.length / 40));for (var u = 0; u < t.length; u += s) {
					var c = t[u],
					    h = l.getBoundingRect(e[u], i, "center", "top");h[n ? "x" : "y"] += c, h[n ? "width" : "height"] *= 1.3, a ? a.intersect(h) ? (r++, o = Math.max(o, r)) : (a.union(h), r = 0) : a = h.clone();
				}return 0 === o && s > 1 ? s : (o + 1) * s - 1;
			}, u.getFormattedLabels = function (t, e) {
				var i = t.scale,
				    n = i.getTicksLabels(),
				    a = i.getTicks();return "string" == typeof e ? (e = function (t) {
					return function (e) {
						return t.replace("{value}", null != e ? e : "");
					};
				}(e), s.map(n, e)) : "function" == typeof e ? s.map(a, function (i, n) {
					return e(u.getAxisRawValue(t, i), n);
				}, this) : n;
			}, u.getAxisRawValue = function (t, e) {
				return "category" === t.type ? t.scale.getLabel(e) : e;
			}, t.exports = u;
		}, function (t, e) {
			var i = "undefined" == typeof Float32Array ? Array : Float32Array,
			    n = { create: function create() {
					var t = new i(6);return n.identity(t), t;
				}, identity: function identity(t) {
					return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;
				}, copy: function copy(t, e) {
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t;
				}, mul: function mul(t, e, i) {
					var n = e[0] * i[0] + e[2] * i[1],
					    a = e[1] * i[0] + e[3] * i[1],
					    o = e[0] * i[2] + e[2] * i[3],
					    r = e[1] * i[2] + e[3] * i[3],
					    s = e[0] * i[4] + e[2] * i[5] + e[4],
					    l = e[1] * i[4] + e[3] * i[5] + e[5];return t[0] = n, t[1] = a, t[2] = o, t[3] = r, t[4] = s, t[5] = l, t;
				}, translate: function translate(t, e, i) {
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t;
				}, rotate: function rotate(t, e, i) {
					var n = e[0],
					    a = e[2],
					    o = e[4],
					    r = e[1],
					    s = e[3],
					    l = e[5],
					    u = Math.sin(i),
					    c = Math.cos(i);return t[0] = n * c + r * u, t[1] = -n * u + r * c, t[2] = a * c + s * u, t[3] = -a * u + c * s, t[4] = c * o + u * l, t[5] = c * l - u * o, t;
				}, scale: function scale(t, e, i) {
					var n = i[0],
					    a = i[1];return t[0] = e[0] * n, t[1] = e[1] * a, t[2] = e[2] * n, t[3] = e[3] * a, t[4] = e[4] * n, t[5] = e[5] * a, t;
				}, invert: function invert(t, e) {
					var i = e[0],
					    n = e[2],
					    a = e[4],
					    o = e[1],
					    r = e[3],
					    s = e[5],
					    l = i * r - o * n;return l ? (l = 1 / l, t[0] = r * l, t[1] = -o * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - r * a) * l, t[5] = (o * a - i * s) * l, t) : null;
				} };t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return t > -w && t < w;
			}function a(t) {
				return t > w || t < -w;
			}function o(t, e, i, n, a) {
				var o = 1 - a;return o * o * (o * t + 3 * a * e) + a * a * (a * n + 3 * o * i);
			}function r(t, e, i, n, a) {
				var o = 1 - a;return 3 * (((e - t) * o + 2 * (i - e) * a) * o + (n - i) * a * a);
			}function s(t, e, i, a, o, r) {
				var s = a + 3 * (e - i) - t,
				    l = 3 * (i - 2 * e + t),
				    u = 3 * (e - t),
				    c = t - o,
				    h = l * l - 3 * s * u,
				    d = l * u - 9 * s * c,
				    f = u * u - 3 * l * c,
				    p = 0;if (n(h) && n(d)) {
					if (n(l)) r[0] = 0;else {
						var g = -u / l;g >= 0 && g <= 1 && (r[p++] = g);
					}
				} else {
					var m = d * d - 4 * h * f;if (n(m)) {
						var v = d / h,
						    g = -l / s + v,
						    y = -v / 2;g >= 0 && g <= 1 && (r[p++] = g), y >= 0 && y <= 1 && (r[p++] = y);
					} else if (m > 0) {
						var x = b(m),
						    w = h * l + 1.5 * s * (-d + x),
						    S = h * l + 1.5 * s * (-d - x);w = w < 0 ? -_(-w, I) : _(w, I), S = S < 0 ? -_(-S, I) : _(S, I);var g = (-l - (w + S)) / (3 * s);g >= 0 && g <= 1 && (r[p++] = g);
					} else {
						var T = (2 * h * l - 3 * s * d) / (2 * b(h * h * h)),
						    A = Math.acos(T) / 3,
						    C = b(h),
						    L = Math.cos(A),
						    g = (-l - 2 * C * L) / (3 * s),
						    y = (-l + C * (L + M * Math.sin(A))) / (3 * s),
						    D = (-l + C * (L - M * Math.sin(A))) / (3 * s);g >= 0 && g <= 1 && (r[p++] = g), y >= 0 && y <= 1 && (r[p++] = y), D >= 0 && D <= 1 && (r[p++] = D);
					}
				}return p;
			}function l(t, e, i, o, r) {
				var s = 6 * i - 12 * e + 6 * t,
				    l = 9 * e + 3 * o - 3 * t - 9 * i,
				    u = 3 * e - 3 * t,
				    c = 0;if (n(l)) {
					if (a(s)) {
						var h = -u / s;h >= 0 && h <= 1 && (r[c++] = h);
					}
				} else {
					var d = s * s - 4 * l * u;if (n(d)) r[0] = -s / (2 * l);else if (d > 0) {
						var f = b(d),
						    h = (-s + f) / (2 * l),
						    p = (-s - f) / (2 * l);h >= 0 && h <= 1 && (r[c++] = h), p >= 0 && p <= 1 && (r[c++] = p);
					}
				}return c;
			}function u(t, e, i, n, a, o) {
				var r = (e - t) * a + t,
				    s = (i - e) * a + e,
				    l = (n - i) * a + i,
				    u = (s - r) * a + r,
				    c = (l - s) * a + s,
				    h = (c - u) * a + u;o[0] = t, o[1] = r, o[2] = u, o[3] = h, o[4] = h, o[5] = c, o[6] = l, o[7] = n;
			}function c(t, e, i, n, a, r, s, l, u, c, h) {
				var d,
				    f,
				    p,
				    g,
				    m,
				    v = .005,
				    y = 1 / 0;T[0] = u, T[1] = c;for (var _ = 0; _ < 1; _ += .05) {
					A[0] = o(t, i, a, s, _), A[1] = o(e, n, r, l, _), g = x(T, A), g < y && (d = _, y = g);
				}y = 1 / 0;for (var w = 0; w < 32 && !(v < S); w++) {
					f = d - v, p = d + v, A[0] = o(t, i, a, s, f), A[1] = o(e, n, r, l, f), g = x(A, T), f >= 0 && g < y ? (d = f, y = g) : (C[0] = o(t, i, a, s, p), C[1] = o(e, n, r, l, p), m = x(C, T), p <= 1 && m < y ? (d = p, y = m) : v *= .5);
				}return h && (h[0] = o(t, i, a, s, d), h[1] = o(e, n, r, l, d)), b(y);
			}function h(t, e, i, n) {
				var a = 1 - n;return a * (a * t + 2 * n * e) + n * n * i;
			}function d(t, e, i, n) {
				return 2 * ((1 - n) * (e - t) + n * (i - e));
			}function f(t, e, i, o, r) {
				var s = t - 2 * e + i,
				    l = 2 * (e - t),
				    u = t - o,
				    c = 0;if (n(s)) {
					if (a(l)) {
						var h = -u / l;h >= 0 && h <= 1 && (r[c++] = h);
					}
				} else {
					var d = l * l - 4 * s * u;if (n(d)) {
						var h = -l / (2 * s);h >= 0 && h <= 1 && (r[c++] = h);
					} else if (d > 0) {
						var f = b(d),
						    h = (-l + f) / (2 * s),
						    p = (-l - f) / (2 * s);h >= 0 && h <= 1 && (r[c++] = h), p >= 0 && p <= 1 && (r[c++] = p);
					}
				}return c;
			}function p(t, e, i) {
				var n = t + i - 2 * e;return 0 === n ? .5 : (t - e) / n;
			}function g(t, e, i, n, a) {
				var o = (e - t) * n + t,
				    r = (i - e) * n + e,
				    s = (r - o) * n + o;a[0] = t, a[1] = o, a[2] = s, a[3] = s, a[4] = r, a[5] = i;
			}function m(t, e, i, n, a, o, r, s, l) {
				var u,
				    c = .005,
				    d = 1 / 0;T[0] = r, T[1] = s;for (var f = 0; f < 1; f += .05) {
					A[0] = h(t, i, a, f), A[1] = h(e, n, o, f);var p = x(T, A);p < d && (u = f, d = p);
				}d = 1 / 0;for (var g = 0; g < 32 && !(c < S); g++) {
					var m = u - c,
					    v = u + c;A[0] = h(t, i, a, m), A[1] = h(e, n, o, m);var p = x(A, T);if (m >= 0 && p < d) u = m, d = p;else {
						C[0] = h(t, i, a, v), C[1] = h(e, n, o, v);var y = x(C, T);v <= 1 && y < d ? (u = v, d = y) : c *= .5;
					}
				}return l && (l[0] = h(t, i, a, u), l[1] = h(e, n, o, u)), b(d);
			}var v = i(6),
			    y = v.create,
			    x = v.distSquare,
			    _ = Math.pow,
			    b = Math.sqrt,
			    w = 1e-8,
			    S = 1e-4,
			    M = b(3),
			    I = 1 / 3,
			    T = y(),
			    A = y(),
			    C = y();t.exports = { cubicAt: o, cubicDerivativeAt: r, cubicRootAt: s, cubicExtrema: l, cubicSubdivide: u, cubicProjectPoint: c, quadraticAt: h, quadraticDerivativeAt: d, quadraticRootAt: f, quadraticExtremum: p, quadraticSubdivide: g, quadraticProjectPoint: m };
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return t.getBoundingClientRect ? t.getBoundingClientRect() : { left: 0, top: 0 };
			}function a(t, e, i, n) {
				return i = i || {}, n || !c.canvasSupported ? o(t, e, i) : c.browser.firefox && null != e.layerX && e.layerX !== e.offsetX ? (i.zrX = e.layerX, i.zrY = e.layerY) : null != e.offsetX ? (i.zrX = e.offsetX, i.zrY = e.offsetY) : o(t, e, i), i;
			}function o(t, e, i) {
				var a = n(t);i.zrX = e.clientX - a.left, i.zrY = e.clientY - a.top;
			}function r(t, e, i) {
				if (e = e || window.event, null != e.zrX) return e;var n = e.type,
				    o = n && n.indexOf("touch") >= 0;if (o) {
					var r = "touchend" != n ? e.targetTouches[0] : e.changedTouches[0];r && a(t, r, e, i);
				} else a(t, e, e, i), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;return e;
			}function s(t, e, i) {
				h ? t.addEventListener(e, i) : t.attachEvent("on" + e, i);
			}function l(t, e, i) {
				h ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i);
			}var u = i(23),
			    c = i(9),
			    h = "undefined" != typeof window && !!window.addEventListener,
			    d = h ? function (t) {
				t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0;
			} : function (t) {
				t.returnValue = !1, t.cancelBubble = !0;
			};t.exports = { clientToLocal: a, normalizeEvent: r, addEventListener: s, removeEventListener: l, stop: d, Dispatcher: u };
		}, function (t, e, i) {
			function n(t) {
				return t = Math.round(t), t < 0 ? 0 : t > 255 ? 255 : t;
			}function a(t) {
				return t = Math.round(t), t < 0 ? 0 : t > 360 ? 360 : t;
			}function o(t) {
				return t < 0 ? 0 : t > 1 ? 1 : t;
			}function r(t) {
				return n(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 * 255 : parseInt(t, 10));
			}function s(t) {
				return o(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 : parseFloat(t));
			}function l(t, e, i) {
				return i < 0 ? i += 1 : i > 1 && (i -= 1), 6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t;
			}function u(t, e, i) {
				return t + (e - t) * i;
			}function c(t, e, i, n, a) {
				return t[0] = e, t[1] = i, t[2] = n, t[3] = a, t;
			}function h(t, e) {
				return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;
			}function d(t, e) {
				T && h(T, e), T = I.put(t, T || e.slice());
			}function f(t, e) {
				if (t) {
					e = e || [];var i = I.get(t);if (i) return h(e, i);t += "";var n = t.replace(/ /g, "").toLowerCase();if (n in M) return h(e, M[n]), d(t, e), e;if ("#" !== n.charAt(0)) {
						var a = n.indexOf("("),
						    o = n.indexOf(")");if (a !== -1 && o + 1 === n.length) {
							var l = n.substr(0, a),
							    u = n.substr(a + 1, o - (a + 1)).split(","),
							    f = 1;switch (l) {case "rgba":
									if (4 !== u.length) return void c(e, 0, 0, 0, 1);f = s(u.pop());case "rgb":
									return 3 !== u.length ? void c(e, 0, 0, 0, 1) : (c(e, r(u[0]), r(u[1]), r(u[2]), f), d(t, e), e);case "hsla":
									return 4 !== u.length ? void c(e, 0, 0, 0, 1) : (u[3] = s(u[3]), p(u, e), d(t, e), e);case "hsl":
									return 3 !== u.length ? void c(e, 0, 0, 0, 1) : (p(u, e), d(t, e), e);default:
									return;}
						}c(e, 0, 0, 0, 1);
					} else {
						if (4 === n.length) {
							var g = parseInt(n.substr(1), 16);return g >= 0 && g <= 4095 ? (c(e, (3840 & g) >> 4 | (3840 & g) >> 8, 240 & g | (240 & g) >> 4, 15 & g | (15 & g) << 4, 1), d(t, e), e) : void c(e, 0, 0, 0, 1);
						}if (7 === n.length) {
							var g = parseInt(n.substr(1), 16);return g >= 0 && g <= 16777215 ? (c(e, (16711680 & g) >> 16, (65280 & g) >> 8, 255 & g, 1), d(t, e), e) : void c(e, 0, 0, 0, 1);
						}
					}
				}
			}function p(t, e) {
				var i = (parseFloat(t[0]) % 360 + 360) % 360 / 360,
				    a = s(t[1]),
				    o = s(t[2]),
				    r = o <= .5 ? o * (a + 1) : o + a - o * a,
				    u = 2 * o - r;return e = e || [], c(e, n(255 * l(u, r, i + 1 / 3)), n(255 * l(u, r, i)), n(255 * l(u, r, i - 1 / 3)), 1), 4 === t.length && (e[3] = t[3]), e;
			}function g(t) {
				if (t) {
					var e,
					    i,
					    n = t[0] / 255,
					    a = t[1] / 255,
					    o = t[2] / 255,
					    r = Math.min(n, a, o),
					    s = Math.max(n, a, o),
					    l = s - r,
					    u = (s + r) / 2;if (0 === l) e = 0, i = 0;else {
						i = u < .5 ? l / (s + r) : l / (2 - s - r);var c = ((s - n) / 6 + l / 2) / l,
						    h = ((s - a) / 6 + l / 2) / l,
						    d = ((s - o) / 6 + l / 2) / l;n === s ? e = d - h : a === s ? e = 1 / 3 + c - d : o === s && (e = 2 / 3 + h - c), e < 0 && (e += 1), e > 1 && (e -= 1);
					}var f = [360 * e, i, u];return null != t[3] && f.push(t[3]), f;
				}
			}function m(t, e) {
				var i = f(t);if (i) {
					for (var n = 0; n < 3; n++) {
						e < 0 ? i[n] = i[n] * (1 - e) | 0 : i[n] = (255 - i[n]) * e + i[n] | 0;
					}return w(i, 4 === i.length ? "rgba" : "rgb");
				}
			}function v(t, e) {
				var i = f(t);if (i) return ((1 << 24) + (i[0] << 16) + (i[1] << 8) + +i[2]).toString(16).slice(1);
			}function y(t, e, i) {
				if (e && e.length && t >= 0 && t <= 1) {
					i = i || [];var a = t * (e.length - 1),
					    r = Math.floor(a),
					    s = Math.ceil(a),
					    l = e[r],
					    c = e[s],
					    h = a - r;return i[0] = n(u(l[0], c[0], h)), i[1] = n(u(l[1], c[1], h)), i[2] = n(u(l[2], c[2], h)), i[3] = o(u(l[3], c[3], h)), i;
				}
			}function x(t, e, i) {
				if (e && e.length && t >= 0 && t <= 1) {
					var a = t * (e.length - 1),
					    r = Math.floor(a),
					    s = Math.ceil(a),
					    l = f(e[r]),
					    c = f(e[s]),
					    h = a - r,
					    d = w([n(u(l[0], c[0], h)), n(u(l[1], c[1], h)), n(u(l[2], c[2], h)), o(u(l[3], c[3], h))], "rgba");return i ? { color: d, leftIndex: r, rightIndex: s, value: a } : d;
				}
			}function _(t, e, i, n) {
				if (t = f(t)) return t = g(t), null != e && (t[0] = a(e)), null != i && (t[1] = s(i)), null != n && (t[2] = s(n)), w(p(t), "rgba");
			}function b(t, e) {
				if (t = f(t), t && null != e) return t[3] = o(e), w(t, "rgba");
			}function w(t, e) {
				if (t && t.length) {
					var i = t[0] + "," + t[1] + "," + t[2];return "rgba" !== e && "hsva" !== e && "hsla" !== e || (i += "," + t[3]), e + "(" + i + ")";
				}
			}var S = i(70),
			    M = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1],
				darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] },
			    I = new S(20),
			    T = null;t.exports = { parse: f, lift: m, toHex: v, fastMapToColor: y, mapToColor: x, modifyHSL: _, modifyAlpha: b, stringify: w };
		}, function (t, e) {
			var i = Array.prototype.slice,
			    n = function n() {
				this._$handlers = {};
			};n.prototype = { constructor: n, one: function one(t, e, i) {
					var n = this._$handlers;if (!e || !t) return this;n[t] || (n[t] = []);for (var a = 0; a < n[t].length; a++) {
						if (n[t][a].h === e) return this;
					}return n[t].push({ h: e, one: !0, ctx: i || this }), this;
				}, on: function on(t, e, i) {
					var n = this._$handlers;if (!e || !t) return this;n[t] || (n[t] = []);for (var a = 0; a < n[t].length; a++) {
						if (n[t][a].h === e) return this;
					}return n[t].push({ h: e, one: !1, ctx: i || this }), this;
				}, isSilent: function isSilent(t) {
					var e = this._$handlers;return e[t] && e[t].length;
				}, off: function off(t, e) {
					var i = this._$handlers;if (!t) return this._$handlers = {}, this;if (e) {
						if (i[t]) {
							for (var n = [], a = 0, o = i[t].length; a < o; a++) {
								i[t][a].h != e && n.push(i[t][a]);
							}i[t] = n;
						}i[t] && 0 === i[t].length && delete i[t];
					} else delete i[t];return this;
				}, trigger: function trigger(t) {
					if (this._$handlers[t]) {
						var e = arguments,
						    n = e.length;n > 3 && (e = i.call(e, 1));for (var a = this._$handlers[t], o = a.length, r = 0; r < o;) {
							switch (n) {case 1:
									a[r].h.call(a[r].ctx);break;case 2:
									a[r].h.call(a[r].ctx, e[1]);break;case 3:
									a[r].h.call(a[r].ctx, e[1], e[2]);break;default:
									a[r].h.apply(a[r].ctx, e);}a[r].one ? (a.splice(r, 1), o--) : r++;
						}
					}return this;
				}, triggerWithContext: function triggerWithContext(t) {
					if (this._$handlers[t]) {
						var e = arguments,
						    n = e.length;n > 4 && (e = i.call(e, 1, e.length - 1));for (var a = e[e.length - 1], o = this._$handlers[t], r = o.length, s = 0; s < r;) {
							switch (n) {case 1:
									o[s].h.call(a);break;case 2:
									o[s].h.call(a, e[1]);break;case 3:
									o[s].h.call(a, e[1], e[2]);break;default:
									o[s].h.apply(a, e);}o[s].one ? (o.splice(s, 1), r--) : s++;
						}
					}return this;
				} }, t.exports = n;
		}, function (t, e, i) {
			"use strict";
			var n = i(3),
			    a = i(11),
			    o = n.extendShape({ type: "triangle", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function buildPath(t, e) {
					var i = e.cx,
					    n = e.cy,
					    a = e.width / 2,
					    o = e.height / 2;t.moveTo(i, n - o), t.lineTo(i + a, n + o), t.lineTo(i - a, n + o), t.closePath();
				} }),
			    r = n.extendShape({ type: "diamond", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function buildPath(t, e) {
					var i = e.cx,
					    n = e.cy,
					    a = e.width / 2,
					    o = e.height / 2;t.moveTo(i, n - o), t.lineTo(i + a, n), t.lineTo(i, n + o), t.lineTo(i - a, n), t.closePath();
				} }),
			    s = n.extendShape({ type: "pin", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function buildPath(t, e) {
					var i = e.x,
					    n = e.y,
					    a = e.width / 5 * 3,
					    o = Math.max(a, e.height),
					    r = a / 2,
					    s = r * r / (o - r),
					    l = n - o + r + s,
					    u = Math.asin(s / r),
					    c = Math.cos(u) * r,
					    h = Math.sin(u),
					    d = Math.cos(u);t.arc(i, l, r, Math.PI - u, 2 * Math.PI + u);var f = .6 * r,
					    p = .7 * r;t.bezierCurveTo(i + c - h * f, l + s + d * f, i, n - p, i, n), t.bezierCurveTo(i, n - p, i - c + h * f, l + s + d * f, i - c, l + s), t.closePath();
				} }),
			    l = n.extendShape({ type: "arrow", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function buildPath(t, e) {
					var i = e.height,
					    n = e.width,
					    a = e.x,
					    o = e.y,
					    r = n / 3 * 2;t.moveTo(a, o), t.lineTo(a + r, o + i), t.lineTo(a, o + i / 4 * 3), t.lineTo(a - r, o + i), t.lineTo(a, o), t.closePath();
				} }),
			    u = { line: n.Line, rect: n.Rect, roundRect: n.Rect, square: n.Rect, circle: n.Circle, diamond: r, pin: s, arrow: l, triangle: o },
			    c = { line: function line(t, e, i, n, a) {
					a.x1 = t, a.y1 = e + n / 2, a.x2 = t + i, a.y2 = e + n / 2;
				}, rect: function rect(t, e, i, n, a) {
					a.x = t, a.y = e, a.width = i, a.height = n;
				}, roundRect: function roundRect(t, e, i, n, a) {
					a.x = t, a.y = e, a.width = i, a.height = n, a.r = Math.min(i, n) / 4;
				}, square: function square(t, e, i, n, a) {
					var o = Math.min(i, n);a.x = t, a.y = e, a.width = o, a.height = o;
				}, circle: function circle(t, e, i, n, a) {
					a.cx = t + i / 2, a.cy = e + n / 2, a.r = Math.min(i, n) / 2;
				}, diamond: function diamond(t, e, i, n, a) {
					a.cx = t + i / 2, a.cy = e + n / 2, a.width = i, a.height = n;
				}, pin: function pin(t, e, i, n, a) {
					a.x = t + i / 2, a.y = e + n / 2, a.width = i, a.height = n;
				}, arrow: function arrow(t, e, i, n, a) {
					a.x = t + i / 2, a.y = e + n / 2, a.width = i, a.height = n;
				}, triangle: function triangle(t, e, i, n, a) {
					a.cx = t + i / 2, a.cy = e + n / 2, a.width = i, a.height = n;
				} },
			    h = {};for (var d in u) {
				u.hasOwnProperty(d) && (h[d] = new u[d]());
			}var f = n.extendShape({ type: "symbol", shape: { symbolType: "", x: 0, y: 0, width: 0, height: 0 }, beforeBrush: function beforeBrush() {
					var t = this.style,
					    e = this.shape;"pin" === e.symbolType && "inside" === t.textPosition && (t.textPosition = ["50%", "40%"], t.textAlign = "center", t.textVerticalAlign = "middle");
				}, buildPath: function buildPath(t, e, i) {
					var n = e.symbolType,
					    a = h[n];"none" !== e.symbolType && (a || (n = "rect", a = h[n]), c[n](e.x, e.y, e.width, e.height, a.shape), a.buildPath(t, a.shape, i));
				} }),
			    p = function p(t) {
				if ("image" !== this.type) {
					var e = this.style,
					    i = this.shape;i && "line" === i.symbolType ? e.stroke = t : this.__isEmptyBrush ? (e.stroke = t, e.fill = "#fff") : (e.fill && (e.fill = t), e.stroke && (e.stroke = t)), this.dirty(!1);
				}
			},
			    g = { createSymbol: function createSymbol(t, e, i, o, r, s) {
					var l = 0 === t.indexOf("empty");l && (t = t.substr(5, 1).toLowerCase() + t.substr(6));var u;return u = 0 === t.indexOf("image://") ? new n.Image({ style: { image: t.slice(8), x: e, y: i, width: o, height: r } }) : 0 === t.indexOf("path://") ? n.makePath(t.slice(7), {}, new a(e, i, o, r)) : new f({ shape: { symbolType: t, x: e, y: i, width: o, height: r } }), u.__isEmptyBrush = l, u.setColor = p, u.setColor(s), u;
				} };t.exports = g;
		}, function (t, e, i) {
			function n(t, e, i) {
				function n(t, e, i) {
					h[e] ? t.otherDims[e] = i : (t.coordDim = e, t.coordDimIndex = i, m.set(e, !0));
				}function r(t, e, i) {
					if (i || null != e.get(t)) {
						for (var n = 0; null != e.get(t + n);) {
							n++;
						}t += n;
					}return e.set(t, !0), t;
				}e = e || [], i = i || {}, t = (t || []).slice();var f = (i.dimsDef || []).slice(),
				    p = o.createHashMap(i.encodeDef),
				    g = o.createHashMap(),
				    m = o.createHashMap(),
				    v = [],
				    y = i.dimCount;if (null == y) {
					var x = a(e[0]);y = Math.max(o.isArray(x) && x.length || 1, t.length, f.length), s(t, function (t) {
						var e = t.dimsDef;e && (y = Math.max(y, e.length));
					});
				}for (var _ = 0; _ < y; _++) {
					var b = l(f[_]) ? { name: f[_] } : f[_] || {},
					    w = b.name,
					    S = v[_] = { otherDims: {} };null != w && null == g.get(w) && (S.name = S.tooltipName = w, g.set(w, _)), null != b.type && (S.type = b.type);
				}p.each(function (t, e) {
					t = p.set(e, c(t).slice()), s(t, function (i, a) {
						l(i) && (i = g.get(i)), null != i && i < y && (t[a] = i, n(v[i], e, a));
					});
				});var M = 0;s(t, function (t, e) {
					var i, t, a, r;l(t) ? (i = t, t = {}) : (i = t.name, t = o.clone(t), a = t.dimsDef, r = t.otherDims, t.name = t.coordDim = t.coordDimIndex = t.dimsDef = t.otherDims = null);var h = c(p.get(i));if (!h.length) for (var d = 0; d < (a && a.length || 1); d++) {
						for (; M < v.length && null != v[M].coordDim;) {
							M++;
						}M < v.length && h.push(M++);
					}s(h, function (e, o) {
						var s = v[e];n(u(s, t), i, o), null == s.name && a && (s.name = s.tooltipName = a[o]), r && u(s.otherDims, r);
					});
				});for (var I = i.extraPrefix || "value", T = 0; T < y; T++) {
					var S = v[T] = v[T] || {},
					    A = S.coordDim;null == A && (S.coordDim = r(I, m, i.extraFromZero), S.coordDimIndex = 0, S.isExtraCoord = !0), null == S.name && (S.name = r(S.coordDim, g)), null == S.type && d(e, T) && (S.type = "ordinal");
				}return v;
			}function a(t) {
				return o.isArray(t) ? t : o.isObject(t) ? t.value : t;
			}var o = i(1),
			    r = i(5),
			    s = o.each,
			    l = o.isString,
			    u = o.defaults,
			    c = r.normalizeToArray,
			    h = { tooltip: 1, label: 1, itemName: 1 },
			    d = n.guessOrdinal = function (t, e) {
				for (var i = 0, n = t.length; i < n; i++) {
					var r = a(t[i]);if (!o.isArray(r)) return !1;var r = r[e];if (null != r && isFinite(r)) return !1;if (l(r) && "-" !== r) return !0;
				}return !1;
			};t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n() {
				this._coordinateSystems = [];
			}var a = i(1),
			    o = {};n.prototype = { constructor: n, create: function create(t, e) {
					var i = [];a.each(o, function (n, a) {
						var o = n.create(t, e);i = i.concat(o || []);
					}), this._coordinateSystems = i;
				}, update: function update(t, e) {
					a.each(this._coordinateSystems, function (i) {
						i.update && i.update(t, e);
					});
				}, getCoordinateSystems: function getCoordinateSystems() {
					return this._coordinateSystems.slice();
				} }, n.register = function (t, e) {
				o[t] = e;
			}, n.get = function (t) {
				return o[t];
			}, t.exports = n;
		}, function (t, e, i) {
			"use strict";
			var n = i(20),
			    a = i(6),
			    o = i(85),
			    r = i(11),
			    s = i(35).devicePixelRatio,
			    l = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 },
			    u = [],
			    c = [],
			    h = [],
			    d = [],
			    f = Math.min,
			    p = Math.max,
			    g = Math.cos,
			    m = Math.sin,
			    v = Math.sqrt,
			    y = Math.abs,
			    x = "undefined" != typeof Float32Array,
			    _ = function _(t) {
				this._saveData = !t, this._saveData && (this.data = []), this._ctx = null;
			};_.prototype = { constructor: _, _xi: 0, _yi: 0, _x0: 0, _y0: 0, _ux: 0, _uy: 0, _len: 0, _lineDash: null, _dashOffset: 0, _dashIdx: 0, _dashSum: 0, setScale: function setScale(t, e) {
					this._ux = y(1 / s / t) || 0, this._uy = y(1 / s / e) || 0;
				}, getContext: function getContext() {
					return this._ctx;
				}, beginPath: function beginPath(t) {
					return this._ctx = t, t && t.beginPath(), t && (this.dpr = t.dpr), this._saveData && (this._len = 0), this._lineDash && (this._lineDash = null, this._dashOffset = 0), this;
				}, moveTo: function moveTo(t, e) {
					return this.addData(l.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this;
				}, lineTo: function lineTo(t, e) {
					var i = y(t - this._xi) > this._ux || y(e - this._yi) > this._uy || this._len < 5;return this.addData(l.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), i && (this._xi = t, this._yi = e), this;
				}, bezierCurveTo: function bezierCurveTo(t, e, i, n, a, o) {
					return this.addData(l.C, t, e, i, n, a, o), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, a, o) : this._ctx.bezierCurveTo(t, e, i, n, a, o)), this._xi = a, this._yi = o, this;
				}, quadraticCurveTo: function quadraticCurveTo(t, e, i, n) {
					return this.addData(l.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this;
				}, arc: function arc(t, e, i, n, a, o) {
					return this.addData(l.A, t, e, i, i, n, a - n, 0, o ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, a, o), this._xi = g(a) * i + t, this._yi = m(a) * i + t, this;
				}, arcTo: function arcTo(t, e, i, n, a) {
					return this._ctx && this._ctx.arcTo(t, e, i, n, a), this;
				}, rect: function rect(t, e, i, n) {
					return this._ctx && this._ctx.rect(t, e, i, n), this.addData(l.R, t, e, i, n), this;
				}, closePath: function closePath() {
					this.addData(l.Z);var t = this._ctx,
					    e = this._x0,
					    i = this._y0;return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this;
				}, fill: function fill(t) {
					t && t.fill(), this.toStatic();
				}, stroke: function stroke(t) {
					t && t.stroke(), this.toStatic();
				}, setLineDash: function setLineDash(t) {
					if (t instanceof Array) {
						this._lineDash = t, this._dashIdx = 0;for (var e = 0, i = 0; i < t.length; i++) {
							e += t[i];
						}this._dashSum = e;
					}return this;
				}, setLineDashOffset: function setLineDashOffset(t) {
					return this._dashOffset = t, this;
				}, len: function len() {
					return this._len;
				}, setData: function setData(t) {
					var e = t.length;this.data && this.data.length == e || !x || (this.data = new Float32Array(e));for (var i = 0; i < e; i++) {
						this.data[i] = t[i];
					}this._len = e;
				}, appendPath: function appendPath(t) {
					t instanceof Array || (t = [t]);for (var e = t.length, i = 0, n = this._len, a = 0; a < e; a++) {
						i += t[a].len();
					}x && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));for (var a = 0; a < e; a++) {
						for (var o = t[a].data, r = 0; r < o.length; r++) {
							this.data[n++] = o[r];
						}
					}this._len = n;
				}, addData: function addData(t) {
					if (this._saveData) {
						var e = this.data;this._len + arguments.length > e.length && (this._expandData(), e = this.data);for (var i = 0; i < arguments.length; i++) {
							e[this._len++] = arguments[i];
						}this._prevCmd = t;
					}
				}, _expandData: function _expandData() {
					if (!(this.data instanceof Array)) {
						for (var t = [], e = 0; e < this._len; e++) {
							t[e] = this.data[e];
						}this.data = t;
					}
				}, _needsDash: function _needsDash() {
					return this._lineDash;
				}, _dashedLineTo: function _dashedLineTo(t, e) {
					var i,
					    n,
					    a = this._dashSum,
					    o = this._dashOffset,
					    r = this._lineDash,
					    s = this._ctx,
					    l = this._xi,
					    u = this._yi,
					    c = t - l,
					    h = e - u,
					    d = v(c * c + h * h),
					    g = l,
					    m = u,
					    y = r.length;for (c /= d, h /= d, o < 0 && (o = a + o), o %= a, g -= o * c, m -= o * h; c > 0 && g <= t || c < 0 && g >= t || 0 == c && (h > 0 && m <= e || h < 0 && m >= e);) {
						n = this._dashIdx, i = r[n], g += c * i, m += h * i, this._dashIdx = (n + 1) % y, c > 0 && g < l || c < 0 && g > l || h > 0 && m < u || h < 0 && m > u || s[n % 2 ? "moveTo" : "lineTo"](c >= 0 ? f(g, t) : p(g, t), h >= 0 ? f(m, e) : p(m, e));
					}c = g - t, h = m - e, this._dashOffset = -v(c * c + h * h);
				}, _dashedBezierTo: function _dashedBezierTo(t, e, i, a, o, r) {
					var s,
					    l,
					    u,
					    c,
					    h,
					    d = this._dashSum,
					    f = this._dashOffset,
					    p = this._lineDash,
					    g = this._ctx,
					    m = this._xi,
					    y = this._yi,
					    x = n.cubicAt,
					    _ = 0,
					    b = this._dashIdx,
					    w = p.length,
					    S = 0;for (f < 0 && (f = d + f), f %= d, s = 0; s < 1; s += .1) {
						l = x(m, t, i, o, s + .1) - x(m, t, i, o, s), u = x(y, e, a, r, s + .1) - x(y, e, a, r, s), _ += v(l * l + u * u);
					}for (; b < w && (S += p[b], !(S > f)); b++) {}for (s = (S - f) / _; s <= 1;) {
						c = x(m, t, i, o, s), h = x(y, e, a, r, s), b % 2 ? g.moveTo(c, h) : g.lineTo(c, h), s += p[b] / _, b = (b + 1) % w;
					}b % 2 !== 0 && g.lineTo(o, r), l = o - c, u = r - h, this._dashOffset = -v(l * l + u * u);
				}, _dashedQuadraticTo: function _dashedQuadraticTo(t, e, i, n) {
					var a = i,
					    o = n;i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, a, o);
				}, toStatic: function toStatic() {
					var t = this.data;t instanceof Array && (t.length = this._len, x && (this.data = new Float32Array(t)));
				}, getBoundingRect: function getBoundingRect() {
					u[0] = u[1] = h[0] = h[1] = Number.MAX_VALUE, c[0] = c[1] = d[0] = d[1] = -Number.MAX_VALUE;for (var t = this.data, e = 0, i = 0, n = 0, s = 0, f = 0; f < t.length;) {
						var p = t[f++];switch (1 == f && (e = t[f], i = t[f + 1], n = e, s = i), p) {case l.M:
								n = t[f++], s = t[f++], e = n, i = s, h[0] = n, h[1] = s, d[0] = n, d[1] = s;break;case l.L:
								o.fromLine(e, i, t[f], t[f + 1], h, d), e = t[f++], i = t[f++];break;case l.C:
								o.fromCubic(e, i, t[f++], t[f++], t[f++], t[f++], t[f], t[f + 1], h, d), e = t[f++], i = t[f++];break;case l.Q:
								o.fromQuadratic(e, i, t[f++], t[f++], t[f], t[f + 1], h, d), e = t[f++], i = t[f++];break;case l.A:
								var v = t[f++],
								    y = t[f++],
								    x = t[f++],
								    _ = t[f++],
								    b = t[f++],
								    w = t[f++] + b,
								    S = (t[f++], 1 - t[f++]);1 == f && (n = g(b) * x + v, s = m(b) * _ + y), o.fromArc(v, y, x, _, b, w, S, h, d), e = g(w) * x + v, i = m(w) * _ + y;break;case l.R:
								n = e = t[f++], s = i = t[f++];var M = t[f++],
								    I = t[f++];o.fromLine(n, s, n + M, s + I, h, d);break;case l.Z:
								e = n, i = s;}a.min(u, u, h), a.max(c, c, d);
					}return 0 === f && (u[0] = u[1] = c[0] = c[1] = 0), new r(u[0], u[1], c[0] - u[0], c[1] - u[1]);
				}, rebuildPath: function rebuildPath(t) {
					for (var e, i, n, a, o, r, s = this.data, u = this._ux, c = this._uy, h = this._len, d = 0; d < h;) {
						var f = s[d++];switch (1 == d && (n = s[d], a = s[d + 1], e = n, i = a), f) {case l.M:
								e = n = s[d++], i = a = s[d++], t.moveTo(n, a);break;case l.L:
								o = s[d++], r = s[d++], (y(o - n) > u || y(r - a) > c || d === h - 1) && (t.lineTo(o, r), n = o, a = r);break;case l.C:
								t.bezierCurveTo(s[d++], s[d++], s[d++], s[d++], s[d++], s[d++]), n = s[d - 2], a = s[d - 1];break;case l.Q:
								t.quadraticCurveTo(s[d++], s[d++], s[d++], s[d++]), n = s[d - 2], a = s[d - 1];break;case l.A:
								var p = s[d++],
								    v = s[d++],
								    x = s[d++],
								    _ = s[d++],
								    b = s[d++],
								    w = s[d++],
								    S = s[d++],
								    M = s[d++],
								    I = x > _ ? x : _,
								    T = x > _ ? 1 : x / _,
								    A = x > _ ? _ / x : 1,
								    C = Math.abs(x - _) > .001,
								    L = b + w;C ? (t.translate(p, v), t.rotate(S), t.scale(T, A), t.arc(0, 0, I, b, L, 1 - M), t.scale(1 / T, 1 / A), t.rotate(-S), t.translate(-p, -v)) : t.arc(p, v, I, b, L, 1 - M), 1 == d && (e = g(b) * x + p, i = m(b) * _ + v), n = g(L) * x + p, a = m(L) * _ + v;break;case l.R:
								e = n = s[d], i = a = s[d + 1], t.rect(s[d++], s[d++], s[d++], s[d++]);break;case l.Z:
								t.closePath(), n = e, a = i;}
					}
				} }, _.CMD = l, t.exports = _;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				for (var e = 0; e < t.length && null == t[e];) {
					e++;
				}return t[e];
			}function a(t) {
				var e = n(t);return null != e && !h.isArray(p(e));
			}function o(t, e, i) {
				t = t || [];var n = e.get("coordinateSystem"),
				    o = m[n],
				    r = f.get(n),
				    s = { encodeDef: e.get("encode"), dimsDef: e.get("dimensions") },
				    v = o && o(t, e, i, s),
				    y = v && v.dimensions;y || (y = r && (r.getDimensionsInfo ? r.getDimensionsInfo() : r.dimensions.slice()) || ["x", "y"], y = c(y, t, s));var x = v ? v.categoryIndex : -1,
				    _ = new u(y, e),
				    b = l(v, t),
				    w = {},
				    S = x >= 0 && a(t) ? function (t, e, i, n) {
					return d.isDataItemOption(t) && (_.hasItemOption = !0), n === x ? i : g(p(t), y[n]);
				} : function (t, e, i, n) {
					var a = p(t),
					    o = g(a && a[n], y[n]);d.isDataItemOption(t) && (_.hasItemOption = !0);var r = v && v.categoryAxesModels;return r && r[e] && "string" == typeof o && (w[e] = w[e] || r[e].getCategories(), o = h.indexOf(w[e], o), o < 0 && !isNaN(o) && (o = +o)), o;
				};return _.hasItemOption = !1, _.initData(t, b, S), _;
			}function r(t) {
				return "category" !== t && "time" !== t;
			}function s(t) {
				return "category" === t ? "ordinal" : "time" === t ? "time" : "float";
			}function l(t, e) {
				var i,
				    n = [],
				    a = t && t.dimensions[t.categoryIndex];if (a && (i = t.categoryAxesModels[a.name]), i) {
					var o = i.getCategories();if (o) {
						var r = e.length;if (h.isArray(e[0]) && e[0].length > 1) {
							n = [];for (var s = 0; s < r; s++) {
								n[s] = o[e[s][t.categoryIndex || 0]];
							}
						} else n = o.slice(0);
					}
				}return n;
			}var u = i(14),
			    c = i(25),
			    h = i(1),
			    d = i(5),
			    f = i(26),
			    p = d.getDataItemValue,
			    g = d.converDataValue,
			    m = { cartesian2d: function cartesian2d(t, e, i, n) {
					var a = h.map(["xAxis", "yAxis"], function (t) {
						return i.queryComponents({ mainType: t, index: e.get(t + "Index"), id: e.get(t + "Id") })[0];
					}),
					    o = a[0],
					    l = a[1],
					    u = o.get("type"),
					    d = l.get("type"),
					    f = [{ name: "x", type: s(u), stackable: r(u) }, { name: "y", type: s(d), stackable: r(d) }],
					    p = "category" === u,
					    g = "category" === d;f = c(f, t, n);var m = {};return p && (m.x = o), g && (m.y = l), { dimensions: f, categoryIndex: p ? 0 : g ? 1 : -1, categoryAxesModels: m };
				}, singleAxis: function singleAxis(t, e, i, n) {
					var a = i.queryComponents({ mainType: "singleAxis", index: e.get("singleAxisIndex"), id: e.get("singleAxisId") })[0],
					    o = a.get("type"),
					    l = "category" === o,
					    u = [{ name: "single", type: s(o), stackable: r(o) }];u = c(u, t, n);var h = {};return l && (h.single = a), { dimensions: u, categoryIndex: l ? 0 : -1, categoryAxesModels: h };
				}, polar: function polar(t, e, i, n) {
					var a = i.queryComponents({ mainType: "polar", index: e.get("polarIndex"), id: e.get("polarId") })[0],
					    o = a.findAxisModel("angleAxis"),
					    l = a.findAxisModel("radiusAxis"),
					    u = l.get("type"),
					    h = o.get("type"),
					    d = [{ name: "radius", type: s(u), stackable: r(u) }, { name: "angle", type: s(h), stackable: r(h) }],
					    f = "category" === h,
					    p = "category" === u;d = c(d, t, n);var g = {};return p && (g.radius = l), f && (g.angle = o), { dimensions: d, categoryIndex: f ? 1 : p ? 0 : -1, categoryAxesModels: g };
				}, geo: function geo(t, e, i, n) {
					return { dimensions: c([{ name: "lng" }, { name: "lat" }], t, n) };
				} };t.exports = o;
		}, function (t, e) {
			"use strict";
			var i = {};t.exports = { register: function register(t, e) {
					i[t] = e;
				}, get: function get(t) {
					return i[t];
				} };
		}, function (t, e, i) {
			function n() {
				this.group = new r(), this.uid = s.getUID("viewChart");
			}function a(t, e) {
				if (t && (t.trigger(e), "group" === t.type)) for (var i = 0; i < t.childCount(); i++) {
					a(t.childAt(i), e);
				}
			}function o(t, e, i) {
				var n = u.queryDataIndex(t, e);null != n ? c.each(u.normalizeToArray(n), function (e) {
					a(t.getItemGraphicEl(e), i);
				}) : t.eachItemGraphicEl(function (t) {
					a(t, i);
				});
			}var r = i(36),
			    s = i(49),
			    l = i(15),
			    u = i(5),
			    c = i(1);n.prototype = { type: "chart", init: function init(t, e) {}, render: function render(t, e, i, n) {}, highlight: function highlight(t, e, i, n) {
					o(t.getData(), n, "emphasis");
				}, downplay: function downplay(t, e, i, n) {
					o(t.getData(), n, "normal");
				}, remove: function remove(t, e) {
					this.group.removeAll();
				}, dispose: function dispose() {} };var h = n.prototype;h.updateView = h.updateLayout = h.updateVisual = function (t, e, i, n) {
				this.render(t, e, i, n);
			}, l.enableClassExtend(n, ["dispose"]), l.enableClassManagement(n, { registerWhenExtend: !0 }), t.exports = n;
		}, function (t, e, i) {
			var n = i(1);t.exports = function (t) {
				for (var e = 0; e < t.length; e++) {
					t[e][1] || (t[e][1] = t[e][0]);
				}return function (e, i) {
					for (var a = {}, o = 0; o < t.length; o++) {
						var r = t[o][1];if (!(e && n.indexOf(e, r) >= 0 || i && n.indexOf(i, r) < 0)) {
							var s = this.getShallow(r);null != s && (a[t[o][0]] = s);
						}
					}return a;
				};
			};
		}, function (t, e, i) {
			"use strict";
			var n = i(3),
			    a = i(1),
			    o = i(2);i(57), i(117), o.extendComponentView({ type: "grid", render: function render(t, e) {
					this.group.removeAll(), t.get("show") && this.group.add(new n.Rect({ shape: t.coordinateSystem.getRect(), style: a.defaults({ fill: t.get("backgroundColor") }, t.getItemStyle()), silent: !0, z2: -1 }));
				} }), o.registerPreprocessor(function (t) {
				t.xAxis && t.yAxis && !t.grid && (t.grid = {});
			});
		}, function (t, e, i) {
			function n(t, e) {
				var i = t[1] - t[0],
				    n = e,
				    a = i / n / 2;t[0] += a, t[1] -= a;
			}var a = i(4),
			    o = a.linearMap,
			    r = i(1),
			    s = i(18),
			    l = [0, 1],
			    u = function u(t, e, i) {
				this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1, this._labelInterval;
			};u.prototype = { constructor: u, contain: function contain(t) {
					var e = this._extent,
					    i = Math.min(e[0], e[1]),
					    n = Math.max(e[0], e[1]);return t >= i && t <= n;
				}, containData: function containData(t) {
					return this.contain(this.dataToCoord(t));
				}, getExtent: function getExtent() {
					return this._extent.slice();
				}, getPixelPrecision: function getPixelPrecision(t) {
					return a.getPixelPrecision(t || this.scale.getExtent(), this._extent);
				}, setExtent: function setExtent(t, e) {
					var i = this._extent;i[0] = t, i[1] = e;
				}, dataToCoord: function dataToCoord(t, e) {
					var i = this._extent,
					    a = this.scale;return t = a.normalize(t), this.onBand && "ordinal" === a.type && (i = i.slice(), n(i, a.count())), o(t, l, i, e);
				}, coordToData: function coordToData(t, e) {
					var i = this._extent,
					    a = this.scale;this.onBand && "ordinal" === a.type && (i = i.slice(), n(i, a.count()));var r = o(t, i, l, e);return this.scale.scale(r);
				}, pointToData: function pointToData(t, e) {}, getTicksCoords: function getTicksCoords(t) {
					if (this.onBand && !t) {
						for (var e = this.getBands(), i = [], n = 0; n < e.length; n++) {
							i.push(e[n][0]);
						}return e[n - 1] && i.push(e[n - 1][1]), i;
					}return r.map(this.scale.getTicks(), this.dataToCoord, this);
				}, getLabelsCoords: function getLabelsCoords() {
					return r.map(this.scale.getTicks(), this.dataToCoord, this);
				}, getBands: function getBands() {
					for (var t = this.getExtent(), e = [], i = this.scale.count(), n = t[0], a = t[1], o = a - n, r = 0; r < i; r++) {
						e.push([o * r / i + n, o * (r + 1) / i + n]);
					}return e;
				}, getBandWidth: function getBandWidth() {
					var t = this._extent,
					    e = this.scale.getExtent(),
					    i = e[1] - e[0] + (this.onBand ? 1 : 0);0 === i && (i = 1);var n = Math.abs(t[1] - t[0]);return Math.abs(n) / i;
				}, getLabelInterval: function getLabelInterval() {
					var t = this._labelInterval;if (!t) {
						var e = this.model,
						    i = e.getModel("axisLabel"),
						    n = i.get("interval");"category" !== this.type || "auto" !== n ? t = "auto" === n ? 0 : n : this.isHorizontal && (t = s.getAxisLabelInterval(r.map(this.scale.getTicks(), this.dataToCoord, this), e.getFormattedLabels(), i.getModel("textStyle").getFont(), this.isHorizontal())), this._labelInterval = t;
					}return t;
				} }, t.exports = u;
		}, function (t, e, i) {
			function n(t) {
				this._setting = t || {}, this._extent = [1 / 0, -(1 / 0)], this._interval = 0, this.init && this.init.apply(this, arguments);
			}var a = i(15),
			    o = n.prototype;o.parse = function (t) {
				return t;
			}, o.getSetting = function (t) {
				return this._setting[t];
			}, o.contain = function (t) {
				var e = this._extent;return t >= e[0] && t <= e[1];
			}, o.normalize = function (t) {
				var e = this._extent;return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0]);
			}, o.scale = function (t) {
				var e = this._extent;return t * (e[1] - e[0]) + e[0];
			}, o.unionExtent = function (t) {
				var e = this._extent;t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]);
			}, o.unionExtentFromData = function (t, e) {
				this.unionExtent(t.getDataExtent(e, !0));
			}, o.getExtent = function () {
				return this._extent.slice();
			}, o.setExtent = function (t, e) {
				var i = this._extent;isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e);
			}, o.getTicksLabels = function () {
				for (var t = [], e = this.getTicks(), i = 0; i < e.length; i++) {
					t.push(this.getLabel(e[i]));
				}return t;
			}, o.isBlank = function () {
				return this._isBlank;
			}, o.setBlank = function (t) {
				this._isBlank = t;
			}, a.enableClassExtend(n), a.enableClassManagement(n, { registerWhenExtend: !0 }), t.exports = n;
		}, function (t, e) {
			var i = 1;"undefined" != typeof window && (i = Math.max(window.devicePixelRatio || 1, 1));var n = { debugMode: 0, devicePixelRatio: i };t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(66),
			    o = i(11),
			    r = function r(t) {
				t = t || {}, a.call(this, t);for (var e in t) {
					t.hasOwnProperty(e) && (this[e] = t[e]);
				}this._children = [], this.__storage = null, this.__dirty = !0;
			};r.prototype = { constructor: r, isGroup: !0, type: "group", silent: !1, children: function children() {
					return this._children.slice();
				}, childAt: function childAt(t) {
					return this._children[t];
				}, childOfName: function childOfName(t) {
					for (var e = this._children, i = 0; i < e.length; i++) {
						if (e[i].name === t) return e[i];
					}
				}, childCount: function childCount() {
					return this._children.length;
				}, add: function add(t) {
					return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this;
				}, addBefore: function addBefore(t, e) {
					if (t && t !== this && t.parent !== this && e && e.parent === this) {
						var i = this._children,
						    n = i.indexOf(e);n >= 0 && (i.splice(n, 0, t), this._doAdd(t));
					}return this;
				}, _doAdd: function _doAdd(t) {
					t.parent && t.parent.remove(t), t.parent = this;var e = this.__storage,
					    i = this.__zr;e && e !== t.__storage && (e.addToStorage(t), t instanceof r && t.addChildrenToStorage(e)), i && i.refresh();
				}, remove: function remove(t) {
					var e = this.__zr,
					    i = this.__storage,
					    a = this._children,
					    o = n.indexOf(a, t);return o < 0 ? this : (a.splice(o, 1), t.parent = null, i && (i.delFromStorage(t), t instanceof r && t.delChildrenFromStorage(i)), e && e.refresh(), this);
				}, removeAll: function removeAll() {
					var t,
					    e,
					    i = this._children,
					    n = this.__storage;for (e = 0; e < i.length; e++) {
						t = i[e], n && (n.delFromStorage(t), t instanceof r && t.delChildrenFromStorage(n)), t.parent = null;
					}return i.length = 0, this;
				}, eachChild: function eachChild(t, e) {
					for (var i = this._children, n = 0; n < i.length; n++) {
						var a = i[n];t.call(e, a, n);
					}return this;
				}, traverse: function traverse(t, e) {
					for (var i = 0; i < this._children.length; i++) {
						var n = this._children[i];t.call(e, n), "group" === n.type && n.traverse(t, e);
					}return this;
				}, addChildrenToStorage: function addChildrenToStorage(t) {
					for (var e = 0; e < this._children.length; e++) {
						var i = this._children[e];t.addToStorage(i), i instanceof r && i.addChildrenToStorage(t);
					}
				}, delChildrenFromStorage: function delChildrenFromStorage(t) {
					for (var e = 0; e < this._children.length; e++) {
						var i = this._children[e];t.delFromStorage(i), i instanceof r && i.delChildrenFromStorage(t);
					}
				}, dirty: function dirty() {
					return this.__dirty = !0, this.__zr && this.__zr.refresh(), this;
				}, getBoundingRect: function getBoundingRect(t) {
					for (var e = null, i = new o(0, 0, 0, 0), n = t || this._children, a = [], r = 0; r < n.length; r++) {
						var s = n[r];if (!s.ignore && !s.invisible) {
							var l = s.getBoundingRect(),
							    u = s.getLocalTransform(a);u ? (i.copy(l), i.applyTransform(u), e = e || i.clone(), e.union(i)) : (e = e || l.clone(), e.union(l));
						}
					}return e || i;
				} }, n.inherits(r, a), t.exports = r;
		}, function (t, e) {
			var i = {},
			    n = "\0__throttleOriginMethod",
			    a = "\0__throttleRate",
			    o = "\0__throttleType";i.throttle = function (t, e, i) {
				function n() {
					c = new Date().getTime(), h = null, t.apply(r, s || []);
				}var a,
				    o,
				    r,
				    s,
				    l,
				    u = 0,
				    c = 0,
				    h = null;e = e || 0;var d = function d() {
					a = new Date().getTime(), r = this, s = arguments;var t = l || e,
					    d = l || i;l = null, o = a - (d ? u : c) - t, clearTimeout(h), d ? h = setTimeout(n, t) : o >= 0 ? n() : h = setTimeout(n, -o), u = a;
				};return d.clear = function () {
					h && (clearTimeout(h), h = null);
				}, d.debounceNextCall = function (t) {
					l = t;
				}, d;
			}, i.createOrUpdate = function (t, e, r, s) {
				var l = t[e];if (l) {
					var u = l[n] || l,
					    c = l[o],
					    h = l[a];if (h !== r || c !== s) {
						if (null == r || !s) return t[e] = u;l = t[e] = i.throttle(u, r, "debounce" === s), l[n] = u, l[o] = s, l[a] = r;
					}return l;
				}
			}, i.clear = function (t, e) {
				var i = t[e];i && i[n] && (t[e] = i[n]);
			}, t.exports = i;
		}, function (t, e, i) {
			function n(t) {
				t = t || {}, r.call(this, t);for (var e in t) {
					t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
				}this.style = new o(t.style), this._rect = null, this.__clipPaths = [];
			}var a = i(1),
			    o = i(73),
			    r = i(66),
			    s = i(87);n.prototype = { constructor: n, type: "displayable", __dirty: !0, invisible: !1, z: 0, z2: 0, zlevel: 0, draggable: !1, dragging: !1, silent: !1, culling: !1, cursor: "pointer", rectHover: !1, progressive: -1, beforeBrush: function beforeBrush(t) {}, afterBrush: function afterBrush(t) {}, brush: function brush(t, e) {}, getBoundingRect: function getBoundingRect() {}, contain: function contain(t, e) {
					return this.rectContain(t, e);
				}, traverse: function traverse(t, e) {
					t.call(e, this);
				}, rectContain: function rectContain(t, e) {
					var i = this.transformCoordToLocal(t, e),
					    n = this.getBoundingRect();return n.contain(i[0], i[1]);
				}, dirty: function dirty() {
					this.__dirty = !0, this._rect = null, this.__zr && this.__zr.refresh();
				}, animateStyle: function animateStyle(t) {
					return this.animate("style", t);
				}, attrKV: function attrKV(t, e) {
					"style" !== t ? r.prototype.attrKV.call(this, t, e) : this.style.set(e);
				}, setStyle: function setStyle(t, e) {
					return this.style.set(t, e), this.dirty(!1), this;
				}, useStyle: function useStyle(t) {
					return this.style = new o(t), this.dirty(!1), this;
				} }, a.inherits(n, r), a.mixin(n, s), t.exports = n;
		}, function (t, e) {
			var i = function i(t) {
				this.colorStops = t || [];
			};i.prototype = { constructor: i, addColorStop: function addColorStop(t, e) {
					this.colorStops.push({ offset: t, color: e });
				} }, t.exports = i;
		}, function (t, e, i) {
			function n(t) {
				var e = { componentType: t.mainType };return e[t.mainType + "Index"] = t.componentIndex, e;
			}function a(t, e, i, n) {
				var a,
				    o,
				    r = f(i - t.rotation),
				    s = n[0] > n[1],
				    l = "start" === e && !s || "start" !== e && s;return p(r - x / 2) ? (o = l ? "bottom" : "top", a = "center") : p(r - 1.5 * x) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", a = r < 1.5 * x && r > x / 2 ? l ? "left" : "right" : l ? "right" : "left"), { rotation: r, textAlign: a, textVerticalAlign: o };
			}function o(t) {
				var e = t.get("tooltip");return t.get("silent") || !(t.get("triggerEvent") || e && e.show);
			}function r(t, e) {
				var i = t.get("axisLabel.showMinLabel"),
				    n = t.get("axisLabel.showMaxLabel"),
				    a = e[0],
				    o = e[1],
				    r = e[e.length - 1],
				    l = e[e.length - 2];i === !1 ? a.ignore = !0 : null != t.getMin() && s(a, o) && (i ? o.ignore = !0 : a.ignore = !0), n === !1 ? r.ignore = !0 : null != t.getMax() && s(l, r) && (n ? l.ignore = !0 : r.ignore = !0);
			}function s(t, e, i) {
				var n = t && t.getBoundingRect().clone(),
				    a = e && e.getBoundingRect().clone();if (n && a) {
					var o = m.identity([]);return m.rotate(o, o, -t.rotation), n.applyTransform(m.mul([], o, t.getLocalTransform())), a.applyTransform(m.mul([], o, e.getLocalTransform())), n.intersect(a);
				}
			}var l = i(1),
			    u = i(7),
			    c = i(3),
			    h = i(10),
			    d = i(4),
			    f = d.remRadian,
			    p = d.isRadianAroundZero,
			    g = i(6),
			    m = i(19),
			    v = g.applyTransform,
			    y = l.retrieve,
			    x = Math.PI,
			    _ = function _(t, e) {
				this.opt = e, this.axisModel = t, l.defaults(e, { labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: !0 }), this.group = new c.Group();var i = new c.Group({ position: e.position.slice(), rotation: e.rotation });i.updateTransform(), this._transform = i.transform, this._dumbGroup = i;
			};_.prototype = { constructor: _, hasBuilder: function hasBuilder(t) {
					return !!b[t];
				}, add: function add(t) {
					b[t].call(this);
				}, getGroup: function getGroup() {
					return this.group;
				} };var b = { axisLine: function axisLine() {
					var t = this.opt,
					    e = this.axisModel;if (e.get("axisLine.show")) {
						var i = this.axisModel.axis.getExtent(),
						    n = this._transform,
						    a = [i[0], 0],
						    o = [i[1], 0];n && (v(a, a, n), v(o, o, n)), this.group.add(new c.Line(c.subPixelOptimizeLine({ anid: "line", shape: { x1: a[0], y1: a[1], x2: o[0], y2: o[1] }, style: l.extend({ lineCap: "round" }, e.getModel("axisLine.lineStyle").getLineStyle()), strokeContainThreshold: t.strokeContainThreshold || 5, silent: !0, z2: 1 })));
					}
				}, axisTick: function axisTick() {
					var t = this.axisModel,
					    e = t.axis;if (t.get("axisTick.show") && !e.scale.isBlank()) for (var i = t.getModel("axisTick"), n = this.opt, a = i.getModel("lineStyle"), o = i.get("length"), r = M(i, n.labelInterval), s = e.getTicksCoords(i.get("alignWithLabel")), u = e.scale.getTicks(), h = [], d = [], f = this._transform, p = 0; p < s.length; p++) {
						if (!S(e, p, r)) {
							var g = s[p];h[0] = g, h[1] = 0, d[0] = g, d[1] = n.tickDirection * o, f && (v(h, h, f), v(d, d, f)), this.group.add(new c.Line(c.subPixelOptimizeLine({ anid: "tick_" + u[p], shape: { x1: h[0], y1: h[1], x2: d[0], y2: d[1] }, style: l.defaults(a.getLineStyle(), { stroke: t.get("axisLine.lineStyle.color") }), z2: 2, silent: !0 })));
						}
					}
				}, axisLabel: function axisLabel() {
					var t = this.opt,
					    e = this.axisModel,
					    i = e.axis,
					    a = y(t.axisLabelShow, e.get("axisLabel.show"));if (a && !i.scale.isBlank()) {
						var s = e.getModel("axisLabel"),
						    u = s.getModel("textStyle"),
						    d = s.get("margin"),
						    f = i.scale.getTicks(),
						    p = e.getFormattedLabels(),
						    g = (y(t.labelRotate, s.get("rotate")) || 0) * x / 180,
						    m = w(t.rotation, g, t.labelDirection),
						    v = e.get("data"),
						    _ = [],
						    b = o(e),
						    M = e.get("triggerEvent");l.each(f, function (a, o) {
							if (!S(i, o, t.labelInterval)) {
								var r = u;v && v[a] && v[a].textStyle && (r = new h(v[a].textStyle, u, e.ecModel));var s = r.getTextColor() || e.get("axisLine.lineStyle.color"),
								    l = i.dataToCoord(a),
								    f = [l, t.labelOffset + t.labelDirection * d],
								    g = i.scale.getLabel(a),
								    y = new c.Text({ anid: "label_" + a, style: { text: p[o], textAlign: r.get("align", !0) || m.textAlign, textVerticalAlign: r.get("baseline", !0) || m.textVerticalAlign, textFont: r.getFont(), fill: "function" == typeof s ? s("category" === i.type ? g : "value" === i.type ? a + "" : a, o) : s }, position: f, rotation: m.rotation, silent: b, z2: 10 });M && (y.eventData = n(e), y.eventData.targetType = "axisLabel", y.eventData.value = g), this._dumbGroup.add(y), y.updateTransform(), _.push(y), this.group.add(y), y.decomposeTransform();
							}
						}, this), r(e, _);
					}
				}, axisName: function axisName() {
					var t = this.opt,
					    e = this.axisModel,
					    i = y(t.axisName, e.get("name"));if (i) {
						var r,
						    s = e.get("nameLocation"),
						    h = t.nameDirection,
						    d = e.getModel("nameTextStyle"),
						    f = e.get("nameGap") || 0,
						    p = this.axisModel.axis.getExtent(),
						    g = p[0] > p[1] ? -1 : 1,
						    m = ["start" === s ? p[0] - g * f : "end" === s ? p[1] + g * f : (p[0] + p[1]) / 2, "middle" === s ? t.labelOffset + h * f : 0],
						    v = e.get("nameRotate");
						null != v && (v = v * x / 180);var _;"middle" === s ? r = w(t.rotation, null != v ? v : t.rotation, h) : (r = a(t, s, v || 0, p), _ = t.axisNameAvailableWidth, null != _ && (_ = Math.abs(_ / Math.sin(r.rotation)), !isFinite(_) && (_ = null)));var b = d.getFont(),
						    S = e.get("nameTruncate", !0) || {},
						    M = S.ellipsis,
						    I = y(t.nameTruncateMaxWidth, S.maxWidth, _),
						    T = null != M && null != I ? u.truncateText(i, I, b, M, { minChar: 2, placeholder: S.placeholder }) : i,
						    A = e.get("tooltip", !0),
						    C = e.mainType,
						    L = { componentType: C, name: i, $vars: ["name"] };L[C + "Index"] = e.componentIndex;var D = new c.Text({ anid: "name", __fullText: i, __truncatedText: T, style: { text: T, textFont: b, fill: d.getTextColor() || e.get("axisLine.lineStyle.color"), textAlign: r.textAlign, textVerticalAlign: r.textVerticalAlign }, position: m, rotation: r.rotation, silent: o(e), z2: 1, tooltip: A && A.show ? l.extend({ content: i, formatter: function formatter() {
									return i;
								}, formatterParams: L }, A) : null });e.get("triggerEvent") && (D.eventData = n(e), D.eventData.targetType = "axisName", D.eventData.name = i), this._dumbGroup.add(D), D.updateTransform(), this.group.add(D), D.decomposeTransform();
					}
				} },
			    w = _.innerTextLayout = function (t, e, i) {
				var n,
				    a,
				    o = f(e - t);return p(o) ? (a = i > 0 ? "top" : "bottom", n = "center") : p(o - x) ? (a = i > 0 ? "bottom" : "top", n = "center") : (a = "middle", n = o > 0 && o < x ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), { rotation: o, textAlign: n, textVerticalAlign: a };
			},
			    S = _.ifIgnoreOnTick = function (t, e, i) {
				var n,
				    a = t.scale;return "ordinal" === a.type && ("function" == typeof i ? (n = a.getTicks()[e], !i(n, a.getLabel(n))) : e % (i + 1));
			},
			    M = _.getInterval = function (t, e) {
				var i = t.get("interval");return null != i && "auto" != i || (i = e), i;
			};t.exports = _;
		}, function (t, e, i) {
			function n(t, e, i, n, s, l) {
				var u = r.getAxisPointerClass(t.axisPointerClass);if (u) {
					var c = o.getAxisPointerModel(e);c ? (t._axisPointer || (t._axisPointer = new u())).render(e, c, n, l) : a(t, n);
				}
			}function a(t, e, i) {
				var n = t._axisPointer;n && n.dispose(e, i), t._axisPointer = null;
			}var o = i(45),
			    r = i(2).extendComponentView({ type: "axis", _axisPointer: null, axisPointerClass: null, render: function render(t, e, i, a) {
					this.axisPointerClass && o.fixValue(t), r.superApply(this, "render", arguments), n(this, t, e, i, a, !0);
				}, updateAxisPointer: function updateAxisPointer(t, e, i, a, o) {
					n(this, t, e, i, a, !1);
				}, remove: function remove(t, e) {
					var i = this._axisPointer;i && i.remove(e), r.superApply(this, "remove", arguments);
				}, dispose: function dispose(t, e) {
					a(this, e), r.superApply(this, "dispose", arguments);
				} }),
			    s = [];r.registerAxisPointerClass = function (t, e) {
				s[t] = e;
			}, r.getAxisPointerClass = function (t) {
				return t && s[t];
			}, t.exports = r;
		}, function (t, e, i) {
			function n(t) {
				return a.isObject(t) && null != t.value ? t.value : t + "";
			}var a = i(1),
			    o = i(18);t.exports = { getFormattedLabels: function getFormattedLabels() {
					return o.getFormattedLabels(this.axis, this.get("axisLabel.formatter"));
				}, getCategories: function getCategories() {
					return "category" === this.get("type") && a.map(this.get("data"), n);
				}, getMin: function getMin(t) {
					var e = this.option,
					    i = t || null == e.rangeStart ? e.min : e.rangeStart;return this.axis && null != i && "dataMin" !== i && !a.eqNaN(i) && (i = this.axis.scale.parse(i)), i;
				}, getMax: function getMax(t) {
					var e = this.option,
					    i = t || null == e.rangeEnd ? e.max : e.rangeEnd;return this.axis && null != i && "dataMax" !== i && !a.eqNaN(i) && (i = this.axis.scale.parse(i)), i;
				}, getNeedCrossZero: function getNeedCrossZero() {
					var t = this.option;return null == t.rangeStart && null == t.rangeEnd && !t.scale;
				}, getCoordSysModel: a.noop, setRange: function setRange(t, e) {
					this.option.rangeStart = t, this.option.rangeEnd = e;
				}, resetRange: function resetRange() {
					this.option.rangeStart = this.option.rangeEnd = null;
				} };
		}, function (t, e, i) {
			var n = i(4),
			    a = i(7),
			    o = i(34),
			    r = i(64),
			    s = n.round,
			    l = o.extend({ type: "interval", _interval: 0, _intervalPrecision: 2, setExtent: function setExtent(t, e) {
					var i = this._extent;isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e));
				}, unionExtent: function unionExtent(t) {
					var e = this._extent;t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), l.prototype.setExtent.call(this, e[0], e[1]);
				}, getInterval: function getInterval() {
					return this._interval;
				}, setInterval: function setInterval(t) {
					this._interval = t, this._niceExtent = this._extent.slice();
				}, getTicks: function getTicks() {
					return r.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision);
				}, getTicksLabels: function getTicksLabels() {
					for (var t = [], e = this.getTicks(), i = 0; i < e.length; i++) {
						t.push(this.getLabel(e[i]));
					}return t;
				}, getLabel: function getLabel(t, e) {
					if (null == t) return "";var i = e && e.precision;return null == i ? i = n.getPrecisionSafe(t) || 0 : "auto" === i && (i = this._intervalPrecision), t = s(t, i, !0), a.addCommas(t);
				}, niceTicks: function niceTicks(t, e) {
					t = t || 5;var i = this._extent,
					    n = i[1] - i[0];if (isFinite(n)) {
						n < 0 && (n = -n, i.reverse());var a = r.intervalScaleNiceTicks(i, t, e);this._intervalPrecision = a.intervalPrecision, this._interval = a.interval, this._niceExtent = a.niceTickExtent;
					}
				}, niceExtent: function niceExtent(t) {
					var e = this._extent;if (e[0] === e[1]) if (0 !== e[0]) {
						var i = e[0];t.fixMax ? e[0] -= i / 2 : (e[1] += i / 2, e[0] -= i / 2);
					} else e[1] = 1;var n = e[1] - e[0];isFinite(n) || (e[0] = 0, e[1] = 1), this.niceTicks(t.splitNumber, t.minInterval);var a = this._interval;t.fixMin || (e[0] = s(Math.floor(e[0] / a) * a)), t.fixMax || (e[1] = s(Math.ceil(e[1] / a) * a));
				} });l.create = function () {
				return new l();
			}, t.exports = l;
		}, function (t, e, i) {
			function n(t) {
				this.group = new o.Group(), this._symbolCtor = t || r;
			}function a(t, e, i) {
				var n = t.getItemLayout(e);return n && !isNaN(n[0]) && !isNaN(n[1]) && !(i && i(e)) && "none" !== t.getItemVisual(e, "symbol");
			}var o = i(3),
			    r = i(54),
			    s = n.prototype;s.updateData = function (t, e) {
				var i = this.group,
				    n = t.hostModel,
				    r = this._data,
				    s = this._symbolCtor,
				    l = { itemStyle: n.getModel("itemStyle.normal").getItemStyle(["color"]), hoverItemStyle: n.getModel("itemStyle.emphasis").getItemStyle(), symbolRotate: n.get("symbolRotate"), symbolOffset: n.get("symbolOffset"), hoverAnimation: n.get("hoverAnimation"), labelModel: n.getModel("label.normal"), hoverLabelModel: n.getModel("label.emphasis") };t.diff(r).add(function (n) {
					var o = t.getItemLayout(n);if (a(t, n, e)) {
						var r = new s(t, n, l);r.attr("position", o), t.setItemGraphicEl(n, r), i.add(r);
					}
				}).update(function (u, c) {
					var h = r.getItemGraphicEl(c),
					    d = t.getItemLayout(u);return a(t, u, e) ? (h ? (h.updateData(t, u, l), o.updateProps(h, { position: d }, n)) : (h = new s(t, u), h.attr("position", d)), i.add(h), void t.setItemGraphicEl(u, h)) : void i.remove(h);
				}).remove(function (t) {
					var e = r.getItemGraphicEl(t);e && e.fadeOut(function () {
						i.remove(e);
					});
				}).execute(), this._data = t;
			}, s.updateLayout = function () {
				var t = this._data;t && t.eachItemGraphicEl(function (e, i) {
					var n = t.getItemLayout(i);e.attr("position", n);
				});
			}, s.remove = function (t) {
				var e = this.group,
				    i = this._data;i && (t ? i.eachItemGraphicEl(function (t) {
					t.fadeOut(function () {
						e.remove(t);
					});
				}) : e.removeAll());
			}, t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = e.getComponent("tooltip"),
				    o = e.getComponent("axisPointer"),
				    s = o.get("link", !0) || [],
				    u = [];h(i.getCoordinateSystems(), function (i) {
					function c(n, c, h) {
						var d = h.model.getModel("axisPointer", o),
						    f = d.get("show");if (f && ("auto" !== f || n || l(d))) {
							null == c && (c = d.get("triggerTooltip")), d = n ? a(h, v, o, e, n, c) : d;var m = d.get("snap"),
							    y = p(h.model),
							    x = c || m || "category" === h.type,
							    _ = t.axesInfo[y] = { key: y, axis: h, coordSys: i, axisPointerModel: d, triggerTooltip: c, involveSeries: x, snap: m, useHandle: l(d), seriesModels: [] };g[y] = _, t.seriesInvolved |= x;var b = r(s, h);if (null != b) {
								var w = u[b] || (u[b] = { axesInfo: {} });w.axesInfo[y] = _, w.mapper = s[b].mapper, _.linkGroup = w;
							}
						}
					}if (i.axisPointerEnabled) {
						var f = p(i.model),
						    g = t.coordSysAxesInfo[f] = {};t.coordSysMap[f] = i;var m = i.model,
						    v = m.getModel("tooltip", n);if (h(i.getAxes(), d(c, !1, null)), i.getTooltipAxes && n && v.get("show")) {
							var y = "axis" === v.get("trigger"),
							    x = "cross" === v.get("axisPointer.type"),
							    _ = i.getTooltipAxes(v.get("axisPointer.axis"));(y || x) && h(_.baseAxes, d(c, !x || "cross", y)), x && h(_.otherAxes, d(c, "cross", !1));
						}
					}
				});
			}function a(t, e, i, n, a, o) {
				var r = e.getModel("axisPointer"),
				    s = {};h(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], function (t) {
					s[t] = u.clone(r.get(t));
				}), s.snap = "category" !== t.type && !!o, "cross" === r.get("type") && (s.type = "line");var l = s.label || (s.label = {});if (null == l.show && (l.show = !1), "cross" === a && (l.show = !0, !o)) {
					var d = s.lineStyle = r.get("crossStyle");d && u.defaults(l.textStyle || (l.textStyle = {}), d.textStyle);
				}return t.model.getModel("axisPointer", new c(s, i, n));
			}function o(t, e) {
				e.eachSeries(function (e) {
					var i = e.coordinateSystem,
					    n = e.get("tooltip.trigger", !0);i && "none" !== n && n !== !1 && "item" !== n && e.get("axisPointer.show", !0) !== !1 && h(t.coordSysAxesInfo[p(i.model)], function (t) {
						var n = t.axis;i.getAxis(n.dim) === n && (t.seriesModels.push(e), null == t.seriesDataCount && (t.seriesDataCount = 0), t.seriesDataCount += e.getData().count());
					});
				}, this);
			}function r(t, e) {
				for (var i = e.model, n = e.dim, a = 0; a < t.length; a++) {
					var o = t[a] || {};if (s(o[n + "AxisId"], i.id) || s(o[n + "AxisIndex"], i.componentIndex) || s(o[n + "AxisName"], i.name)) return a;
				}
			}function s(t, e) {
				return "all" === t || u.isArray(t) && u.indexOf(t, e) >= 0 || t === e;
			}function l(t) {
				return !!t.get("handle.show");
			}var u = i(1),
			    c = i(10),
			    h = u.each,
			    d = u.curry,
			    f = {};f.collect = function (t, e) {
				var i = { axesInfo: {}, seriesInvolved: !1, coordSysAxesInfo: {}, coordSysMap: {} };return n(i, t, e), i.seriesInvolved && o(i, t), i;
			}, f.fixValue = function (t) {
				var e = f.getAxisInfo(t);if (e) {
					var i = e.axisPointerModel,
					    n = e.axis.scale,
					    a = i.option,
					    o = i.get("status"),
					    r = i.get("value");null != r && (r = n.parse(r));var s = l(i);null == o && (a.status = s ? "show" : "hide");var u = n.getExtent().slice();u[0] > u[1] && u.reverse(), (null == r || r > u[1]) && (r = u[1]), r < u[0] && (r = u[0]), a.value = r, s && (a.status = e.axis.scale.isBlank() ? "hide" : "show");
				}
			}, f.getAxisInfo = function (t) {
				var e = (t.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;return e && e.axesInfo[p(t)];
			}, f.getAxisPointerModel = function (t) {
				var e = f.getAxisInfo(t);return e && e.axisPointerModel;
			};var p = f.makeKey = function (t) {
				return t.type + "||" + t.id;
			};t.exports = f;
		}, function (t, e, i) {
			function n(t) {
				var e = {};return h(["start", "end", "startValue", "endValue", "throttle"], function (i) {
					t.hasOwnProperty(i) && (e[i] = t[i]);
				}), e;
			}function a(t, e) {
				h([["start", "startValue"], ["end", "endValue"]], function (i, n) {
					var a = t._rangePropMode;null != e[i[0]] ? a[n] = "percent" : null != e[i[1]] && (a[n] = "value");
				});
			}var o = i(1),
			    r = i(9),
			    s = i(2),
			    l = i(5),
			    u = i(77),
			    c = i(198),
			    h = o.each,
			    d = u.eachAxisDim,
			    f = s.extendComponentModel({ type: "dataZoom", dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series"], defaultOption: { zlevel: 0, z: 4, orient: null, xAxisIndex: null, yAxisIndex: null, filterMode: "filter", throttle: null, start: 0, end: 100, startValue: null, endValue: null, minSpan: null, maxSpan: null, minValueSpan: null, maxValueSpan: null }, init: function init(t, e, i) {
					this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel, this._autoThrottle = !0, this._rangePropMode = ["percent", "percent"];var a = n(t);this.mergeDefaultAndTheme(t, i), this.doInit(a);
				}, mergeOption: function mergeOption(t) {
					var e = n(t);o.merge(this.option, t, !0), this.doInit(e);
				}, doInit: function doInit(t) {
					var e = this.option;r.canvasSupported || (e.realtime = !1), this._setDefaultThrottle(t), a(this, t), h([["start", "startValue"], ["end", "endValue"]], function (t, i) {
						"value" === this._rangePropMode[i] && (e[t[0]] = null);
					}, this), this.textStyleModel = this.getModel("textStyle"), this._resetTarget(), this._giveAxisProxies();
				}, _giveAxisProxies: function _giveAxisProxies() {
					var t = this._axisProxies;this.eachTargetAxis(function (e, i, n, a) {
						var o = this.dependentModels[e.axis][i],
						    r = o.__dzAxisProxy || (o.__dzAxisProxy = new c(e.name, i, this, a));t[e.name + "_" + i] = r;
					}, this);
				}, _resetTarget: function _resetTarget() {
					var t = this.option,
					    e = this._judgeAutoMode();d(function (e) {
						var i = e.axisIndex;t[i] = l.normalizeToArray(t[i]);
					}, this), "axisIndex" === e ? this._autoSetAxisIndex() : "orient" === e && this._autoSetOrient();
				}, _judgeAutoMode: function _judgeAutoMode() {
					var t = this.option,
					    e = !1;d(function (i) {
						null != t[i.axisIndex] && (e = !0);
					}, this);var i = t.orient;return null == i && e ? "orient" : e ? void 0 : (null == i && (t.orient = "horizontal"), "axisIndex");
				}, _autoSetAxisIndex: function _autoSetAxisIndex() {
					var t = !0,
					    e = this.get("orient", !0),
					    i = this.option,
					    n = this.dependentModels;if (t) {
						var a = "vertical" === e ? "y" : "x";n[a + "Axis"].length ? (i[a + "AxisIndex"] = [0], t = !1) : h(n.singleAxis, function (n) {
							t && n.get("orient", !0) === e && (i.singleAxisIndex = [n.componentIndex], t = !1);
						});
					}t && d(function (e) {
						if (t) {
							var n = [],
							    a = this.dependentModels[e.axis];if (a.length && !n.length) for (var o = 0, r = a.length; o < r; o++) {
								"category" === a[o].get("type") && n.push(o);
							}i[e.axisIndex] = n, n.length && (t = !1);
						}
					}, this), t && this.ecModel.eachSeries(function (t) {
						this._isSeriesHasAllAxesTypeOf(t, "value") && d(function (e) {
							var n = i[e.axisIndex],
							    a = t.get(e.axisIndex),
							    r = t.get(e.axisId),
							    s = t.ecModel.queryComponents({ mainType: e.axis, index: a, id: r })[0];a = s.componentIndex, o.indexOf(n, a) < 0 && n.push(a);
						});
					}, this);
				}, _autoSetOrient: function _autoSetOrient() {
					var t;this.eachTargetAxis(function (e) {
						!t && (t = e.name);
					}, this), this.option.orient = "y" === t ? "vertical" : "horizontal";
				}, _isSeriesHasAllAxesTypeOf: function _isSeriesHasAllAxesTypeOf(t, e) {
					var i = !0;return d(function (n) {
						var a = t.get(n.axisIndex),
						    o = this.dependentModels[n.axis][a];o && o.get("type") === e || (i = !1);
					}, this), i;
				}, _setDefaultThrottle: function _setDefaultThrottle(t) {
					if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
						var e = this.ecModel.option;this.option.throttle = e.animation && e.animationDurationUpdate > 0 ? 100 : 20;
					}
				}, getFirstTargetAxisModel: function getFirstTargetAxisModel() {
					var t;return d(function (e) {
						if (null == t) {
							var i = this.get(e.axisIndex);i.length && (t = this.dependentModels[e.axis][i[0]]);
						}
					}, this), t;
				}, eachTargetAxis: function eachTargetAxis(t, e) {
					var i = this.ecModel;d(function (n) {
						h(this.get(n.axisIndex), function (a) {
							t.call(e, n, a, this, i);
						}, this);
					}, this);
				}, getAxisProxy: function getAxisProxy(t, e) {
					return this._axisProxies[t + "_" + e];
				}, getAxisModel: function getAxisModel(t, e) {
					var i = this.getAxisProxy(t, e);return i && i.getAxisModel();
				}, setRawRange: function setRawRange(t, e) {
					h(["start", "end", "startValue", "endValue"], function (e) {
						this.option[e] = t[e];
					}, this), !e && a(this, t);
				}, getPercentRange: function getPercentRange() {
					var t = this.findRepresentativeAxisProxy();if (t) return t.getDataPercentWindow();
				}, getValueRange: function getValueRange(t, e) {
					if (null != t || null != e) return this.getAxisProxy(t, e).getDataValueWindow();var i = this.findRepresentativeAxisProxy();return i ? i.getDataValueWindow() : void 0;
				}, findRepresentativeAxisProxy: function findRepresentativeAxisProxy(t) {
					if (t) return t.__dzAxisProxy;var e = this._axisProxies;for (var i in e) {
						if (e.hasOwnProperty(i) && e[i].hostedBy(this)) return e[i];
					}for (var i in e) {
						if (e.hasOwnProperty(i) && !e[i].hostedBy(this)) return e[i];
					}
				}, getRangePropMode: function getRangePropMode() {
					return this._rangePropMode.slice();
				} });t.exports = f;
		}, function (t, e, i) {
			var n = i(65);t.exports = n.extend({ type: "dataZoom", render: function render(t, e, i, n) {
					this.dataZoomModel = t, this.ecModel = e, this.api = i;
				}, getTargetCoordInfo: function getTargetCoordInfo() {
					function t(t, e, i, n) {
						for (var a, o = 0; o < i.length; o++) {
							if (i[o].model === t) {
								a = i[o];break;
							}
						}a || i.push(a = { model: t, axisModels: [], coordIndex: n }), a.axisModels.push(e);
					}var e = this.dataZoomModel,
					    i = this.ecModel,
					    n = {};return e.eachTargetAxis(function (e, a) {
						var o = i.getComponent(e.axis, a);if (o) {
							var r = o.getCoordSysModel();r && t(r, o, n[r.mainType] || (n[r.mainType] = []), r.componentIndex);
						}
					}, this), n;
				} });
		}, function (t, e) {
			"use strict";
			function i(t) {
				return t;
			}function n(t, e, n, a) {
				this._old = t, this._new = e, this._oldKeyGetter = n || i, this._newKeyGetter = a || i;
			}function a(t, e, i, n) {
				for (var a = 0; a < t.length; a++) {
					var o = "_ec_" + n(t[a], a),
					    r = e[o];null == r ? (i.push(o), e[o] = a) : (r.length || (e[o] = r = [r]), r.push(a));
				}
			}n.prototype = { constructor: n, add: function add(t) {
					return this._add = t, this;
				}, update: function update(t) {
					return this._update = t, this;
				}, remove: function remove(t) {
					return this._remove = t, this;
				}, execute: function execute() {
					var t,
					    e = this._old,
					    i = this._new,
					    n = this._oldKeyGetter,
					    o = this._newKeyGetter,
					    r = {},
					    s = {},
					    l = [],
					    u = [];for (a(e, r, l, n), a(i, s, u, o), t = 0; t < e.length; t++) {
						var c = l[t],
						    h = s[c];if (null != h) {
							var d = h.length;d ? (1 === d && (s[c] = null), h = h.unshift()) : s[c] = null, this._update && this._update(h, t);
						} else this._remove && this._remove(t);
					}for (var t = 0; t < u.length; t++) {
						var c = u[t];if (s.hasOwnProperty(c)) {
							var h = s[c];if (null == h) continue;if (h.length) for (var f = 0, d = h.length; f < d; f++) {
								this._add && this._add(h[f]);
							} else this._add && this._add(h);
						}
					}
				} }, t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(15),
			    o = a.parseClassType,
			    r = 0,
			    s = {},
			    l = "_";s.getUID = function (t) {
				return [t || "", r++, Math.random()].join(l);
			}, s.enableSubTypeDefaulter = function (t) {
				var e = {};return t.registerSubTypeDefaulter = function (t, i) {
					t = o(t), e[t.main] = i;
				}, t.determineSubType = function (i, n) {
					var a = n.type;if (!a) {
						var r = o(i).main;t.hasSubTypes(i) && e[r] && (a = e[r](n));
					}return a;
				}, t;
			}, s.enableTopologicalTravel = function (t, e) {
				function i(t) {
					var i = {},
					    r = [];return n.each(t, function (s) {
						var l = a(i, s),
						    u = l.originalDeps = e(s),
						    c = o(u, t);l.entryCount = c.length, 0 === l.entryCount && r.push(s), n.each(c, function (t) {
							n.indexOf(l.predecessor, t) < 0 && l.predecessor.push(t);var e = a(i, t);n.indexOf(e.successor, t) < 0 && e.successor.push(s);
						});
					}), { graph: i, noEntryList: r };
				}function a(t, e) {
					return t[e] || (t[e] = { predecessor: [], successor: [] }), t[e];
				}function o(t, e) {
					var i = [];return n.each(t, function (t) {
						n.indexOf(e, t) >= 0 && i.push(t);
					}), i;
				}t.topologicalTravel = function (t, e, a, o) {
					function r(t) {
						u[t].entryCount--, 0 === u[t].entryCount && c.push(t);
					}function s(t) {
						h[t] = !0, r(t);
					}if (t.length) {
						var l = i(e),
						    u = l.graph,
						    c = l.noEntryList,
						    h = {};for (n.each(t, function (t) {
							h[t] = !0;
						}); c.length;) {
							var d = c.pop(),
							    f = u[d],
							    p = !!h[d];p && (a.call(o, d, f.originalDeps.slice()), delete h[d]), n.each(f.successor, p ? s : r);
						}n.each(h, function () {
							throw new Error("Circle dependency may exists");
						});
					}
				};
			}, t.exports = s;
		}, function (t, e) {
			t.exports = function (t, e, i, n, a) {
				n.eachRawSeriesByType(t, function (t) {
					var a = t.getData(),
					    o = t.get("symbol") || e,
					    r = t.get("symbolSize");a.setVisual({ legendSymbol: i || o, symbol: o, symbolSize: r }), n.isSeriesFiltered(t) || ("function" == typeof r && a.each(function (e) {
						var i = t.getRawValue(e),
						    n = t.getDataParams(e);a.setItemVisual(e, "symbolSize", r(i, n));
					}), a.each(function (t) {
						var e = a.getItemModel(t),
						    i = e.getShallow("symbol", !0),
						    n = e.getShallow("symbolSize", !0);null != i && a.setItemVisual(t, "symbol", i), null != n && a.setItemVisual(t, "symbolSize", n);
					}));
				});
			};
		}, function (t, e) {
			function i(t) {
				for (var e = 0; t >= c;) {
					e |= 1 & t, t >>= 1;
				}return t + e;
			}function n(t, e, i, n) {
				var o = e + 1;if (o === i) return 1;if (n(t[o++], t[e]) < 0) {
					for (; o < i && n(t[o], t[o - 1]) < 0;) {
						o++;
					}a(t, e, o);
				} else for (; o < i && n(t[o], t[o - 1]) >= 0;) {
					o++;
				}return o - e;
			}function a(t, e, i) {
				for (i--; e < i;) {
					var n = t[e];t[e++] = t[i], t[i--] = n;
				}
			}function o(t, e, i, n, a) {
				for (n === e && n++; n < i; n++) {
					for (var o, r = t[n], s = e, l = n; s < l;) {
						o = s + l >>> 1, a(r, t[o]) < 0 ? l = o : s = o + 1;
					}var u = n - s;switch (u) {case 3:
							t[s + 3] = t[s + 2];case 2:
							t[s + 2] = t[s + 1];case 1:
							t[s + 1] = t[s];break;default:
							for (; u > 0;) {
								t[s + u] = t[s + u - 1], u--;
							}}t[s] = r;
				}
			}function r(t, e, i, n, a, o) {
				var r = 0,
				    s = 0,
				    l = 1;if (o(t, e[i + a]) > 0) {
					for (s = n - a; l < s && o(t, e[i + a + l]) > 0;) {
						r = l, l = (l << 1) + 1, l <= 0 && (l = s);
					}l > s && (l = s), r += a, l += a;
				} else {
					for (s = a + 1; l < s && o(t, e[i + a - l]) <= 0;) {
						r = l, l = (l << 1) + 1, l <= 0 && (l = s);
					}l > s && (l = s);var u = r;r = a - l, l = a - u;
				}for (r++; r < l;) {
					var c = r + (l - r >>> 1);o(t, e[i + c]) > 0 ? r = c + 1 : l = c;
				}return l;
			}function s(t, e, i, n, a, o) {
				var r = 0,
				    s = 0,
				    l = 1;if (o(t, e[i + a]) < 0) {
					for (s = a + 1; l < s && o(t, e[i + a - l]) < 0;) {
						r = l, l = (l << 1) + 1, l <= 0 && (l = s);
					}l > s && (l = s);var u = r;r = a - l, l = a - u;
				} else {
					for (s = n - a; l < s && o(t, e[i + a + l]) >= 0;) {
						r = l, l = (l << 1) + 1, l <= 0 && (l = s);
					}l > s && (l = s), r += a, l += a;
				}for (r++; r < l;) {
					var c = r + (l - r >>> 1);o(t, e[i + c]) < 0 ? l = c : r = c + 1;
				}return l;
			}function l(t, e) {
				function i(t, e) {
					c[y] = t, f[y] = e, y += 1;
				}function n() {
					for (; y > 1;) {
						var t = y - 2;if (t >= 1 && f[t - 1] <= f[t] + f[t + 1] || t >= 2 && f[t - 2] <= f[t] + f[t - 1]) f[t - 1] < f[t + 1] && t--;else if (f[t] > f[t + 1]) break;o(t);
					}
				}function a() {
					for (; y > 1;) {
						var t = y - 2;t > 0 && f[t - 1] < f[t + 1] && t--, o(t);
					}
				}function o(i) {
					var n = c[i],
					    a = f[i],
					    o = c[i + 1],
					    h = f[i + 1];f[i] = a + h, i === y - 3 && (c[i + 1] = c[i + 2], f[i + 1] = f[i + 2]), y--;var d = s(t[o], t, n, a, 0, e);n += d, a -= d, 0 !== a && (h = r(t[n + a - 1], t, o, h, h - 1, e), 0 !== h && (a <= h ? l(n, a, o, h) : u(n, a, o, h)));
				}function l(i, n, a, o) {
					var l = 0;for (l = 0; l < n; l++) {
						x[l] = t[i + l];
					}var u = 0,
					    c = a,
					    d = i;if (t[d++] = t[c++], 0 !== --o) {
						if (1 === n) {
							for (l = 0; l < o; l++) {
								t[d + l] = t[c + l];
							}return void (t[d + o] = x[u]);
						}for (var f, g, m, v = p;;) {
							f = 0, g = 0, m = !1;do {
								if (e(t[c], x[u]) < 0) {
									if (t[d++] = t[c++], g++, f = 0, 0 === --o) {
										m = !0;break;
									}
								} else if (t[d++] = x[u++], f++, g = 0, 1 === --n) {
									m = !0;break;
								}
							} while ((f | g) < v);if (m) break;do {
								if (f = s(t[c], x, u, n, 0, e), 0 !== f) {
									for (l = 0; l < f; l++) {
										t[d + l] = x[u + l];
									}if (d += f, u += f, n -= f, n <= 1) {
										m = !0;break;
									}
								}if (t[d++] = t[c++], 0 === --o) {
									m = !0;break;
								}if (g = r(x[u], t, c, o, 0, e), 0 !== g) {
									for (l = 0; l < g; l++) {
										t[d + l] = t[c + l];
									}if (d += g, c += g, o -= g, 0 === o) {
										m = !0;break;
									}
								}if (t[d++] = x[u++], 1 === --n) {
									m = !0;break;
								}v--;
							} while (f >= h || g >= h);if (m) break;v < 0 && (v = 0), v += 2;
						}if (p = v, p < 1 && (p = 1), 1 === n) {
							for (l = 0; l < o; l++) {
								t[d + l] = t[c + l];
							}t[d + o] = x[u];
						} else {
							if (0 === n) throw new Error();for (l = 0; l < n; l++) {
								t[d + l] = x[u + l];
							}
						}
					} else for (l = 0; l < n; l++) {
						t[d + l] = x[u + l];
					}
				}function u(i, n, a, o) {
					var l = 0;for (l = 0; l < o; l++) {
						x[l] = t[a + l];
					}var u = i + n - 1,
					    c = o - 1,
					    d = a + o - 1,
					    f = 0,
					    g = 0;if (t[d--] = t[u--], 0 !== --n) {
						if (1 === o) {
							for (d -= n, u -= n, g = d + 1, f = u + 1, l = n - 1; l >= 0; l--) {
								t[g + l] = t[f + l];
							}return void (t[d] = x[c]);
						}for (var m = p;;) {
							var v = 0,
							    y = 0,
							    _ = !1;do {
								if (e(x[c], t[u]) < 0) {
									if (t[d--] = t[u--], v++, y = 0, 0 === --n) {
										_ = !0;break;
									}
								} else if (t[d--] = x[c--], y++, v = 0, 1 === --o) {
									_ = !0;break;
								}
							} while ((v | y) < m);if (_) break;do {
								if (v = n - s(x[c], t, i, n, n - 1, e), 0 !== v) {
									for (d -= v, u -= v, n -= v, g = d + 1, f = u + 1, l = v - 1; l >= 0; l--) {
										t[g + l] = t[f + l];
									}if (0 === n) {
										_ = !0;break;
									}
								}if (t[d--] = x[c--], 1 === --o) {
									_ = !0;break;
								}if (y = o - r(t[u], x, 0, o, o - 1, e), 0 !== y) {
									for (d -= y, c -= y, o -= y, g = d + 1, f = c + 1, l = 0; l < y; l++) {
										t[g + l] = x[f + l];
									}if (o <= 1) {
										_ = !0;break;
									}
								}if (t[d--] = t[u--], 0 === --n) {
									_ = !0;break;
								}m--;
							} while (v >= h || y >= h);if (_) break;m < 0 && (m = 0), m += 2;
						}if (p = m, p < 1 && (p = 1), 1 === o) {
							for (d -= n, u -= n, g = d + 1, f = u + 1, l = n - 1; l >= 0; l--) {
								t[g + l] = t[f + l];
							}t[d] = x[c];
						} else {
							if (0 === o) throw new Error();for (f = d - (o - 1), l = 0; l < o; l++) {
								t[f + l] = x[l];
							}
						}
					} else for (f = d - (o - 1), l = 0; l < o; l++) {
						t[f + l] = x[l];
					}
				}var c,
				    f,
				    p = h,
				    g = 0,
				    m = d,
				    v = 0,
				    y = 0;g = t.length, g < 2 * d && (m = g >>> 1);var x = [];v = g < 120 ? 5 : g < 1542 ? 10 : g < 119151 ? 19 : 40, c = [], f = [], this.mergeRuns = n, this.forceMergeRuns = a, this.pushRun = i;
			}function u(t, e, a, r) {
				a || (a = 0), r || (r = t.length);var s = r - a;if (!(s < 2)) {
					var u = 0;if (s < c) return u = n(t, a, r, e), void o(t, a, r, a + u, e);var h = new l(t, e),
					    d = i(s);do {
						if (u = n(t, a, r, e), u < d) {
							var f = s;f > d && (f = d), o(t, a, a + f, a + u, e), u = f;
						}h.pushRun(a, u), h.mergeRuns(), s -= u, a += u;
					} while (0 !== s);h.forceMergeRuns();
				}
			}var c = 32,
			    h = 7,
			    d = 256;t.exports = u;
		}, function (t, e, i) {
			var n = i(35);t.exports = function () {
				if (0 !== n.debugMode) if (1 == n.debugMode) for (var t in arguments) {
					throw new Error(arguments[t]);
				} else if (n.debugMode > 1) for (var t in arguments) {
					console.log(arguments[t]);
				}
			};
		}, function (t, e, i) {
			function n(t) {
				a.call(this, t);
			}var a = i(38),
			    o = i(11),
			    r = i(1),
			    s = i(70),
			    l = new s(50);n.prototype = { constructor: n, type: "image", brush: function brush(t, e) {
					var i,
					    n = this.style,
					    a = n.image;if (n.bind(t, this, e), i = "string" == typeof a ? this._image : a, !i && a) {
						var o = l.get(a);if (!o) return i = new Image(), i.onload = function () {
							i.onload = null;for (var t = 0; t < o.pending.length; t++) {
								o.pending[t].dirty();
							}
						}, o = { image: i, pending: [this] }, i.src = a, l.put(a, o), void (this._image = i);if (i = o.image, this._image = i, !i.width || !i.height) return void o.pending.push(this);
					}if (i) {
						var r = n.x || 0,
						    s = n.y || 0;if (!i.width || !i.height) return;var u = n.width,
						    c = n.height,
						    h = i.width / i.height;if (null == u && null != c ? u = c * h : null == c && null != u ? c = u / h : null == u && null == c && (u = i.width, c = i.height), this.setTransform(t), n.sWidth && n.sHeight) {
							var d = n.sx || 0,
							    f = n.sy || 0;t.drawImage(i, d, f, n.sWidth, n.sHeight, r, s, u, c);
						} else if (n.sx && n.sy) {
							var d = n.sx,
							    f = n.sy,
							    p = u - d,
							    g = c - f;t.drawImage(i, d, f, p, g, r, s, u, c);
						} else t.drawImage(i, r, s, u, c);this.restoreTransform(t), null != n.text && this.drawRectText(t, this.getBoundingRect());
					}
				}, getBoundingRect: function getBoundingRect() {
					var t = this.style;return this._rect || (this._rect = new o(t.x || 0, t.y || 0, t.width || 0, t.height || 0)), this._rect;
				} }, r.inherits(n, a), t.exports = n;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t.getItemVisual(e, "symbolSize");return i instanceof Array ? i.slice() : [+i, +i];
			}function a(t) {
				return [t[0] / 2, t[1] / 2];
			}function o(t, e, i) {
				u.Group.call(this), this.updateData(t, e, i);
			}function r(t, e) {
				this.parent.drift(t, e);
			}var s = i(1),
			    l = i(24),
			    u = i(3),
			    c = i(4),
			    h = i(92),
			    d = o.prototype;d._createSymbol = function (t, e, i, n) {
				this.removeAll();var o = e.hostModel,
				    s = e.getItemVisual(i, "color"),
				    c = l.createSymbol(t, -1, -1, 2, 2, s);c.attr({ z2: 100, culling: !0, scale: [0, 0] }), c.drift = r, u.initProps(c, { scale: a(n) }, o, i), this._symbolType = t, this.add(c);
			}, d.stopSymbolAnimation = function (t) {
				this.childAt(0).stopAnimation(t);
			}, d.getSymbolPath = function () {
				return this.childAt(0);
			}, d.getScale = function () {
				return this.childAt(0).scale;
			}, d.highlight = function () {
				this.childAt(0).trigger("emphasis");
			}, d.downplay = function () {
				this.childAt(0).trigger("normal");
			}, d.setZ = function (t, e) {
				var i = this.childAt(0);i.zlevel = t, i.z = e;
			}, d.setDraggable = function (t) {
				var e = this.childAt(0);e.draggable = t, e.cursor = t ? "move" : "pointer";
			}, d.updateData = function (t, e, i) {
				this.silent = !1;var o = t.getItemVisual(e, "symbol") || "circle",
				    r = t.hostModel,
				    s = n(t, e);if (o !== this._symbolType) this._createSymbol(o, t, e, s);else {
					var l = this.childAt(0);l.silent = !1, u.updateProps(l, { scale: a(s) }, r, e);
				}this._updateCommon(t, e, s, i), this._seriesModel = r;
			};var f = ["itemStyle", "normal"],
			    p = ["itemStyle", "emphasis"],
			    g = ["label", "normal"],
			    m = ["label", "emphasis"];d._updateCommon = function (t, e, i, n) {
				var o = this.childAt(0),
				    r = t.hostModel,
				    l = t.getItemVisual(e, "color");"image" !== o.type && o.useStyle({ strokeNoScale: !0 }), n = n || null;var d = n && n.itemStyle,
				    v = n && n.hoverItemStyle,
				    y = n && n.symbolRotate,
				    x = n && n.symbolOffset,
				    _ = n && n.labelModel,
				    b = n && n.hoverLabelModel,
				    w = n && n.hoverAnimation;if (!n || t.hasItemOption) {
					var S = t.getItemModel(e);d = S.getModel(f).getItemStyle(["color"]), v = S.getModel(p).getItemStyle(), y = S.getShallow("symbolRotate"), x = S.getShallow("symbolOffset"), _ = S.getModel(g), b = S.getModel(m), w = S.getShallow("hoverAnimation");
				} else v = s.extend({}, v);var M = o.style;o.attr("rotation", (y || 0) * Math.PI / 180 || 0), x && o.attr("position", [c.parsePercent(x[0], i[0]), c.parsePercent(x[1], i[1])]), o.setColor(l), o.setStyle(d);var I = t.getItemVisual(e, "opacity");null != I && (M.opacity = I);var T = h.findLabelValueDim(t);h.setTextToStyle(t, e, T, M, r, _, l), h.setTextToStyle(t, e, T, v, r, b, l), o.off("mouseover").off("mouseout").off("emphasis").off("normal"), o.hoverStyle = v, u.setHoverStyle(o);var A = a(i);if (w && r.isAnimationEnabled()) {
					var C = function C() {
						var t = A[1] / A[0];this.animateTo({ scale: [Math.max(1.1 * A[0], A[0] + 3), Math.max(1.1 * A[1], A[1] + 3 * t)] }, 400, "elasticOut");
					},
					    L = function L() {
						this.animateTo({ scale: A }, 400, "elasticOut");
					};o.on("mouseover", C).on("mouseout", L).on("emphasis", C).on("normal", L);
				}
			}, d.fadeOut = function (t) {
				var e = this.childAt(0);this.silent = e.silent = !0, e.style.text = "", u.updateProps(e, { scale: [0, 0] }, this._seriesModel, this.dataIndex, t);
			}, s.inherits(o, u.Group), t.exports = o;
		}, function (t, e, i) {
			var n = i(2),
			    a = i(45),
			    o = i(196),
			    r = i(1);i(194), i(195), i(120), n.registerPreprocessor(function (t) {
				if (t) {
					(!t.axisPointer || 0 === t.axisPointer.length) && (t.axisPointer = {});var e = t.axisPointer.link;e && !r.isArray(e) && (t.axisPointer.link = [e]);
				}
			}), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, function (t, e) {
				t.getComponent("axisPointer").coordSysAxesInfo = a.collect(t, e);
			}), n.registerAction({ type: "updateAxisPointer", event: "updateAxisPointer", update: ":updateAxisPointer" }, function (t, e, i) {
				var n = o(e.getComponent("axisPointer").coordSysAxesInfo, t.currTrigger, [t.x, t.y], t, t.dispatchAction || r.bind(i.dispatchAction, i), e, i, t.tooltipOption);return n;
			});
		}, function (t, e) {
			function i(t, e) {
				var i = t[e] - t[1 - e];return { span: Math.abs(i), sign: i > 0 ? -1 : i < 0 ? 1 : e ? -1 : 1 };
			}function n(t, e) {
				return Math.min(e[1], Math.max(e[0], t));
			}t.exports = function (t, e, a, o, r, s) {
				e[0] = n(e[0], a), e[1] = n(e[1], a), t = t || 0;var l = a[1] - a[0];null != r && (r = n(r, [0, l])), null != s && (s = Math.max(s, null != r ? r : 0)), "all" === o && (r = s = Math.abs(e[1] - e[0]), o = 0);var u = i(e, o);e[o] += t;var c = r || 0,
				    h = a.slice();u.sign < 0 ? h[0] += c : h[1] -= c, e[o] = n(e[o], h);var d = i(e, o);null != r && (d.sign !== u.sign || d.span < r) && (e[1 - o] = e[o] + u.sign * r);var d = i(e, o);return null != s && d.span > s && (e[1 - o] = e[o] + d.sign * s), e;
			};
		}, function (t, e, i) {
			function n(t, e, i) {
				return t.getCoordSysModel() === e;
			}function a(t) {
				var e,
				    i = t.model,
				    n = i.getFormattedLabels(),
				    a = i.getModel("axisLabel.textStyle"),
				    o = 1,
				    r = n.length;r > 40 && (o = Math.ceil(r / 40));for (var s = 0; s < r; s += o) {
					if (!t.isLabelIgnored(s)) {
						var l = a.getTextRect(n[s]);e ? e.union(l) : e = l;
					}
				}return e;
			}function o(t, e, i) {
				this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this.model = t;
			}function r(t, e) {
				var i = t.getExtent(),
				    n = i[0] + i[1];t.toGlobalCoord = "x" === t.dim ? function (t) {
					return t + e;
				} : function (t) {
					return n - t + e;
				}, t.toLocalCoord = "x" === t.dim ? function (t) {
					return t - e;
				} : function (t) {
					return n - t + e;
				};
			}function s(t, e) {
				return h.map(y, function (e) {
					var i = t.getReferringComponents(e)[0];return i;
				});
			}function l(t) {
				return "cartesian2d" === t.get("coordinateSystem");
			}var u = i(12),
			    c = i(18),
			    h = i(1),
			    d = i(133),
			    f = i(131),
			    p = h.each,
			    g = c.ifAxisCrossZero,
			    m = c.niceScaleExtent;i(134);var v = o.prototype;v.type = "grid", v.axisPointerEnabled = !0, v.getRect = function () {
				return this._rect;
			}, v.update = function (t, e) {
				function i(t) {
					var e = n[t];for (var i in e) {
						if (e.hasOwnProperty(i)) {
							var a = e[i];if (a && ("category" === a.type || "time" === a.type || !g(a))) return !0;
						}
					}return !1;
				}var n = this._axesMap;this._updateScale(t, this.model), p(n.x, function (t) {
					m(t.scale, t.model);
				}), p(n.y, function (t) {
					m(t.scale, t.model);
				}), p(n.x, function (t) {
					i("y") && (t.onZero = !1);
				}), p(n.y, function (t) {
					i("x") && (t.onZero = !1);
				}), this.resize(this.model, e);
			}, v.resize = function (t, e, i) {
				function n() {
					p(s, function (t) {
						var e = t.isHorizontal(),
						    i = e ? [0, o.width] : [0, o.height],
						    n = t.inverse ? 1 : 0;t.setExtent(i[n], i[1 - n]), r(t, e ? o.x : o.y);
					});
				}var o = u.getLayoutRect(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() });this._rect = o;var s = this._axesList;n(), !i && t.get("containLabel") && (p(s, function (t) {
					if (!t.model.get("axisLabel.inside")) {
						var e = a(t);if (e) {
							var i = t.isHorizontal() ? "height" : "width",
							    n = t.model.get("axisLabel.margin");o[i] -= e[i] + n, "top" === t.position ? o.y += e.height + n : "left" === t.position && (o.x += e.width + n);
						}
					}
				}), n());
			}, v.getAxis = function (t, e) {
				var i = this._axesMap[t];if (null != i) {
					if (null == e) for (var n in i) {
						if (i.hasOwnProperty(n)) return i[n];
					}return i[e];
				}
			}, v.getAxes = function () {
				return this._axesList.slice();
			}, v.getCartesian = function (t, e) {
				if (null != t && null != e) {
					var i = "x" + t + "y" + e;return this._coordsMap[i];
				}h.isObject(t) && (e = t.yAxisIndex, t = t.xAxisIndex);for (var n = 0, a = this._coordsList; n < a.length; n++) {
					if (a[n].getAxis("x").index === t || a[n].getAxis("y").index === e) return a[n];
				}
			}, v.getCartesians = function () {
				return this._coordsList.slice();
			}, v.convertToPixel = function (t, e, i) {
				var n = this._findConvertTarget(t, e);return n.cartesian ? n.cartesian.dataToPoint(i) : n.axis ? n.axis.toGlobalCoord(n.axis.dataToCoord(i)) : null;
			}, v.convertFromPixel = function (t, e, i) {
				var n = this._findConvertTarget(t, e);return n.cartesian ? n.cartesian.pointToData(i) : n.axis ? n.axis.coordToData(n.axis.toLocalCoord(i)) : null;
			}, v._findConvertTarget = function (t, e) {
				var i,
				    n,
				    a = e.seriesModel,
				    o = e.xAxisModel || a && a.getReferringComponents("xAxis")[0],
				    r = e.yAxisModel || a && a.getReferringComponents("yAxis")[0],
				    s = e.gridModel,
				    l = this._coordsList;if (a) i = a.coordinateSystem, h.indexOf(l, i) < 0 && (i = null);else if (o && r) i = this.getCartesian(o.componentIndex, r.componentIndex);else if (o) n = this.getAxis("x", o.componentIndex);else if (r) n = this.getAxis("y", r.componentIndex);else if (s) {
					var u = s.coordinateSystem;u === this && (i = this._coordsList[0]);
				}return { cartesian: i, axis: n };
			}, v.containPoint = function (t) {
				var e = this._coordsList[0];if (e) return e.containPoint(t);
			}, v._initCartesian = function (t, e, i) {
				function a(i) {
					return function (a, l) {
						if (n(a, t, e)) {
							var u = a.get("position");"x" === i ? "top" !== u && "bottom" !== u && (u = "bottom", o[u] && (u = "top" === u ? "bottom" : "top")) : "left" !== u && "right" !== u && (u = "left", o[u] && (u = "left" === u ? "right" : "left")), o[u] = !0;var h = new f(i, c.createScaleByModel(a), [0, 0], a.get("type"), u),
							    d = "category" === h.type;h.onBand = d && a.get("boundaryGap"), h.inverse = a.get("inverse"), h.onZero = a.get("axisLine.onZero"), a.axis = h, h.model = a, h.grid = this, h.index = l, this._axesList.push(h), r[i][l] = h, s[i]++;
						}
					};
				}var o = { left: !1, right: !1, top: !1, bottom: !1 },
				    r = { x: {}, y: {} },
				    s = { x: 0, y: 0 };return e.eachComponent("xAxis", a("x"), this), e.eachComponent("yAxis", a("y"), this), s.x && s.y ? (this._axesMap = r, void p(r.x, function (e, i) {
					p(r.y, function (n, a) {
						var o = "x" + i + "y" + a,
						    r = new d(o);r.grid = this, r.model = t, this._coordsMap[o] = r, this._coordsList.push(r), r.addAxis(e), r.addAxis(n);
					}, this);
				}, this)) : (this._axesMap = {}, void (this._axesList = []));
			}, v._updateScale = function (t, e) {
				function i(t, e, i) {
					p(i.coordDimToDataDim(e.dim), function (i) {
						e.scale.unionExtentFromData(t, i);
					});
				}h.each(this._axesList, function (t) {
					t.scale.setExtent(1 / 0, -(1 / 0));
				}), t.eachSeries(function (a) {
					if (l(a)) {
						var o = s(a, t),
						    r = o[0],
						    u = o[1];if (!n(r, e, t) || !n(u, e, t)) return;var c = this.getCartesian(r.componentIndex, u.componentIndex),
						    h = a.getData(),
						    d = c.getAxis("x"),
						    f = c.getAxis("y");"list" === h.type && (i(h, d, a), i(h, f, a));
					}
				}, this);
			}, v.getTooltipAxes = function (t) {
				var e = [],
				    i = [];return p(this.getCartesians(), function (n) {
					var a = null != t && "auto" !== t ? n.getAxis(t) : n.getBaseAxis(),
					    o = n.getOtherAxis(a);h.indexOf(e, a) < 0 && e.push(a), h.indexOf(i, o) < 0 && i.push(o);
				}), { baseAxes: e, otherAxes: i };
			};var y = ["xAxis", "yAxis"];o.create = function (t, e) {
				var i = [];return t.eachComponent("grid", function (n, a) {
					var r = new o(n, t, e);r.name = "grid_" + a, r.resize(n, e, !0), n.coordinateSystem = r, i.push(r);
				}), t.eachSeries(function (e) {
					if (l(e)) {
						var i = s(e, t),
						    n = i[0],
						    a = i[1],
						    o = n.getCoordSysModel(),
						    r = o.coordinateSystem;e.coordinateSystem = r.getCartesian(n.componentIndex, a.componentIndex);
					}
				}), i;
			}, o.dimensions = o.prototype.dimensions = d.prototype.dimensions, i(26).register("cartesian2d", o), t.exports = o;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return t > s || t < -s;
			}var a = i(19),
			    o = i(6),
			    r = a.identity,
			    s = 5e-5,
			    l = function l(t) {
				t = t || {}, t.position || (this.position = [0, 0]), null == t.rotation && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null;
			},
			    u = l.prototype;
			u.transform = null, u.needLocalTransform = function () {
				return n(this.rotation) || n(this.position[0]) || n(this.position[1]) || n(this.scale[0] - 1) || n(this.scale[1] - 1);
			}, u.updateTransform = function () {
				var t = this.parent,
				    e = t && t.transform,
				    i = this.needLocalTransform(),
				    n = this.transform;return i || e ? (n = n || a.create(), i ? this.getLocalTransform(n) : r(n), e && (i ? a.mul(n, t.transform, n) : a.copy(n, t.transform)), this.transform = n, this.invTransform = this.invTransform || a.create(), void a.invert(this.invTransform, n)) : void (n && r(n));
			}, u.getLocalTransform = function (t) {
				return l.getLocalTransform(this, t);
			}, u.setTransform = function (t) {
				var e = this.transform,
				    i = t.dpr || 1;e ? t.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : t.setTransform(i, 0, 0, i, 0, 0);
			}, u.restoreTransform = function (t) {
				var e = t.dpr || 1;t.setTransform(e, 0, 0, e, 0, 0);
			};var c = [];u.decomposeTransform = function () {
				if (this.transform) {
					var t = this.parent,
					    e = this.transform;t && t.transform && (a.mul(c, t.invTransform, e), e = c);var i = e[0] * e[0] + e[1] * e[1],
					    o = e[2] * e[2] + e[3] * e[3],
					    r = this.position,
					    s = this.scale;n(i - 1) && (i = Math.sqrt(i)), n(o - 1) && (o = Math.sqrt(o)), e[0] < 0 && (i = -i), e[3] < 0 && (o = -o), r[0] = e[4], r[1] = e[5], s[0] = i, s[1] = o, this.rotation = Math.atan2(-e[1] / o, e[0] / i);
				}
			}, u.getGlobalScale = function () {
				var t = this.transform;if (!t) return [1, 1];var e = Math.sqrt(t[0] * t[0] + t[1] * t[1]),
				    i = Math.sqrt(t[2] * t[2] + t[3] * t[3]);return t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), [e, i];
			}, u.transformCoordToLocal = function (t, e) {
				var i = [t, e],
				    n = this.invTransform;return n && o.applyTransform(i, i, n), i;
			}, u.transformCoordToGlobal = function (t, e) {
				var i = [t, e],
				    n = this.transform;return n && o.applyTransform(i, i, n), i;
			}, l.getLocalTransform = function (t, e) {
				e = e || [], r(e);var i = t.origin,
				    n = t.scale || [1, 1],
				    o = t.rotation || 0,
				    s = t.position || [0, 0];return i && (e[4] -= i[0], e[5] -= i[1]), a.scale(e, e, n), o && a.rotate(e, e, o), i && (e[4] += i[0], e[5] += i[1]), e[4] += s[0], e[5] += s[1], e;
			}, t.exports = l;
		}, function (t, e, i) {
			var n = i(96),
			    a = i(1),
			    o = i(13),
			    r = i(12),
			    s = ["value", "category", "time", "log"];t.exports = function (t, e, i, l) {
				a.each(s, function (o) {
					e.extend({ type: t + "Axis." + o, mergeDefaultAndTheme: function mergeDefaultAndTheme(e, n) {
							var s = this.layoutMode,
							    l = s ? r.getLayoutParams(e) : {},
							    u = n.getTheme();a.merge(e, u.get(o + "Axis")), a.merge(e, this.getDefaultOption()), e.type = i(t, e), s && r.mergeLayoutParam(e, l, s);
						}, defaultOption: a.mergeAll([{}, n[o + "Axis"], l], !0) });
				}), o.registerSubTypeDefaulter(t + "Axis", a.curry(i, t));
			};
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				return e.type || (e.data ? "category" : "value");
			}var a = i(13),
			    o = i(1),
			    r = i(59),
			    s = a.extend({ type: "cartesian2dAxis", axis: null, init: function init() {
					s.superApply(this, "init", arguments), this.resetRange();
				}, mergeOption: function mergeOption() {
					s.superApply(this, "mergeOption", arguments), this.resetRange();
				}, restoreData: function restoreData() {
					s.superApply(this, "restoreData", arguments), this.resetRange();
				}, getCoordSysModel: function getCoordSysModel() {
					return this.ecModel.queryComponents({ mainType: "grid", index: this.option.gridIndex, id: this.option.gridId })[0];
				} });o.merge(s.prototype, i(42));var l = { offset: 0 };r("x", s, n, l), r("y", s, n, l), t.exports = s;
		}, function (t, e) {
			t.exports = function (t, e) {
				e.eachSeriesByType(t, function (t) {
					var e = t.getData(),
					    i = t.coordinateSystem;if (i) {
						for (var n = [], a = i.dimensions, o = 0; o < a.length; o++) {
							n.push(t.coordDimToDataDim(i.dimensions[o])[0]);
						}1 === n.length ? e.each(n[0], function (t, n) {
							e.setItemLayout(n, isNaN(t) ? [NaN, NaN] : i.dataToPoint(t));
						}) : 2 === n.length && e.each(n, function (t, n, a) {
							e.setItemLayout(a, isNaN(t) || isNaN(n) ? [NaN, NaN] : i.dataToPoint([t, n]));
						}, !0);
					}
				});
			};
		}, function (t, e, i) {
			var n = i(15),
			    a = n.set,
			    o = n.get;t.exports = { clearColorPalette: function clearColorPalette() {
					a(this, "colorIdx", 0), a(this, "colorNameMap", {});
				}, getColorFromPalette: function getColorFromPalette(t, e) {
					e = e || this;var i = o(e, "colorIdx") || 0,
					    n = o(e, "colorNameMap") || a(e, "colorNameMap", {});if (n.hasOwnProperty(t)) return n[t];var r = this.get("color", !0) || [];if (r.length) {
						var s = r[i];return t && (n[t] = s), a(e, "colorIdx", (i + 1) % r.length), s;
					}
				} };
		}, function (t, e) {
			t.exports = function (t, e) {
				var i = e.findComponents({ mainType: "legend" });i && i.length && e.eachSeriesByType(t, function (t) {
					var e = t.getData();e.filterSelf(function (t) {
						for (var n = e.getName(t), a = 0; a < i.length; a++) {
							if (!i[a].isSelected(n)) return !1;
						}return !0;
					}, this);
				}, this);
			};
		}, function (t, e, i) {
			function n(t, e, i) {
				t[e] = Math.max(Math.min(t[e], i[1]), i[0]);
			}var a = i(4),
			    o = a.round,
			    r = {};r.intervalScaleNiceTicks = function (t, e, i) {
				var n = {},
				    s = t[1] - t[0],
				    l = n.interval = a.nice(s / e, !0);null != i && l < i && (l = n.interval = i);var u = n.intervalPrecision = a.getPrecisionSafe(l) + 2,
				    c = n.niceTickExtent = [o(Math.ceil(t[0] / l) * l, u), o(Math.floor(t[1] / l) * l, u)];return r.fixExtent(c, t), n;
			}, r.fixExtent = function (t, e) {
				!isFinite(t[0]) && (t[0] = e[0]), !isFinite(t[1]) && (t[1] = e[1]), n(t, 0, e), n(t, 1, e), t[0] > t[1] && (t[0] = t[1]);
			}, r.intervalScaleGetTicks = function (t, e, i, n) {
				var a = [];if (!t) return a;var r = 1e4;e[0] < i[0] && a.push(e[0]);for (var s = i[0]; s <= i[1] && (a.push(s), s = o(s + t, n), s !== a[a.length - 1]);) {
					if (a.length > r) return [];
				}return e[1] > (a.length ? a[a.length - 1] : i[1]) && a.push(e[1]), a;
			}, t.exports = r;
		}, function (t, e, i) {
			var n = i(36),
			    a = i(49),
			    o = i(15),
			    r = function r() {
				this.group = new n(), this.uid = a.getUID("viewComponent");
			};r.prototype = { constructor: r, init: function init(t, e) {}, render: function render(t, e, i, n) {}, dispose: function dispose() {} };var s = r.prototype;s.updateView = s.updateLayout = s.updateVisual = function (t, e, i, n) {}, o.enableClassExtend(r), o.enableClassManagement(r, { registerWhenExtend: !0 }), t.exports = r;
		}, function (t, e, i) {
			"use strict";
			var n = i(71),
			    a = i(23),
			    o = i(58),
			    r = i(178),
			    s = i(1),
			    l = function l(t) {
				o.call(this, t), a.call(this, t), r.call(this, t), this.id = t.id || n();
			};l.prototype = { type: "element", name: "", __zr: null, ignore: !1, clipPath: null, drift: function drift(t, e) {
					switch (this.draggable) {case "horizontal":
							e = 0;break;case "vertical":
							t = 0;}var i = this.transform;i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty(!1);
				}, beforeUpdate: function beforeUpdate() {}, afterUpdate: function afterUpdate() {}, update: function update() {
					this.updateTransform();
				}, traverse: function traverse(t, e) {}, attrKV: function attrKV(t, e) {
					if ("position" === t || "scale" === t || "origin" === t) {
						if (e) {
							var i = this[t];i || (i = this[t] = []), i[0] = e[0], i[1] = e[1];
						}
					} else this[t] = e;
				}, hide: function hide() {
					this.ignore = !0, this.__zr && this.__zr.refresh();
				}, show: function show() {
					this.ignore = !1, this.__zr && this.__zr.refresh();
				}, attr: function attr(t, e) {
					if ("string" == typeof t) this.attrKV(t, e);else if (s.isObject(t)) for (var i in t) {
						t.hasOwnProperty(i) && this.attrKV(i, t[i]);
					}return this.dirty(!1), this;
				}, setClipPath: function setClipPath(t) {
					var e = this.__zr;e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty(!1);
				}, removeClipPath: function removeClipPath() {
					var t = this.clipPath;t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1));
				}, addSelfToZr: function addSelfToZr(t) {
					this.__zr = t;var e = this.animators;if (e) for (var i = 0; i < e.length; i++) {
						t.animation.addAnimator(e[i]);
					}this.clipPath && this.clipPath.addSelfToZr(t);
				}, removeSelfFromZr: function removeSelfFromZr(t) {
					this.__zr = null;var e = this.animators;if (e) for (var i = 0; i < e.length; i++) {
						t.animation.removeAnimator(e[i]);
					}this.clipPath && this.clipPath.removeSelfFromZr(t);
				} }, s.mixin(l, r), s.mixin(l, o), s.mixin(l, a), t.exports = l;
		}, function (t, e, i) {
			function n(t, e) {
				return t[e];
			}function a(t, e, i) {
				t[e] = i;
			}function o(t, e, i) {
				return (e - t) * i + t;
			}function r(t, e, i) {
				return i > .5 ? e : t;
			}function s(t, e, i, n, a) {
				var r = t.length;if (1 == a) for (var s = 0; s < r; s++) {
					n[s] = o(t[s], e[s], i);
				} else for (var l = r && t[0].length, s = 0; s < r; s++) {
					for (var u = 0; u < l; u++) {
						n[s][u] = o(t[s][u], e[s][u], i);
					}
				}
			}function l(t, e, i) {
				var n = t.length,
				    a = e.length;if (n !== a) {
					var o = n > a;if (o) t.length = a;else for (var r = n; r < a; r++) {
						t.push(1 === i ? e[r] : _.call(e[r]));
					}
				}for (var s = t[0] && t[0].length, r = 0; r < t.length; r++) {
					if (1 === i) isNaN(t[r]) && (t[r] = e[r]);else for (var l = 0; l < s; l++) {
						isNaN(t[r][l]) && (t[r][l] = e[r][l]);
					}
				}
			}function u(t, e, i) {
				if (t === e) return !0;var n = t.length;if (n !== e.length) return !1;if (1 === i) {
					for (var a = 0; a < n; a++) {
						if (t[a] !== e[a]) return !1;
					}
				} else for (var o = t[0].length, a = 0; a < n; a++) {
					for (var r = 0; r < o; r++) {
						if (t[a][r] !== e[a][r]) return !1;
					}
				}return !0;
			}function c(t, e, i, n, a, o, r, s, l) {
				var u = t.length;if (1 == l) for (var c = 0; c < u; c++) {
					s[c] = h(t[c], e[c], i[c], n[c], a, o, r);
				} else for (var d = t[0].length, c = 0; c < u; c++) {
					for (var f = 0; f < d; f++) {
						s[c][f] = h(t[c][f], e[c][f], i[c][f], n[c][f], a, o, r);
					}
				}
			}function h(t, e, i, n, a, o, r) {
				var s = .5 * (i - t),
				    l = .5 * (n - e);return (2 * (e - i) + s + l) * r + (-3 * (e - i) - 2 * s - l) * o + s * a + e;
			}function d(t) {
				if (x(t)) {
					var e = t.length;if (x(t[0])) {
						for (var i = [], n = 0; n < e; n++) {
							i.push(_.call(t[n]));
						}return i;
					}return _.call(t);
				}return t;
			}function f(t) {
				return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")";
			}function p(t) {
				var e = t[t.length - 1].value;return x(e && e[0]) ? 2 : 1;
			}function g(t, e, i, n, a) {
				var d = t._getter,
				    g = t._setter,
				    y = "spline" === e,
				    _ = n.length;if (_) {
					var b,
					    w = n[0].value,
					    S = x(w),
					    M = !1,
					    I = !1,
					    T = S ? p(n) : 0;n.sort(function (t, e) {
						return t.time - e.time;
					}), b = n[_ - 1].time;for (var A = [], C = [], L = n[0].value, D = !0, P = 0; P < _; P++) {
						A.push(n[P].time / b);var k = n[P].value;if (S && u(k, L, T) || !S && k === L || (D = !1), L = k, "string" == typeof k) {
							var O = v.parse(k);O ? (k = O, M = !0) : I = !0;
						}C.push(k);
					}if (!D) {
						for (var z = C[_ - 1], P = 0; P < _ - 1; P++) {
							S ? l(C[P], z, T) : !isNaN(C[P]) || isNaN(z) || I || M || (C[P] = z);
						}S && l(d(t._target, a), z, T);var E,
						    R,
						    N,
						    V,
						    B,
						    G,
						    H = 0,
						    F = 0;if (M) var W = [0, 0, 0, 0];var Z = function Z(t, e) {
							var i;if (e < 0) i = 0;else if (e < F) {
								for (E = Math.min(H + 1, _ - 1), i = E; i >= 0 && !(A[i] <= e); i--) {}i = Math.min(i, _ - 2);
							} else {
								for (i = H; i < _ && !(A[i] > e); i++) {}i = Math.min(i - 1, _ - 2);
							}H = i, F = e;var n = A[i + 1] - A[i];if (0 !== n) if (R = (e - A[i]) / n, y) {
								if (V = C[i], N = C[0 === i ? i : i - 1], B = C[i > _ - 2 ? _ - 1 : i + 1], G = C[i > _ - 3 ? _ - 1 : i + 2], S) c(N, V, B, G, R, R * R, R * R * R, d(t, a), T);else {
									var l;if (M) l = c(N, V, B, G, R, R * R, R * R * R, W, 1), l = f(W);else {
										if (I) return r(V, B, R);l = h(N, V, B, G, R, R * R, R * R * R);
									}g(t, a, l);
								}
							} else if (S) s(C[i], C[i + 1], R, d(t, a), T);else {
								var l;if (M) s(C[i], C[i + 1], R, W, 1), l = f(W);else {
									if (I) return r(C[i], C[i + 1], R);l = o(C[i], C[i + 1], R);
								}g(t, a, l);
							}
						},
						    q = new m({ target: t._target, life: b, loop: t._loop, delay: t._delay, onframe: Z, ondestroy: i });return e && "spline" !== e && (q.easing = e), q;
					}
				}
			}var m = i(157),
			    v = i(22),
			    y = i(1),
			    x = y.isArrayLike,
			    _ = Array.prototype.slice,
			    b = function b(t, e, i, o) {
				this._tracks = {}, this._target = t, this._loop = e || !1, this._getter = i || n, this._setter = o || a, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = [];
			};b.prototype = { when: function when(t, e) {
					var i = this._tracks;for (var n in e) {
						if (e.hasOwnProperty(n)) {
							if (!i[n]) {
								i[n] = [];var a = this._getter(this._target, n);if (null == a) continue;0 !== t && i[n].push({ time: 0, value: d(a) });
							}i[n].push({ time: t, value: e[n] });
						}
					}return this;
				}, during: function during(t) {
					return this._onframeList.push(t), this;
				}, pause: function pause() {
					for (var t = 0; t < this._clipList.length; t++) {
						this._clipList[t].pause();
					}this._paused = !0;
				}, resume: function resume() {
					for (var t = 0; t < this._clipList.length; t++) {
						this._clipList[t].resume();
					}this._paused = !1;
				}, isPaused: function isPaused() {
					return !!this._paused;
				}, _doneCallback: function _doneCallback() {
					this._tracks = {}, this._clipList.length = 0;for (var t = this._doneList, e = t.length, i = 0; i < e; i++) {
						t[i].call(this);
					}
				}, start: function start(t) {
					var e,
					    i = this,
					    n = 0,
					    a = function a() {
						n--, n || i._doneCallback();
					};for (var o in this._tracks) {
						if (this._tracks.hasOwnProperty(o)) {
							var r = g(this, t, a, this._tracks[o], o);r && (this._clipList.push(r), n++, this.animation && this.animation.addClip(r), e = r);
						}
					}if (e) {
						var s = e.onframe;e.onframe = function (t, e) {
							s(t, e);for (var n = 0; n < i._onframeList.length; n++) {
								i._onframeList[n](t, e);
							}
						};
					}return n || this._doneCallback(), this;
				}, stop: function stop(t) {
					for (var e = this._clipList, i = this.animation, n = 0; n < e.length; n++) {
						var a = e[n];t && a.onframe(this._target, 1), i && i.removeClip(a);
					}e.length = 0;
				}, delay: function delay(t) {
					return this._delay = t, this;
				}, done: function done(t) {
					return t && this._doneList.push(t), this;
				}, getClips: function getClips() {
					return this._clipList;
				} }, t.exports = b;
		}, function (t, e) {
			t.exports = "undefined" != typeof window && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (t) {
				setTimeout(t, 16);
			};
		}, function (t, e) {
			var i = 2 * Math.PI;t.exports = { normalizeRadian: function normalizeRadian(t) {
					return t %= i, t < 0 && (t += i), t;
				} };
		}, function (t, e) {
			var i = function i() {
				this.head = null, this.tail = null, this._len = 0;
			},
			    n = i.prototype;n.insert = function (t) {
				var e = new a(t);return this.insertEntry(e), e;
			}, n.insertEntry = function (t) {
				this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
			}, n.remove = function (t) {
				var e = t.prev,
				    i = t.next;e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--;
			}, n.len = function () {
				return this._len;
			}, n.clear = function () {
				this.head = this.tail = null, this._len = 0;
			};var a = function a(t) {
				this.value = t, this.next, this.prev;
			},
			    o = function o(t) {
				this._list = new i(), this._map = {}, this._maxSize = t || 10, this._lastRemovedEntry = null;
			},
			    r = o.prototype;r.put = function (t, e) {
				var i = this._list,
				    n = this._map,
				    o = null;if (null == n[t]) {
					var r = i.len(),
					    s = this._lastRemovedEntry;if (r >= this._maxSize && r > 0) {
						var l = i.head;i.remove(l), delete n[l.key], o = l.value, this._lastRemovedEntry = l;
					}s ? s.value = e : s = new a(e), s.key = t, i.insertEntry(s), n[t] = s;
				}return o;
			}, r.get = function (t) {
				var e = this._map[t],
				    i = this._list;if (null != e) return e !== i.tail && (i.remove(e), i.insertEntry(e)), e.value;
			}, r.clear = function () {
				this._list.clear(), this._map = {};
			}, t.exports = o;
		}, function (t, e) {
			var i = 2311;t.exports = function () {
				return i++;
			};
		}, function (t, e) {
			var i = function i(t, e) {
				this.image = t, this.repeat = e, this.type = "pattern";
			};i.prototype.getCanvasPattern = function (t) {
				return t.createPattern(this.image, this.repeat || "repeat");
			}, t.exports = i;
		}, function (t, e) {
			function i(t, e, i) {
				var n = null == e.x ? 0 : e.x,
				    a = null == e.x2 ? 1 : e.x2,
				    o = null == e.y ? 0 : e.y,
				    r = null == e.y2 ? 0 : e.y2;e.global || (n = n * i.width + i.x, a = a * i.width + i.x, o = o * i.height + i.y, r = r * i.height + i.y);var s = t.createLinearGradient(n, o, a, r);return s;
			}function n(t, e, i) {
				var n = i.width,
				    a = i.height,
				    o = Math.min(n, a),
				    r = null == e.x ? .5 : e.x,
				    s = null == e.y ? .5 : e.y,
				    l = null == e.r ? .5 : e.r;e.global || (r = r * n + i.x, s = s * a + i.y, l *= o);var u = t.createRadialGradient(r, s, 0, r, s, l);return u;
			}var a = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]],
			    o = function o(t) {
				this.extendFrom(t);
			};o.prototype = { constructor: o, fill: "#000000", stroke: null, opacity: 1, lineDash: null, lineDashOffset: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, lineWidth: 1, strokeNoScale: !1, text: null, textFill: "#000", textStroke: null, textPosition: "inside", textOffset: null, textBaseline: null, textAlign: null, textVerticalAlign: null, textDistance: 5, textShadowBlur: 0, textShadowOffsetX: 0, textShadowOffsetY: 0, textTransform: !1, textRotation: 0, blend: null, bind: function bind(t, e, i) {
					for (var n = this, o = i && i.style, r = !o, s = 0; s < a.length; s++) {
						var l = a[s],
						    u = l[0];(r || n[u] !== o[u]) && (t[u] = n[u] || l[1]);
					}if ((r || n.fill !== o.fill) && (t.fillStyle = n.fill), (r || n.stroke !== o.stroke) && (t.strokeStyle = n.stroke), (r || n.opacity !== o.opacity) && (t.globalAlpha = null == n.opacity ? 1 : n.opacity), (r || n.blend !== o.blend) && (t.globalCompositeOperation = n.blend || "source-over"), this.hasStroke()) {
						var c = n.lineWidth;t.lineWidth = c / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1);
					}
				}, hasFill: function hasFill() {
					var t = this.fill;return null != t && "none" !== t;
				}, hasStroke: function hasStroke() {
					var t = this.stroke;return null != t && "none" !== t && this.lineWidth > 0;
				}, extendFrom: function extendFrom(t, e) {
					if (t) {
						var i = this;for (var n in t) {
							!t.hasOwnProperty(n) || !e && i.hasOwnProperty(n) || (i[n] = t[n]);
						}
					}
				}, set: function set(t, e) {
					"string" == typeof t ? this[t] = e : this.extendFrom(t, !0);
				}, clone: function clone() {
					var t = new this.constructor();return t.extendFrom(this, !0), t;
				}, getGradient: function getGradient(t, e, a) {
					for (var o = "radial" === e.type ? n : i, r = o(t, e, a), s = e.colorStops, l = 0; l < s.length; l++) {
						r.addColorStop(s[l].offset, s[l].color);
					}return r;
				} };for (var r = o.prototype, s = 0; s < a.length; s++) {
				var l = a[s];l[0] in r || (r[l[0]] = l[1]);
			}o.getGradient = r.getGradient, t.exports = o;
		}, function (t, e, i) {
			var n = i(168),
			    a = i(167);t.exports = { buildPath: function buildPath(t, e, i) {
					var o = e.points,
					    r = e.smooth;if (o && o.length >= 2) {
						if (r && "spline" !== r) {
							var s = a(o, r, i, e.smoothConstraint);t.moveTo(o[0][0], o[0][1]);for (var l = o.length, u = 0; u < (i ? l : l - 1); u++) {
								var c = s[2 * u],
								    h = s[2 * u + 1],
								    d = o[(u + 1) % l];t.bezierCurveTo(c[0], c[1], h[0], h[1], d[0], d[1]);
							}
						} else {
							"spline" === r && (o = n(o, i)), t.moveTo(o[0][0], o[0][1]);for (var u = 1, f = o.length; u < f; u++) {
								t.lineTo(o[u][0], o[u][1]);
							}
						}i && t.closePath();
					}
				} };
		}, function (t, e, i) {
			var n = i(1),
			    a = {};a.layout = function (t, e, i) {
				function a(t, e) {
					var i = o.getAxis(t);return i.toGlobalCoord(i.dataToCoord(0));
				}i = i || {};var o = t.coordinateSystem,
				    r = e.axis,
				    s = {},
				    l = r.position,
				    u = r.onZero ? "onZero" : l,
				    c = r.dim,
				    h = o.getRect(),
				    d = [h.x, h.x + h.width, h.y, h.y + h.height],
				    f = e.get("offset") || 0,
				    p = { x: { top: d[2] - f, bottom: d[3] + f }, y: { left: d[0] - f, right: d[1] + f } };p.x.onZero = Math.max(Math.min(a("y"), p.x.bottom), p.x.top), p.y.onZero = Math.max(Math.min(a("x"), p.y.right), p.y.left), s.position = ["y" === c ? p.y[u] : d[0], "x" === c ? p.x[u] : d[3]], s.rotation = Math.PI / 2 * ("x" === c ? 0 : 1);var g = { top: -1, bottom: 1, left: -1, right: 1 };s.labelDirection = s.tickDirection = s.nameDirection = g[l], s.labelOffset = r.onZero ? p[c][l] - p[c].onZero : 0, e.get("axisTick.inside") && (s.tickDirection = -s.tickDirection), n.retrieve(i.labelInside, e.get("axisLabel.inside")) && (s.labelDirection = -s.labelDirection);var m = e.get("axisLabel.rotate");return s.labelRotate = "top" === u ? -m : m, s.labelInterval = r.getLabelInterval(), s.z2 = 1, s;
			}, t.exports = a;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i, n) {
				var a = n.getWidth(),
				    o = n.getHeight();t[0] = Math.min(t[0] + e, a) - e, t[1] = Math.min(t[1] + i, o) - i, t[0] = Math.max(t[0], 0), t[1] = Math.max(t[1], 0);
			}var a = i(1),
			    o = i(3),
			    r = i(16),
			    s = i(7),
			    l = i(19),
			    u = i(18),
			    c = i(40),
			    h = {};h.buildElStyle = function (t) {
				var e,
				    i = t.get("type"),
				    n = t.getModel(i + "Style");return "line" === i ? (e = n.getLineStyle(), e.fill = null) : "shadow" === i && (e = n.getAreaStyle(), e.stroke = null), e;
			}, h.buildLabelElOption = function (t, e, i, a, o) {
				var l = i.get("value"),
				    u = h.getValueLabel(l, e.axis, e.ecModel, i.get("seriesDataIndices"), { precision: i.get("label.precision"), formatter: i.get("label.formatter") }),
				    c = i.getModel("label"),
				    d = c.getModel("textStyle"),
				    f = s.normalizeCssArray(c.get("padding") || 0),
				    p = d.getFont(),
				    g = r.getBoundingRect(u, p, o.textAlign, o.textBaseline),
				    m = o.position,
				    v = g.width + f[1] + f[3],
				    y = g.height + f[0] + f[2],
				    x = o.align;"right" === x && (m[0] -= v), "center" === x && (m[0] -= v / 2);var _ = o.verticalAlign;"bottom" === _ && (m[1] -= y), "middle" === _ && (m[1] -= y / 2), n(m, v, y, a);var b = c.get("backgroundColor");b && "auto" !== b || (b = e.get("axisLine.lineStyle.color")), t.label = { shape: { x: 0, y: 0, width: v, height: y, r: c.get("borderRadius") }, position: m.slice(), style: { text: u, textFont: p, textFill: d.getTextColor(), textPosition: "inside", fill: b, stroke: c.get("borderColor") || "transparent", lineWidth: c.get("borderWidth") || 0, shadowBlur: c.get("shadowBlur"), shadowColor: c.get("shadowColor"), shadowOffsetX: c.get("shadowOffsetX"), shadowOffsetY: c.get("shadowOffsetY") }, z2: 10 };
			}, h.getValueLabel = function (t, e, i, n, o) {
				var r = e.scale.getLabel(t, { precision: o.precision }),
				    s = o.formatter;if (s) {
					var l = { value: u.getAxisRawValue(e, t), seriesData: [] };a.each(n, function (t) {
						var e = i.getSeriesByIndex(t.seriesIndex),
						    n = t.dataIndexInside,
						    a = e && e.getDataParams(n);a && l.seriesData.push(a);
					}), a.isString(s) ? r = s.replace("{value}", r) : a.isFunction(s) && (r = s(l));
				}return r;
			}, h.getTransformedPosition = function (t, e, i) {
				var n = l.create();return l.rotate(n, n, i.rotation), l.translate(n, n, i.position), o.applyTransform([t.dataToCoord(e), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)], n);
			}, h.buildCartesianSingleLabelElOption = function (t, e, i, n, a, o) {
				var r = c.innerTextLayout(i.rotation, 0, i.labelDirection);i.labelMargin = a.get("label.margin"), h.buildLabelElOption(e, n, a, o, { position: h.getTransformedPosition(n.axis, t, i), align: r.textAlign, verticalAlign: r.textVerticalAlign });
			}, h.makeLineShape = function (t, e, i) {
				return i = i || 0, { x1: t[i], y1: t[1 - i], x2: e[i], y2: e[1 - i] };
			}, h.makeRectShape = function (t, e, i) {
				return i = i || 0, { x: t[i], y: t[1 - i], width: e[i], height: e[1 - i] };
			}, h.makeSectorShape = function (t, e, i, n, a, o) {
				return { cx: t, cy: e, r0: i, r: n, startAngle: a, endAngle: o, clockwise: !0 };
			}, t.exports = h;
		}, function (t, e, i) {
			var n = i(7),
			    a = i(1),
			    o = {},
			    r = ["x", "y", "z", "radius", "angle", "single"],
			    s = ["cartesian2d", "polar", "singleAxis"];o.isCoordSupported = function (t) {
				return a.indexOf(s, t) >= 0;
			}, o.createNameEach = function (t, e) {
				t = t.slice();var i = a.map(t, n.capitalFirst);e = (e || []).slice();var o = a.map(e, n.capitalFirst);return function (n, r) {
					a.each(t, function (t, a) {
						for (var s = { name: t, capital: i[a] }, l = 0; l < e.length; l++) {
							s[e[l]] = t + o[l];
						}n.call(r, s);
					});
				};
			}, o.eachAxisDim = o.createNameEach(r, ["axisIndex", "axis", "index", "id"]), o.createLinkedNodesFinder = function (t, e, i) {
				function n(t, e) {
					return a.indexOf(e.nodes, t) >= 0;
				}function o(t, n) {
					var o = !1;return e(function (e) {
						a.each(i(t, e) || [], function (t) {
							n.records[e.name][t] && (o = !0);
						});
					}), o;
				}function r(t, n) {
					n.nodes.push(t), e(function (e) {
						a.each(i(t, e) || [], function (t) {
							n.records[e.name][t] = !0;
						});
					});
				}return function (i) {
					function a(t) {
						!n(t, s) && o(t, s) && (r(t, s), l = !0);
					}var s = { nodes: [], records: {} };if (e(function (t) {
						s.records[t.name] = {};
					}), !i) return s;r(i, s);var l;do {
						l = !1, t(a);
					} while (l);return s;
				};
			}, t.exports = o;
		}, function (t, e, i) {
			var n = i(1);t.exports = { updateSelectedMap: function updateSelectedMap(t) {
					this._selectTargetMap = n.reduce(t || [], function (t, e) {
						return t.set(e.name, e), t;
					}, n.createHashMap());
				}, select: function select(t) {
					var e = this._selectTargetMap,
					    i = e.get(t),
					    n = this.get("selectedMode");"single" === n && e.each(function (t) {
						t.selected = !1;
					}), i && (i.selected = !0);
				}, unSelect: function unSelect(t) {
					var e = this._selectTargetMap.get(t);e && (e.selected = !1);
				}, toggleSelected: function toggleSelected(t) {
					var e = this._selectTargetMap.get(t);if (null != e) return this[e.selected ? "unSelect" : "select"](t), e.selected;
				}, isSelected: function isSelected(t) {
					var e = this._selectTargetMap.get(t);return e && e.selected;
				} };
		}, function (t, e, i) {
			function n(t) {
				a.defaultEmphasis(t.label, a.LABEL_OPTIONS);
			}var a = i(5),
			    o = i(1),
			    r = i(9),
			    s = i(7),
			    l = s.addCommas,
			    u = s.encodeHTML,
			    c = i(2).extendComponentModel({ type: "marker", dependencies: ["series", "grid", "polar", "geo"], init: function init(t, e, i, n) {
					this.mergeDefaultAndTheme(t, i), this.mergeOption(t, i, n.createdBySelf, !0);
				}, isAnimationEnabled: function isAnimationEnabled() {
					if (r.node) return !1;var t = this.__hostSeries;return this.getShallow("animation") && t && t.isAnimationEnabled();
				}, mergeOption: function mergeOption(t, e, i, a) {
					var r = this.constructor,
					    s = this.mainType + "Model";i || e.eachSeries(function (t) {
						var i = t.get(this.mainType),
						    l = t[s];return i && i.data ? (l ? l.mergeOption(i, e, !0) : (a && n(i), o.each(i.data, function (t) {
							t instanceof Array ? (n(t[0]), n(t[1])) : n(t);
						}), l = new r(i, this, e), o.extend(l, { mainType: this.mainType, seriesIndex: t.seriesIndex, name: t.name, createdBySelf: !0 }), l.__hostSeries = t), void (t[s] = l)) : void (t[s] = null);
					}, this);
				}, formatTooltip: function formatTooltip(t) {
					var e = this.getData(),
					    i = this.getRawValue(t),
					    n = o.isArray(i) ? o.map(i, l).join(", ") : l(i),
					    a = e.getName(t),
					    r = u(this.name);return (null != i || a) && (r += "<br />"), a && (r += u(a), null != i && (r += " : ")), null != i && (r += u(n)), r;
				}, getData: function getData() {
					return this._data;
				}, setData: function setData(t) {
					this._data = t;
				} });o.mixin(c, a.dataFormatMixin), t.exports = c;
		}, function (t, e, i) {
			var n = i(1);t.exports = i(2).extendComponentView({ type: "marker", init: function init() {
					this.markerGroupMap = n.createHashMap();
				}, render: function render(t, e, i) {
					var n = this.markerGroupMap;n.each(function (t) {
						t.__keep = !1;
					});var a = this.type + "Model";e.eachSeries(function (t) {
						var n = t[a];n && this.renderSeries(t, n, e, i);
					}, this), n.each(function (t) {
						!t.__keep && this.group.remove(t.group);
					}, this);
				}, renderSeries: function renderSeries() {} });
		}, function (t, e, i) {
			function n(t) {
				return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y)));
			}function a(t) {
				return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y));
			}function o(t, e, i) {
				var n = -1;do {
					n = Math.max(l.getPrecision(t.get(e, i)), n), t = t.stackedOn;
				} while (t);return n;
			}function r(t, e, i, n, a, r) {
				var s = [],
				    l = m(e, n, t),
				    u = e.indicesOfNearest(n, l, !0)[0];s[a] = e.get(i, u, !0), s[r] = e.get(n, u, !0);var c = o(e, n, u);return c >= 0 && (s[r] = +s[r].toFixed(c)), s;
			}var s = i(1),
			    l = i(4),
			    u = s.indexOf,
			    c = s.curry,
			    h = { min: c(r, "min"), max: c(r, "max"), average: c(r, "average") },
			    d = function d(t, e) {
				var i = t.getData(),
				    n = t.coordinateSystem;if (e && !a(e) && !s.isArray(e.coord) && n) {
					var o = n.dimensions,
					    r = f(e, i, n, t);if (e = s.clone(e), e.type && h[e.type] && r.baseAxis && r.valueAxis) {
						var l = u(o, r.baseAxis.dim),
						    c = u(o, r.valueAxis.dim);e.coord = h[e.type](i, r.baseDataDim, r.valueDataDim, l, c), e.value = e.coord[c];
					} else {
						for (var d = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis], p = 0; p < 2; p++) {
							if (h[d[p]]) {
								var g = t.coordDimToDataDim(o[p])[0];d[p] = m(i, g, d[p]);
							}
						}e.coord = d;
					}
				}return e;
			},
			    f = function f(t, e, i, n) {
				var a = {};return null != t.valueIndex || null != t.valueDim ? (a.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, a.valueAxis = i.getAxis(n.dataDimToCoordDim(a.valueDataDim)), a.baseAxis = i.getOtherAxis(a.valueAxis), a.baseDataDim = n.coordDimToDataDim(a.baseAxis.dim)[0]) : (a.baseAxis = n.getBaseAxis(), a.valueAxis = i.getOtherAxis(a.baseAxis), a.baseDataDim = n.coordDimToDataDim(a.baseAxis.dim)[0], a.valueDataDim = n.coordDimToDataDim(a.valueAxis.dim)[0]), a;
			},
			    p = function p(t, e) {
				return !(t && t.containData && e.coord && !n(e)) || t.containData(e.coord);
			},
			    g = function g(t, e, i, n) {
				return n < 2 ? t.coord && t.coord[n] : t.value;
			},
			    m = function m(t, e, i) {
				if ("average" === i) {
					var n = 0,
					    a = 0;return t.each(e, function (t, e) {
						isNaN(t) || (n += t, a++);
					}, !0), n / a;
				}return t.getDataExtent(e, !0)["max" === i ? 1 : 0];
			};t.exports = { dataTransform: d, dataFilter: p, dimValueGetter: g, getAxisInfo: f, numCalculate: m };
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return t.get("stack") || d + t.seriesIndex;
			}function a(t) {
				return t.dim + t.index;
			}function o(t, e) {
				var i = [],
				    n = t.axis,
				    a = "axis0";if ("category" === n.type) {
					for (var o = n.getBandWidth(), r = 0; r < t.count; r++) {
						i.push(u.defaults({ bandWidth: o, axisKey: a, stackId: d + r }, t));
					}for (var l = s(i, e), c = [], r = 0; r < t.count; r++) {
						var h = l[a][d + r];h.offsetCenter = h.offset + h.width / 2, c.push(h);
					}return c;
				}
			}function r(t, e) {
				var i = u.map(t, function (t) {
					var e = t.getData(),
					    i = t.coordinateSystem,
					    o = i.getBaseAxis(),
					    r = o.getExtent(),
					    s = "category" === o.type ? o.getBandWidth() : Math.abs(r[1] - r[0]) / e.count(),
					    l = h(t.get("barWidth"), s),
					    u = h(t.get("barMaxWidth"), s),
					    c = t.get("barGap"),
					    d = t.get("barCategoryGap");return { bandWidth: s, barWidth: l, barMaxWidth: u, barGap: c, barCategoryGap: d, axisKey: a(o), stackId: n(t) };
				});return s(i, e);
			}function s(t, e) {
				var i = {};u.each(t, function (t, e) {
					var n = t.axisKey,
					    a = t.bandWidth,
					    o = i[n] || { bandWidth: a, remainedWidth: a, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {} },
					    r = o.stacks;i[n] = o;var s = t.stackId;r[s] || o.autoWidthCount++, r[s] = r[s] || { width: 0, maxWidth: 0 };var l = t.barWidth;l && !r[s].width && (l = Math.min(o.remainedWidth, l), r[s].width = l, o.remainedWidth -= l);var u = t.barMaxWidth;u && (r[s].maxWidth = u);var c = t.barGap;null != c && (o.gap = c);var h = t.barCategoryGap;null != h && (o.categoryGap = h);
				});var n = {};return u.each(i, function (t, e) {
					n[e] = {};var i = t.stacks,
					    a = t.bandWidth,
					    o = h(t.categoryGap, a),
					    r = h(t.gap, 1),
					    s = t.remainedWidth,
					    l = t.autoWidthCount,
					    c = (s - o) / (l + (l - 1) * r);c = Math.max(c, 0), u.each(i, function (t, e) {
						var i = t.maxWidth;i && i < c && (i = Math.min(i, s), t.width && (i = Math.min(i, t.width)), s -= i, t.width = i, l--);
					}), c = (s - o) / (l + (l - 1) * r), c = Math.max(c, 0);var d,
					    f = 0;u.each(i, function (t, e) {
						t.width || (t.width = c), d = t, f += t.width * (1 + r);
					}), d && (f -= d.width * r);var p = -f / 2;u.each(i, function (t, i) {
						n[e][i] = n[e][i] || { offset: p, width: t.width }, p += t.width * (1 + r);
					});
				}), n;
			}function l(t, e, i) {
				var o = r(u.filter(e.getSeriesByType(t), function (t) {
					return !e.isSeriesFiltered(t) && t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type;
				})),
				    s = {},
				    l = {};e.eachSeriesByType(t, function (t) {
					if ("cartesian2d" === t.coordinateSystem.type) {
						var e = t.getData(),
						    i = t.coordinateSystem,
						    r = i.getBaseAxis(),
						    u = n(t),
						    c = o[a(r)][u],
						    h = c.offset,
						    d = c.width,
						    f = i.getOtherAxis(r),
						    p = t.get("barMinHeight") || 0,
						    g = r.onZero ? f.toGlobalCoord(f.dataToCoord(0)) : f.getGlobalExtent()[0],
						    m = i.dataToPoints(e, !0);s[u] = s[u] || [], l[u] = l[u] || [], e.setLayout({ offset: h, size: d }), e.each(f.dim, function (t, i) {
							if (!isNaN(t)) {
								s[u][i] || (s[u][i] = { p: g, n: g }, l[u][i] = { p: g, n: g });var n,
								    a,
								    o,
								    r,
								    c = t >= 0 ? "p" : "n",
								    v = m[i],
								    y = s[u][i][c],
								    x = l[u][i][c];f.isHorizontal() ? (n = y, a = v[1] + h, o = v[0] - x, r = d, l[u][i][c] += o, Math.abs(o) < p && (o = (o < 0 ? -1 : 1) * p), s[u][i][c] += o) : (n = v[0] + h, a = y, o = d, r = v[1] - x, l[u][i][c] += r, Math.abs(r) < p && (r = (r <= 0 ? -1 : 1) * p), s[u][i][c] += r), e.setItemLayout(i, { x: n, y: a, width: o, height: r });
							}
						}, !0);
					}
				}, this);
			}var u = i(1),
			    c = i(4),
			    h = c.parsePercent,
			    d = "__ec_stack_";l.getLayoutOnAxis = o, t.exports = l;
		}, function (t, e, i) {
			function n(t) {
				var e = t.pieceList;t.hasSpecialVisual = !1, g.each(e, function (e, i) {
					e.originIndex = i, null != e.visual && (t.hasSpecialVisual = !0);
				});
			}function a(t) {
				var e = t.categories,
				    i = t.visual,
				    n = t.categoryMap = {};if (y(e, function (t, e) {
					n[t] = e;
				}), !g.isArray(i)) {
					var a = [];g.isObject(i) ? y(i, function (t, e) {
						var i = n[e];a[null != i ? i : _] = t;
					}) : a[_] = i, i = f(t, a);
				}for (var o = e.length - 1; o >= 0; o--) {
					null == i[o] && (delete n[e[o]], e.pop());
				}
			}function o(t, e) {
				var i = t.visual,
				    n = [];g.isObject(i) ? y(i, function (t) {
					n.push(t);
				}) : null != i && n.push(i);var a = { color: 1, symbol: 1 };e || 1 !== n.length || a.hasOwnProperty(t.type) || (n[1] = n[0]), f(t, n);
			}function r(t) {
				return { applyVisual: function applyVisual(e, i, n) {
						e = this.mapValueToVisual(e), n("color", t(i("color"), e));
					}, _doMap: h([0, 1]) };
			}function s(t) {
				var e = this.option.visual;return e[Math.round(v(t, [0, 1], [0, e.length - 1], !0))] || {};
			}function l(t) {
				return function (e, i, n) {
					n(t, this.mapValueToVisual(e));
				};
			}function u(t) {
				var e = this.option.visual;return e[this.option.loop && t !== _ ? t % e.length : t];
			}function c() {
				return this.option.visual[0];
			}function h(t) {
				return { linear: function linear(e) {
						return v(e, t, this.option.visual, !0);
					}, category: u, piecewise: function piecewise(e, i) {
						var n = d.call(this, i);return null == n && (n = v(e, t, this.option.visual, !0)), n;
					}, fixed: c };
			}function d(t) {
				var e = this.option,
				    i = e.pieceList;if (e.hasSpecialVisual) {
					var n = b.findPieceIndex(t, i),
					    a = i[n];if (a && a.visual) return a.visual[this.type];
				}
			}function f(t, e) {
				return t.visual = e, "color" === t.type && (t.parsedVisual = g.map(e, function (t) {
					return m.parse(t);
				})), e;
			}function p(t, e, i) {
				return t ? e <= i : e < i;
			}var g = i(1),
			    m = i(22),
			    v = i(4).linearMap,
			    y = g.each,
			    x = g.isObject,
			    _ = -1,
			    b = function b(t) {
				var e = t.mappingMethod,
				    i = t.type,
				    r = this.option = g.clone(t);this.type = i, this.mappingMethod = e, this._normalizeData = S[e];var s = w[i];this.applyVisual = s.applyVisual, this.getColorMapper = s.getColorMapper, this._doMap = s._doMap[e], "piecewise" === e ? (o(r), n(r)) : "category" === e ? r.categories ? a(r) : o(r, !0) : (g.assert("linear" !== e || r.dataExtent), o(r));
			};b.prototype = { constructor: b, mapValueToVisual: function mapValueToVisual(t) {
					var e = this._normalizeData(t);return this._doMap(e, t);
				}, getNormalizer: function getNormalizer() {
					return g.bind(this._normalizeData, this);
				} };var w = b.visualHandlers = { color: { applyVisual: l("color"), getColorMapper: function getColorMapper() {
						var t = this.option;return g.bind("category" === t.mappingMethod ? function (t, e) {
							return !e && (t = this._normalizeData(t)), u.call(this, t);
						} : function (e, i, n) {
							var a = !!n;return !i && (e = this._normalizeData(e)), n = m.fastMapToColor(e, t.parsedVisual, n), a ? n : m.stringify(n, "rgba");
						}, this);
					}, _doMap: { linear: function linear(t) {
							return m.stringify(m.fastMapToColor(t, this.option.parsedVisual), "rgba");
						}, category: u, piecewise: function piecewise(t, e) {
							var i = d.call(this, e);return null == i && (i = m.stringify(m.fastMapToColor(t, this.option.parsedVisual), "rgba")), i;
						}, fixed: c } }, colorHue: r(function (t, e) {
					return m.modifyHSL(t, e);
				}), colorSaturation: r(function (t, e) {
					return m.modifyHSL(t, null, e);
				}), colorLightness: r(function (t, e) {
					return m.modifyHSL(t, null, null, e);
				}), colorAlpha: r(function (t, e) {
					return m.modifyAlpha(t, e);
				}), opacity: { applyVisual: l("opacity"), _doMap: h([0, 1]) }, symbol: { applyVisual: function applyVisual(t, e, i) {
						var n = this.mapValueToVisual(t);if (g.isString(n)) i("symbol", n);else if (x(n)) for (var a in n) {
							n.hasOwnProperty(a) && i(a, n[a]);
						}
					}, _doMap: { linear: s, category: u, piecewise: function piecewise(t, e) {
							var i = d.call(this, e);return null == i && (i = s.call(this, t)), i;
						}, fixed: c } }, symbolSize: { applyVisual: l("symbolSize"), _doMap: h([0, 1]) } },
			    S = { linear: function linear(t) {
					return v(t, this.option.dataExtent, [0, 1], !0);
				}, piecewise: function piecewise(t) {
					var e = this.option.pieceList,
					    i = b.findPieceIndex(t, e, !0);if (null != i) return v(i, [0, e.length - 1], [0, 1], !0);
				}, category: function category(t) {
					var e = this.option.categories ? this.option.categoryMap[t] : t;return null == e ? _ : e;
				}, fixed: g.noop };b.listVisualTypes = function () {
				var t = [];return g.each(w, function (e, i) {
					t.push(i);
				}), t;
			}, b.addVisualHandler = function (t, e) {
				w[t] = e;
			}, b.isValidType = function (t) {
				return w.hasOwnProperty(t);
			}, b.eachVisual = function (t, e, i) {
				g.isObject(t) ? g.each(t, e, i) : e.call(i, t);
			}, b.mapVisual = function (t, e, i) {
				var n,
				    a = g.isArray(t) ? [] : g.isObject(t) ? {} : (n = !0, null);return b.eachVisual(t, function (t, o) {
					var r = e.call(i, t, o);n ? a = r : a[o] = r;
				}), a;
			}, b.retrieveVisuals = function (t) {
				var e,
				    i = {};return t && y(w, function (n, a) {
					t.hasOwnProperty(a) && (i[a] = t[a], e = !0);
				}), e ? i : null;
			}, b.prepareVisualTypes = function (t) {
				if (x(t)) {
					var e = [];y(t, function (t, i) {
						e.push(i);
					}), t = e;
				} else {
					if (!g.isArray(t)) return [];t = t.slice();
				}return t.sort(function (t, e) {
					return "color" === e && "color" !== t && 0 === t.indexOf("color") ? 1 : -1;
				}), t;
			}, b.dependsOn = function (t, e) {
				return "color" === e ? !(!t || 0 !== t.indexOf(e)) : t === e;
			}, b.findPieceIndex = function (t, e, i) {
				function n(e, i) {
					var n = Math.abs(e - t);n < o && (o = n, a = i);
				}for (var a, o = 1 / 0, r = 0, s = e.length; r < s; r++) {
					var l = e[r].value;if (null != l) {
						if (l === t || "string" == typeof l && l === t + "") return r;i && n(l, r);
					}
				}for (var r = 0, s = e.length; r < s; r++) {
					var u = e[r],
					    c = u.interval,
					    h = u.close;if (c) {
						if (c[0] === -(1 / 0)) {
							if (p(h[1], t, c[1])) return r;
						} else if (c[1] === 1 / 0) {
							if (p(h[0], c[0], t)) return r;
						} else if (p(h[0], c[0], t) && p(h[1], t, c[1])) return r;i && n(c[0], r), i && n(c[1], r);
					}
				}if (i) return t === 1 / 0 ? e.length - 1 : t === -(1 / 0) ? 0 : a;
			}, t.exports = b;
		}, function (t, e) {
			t.exports = function (t, e) {
				var i = {};e.eachRawSeriesByType(t, function (t) {
					var n = t.getRawData(),
					    a = {};if (!e.isSeriesFiltered(t)) {
						var o = t.getData();o.each(function (t) {
							var e = o.getRawIndex(t);a[e] = t;
						}), n.each(function (e) {
							var r = a[e],
							    s = null != r && o.getItemVisual(r, "color", !0);if (s) n.setItemVisual(e, "color", s);else {
								var l = n.getItemModel(e),
								    u = l.get("itemStyle.normal.color") || t.getColorFromPalette(n.getName(e), i);n.setItemVisual(e, "color", u), null != r && o.setItemVisual(r, "color", u);
							}
						});
					}
				});
			};
		}, function (t, e, i) {
			var n = i(6),
			    a = i(20),
			    o = {},
			    r = Math.min,
			    s = Math.max,
			    l = Math.sin,
			    u = Math.cos,
			    c = n.create(),
			    h = n.create(),
			    d = n.create(),
			    f = 2 * Math.PI;o.fromPoints = function (t, e, i) {
				if (0 !== t.length) {
					var n,
					    a = t[0],
					    o = a[0],
					    l = a[0],
					    u = a[1],
					    c = a[1];for (n = 1; n < t.length; n++) {
						a = t[n], o = r(o, a[0]), l = s(l, a[0]), u = r(u, a[1]), c = s(c, a[1]);
					}e[0] = o, e[1] = u, i[0] = l, i[1] = c;
				}
			}, o.fromLine = function (t, e, i, n, a, o) {
				a[0] = r(t, i), a[1] = r(e, n), o[0] = s(t, i), o[1] = s(e, n);
			};var p = [],
			    g = [];o.fromCubic = function (t, e, i, n, o, l, u, c, h, d) {
				var f,
				    m = a.cubicExtrema,
				    v = a.cubicAt,
				    y = m(t, i, o, u, p);for (h[0] = 1 / 0, h[1] = 1 / 0, d[0] = -(1 / 0), d[1] = -(1 / 0), f = 0; f < y; f++) {
					var x = v(t, i, o, u, p[f]);h[0] = r(x, h[0]), d[0] = s(x, d[0]);
				}for (y = m(e, n, l, c, g), f = 0; f < y; f++) {
					var _ = v(e, n, l, c, g[f]);h[1] = r(_, h[1]), d[1] = s(_, d[1]);
				}h[0] = r(t, h[0]), d[0] = s(t, d[0]), h[0] = r(u, h[0]), d[0] = s(u, d[0]), h[1] = r(e, h[1]), d[1] = s(e, d[1]), h[1] = r(c, h[1]), d[1] = s(c, d[1]);
			}, o.fromQuadratic = function (t, e, i, n, o, l, u, c) {
				var h = a.quadraticExtremum,
				    d = a.quadraticAt,
				    f = s(r(h(t, i, o), 1), 0),
				    p = s(r(h(e, n, l), 1), 0),
				    g = d(t, i, o, f),
				    m = d(e, n, l, p);u[0] = r(t, o, g), u[1] = r(e, l, m), c[0] = s(t, o, g), c[1] = s(e, l, m);
			}, o.fromArc = function (t, e, i, a, o, r, s, p, g) {
				var m = n.min,
				    v = n.max,
				    y = Math.abs(o - r);if (y % f < 1e-4 && y > 1e-4) return p[0] = t - i, p[1] = e - a, g[0] = t + i, void (g[1] = e + a);if (c[0] = u(o) * i + t, c[1] = l(o) * a + e, h[0] = u(r) * i + t, h[1] = l(r) * a + e, m(p, c, h), v(g, c, h), o %= f, o < 0 && (o += f), r %= f, r < 0 && (r += f), o > r && !s ? r += f : o < r && s && (o += f), s) {
					var x = r;r = o, o = x;
				}for (var _ = 0; _ < r; _ += Math.PI / 2) {
					_ > o && (d[0] = u(_) * i + t, d[1] = l(_) * a + e, m(p, d, p), v(g, d, g));
				}
			}, t.exports = o;
		}, function (t, e, i) {
			var n = i(38),
			    a = i(1),
			    o = i(16),
			    r = function r(t) {
				n.call(this, t);
			};r.prototype = { constructor: r, type: "text", brush: function brush(t, e) {
					var i = this.style,
					    n = i.x || 0,
					    a = i.y || 0,
					    r = i.text;if (null != r && (r += ""), i.bind(t, this, e), r) {
						this.setTransform(t);var s,
						    l = i.textAlign,
						    u = i.textFont || i.font;if (i.textVerticalAlign) {
							var c = o.getBoundingRect(r, u, i.textAlign, "top");switch (s = "middle", i.textVerticalAlign) {case "middle":
									a -= c.height / 2 - c.lineHeight / 2;break;case "bottom":
									a -= c.height - c.lineHeight / 2;break;default:
									a += c.lineHeight / 2;}
						} else s = i.textBaseline;t.font = u || "12px sans-serif", t.textAlign = l || "left", t.textAlign !== l && (t.textAlign = "left"), t.textBaseline = s || "alphabetic", t.textBaseline !== s && (t.textBaseline = "alphabetic");for (var h = o.measureText("", t.font).width, d = r.split("\n"), f = 0; f < d.length; f++) {
							i.hasStroke() && t.strokeText(d[f], n, a), i.hasFill() && t.fillText(d[f], n, a), a += h;
						}this.restoreTransform(t);
					}
				}, getBoundingRect: function getBoundingRect() {
					var t = this.style;if (!this._rect) {
						var e = t.textVerticalAlign,
						    i = o.getBoundingRect(t.text + "", t.textFont || t.font, t.textAlign, e ? "top" : t.textBaseline);switch (e) {case "middle":
								i.y -= i.height / 2;break;case "bottom":
								i.y -= i.height;}if (i.x += t.x || 0, i.y += t.y || 0, t.hasStroke()) {
							var n = t.lineWidth;i.x -= n / 2, i.y -= n / 2, i.width += n, i.height += n;
						}this._rect = i;
					}return this._rect;
				} }, a.inherits(r, n), t.exports = r;
		}, function (t, e, i) {
			function n(t, e) {
				return "string" == typeof t ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t;
			}var a = i(16),
			    o = i(11),
			    r = new o(),
			    s = function s() {};s.prototype = { constructor: s, drawRectText: function drawRectText(t, e, i) {
					var o = this.style,
					    s = o.text;if (null != s && (s += ""), s) {
						t.save();var l,
						    u,
						    c = o.textPosition,
						    h = o.textOffset,
						    d = o.textDistance,
						    f = o.textAlign,
						    p = o.textFont || o.font,
						    g = o.textBaseline,
						    m = o.textVerticalAlign;i = i || a.getBoundingRect(s, p, f, g);var v = this.transform;if (o.textTransform ? this.setTransform(t) : v && (r.copy(e), r.applyTransform(v), e = r), c instanceof Array) {
							if (l = e.x + n(c[0], e.width), u = e.y + n(c[1], e.height), f = f || "left", g = g || "top", m) {
								switch (m) {case "middle":
										u -= i.height / 2 - i.lineHeight / 2;break;case "bottom":
										u -= i.height - i.lineHeight / 2;break;default:
										u += i.lineHeight / 2;}g = "middle";
							}
						} else {
							var y = a.adjustTextPositionOnRect(c, e, i, d);l = y.x, u = y.y, f = f || y.textAlign, g = g || y.textBaseline;
						}h && (l += h[0], u += h[1]), t.textAlign = f || "left", t.textBaseline = g || "alphabetic";var x = o.textFill,
						    _ = o.textStroke;x && (t.fillStyle = x), _ && (t.strokeStyle = _), t.font = p || "12px sans-serif", t.shadowBlur = o.textShadowBlur, t.shadowColor = o.textShadowColor || "transparent", t.shadowOffsetX = o.textShadowOffsetX, t.shadowOffsetY = o.textShadowOffsetY;var b = s.split("\n");o.textRotation && (v && t.translate(v[4], v[5]), t.rotate(o.textRotation), v && t.translate(-v[4], -v[5]));for (var w = 0; w < b.length; w++) {
							_ && t.strokeText(b[w], l, u), x && t.fillText(b[w], l, u), u += i.lineHeight;
						}t.restore();
					}
				} }, t.exports = s;
		}, function (t, e, i) {
			function n(t) {
				delete f[t];
			} /*!
	    * ZRender, a high performance 2d drawing library.
	    *
	    * Copyright (c) 2013, Baidu Inc.
	    * All rights reserved.
	    *
	    * LICENSE
	    * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	    */
			var a = i(71),
			    o = i(9),
			    r = i(1),
			    s = i(152),
			    l = i(155),
			    u = i(156),
			    c = i(163),
			    h = !o.canvasSupported,
			    d = { canvas: i(154) },
			    f = {},
			    p = {};p.version = "3.5.1", p.init = function (t, e) {
				var i = new g(a(), t, e);return f[i.id] = i, i;
			}, p.dispose = function (t) {
				if (t) t.dispose();else {
					for (var e in f) {
						f.hasOwnProperty(e) && f[e].dispose();
					}f = {};
				}return p;
			}, p.getInstance = function (t) {
				return f[t];
			}, p.registerPainter = function (t, e) {
				d[t] = e;
			};var g = function g(t, e, i) {
				i = i || {}, this.dom = e, this.id = t;var n = this,
				    a = new l(),
				    f = i.renderer;if (h) {
					if (!d.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8");f = "vml";
				} else f && d[f] || (f = "canvas");var p = new d[f](e, a, i);this.storage = a, this.painter = p;var g = o.node ? null : new c(p.getViewportRoot());this.handler = new s(a, p, g, p.root), this.animation = new u({ stage: { update: r.bind(this.flush, this) } }), this.animation.start(), this._needsRefresh;var m = a.delFromStorage,
				    v = a.addToStorage;a.delFromStorage = function (t) {
					m.call(a, t), t && t.removeSelfFromZr(n);
				}, a.addToStorage = function (t) {
					v.call(a, t), t.addSelfToZr(n);
				};
			};g.prototype = { constructor: g, getId: function getId() {
					return this.id;
				}, add: function add(t) {
					this.storage.addRoot(t), this._needsRefresh = !0;
				}, remove: function remove(t) {
					this.storage.delRoot(t), this._needsRefresh = !0;
				}, configLayer: function configLayer(t, e) {
					this.painter.configLayer(t, e), this._needsRefresh = !0;
				}, refreshImmediately: function refreshImmediately() {
					this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1;
				}, refresh: function refresh() {
					this._needsRefresh = !0;
				}, flush: function flush() {
					this._needsRefresh && this.refreshImmediately(), this._needsRefreshHover && this.refreshHoverImmediately();
				}, addHover: function addHover(t, e) {
					this.painter.addHover && (this.painter.addHover(t, e), this.refreshHover());
				}, removeHover: function removeHover(t) {
					this.painter.removeHover && (this.painter.removeHover(t), this.refreshHover());
				}, clearHover: function clearHover() {
					this.painter.clearHover && (this.painter.clearHover(), this.refreshHover());
				}, refreshHover: function refreshHover() {
					this._needsRefreshHover = !0;
				}, refreshHoverImmediately: function refreshHoverImmediately() {
					this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover();
				}, resize: function resize(t) {
					t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize();
				}, clearAnimation: function clearAnimation() {
					this.animation.clear();
				}, getWidth: function getWidth() {
					return this.painter.getWidth();
				}, getHeight: function getHeight() {
					return this.painter.getHeight();
				}, pathToImage: function pathToImage(t, e) {
					return this.painter.pathToImage(t, e);
				}, setCursorStyle: function setCursorStyle(t) {
					this.handler.setCursorStyle(t);
				}, findHover: function findHover(t, e) {
					return this.handler.findHover(t, e);
				}, on: function on(t, e, i) {
					this.handler.on(t, e, i);
				}, off: function off(t, e) {
					this.handler.off(t, e);
				}, trigger: function trigger(t, e) {
					this.handler.trigger(t, e);
				}, clear: function clear() {
					this.storage.delRoot(), this.painter.clear();
				}, dispose: function dispose() {
					this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, n(this.id);
				} }, t.exports = p;
		}, function (t, e, i) {
			var n = i(2),
			    a = i(1);t.exports = function (t, e) {
				a.each(e, function (e) {
					e.update = "updateView", n.registerAction(e, function (i, n) {
						var a = {};return n.eachComponent({ mainType: "series", subType: t, query: i }, function (t) {
							t[e.method] && t[e.method](i.name);var n = t.getData();n.each(function (e) {
								var i = n.getName(e);a[i] = t.isSelected(i) || !1;
							});
						}), { name: i.name, selected: a };
					});
				});
			};
		}, function (t, e, i) {
			"use strict";
			var n = i(17),
			    a = i(28);t.exports = n.extend({ type: "series.__base_bar__", getInitialData: function getInitialData(t, e) {
					return a(t.data, this, e);
				}, getMarkerPosition: function getMarkerPosition(t) {
					var e = this.coordinateSystem;if (e) {
						var i = e.dataToPoint(t, !0),
						    n = this.getData(),
						    a = n.getLayout("offset"),
						    o = n.getLayout("size"),
						    r = e.getBaseAxis().isHorizontal() ? 0 : 1;return i[r] += a + o / 2, i;
					}return [NaN, NaN];
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, barMinHeight: 0, barMinAngle: 0, itemStyle: { normal: {}, emphasis: {} } } });
		}, function (t, e, i) {
			function n(t, e, i, n, a) {
				o.setText(t, e, i), t.text = n, "outside" === t.textPosition && (t.textPosition = a);
			}var a = i(1),
			    o = i(3),
			    r = {};r.setLabel = function (t, e, i, o, r, s, l) {
				var u = i.getModel("label.normal"),
				    c = i.getModel("label.emphasis");u.get("show") ? n(t, u, o, a.retrieve(r.getFormattedLabel(s, "normal"), r.getRawValue(s)), l) : t.text = "", c.get("show") ? n(e, c, o, a.retrieve(r.getFormattedLabel(s, "emphasis"), r.getRawValue(s)), l) : e.text = "";
			}, t.exports = r;
		}, function (t, e, i) {
			var n = i(3),
			    a = i(1),
			    o = i(5),
			    r = {};r.findLabelValueDim = function (t) {
				var e,
				    i = o.otherDimToDataDim(t, "label");if (i.length) e = i[0];else for (var n, a = t.dimensions.slice(); a.length && (e = a.pop(), n = t.getDimensionInfo(e).type, "ordinal" === n || "time" === n);) {}return e;
			}, r.setTextToStyle = function (t, e, i, o, r, s, l) {
				null != i && s.getShallow("show") ? (n.setText(o, s, l), o.text = a.retrieve(r.getFormattedLabel(e, "normal"), t.get(i, e))) : o.text = "";
			}, t.exports = r;
		}, function (t, e, i) {
			function n(t) {
				return isNaN(t[0]) || isNaN(t[1]);
			}function a(t, e, i, a, o, r, g, m, v, y, x) {
				for (var _ = 0, b = i, w = 0; w < a; w++) {
					var S = e[b];if (b >= o || b < 0) break;if (n(S)) {
						if (x) {
							b += r;continue;
						}break;
					}if (b === i) t[r > 0 ? "moveTo" : "lineTo"](S[0], S[1]), h(f, S);else if (v > 0) {
						var M = b + r,
						    I = e[M];if (x) for (; I && n(e[M]);) {
							M += r, I = e[M];
						}var T = .5,
						    A = e[_],
						    I = e[M];if (!I || n(I)) h(p, S);else {
							n(I) && !x && (I = S), s.sub(d, I, A);var C, L;if ("x" === y || "y" === y) {
								var D = "x" === y ? 0 : 1;C = Math.abs(S[D] - A[D]), L = Math.abs(S[D] - I[D]);
							} else C = s.dist(S, A), L = s.dist(S, I);T = L / (L + C), c(p, S, d, -v * (1 - T));
						}l(f, f, m), u(f, f, g), l(p, p, m), u(p, p, g), t.bezierCurveTo(f[0], f[1], p[0], p[1], S[0], S[1]), c(f, S, d, v * T);
					} else t.lineTo(S[0], S[1]);_ = b, b += r;
				}return w;
			}function o(t, e) {
				var i = [1 / 0, 1 / 0],
				    n = [-(1 / 0), -(1 / 0)];if (e) for (var a = 0; a < t.length; a++) {
					var o = t[a];o[0] < i[0] && (i[0] = o[0]), o[1] < i[1] && (i[1] = o[1]), o[0] > n[0] && (n[0] = o[0]), o[1] > n[1] && (n[1] = o[1]);
				}return { min: e ? i : n, max: e ? n : i };
			}var r = i(8),
			    s = i(6),
			    l = s.min,
			    u = s.max,
			    c = s.scaleAndAdd,
			    h = s.copy,
			    d = [],
			    f = [],
			    p = [];t.exports = { Polyline: r.extend({ type: "ec-polyline", shape: { points: [], smooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1 }, style: { fill: null, stroke: "#000" }, buildPath: function buildPath(t, e) {
						var i = e.points,
						    r = 0,
						    s = i.length,
						    l = o(i, e.smoothConstraint);if (e.connectNulls) {
							for (; s > 0 && n(i[s - 1]); s--) {}for (; r < s && n(i[r]); r++) {}
						}for (; r < s;) {
							r += a(t, i, r, s, s, 1, l.min, l.max, e.smooth, e.smoothMonotone, e.connectNulls) + 1;
						}
					} }), Polygon: r.extend({ type: "ec-polygon", shape: { points: [], stackedOnPoints: [], smooth: 0, stackedOnSmooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1 }, buildPath: function buildPath(t, e) {
						var i = e.points,
						    r = e.stackedOnPoints,
						    s = 0,
						    l = i.length,
						    u = e.smoothMonotone,
						    c = o(i, e.smoothConstraint),
						    h = o(r, e.smoothConstraint);if (e.connectNulls) {
							for (; l > 0 && n(i[l - 1]); l--) {}for (; s < l && n(i[s]); s++) {}
						}for (; s < l;) {
							var d = a(t, i, s, l, l, 1, c.min, c.max, e.smooth, u, e.connectNulls);a(t, r, s + d - 1, d, l, -1, h.min, h.max, e.stackedOnSmooth, u, e.connectNulls), s += d + 1, t.closePath();
						}
					} }) };
		}, function (t, e, i) {
			var n = i(1),
			    a = { retrieveTargetInfo: function retrieveTargetInfo(t, e) {
					if (t && ("treemapZoomToNode" === t.type || "treemapRootToNode" === t.type)) {
						var i = e.getData().tree.root,
						    n = t.targetNode;if (n && i.contains(n)) return { node: n };var a = t.targetNodeId;if (null != a && (n = i.getNodeById(a))) return { node: n };
					}
				}, getPathToRoot: function getPathToRoot(t) {
					for (var e = []; t;) {
						t = t.parentNode, t && e.push(t);
					}return e.reverse();
				}, aboveViewRoot: function aboveViewRoot(t, e) {
					var i = a.getPathToRoot(t);return n.indexOf(i, e) >= 0;
				}, wrapTreePathInfo: function wrapTreePathInfo(t, e) {
					for (var i = []; t;) {
						var n = t.dataIndex;i.push({ name: t.name, dataIndex: n, value: e.getRawValue(n) }), t = t.parentNode;
					}return i.reverse(), i;
				} };t.exports = a;
		}, function (t, e, i) {
			function n(t) {
				this.pointerChecker, this._zr = t, this._opt = {};var e = d.bind,
				    i = e(a, this),
				    n = e(o, this),
				    u = e(r, this),
				    c = e(s, this),
				    f = e(l, this);h.call(this), this.setPointerChecker = function (t) {
					this.pointerChecker = t;
				}, this.enable = function (e, a) {
					this.disable(), this._opt = d.defaults(d.clone(a) || {}, { zoomOnMouseWheel: !0, moveOnMouseMove: !0, preventDefaultMouseMove: !0 }), null == e && (e = !0), e !== !0 && "move" !== e && "pan" !== e || (t.on("mousedown", i), t.on("mousemove", n), t.on("mouseup", u)), e !== !0 && "scale" !== e && "zoom" !== e || (t.on("mousewheel", c), t.on("pinch", f));
				}, this.disable = function () {
					t.off("mousedown", i), t.off("mousemove", n), t.off("mouseup", u), t.off("mousewheel", c), t.off("pinch", f);
				}, this.dispose = this.disable, this.isDragging = function () {
					return this._dragging;
				}, this.isPinching = function () {
					return this._pinching;
				};
			}function a(t) {
				if (!t.target || !t.target.draggable) {
					var e = t.offsetX,
					    i = t.offsetY;this.pointerChecker && this.pointerChecker(t, e, i) && (this._x = e, this._y = i, this._dragging = !0);
				}
			}function o(t) {
				if (c(this, "moveOnMouseMove", t) && this._dragging && "pinch" !== t.gestureEvent && !p.isTaken(this._zr, "globalPan")) {
					var e = t.offsetX,
					    i = t.offsetY,
					    n = this._x,
					    a = this._y,
					    o = e - n,
					    r = i - a;this._x = e, this._y = i, this._opt.preventDefaultMouseMove && f.stop(t.event), this.trigger("pan", o, r, n, a, e, i);
				}
			}function r(t) {
				this._dragging = !1;
			}function s(t) {
				if (c(this, "zoomOnMouseWheel", t) && 0 !== t.wheelDelta) {
					var e = t.wheelDelta > 0 ? 1.1 : 1 / 1.1;u.call(this, t, e, t.offsetX, t.offsetY);
				}
			}function l(t) {
				if (!p.isTaken(this._zr, "globalPan")) {
					var e = t.pinchScale > 1 ? 1.1 : 1 / 1.1;u.call(this, t, e, t.pinchX, t.pinchY);
				}
			}function u(t, e, i, n) {
				this.pointerChecker && this.pointerChecker(t, i, n) && (f.stop(t.event), this.trigger("zoom", e, i, n));
			}function c(t, e, i) {
				var n = t._opt[e];return n && (!d.isString(n) || i.event[n + "Key"]);
			}var h = i(23),
			    d = i(1),
			    f = i(21),
			    p = i(129);d.mixin(n, h), t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = { show: !0, zlevel: 0, z: 0, inverse: !1, name: "", nameLocation: "end", nameRotate: null, nameTruncate: { maxWidth: null, ellipsis: "...", placeholder: "." }, nameTextStyle: {}, nameGap: 15, silent: !1, triggerEvent: !1, tooltip: { show: !1 }, axisPointer: {}, axisLine: { show: !0, onZero: !0, lineStyle: { color: "#333", width: 1, type: "solid" } }, axisTick: { show: !0, inside: !1, length: 5, lineStyle: { width: 1 } }, axisLabel: { show: !0, inside: !1, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, textStyle: { fontSize: 12 } }, splitLine: { show: !0, lineStyle: { color: ["#ccc"], width: 1, type: "solid" } }, splitArea: { show: !1, areaStyle: { color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"] } } },
			    o = n.merge({ boundaryGap: !0, splitLine: { show: !1 }, axisTick: { alignWithLabel: !1, interval: "auto" }, axisLabel: { interval: "auto" } }, a),
			    r = n.merge({ boundaryGap: [0, 0], splitNumber: 5 }, a),
			    s = n.defaults({ scale: !0, min: "dataMin", max: "dataMax" }, r),
			    l = n.defaults({ scale: !0, logBase: 10 }, r);t.exports = { categoryAxis: o, valueAxis: r, timeAxis: s, logAxis: l };
		}, function (t, e) {
			t.exports = { containStroke: function containStroke(t, e, i, n, a, o, r) {
					if (0 === a) return !1;var s = a,
					    l = 0,
					    u = t;if (r > e + s && r > n + s || r < e - s && r < n - s || o > t + s && o > i + s || o < t - s && o < i - s) return !1;if (t === i) return Math.abs(o - t) <= s / 2;l = (e - n) / (t - i), u = (t * n - i * e) / (t - i);var c = l * o - r + u,
					    h = c * c / (l * l + 1);return h <= s / 2 * s / 2;
				} };
		}, function (t, e, i) {
			var n = i(20);t.exports = { containStroke: function containStroke(t, e, i, a, o, r, s, l, u) {
					if (0 === s) return !1;var c = s;if (u > e + c && u > a + c && u > r + c || u < e - c && u < a - c && u < r - c || l > t + c && l > i + c && l > o + c || l < t - c && l < i - c && l < o - c) return !1;var h = n.quadraticProjectPoint(t, e, i, a, o, r, l, u, null);return h <= c / 2;
				} };
		}, function (t, e) {
			t.exports = function (t, e, i, n, a, o) {
				if (o > e && o > n || o < e && o < n) return 0;if (n === e) return 0;var r = n < e ? 1 : -1,
				    s = (o - e) / (n - e);1 !== s && 0 !== s || (r = n < e ? .5 : -.5);var l = s * (i - t) + t;return l > a ? r : 0;
			};
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(39),
			    o = function o(t, e, i, n, _o, r) {
				this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == i ? 1 : i, this.y2 = null == n ? 0 : n, this.type = "linear", this.global = r || !1, a.call(this, _o);
			};o.prototype = { constructor: o }, n.inherits(o, a), t.exports = o;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				a.each(o, function (e) {
					this[e] = a.bind(t[e], t);
				}, this);
			}var a = i(1),
			    o = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"];t.exports = n;
		}, function (t, e, i) {
			var n = i(1);i(57), i(103), i(104);var a = i(82),
			    o = i(2);o.registerLayout(n.curry(a, "bar")), o.registerVisual(function (t) {
				t.eachSeriesByType("bar", function (t) {
					var e = t.getData();e.setVisual("legendSymbol", "roundRect");
				});
			}), i(32);
		}, function (t, e, i) {
			t.exports = i(90).extend({ type: "series.bar", dependencies: ["grid", "polar"], brushSelector: "rect" });
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				i.style.text = "", l.updateProps(i, { shape: { width: 0 } }, e, t, function () {
					i.parent && i.parent.remove(i);
				});
			}function a(t, e, i) {
				i.style.text = "", l.updateProps(i, { shape: { r: i.shape.r0 } }, e, t, function () {
					i.parent && i.parent.remove(i);
				});
			}function o(t, e, i, n, a, o, r, c) {
				var h = e.getItemVisual(i, "color"),
				    d = e.getItemVisual(i, "opacity"),
				    f = n.getModel("itemStyle.normal"),
				    p = n.getModel("itemStyle.emphasis").getBarItemStyle();!c && r && t.setShape("r", f.get("barBorderRadius") || 0), t.useStyle(s.defaults({ fill: h, opacity: d }, f.getBarItemStyle()));var g = r ? a.height > 0 ? "bottom" : "top" : a.width > 0 ? "left" : "right";c || u.setLabel(t.style, p, n, h, o, i, g), l.setHoverStyle(t, p);
			}function r(t, e) {
				var i = t.get(c) || 0;return Math.min(i, Math.abs(e.width), Math.abs(e.height));
			}var s = i(1),
			    l = i(3),
			    u = i(91),
			    c = ["itemStyle", "normal", "barBorderWidth"];s.extend(i(10).prototype, i(105));var h = i(2).extendChartView({ type: "bar", render: function render(t, e, i) {
					var n = t.get("coordinateSystem");return "cartesian2d" !== n && "polar" !== n || this._render(t, e, i), this.group;
				}, dispose: s.noop, _render: function _render(t, e, i) {
					var r,
					    s = this.group,
					    u = t.getData(),
					    c = this._data,
					    h = t.coordinateSystem,
					    p = h.getBaseAxis();"cartesian2d" === h.type ? r = p.isHorizontal() : "polar" === h.type && (r = "angle" === p.dim);var g = t.isAnimationEnabled() ? t : null;u.diff(c).add(function (e) {
						if (u.hasValue(e)) {
							var i = u.getItemModel(e),
							    n = f[h.type](u, e, i),
							    a = d[h.type](u, e, i, n, r, g);u.setItemGraphicEl(e, a), s.add(a), o(a, u, e, i, n, t, r, "polar" === h.type);
						}
					}).update(function (e, i) {
						var n = c.getItemGraphicEl(i);if (!u.hasValue(e)) return void s.remove(n);var a = u.getItemModel(e),
						    p = f[h.type](u, e, a);n ? l.updateProps(n, { shape: p }, g, e) : n = d[h.type](u, e, a, p, r, g, !0), u.setItemGraphicEl(e, n), s.add(n), o(n, u, e, a, p, t, r, "polar" === h.type);
					}).remove(function (t) {
						var e = c.getItemGraphicEl(t);"cartesian2d" === h.type ? e && n(t, g, e) : e && a(t, g, e);
					}).execute(), this._data = u;
				}, remove: function remove(t, e) {
					var i = this.group,
					    o = this._data;t.get("animation") ? o && o.eachItemGraphicEl(function (e) {
						"sector" === e.type ? a(e.dataIndex, t, e) : n(e.dataIndex, t, e);
					}) : i.removeAll();
				} }),
			    d = { cartesian2d: function cartesian2d(t, e, i, n, a, o, r) {
					var u = new l.Rect({ shape: s.extend({}, n) });if (o) {
						var c = u.shape,
						    h = a ? "height" : "width",
						    d = {};c[h] = 0, d[h] = n[h], l[r ? "updateProps" : "initProps"](u, { shape: d }, o, e);
					}return u;
				}, polar: function polar(t, e, i, n, a, o, r) {
					var u = new l.Sector({ shape: s.extend({}, n) });if (o) {
						var c = u.shape,
						    h = a ? "r" : "endAngle",
						    d = {};c[h] = a ? 0 : n.startAngle, d[h] = n[h], l[r ? "updateProps" : "initProps"](u, { shape: d }, o, e);
					}return u;
				} },
			    f = { cartesian2d: function cartesian2d(t, e, i) {
					var n = t.getItemLayout(e),
					    a = r(i, n),
					    o = n.width > 0 ? 1 : -1,
					    s = n.height > 0 ? 1 : -1;return { x: n.x + o * a / 2, y: n.y + s * a / 2, width: n.width - o * a, height: n.height - s * a };
				}, polar: function polar(t, e, i) {
					var n = t.getItemLayout(e);return { cx: n.cx, cy: n.cy, r0: n.r0, r: n.r, startAngle: n.startAngle, endAngle: n.endAngle };
				} };t.exports = h;
		}, function (t, e, i) {
			var n = i(31)([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["stroke", "barBorderColor"], ["lineWidth", "barBorderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);t.exports = { getBarItemStyle: function getBarItemStyle(t) {
					var e = n.call(this, t);if (this.getBorderLineDash) {
						var i = this.getBorderLineDash();i && (e.lineDash = i);
					}return e;
				} };
		}, function (t, e, i) {
			function n(t) {
				return "_" + t + "Type";
			}function a(t, e, i) {
				var n = e.getItemVisual(i, "color"),
				    a = e.getItemVisual(i, t),
				    o = e.getItemVisual(i, t + "Size");if (a && "none" !== a) {
					f.isArray(o) || (o = [o, o]);var r = u.createSymbol(a, -o[0] / 2, -o[1] / 2, o[0], o[1], n);return r.name = t, r;
				}
			}function o(t) {
				var e = new h({ name: "line" });return r(e.shape, t), e;
			}function r(t, e) {
				var i = e[0],
				    n = e[1],
				    a = e[2];t.x1 = i[0], t.y1 = i[1], t.x2 = n[0], t.y2 = n[1], t.percent = 1, a ? (t.cpx1 = a[0], t.cpy1 = a[1]) : (t.cpx1 = NaN, t.cpy1 = NaN);
			}function s() {
				var t = this,
				    e = t.childOfName("fromSymbol"),
				    i = t.childOfName("toSymbol"),
				    n = t.childOfName("label");if (e || i || !n.ignore) {
					for (var a = 1, o = this.parent; o;) {
						o.scale && (a /= o.scale[0]), o = o.parent;
					}var r = t.childOfName("line");if (this.__dirty || r.__dirty) {
						var s = r.shape.percent,
						    l = r.pointAt(0),
						    u = r.pointAt(s),
						    h = c.sub([], u, l);if (c.normalize(h, h), e) {
							e.attr("position", l);var d = r.tangentAt(0);e.attr("rotation", Math.PI / 2 - Math.atan2(d[1], d[0])), e.attr("scale", [a * s, a * s]);
						}if (i) {
							i.attr("position", u);var d = r.tangentAt(1);i.attr("rotation", -Math.PI / 2 - Math.atan2(d[1], d[0])), i.attr("scale", [a * s, a * s]);
						}if (!n.ignore) {
							n.attr("position", u);var f,
							    p,
							    g,
							    m = 5 * a;if ("end" === n.__position) f = [h[0] * m + u[0], h[1] * m + u[1]], p = h[0] > .8 ? "left" : h[0] < -.8 ? "right" : "center", g = h[1] > .8 ? "top" : h[1] < -.8 ? "bottom" : "middle";else if ("middle" === n.__position) {
								var v = s / 2,
								    d = r.tangentAt(v),
								    y = [d[1], -d[0]],
								    x = r.pointAt(v);y[1] > 0 && (y[0] = -y[0], y[1] = -y[1]), f = [x[0] + y[0] * m, x[1] + y[1] * m], p = "center", g = "bottom";var _ = -Math.atan2(d[1], d[0]);u[0] < l[0] && (_ = Math.PI + _), n.attr("rotation", _);
							} else f = [-h[0] * m + l[0], -h[1] * m + l[1]], p = h[0] > .8 ? "right" : h[0] < -.8 ? "left" : "center", g = h[1] > .8 ? "bottom" : h[1] < -.8 ? "top" : "middle";n.attr({ style: { textVerticalAlign: n.__verticalAlign || g, textAlign: n.__textAlign || p }, position: f, scale: [a, a] });
						}
					}
				}
			}function l(t, e, i) {
				d.Group.call(this), this._createLine(t, e, i);
			}var u = i(24),
			    c = i(6),
			    h = i(190),
			    d = i(3),
			    f = i(1),
			    p = i(4),
			    g = ["fromSymbol", "toSymbol"],
			    m = l.prototype;m.beforeUpdate = s, m._createLine = function (t, e, i) {
				var r = t.hostModel,
				    s = t.getItemLayout(e),
				    l = o(s);l.shape.percent = 0, d.initProps(l, { shape: { percent: 1 } }, r, e), this.add(l);var u = new d.Text({ name: "label" });this.add(u), f.each(g, function (i) {
					var o = a(i, t, e);this.add(o), this[n(i)] = t.getItemVisual(e, i);
				}, this), this._updateCommonStl(t, e, i);
			}, m.updateData = function (t, e, i) {
				var o = t.hostModel,
				    s = this.childOfName("line"),
				    l = t.getItemLayout(e),
				    u = { shape: {} };r(u.shape, l), d.updateProps(s, u, o, e), f.each(g, function (i) {
					var o = t.getItemVisual(e, i),
					    r = n(i);if (this[r] !== o) {
						this.remove(this.childOfName(i));var s = a(i, t, e);this.add(s);
					}this[r] = o;
				}, this), this._updateCommonStl(t, e, i);
			}, m._updateCommonStl = function (t, e, i) {
				var n = t.hostModel,
				    a = this.childOfName("line"),
				    o = i && i.lineStyle,
				    r = i && i.hoverLineStyle,
				    s = i && i.labelModel,
				    l = i && i.hoverLabelModel;if (!i || t.hasItemOption) {
					var u = t.getItemModel(e);o = u.getModel("lineStyle.normal").getLineStyle(), r = u.getModel("lineStyle.emphasis").getLineStyle(), s = u.getModel("label.normal"), l = u.getModel("label.emphasis");
				}var c = t.getItemVisual(e, "color"),
				    h = f.retrieve(t.getItemVisual(e, "opacity"), o.opacity, 1);a.useStyle(f.defaults({ strokeNoScale: !0, fill: "none", stroke: c, opacity: h }, o)), a.hoverStyle = r, f.each(g, function (t) {
					var e = this.childOfName(t);e && (e.setColor(c), e.setStyle({ opacity: h }));
				}, this);var m,
				    v,
				    y = s.getShallow("show"),
				    x = l.getShallow("show"),
				    _ = this.childOfName("label");if (y || x) {
					var b = n.getRawValue(e);v = null == b ? v = t.getName(e) : isFinite(b) ? p.round(b) : b, m = c || "#000";
				}if (y) {
					var w = s.getModel("textStyle");_.setStyle({ text: f.retrieve(n.getFormattedLabel(e, "normal", t.dataType), v), textFont: w.getFont(), fill: w.getTextColor() || m }), _.__textAlign = w.get("align"), _.__verticalAlign = w.get("baseline"), _.__position = s.get("position");
				} else _.setStyle("text", "");if (x) {
					var S = l.getModel("textStyle");_.hoverStyle = { text: f.retrieve(n.getFormattedLabel(e, "emphasis", t.dataType), v), textFont: S.getFont(), fill: S.getTextColor() || m };
				} else _.hoverStyle = { text: "" };_.ignore = !y && !x, d.setHoverStyle(this);
			}, m.updateLayout = function (t, e) {
				this.setLinePoints(t.getItemLayout(e));
			}, m.setLinePoints = function (t) {
				var e = this.childOfName("line");r(e.shape, t), e.dirty();
			}, f.inherits(l, d.Group), t.exports = l;
		}, function (t, e, i) {
			function n(t) {
				return isNaN(t[0]) || isNaN(t[1]);
			}function a(t) {
				return !n(t[0]) && !n(t[1]);
			}function o(t) {
				this._ctor = t || s, this.group = new r.Group();
			}var r = i(3),
			    s = i(106),
			    l = o.prototype;l.updateData = function (t) {
				var e = this._lineData,
				    i = this.group,
				    n = this._ctor,
				    o = t.hostModel,
				    r = { lineStyle: o.getModel("lineStyle.normal").getLineStyle(), hoverLineStyle: o.getModel("lineStyle.emphasis").getLineStyle(), labelModel: o.getModel("label.normal"), hoverLabelModel: o.getModel("label.emphasis") };t.diff(e).add(function (e) {
					if (a(t.getItemLayout(e))) {
						var o = new n(t, e, r);t.setItemGraphicEl(e, o), i.add(o);
					}
				}).update(function (o, s) {
					var l = e.getItemGraphicEl(s);return a(t.getItemLayout(o)) ? (l ? l.updateData(t, o, r) : l = new n(t, o, r), t.setItemGraphicEl(o, l), void i.add(l)) : void i.remove(l);
				}).remove(function (t) {
					i.remove(e.getItemGraphicEl(t));
				}).execute(), this._lineData = t;
			}, l.updateLayout = function () {
				var t = this._lineData;t.eachItemGraphicEl(function (e, i) {
					e.updateLayout(t, i);
				}, this);
			}, l.remove = function () {
				this.group.removeAll();
			}, t.exports = o;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(2),
			    o = a.PRIORITY;i(109), i(110), a.registerVisual(n.curry(i(50), "line", "circle", "line")), a.registerLayout(n.curry(i(61), "line")), a.registerProcessor(o.PROCESSOR.STATISTIC, n.curry(i(147), "line")), i(32);
		}, function (t, e, i) {
			"use strict";
			var n = i(28),
			    a = i(17);t.exports = a.extend({ type: "series.line", dependencies: ["grid", "polar"], getInitialData: function getInitialData(t, e) {
					return n(t.data, this, e);
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, hoverAnimation: !0, clipOverflow: !0, label: { normal: { position: "top" } }, lineStyle: { normal: { width: 2, type: "solid" } }, step: !1, smooth: !1, smoothMonotone: null, symbol: "emptyCircle", symbolSize: 4, symbolRotate: null, showSymbol: !0, showAllSymbol: !1, connectNulls: !1, sampling: "none", animationEasing: "linear", progressive: 0, hoverLayerThreshold: 1 / 0 } });
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				if (t.length === e.length) {
					for (var i = 0; i < t.length; i++) {
						var n = t[i],
						    a = e[i];if (n[0] !== a[0] || n[1] !== a[1]) return;
					}return !0;
				}
			}function a(t) {
				return "number" == typeof t ? t : t ? .3 : 0;
			}function o(t) {
				var e = t.getGlobalExtent();if (t.onBand) {
					var i = t.getBandWidth() / 2 - 1,
					    n = e[1] > e[0] ? 1 : -1;e[0] += n * i, e[1] -= n * i;
				}return e;
			}function r(t) {
				return t >= 0 ? 1 : -1;
			}function s(t, e) {
				var i = t.getBaseAxis(),
				    n = t.getOtherAxis(i),
				    a = i.onZero ? 0 : n.scale.getExtent()[0],
				    o = n.dim,
				    s = "x" === o || "radius" === o ? 1 : 0;return e.mapArray([o], function (n, l) {
					for (var u, c = e.stackedOn; c && r(c.get(o, l)) === r(n);) {
						u = c;break;
					}var h = [];return h[s] = e.get(i.dim, l), h[1 - s] = u ? u.get(o, l, !0) : a, t.dataToPoint(h);
				}, !0);
			}function l(t, e, i) {
				var n = o(t.getAxis("x")),
				    a = o(t.getAxis("y")),
				    r = t.getBaseAxis().isHorizontal(),
				    s = Math.min(n[0], n[1]),
				    l = Math.min(a[0], a[1]),
				    u = Math.max(n[0], n[1]) - s,
				    c = Math.max(a[0], a[1]) - l,
				    h = i.get("lineStyle.normal.width") || 2,
				    d = i.get("clipOverflow") ? h / 2 : Math.max(u, c);r ? (l -= d, c += 2 * d) : (s -= d, u += 2 * d);var f = new v.Rect({ shape: { x: s, y: l, width: u, height: c } });return e && (f.shape[r ? "width" : "height"] = 0, v.initProps(f, { shape: { width: u, height: c } }, i)), f;
			}function u(t, e, i) {
				var n = t.getAngleAxis(),
				    a = t.getRadiusAxis(),
				    o = a.getExtent(),
				    r = n.getExtent(),
				    s = Math.PI / 180,
				    l = new v.Sector({ shape: { cx: t.cx, cy: t.cy, r0: o[0], r: o[1], startAngle: -r[0] * s, endAngle: -r[1] * s, clockwise: n.inverse } });return e && (l.shape.endAngle = -r[0] * s, v.initProps(l, { shape: { endAngle: -r[1] * s } }, i)), l;
			}function c(t, e, i) {
				return "polar" === t.type ? u(t, e, i) : l(t, e, i);
			}function h(t, e, i) {
				for (var n = e.getBaseAxis(), a = "x" === n.dim || "radius" === n.dim ? 0 : 1, o = [], r = 0; r < t.length - 1; r++) {
					var s = t[r + 1],
					    l = t[r];o.push(l);var u = [];switch (i) {case "end":
							u[a] = s[a], u[1 - a] = l[1 - a], o.push(u);break;case "middle":
							var c = (l[a] + s[a]) / 2,
							    h = [];u[a] = h[a] = c, u[1 - a] = l[1 - a], h[1 - a] = s[1 - a], o.push(u), o.push(h);break;default:
							u[a] = l[a], u[1 - a] = s[1 - a], o.push(u);}
				}return t[r] && o.push(t[r]), o;
			}function d(t, e) {
				var i = t.getVisual("visualMeta");if (i && i.length && t.count()) {
					for (var n, a = i.length - 1; a >= 0; a--) {
						if (i[a].dimension < 2) {
							n = i[a];break;
						}
					}if (n && "cartesian2d" === e.type) {
						var o = n.dimension,
						    r = t.dimensions[o],
						    s = e.getAxis(r),
						    l = f.map(n.stops, function (t) {
							return { coord: s.toGlobalCoord(s.dataToCoord(t.value)), color: t.color };
						}),
						    u = l.length,
						    c = n.outerColors.slice();u && l[0].coord > l[u - 1].coord && (l.reverse(), c.reverse());var h = 10,
						    d = l[0].coord - h,
						    p = l[u - 1].coord + h,
						    g = p - d;if (g < .001) return "transparent";f.each(l, function (t) {
							t.offset = (t.coord - d) / g;
						}), l.push({ offset: u ? l[u - 1].offset : .5, color: c[1] || "transparent" }), l.unshift({ offset: u ? l[0].offset : .5, color: c[0] || "transparent" });var m = new v.LinearGradient(0, 0, 0, 0, l, !0);return m[r] = d, m[r + "2"] = p, m;
					}
				}
			}var f = i(1),
			    p = i(44),
			    g = i(54),
			    m = i(111),
			    v = i(3),
			    y = i(5),
			    x = i(93),
			    _ = i(30);t.exports = _.extend({ type: "line", init: function init() {
					var t = new v.Group(),
					    e = new p();this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t;
				}, render: function render(t, e, i) {
					var o = t.coordinateSystem,
					    r = this.group,
					    l = t.getData(),
					    u = t.getModel("lineStyle.normal"),
					    p = t.getModel("areaStyle.normal"),
					    g = l.mapArray(l.getItemLayout, !0),
					    m = "polar" === o.type,
					    v = this._coordSys,
					    y = this._symbolDraw,
					    x = this._polyline,
					    _ = this._polygon,
					    b = this._lineGroup,
					    w = t.get("animation"),
					    S = !p.isEmpty(),
					    M = s(o, l),
					    I = t.get("showSymbol"),
					    T = I && !m && !t.get("showAllSymbol") && this._getSymbolIgnoreFunc(l, o),
					    A = this._data;A && A.eachItemGraphicEl(function (t, e) {
						t.__temp && (r.remove(t), A.setItemGraphicEl(e, null));
					}), I || y.remove(), r.add(b);var C = !m && t.get("step");x && v.type === o.type && C === this._step ? (S && !_ ? _ = this._newPolygon(g, M, o, w) : _ && !S && (b.remove(_), _ = this._polygon = null), b.setClipPath(c(o, !1, t)), I && y.updateData(l, T), l.eachItemGraphicEl(function (t) {
						t.stopAnimation(!0);
					}), n(this._stackedOnPoints, M) && n(this._points, g) || (w ? this._updateAnimation(l, M, o, i, C) : (C && (g = h(g, o, C), M = h(M, o, C)), x.setShape({ points: g }), _ && _.setShape({ points: g, stackedOnPoints: M })))) : (I && y.updateData(l, T), C && (g = h(g, o, C), M = h(M, o, C)), x = this._newPolyline(g, o, w), S && (_ = this._newPolygon(g, M, o, w)), b.setClipPath(c(o, !0, t)));var L = d(l, o) || l.getVisual("color");x.useStyle(f.defaults(u.getLineStyle(), { fill: "none", stroke: L, lineJoin: "bevel" }));var D = t.get("smooth");if (D = a(t.get("smooth")), x.setShape({ smooth: D, smoothMonotone: t.get("smoothMonotone"), connectNulls: t.get("connectNulls") }), _) {
						var P = l.stackedOn,
						    k = 0;if (_.useStyle(f.defaults(p.getAreaStyle(), { fill: L, opacity: .7, lineJoin: "bevel" })), P) {
							var O = P.hostModel;k = a(O.get("smooth"));
						}_.setShape({ smooth: D, stackedOnSmooth: k, smoothMonotone: t.get("smoothMonotone"), connectNulls: t.get("connectNulls") });
					}this._data = l, this._coordSys = o, this._stackedOnPoints = M, this._points = g, this._step = C;
				}, dispose: function dispose() {}, highlight: function highlight(t, e, i, n) {
					var a = t.getData(),
					    o = y.queryDataIndex(a, n);if (!(o instanceof Array) && null != o && o >= 0) {
						var r = a.getItemGraphicEl(o);if (!r) {
							var s = a.getItemLayout(o);if (!s) return;r = new g(a, o), r.position = s, r.setZ(t.get("zlevel"), t.get("z")), r.ignore = isNaN(s[0]) || isNaN(s[1]), r.__temp = !0, a.setItemGraphicEl(o, r), r.stopSymbolAnimation(!0), this.group.add(r);
						}r.highlight();
					} else _.prototype.highlight.call(this, t, e, i, n);
				}, downplay: function downplay(t, e, i, n) {
					var a = t.getData(),
					    o = y.queryDataIndex(a, n);if (null != o && o >= 0) {
						var r = a.getItemGraphicEl(o);r && (r.__temp ? (a.setItemGraphicEl(o, null), this.group.remove(r)) : r.downplay());
					} else _.prototype.downplay.call(this, t, e, i, n);
				}, _newPolyline: function _newPolyline(t) {
					var e = this._polyline;return e && this._lineGroup.remove(e), e = new x.Polyline({ shape: { points: t }, silent: !0, z2: 10 }), this._lineGroup.add(e), this._polyline = e, e;
				}, _newPolygon: function _newPolygon(t, e) {
					var i = this._polygon;return i && this._lineGroup.remove(i), i = new x.Polygon({ shape: { points: t, stackedOnPoints: e }, silent: !0 }), this._lineGroup.add(i), this._polygon = i, i;
				}, _getSymbolIgnoreFunc: function _getSymbolIgnoreFunc(t, e) {
					var i = e.getAxesByScale("ordinal")[0];if (i && i.isLabelIgnored) return f.bind(i.isLabelIgnored, i);
				}, _updateAnimation: function _updateAnimation(t, e, i, n, a) {
					var o = this._polyline,
					    r = this._polygon,
					    s = t.hostModel,
					    l = m(this._data, t, this._stackedOnPoints, e, this._coordSys, i),
					    u = l.current,
					    c = l.stackedOnCurrent,
					    d = l.next,
					    f = l.stackedOnNext;a && (u = h(l.current, i, a), c = h(l.stackedOnCurrent, i, a), d = h(l.next, i, a), f = h(l.stackedOnNext, i, a)), o.shape.__points = l.current, o.shape.points = u, v.updateProps(o, { shape: { points: d } }, s), r && (r.setShape({ points: u, stackedOnPoints: c }), v.updateProps(r, { shape: { points: d, stackedOnPoints: f } }, s));for (var p = [], g = l.status, y = 0; y < g.length; y++) {
						var x = g[y].cmd;if ("=" === x) {
							var _ = t.getItemGraphicEl(g[y].idx1);_ && p.push({ el: _, ptIdx: y });
						}
					}o.animators && o.animators.length && o.animators[0].during(function () {
						for (var t = 0; t < p.length; t++) {
							var e = p[t].el;e.attr("position", o.shape.__points[p[t].ptIdx]);
						}
					});
				}, remove: function remove(t) {
					var e = this.group,
					    i = this._data;this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function (t, n) {
						t.__temp && (e.remove(t), i.setItemGraphicEl(n, null));
					}), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
				} });
		}, function (t, e) {
			function i(t) {
				return t >= 0 ? 1 : -1;
			}function n(t, e, n) {
				for (var a, o = t.getBaseAxis(), r = t.getOtherAxis(o), s = o.onZero ? 0 : r.scale.getExtent()[0], l = r.dim, u = "x" === l || "radius" === l ? 1 : 0, c = e.stackedOn, h = e.get(l, n); c && i(c.get(l, n)) === i(h);) {
					a = c;break;
				}var d = [];return d[u] = e.get(o.dim, n), d[1 - u] = a ? a.get(l, n, !0) : s, t.dataToPoint(d);
			}function a(t, e) {
				var i = [];return e.diff(t).add(function (t) {
					i.push({ cmd: "+", idx: t });
				}).update(function (t, e) {
					i.push({ cmd: "=", idx: e, idx1: t });
				}).remove(function (t) {
					i.push({ cmd: "-", idx: t });
				}).execute(), i;
			}t.exports = function (t, e, i, o, r, s) {
				for (var l = a(t, e), u = [], c = [], h = [], d = [], f = [], p = [], g = [], m = s.dimensions, v = 0; v < l.length; v++) {
					var y = l[v],
					    x = !0;switch (y.cmd) {case "=":
							var _ = t.getItemLayout(y.idx),
							    b = e.getItemLayout(y.idx1);(isNaN(_[0]) || isNaN(_[1])) && (_ = b.slice()), u.push(_), c.push(b), h.push(i[y.idx]), d.push(o[y.idx1]), g.push(e.getRawIndex(y.idx1));break;case "+":
							var w = y.idx;u.push(r.dataToPoint([e.get(m[0], w, !0), e.get(m[1], w, !0)])), c.push(e.getItemLayout(w).slice()), h.push(n(r, e, w)), d.push(o[w]), g.push(e.getRawIndex(w));break;case "-":
							var w = y.idx,
							    S = t.getRawIndex(w);S !== w ? (u.push(t.getItemLayout(w)), c.push(s.dataToPoint([t.get(m[0], w, !0), t.get(m[1], w, !0)])), h.push(i[w]), d.push(n(s, t, w)), g.push(S)) : x = !1;}x && (f.push(y), p.push(p.length));
				}p.sort(function (t, e) {
					return g[t] - g[e];
				});for (var M = [], I = [], T = [], A = [], C = [], v = 0; v < p.length; v++) {
					var w = p[v];M[v] = u[w], I[v] = c[w], T[v] = h[w], A[v] = d[w], C[v] = f[w];
				}return { current: M, next: I, stackedOnCurrent: T, stackedOnNext: A, status: C };
			};
		}, function (t, e, i) {
			var n = i(1),
			    a = i(2);i(113), i(114), i(89)("pie", [{ type: "pieToggleSelect", event: "pieselectchanged", method: "toggleSelected" }, { type: "pieSelect", event: "pieselected", method: "select" }, { type: "pieUnSelect", event: "pieunselected", method: "unSelect" }]), a.registerVisual(n.curry(i(84), "pie")), a.registerLayout(n.curry(i(116), "pie")), a.registerProcessor(n.curry(i(63), "pie"));
		}, function (t, e, i) {
			"use strict";
			var n = i(14),
			    a = i(1),
			    o = i(5),
			    r = i(25),
			    s = i(78),
			    l = i(2).extendSeriesModel({ type: "series.pie", init: function init(t) {
					l.superApply(this, "init", arguments), this.legendDataProvider = function () {
						return this.getRawData();
					}, this.updateSelectedMap(t.data), this._defaultLabelLine(t);
				}, mergeOption: function mergeOption(t) {
					l.superCall(this, "mergeOption", t), this.updateSelectedMap(this.option.data);
				}, getInitialData: function getInitialData(t, e) {
					var i = r(["value"], t.data),
					    a = new n(i, this);return a.initData(t.data), a;
				}, getDataParams: function getDataParams(t) {
					var e = this.getData(),
					    i = l.superCall(this, "getDataParams", t),
					    n = e.getSum("value");return i.percent = n ? +(e.get("value", t) / n * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
				}, _defaultLabelLine: function _defaultLabelLine(t) {
					o.defaultEmphasis(t.labelLine, ["show"]);var e = t.labelLine.normal,
					    i = t.labelLine.emphasis;e.show = e.show && t.label.normal.show, i.show = i.show && t.label.emphasis.show;
				}, defaultOption: { zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, center: ["50%", "50%"], radius: [0, "75%"], clockwise: !0, startAngle: 90, minAngle: 0, selectedOffset: 10, avoidLabelOverlap: !0, stillShowZeroSum: !0, label: { normal: { rotate: !1, show: !0, position: "outer" }, emphasis: {} }, labelLine: { normal: { show: !0, length: 15, length2: 15, smooth: !1, lineStyle: { width: 1, type: "solid" } } }, itemStyle: { normal: { borderWidth: 1 }, emphasis: {} }, animationType: "expansion", animationEasing: "cubicOut", data: [] } });a.mixin(l, s), t.exports = l;
		}, function (t, e, i) {
			function n(t, e, i, n) {
				var o = e.getData(),
				    r = this.dataIndex,
				    s = o.getName(r),
				    l = e.get("selectedOffset");n.dispatchAction({ type: "pieToggleSelect", from: t, name: s, seriesId: e.id }), o.each(function (t) {
					a(o.getItemGraphicEl(t), o.getItemLayout(t), e.isSelected(o.getName(t)), l, i);
				});
			}function a(t, e, i, n, a) {
				var o = (e.startAngle + e.endAngle) / 2,
				    r = Math.cos(o),
				    s = Math.sin(o),
				    l = i ? n : 0,
				    u = [r * l, s * l];a ? t.animate().when(200, { position: u }).start("bounceOut") : t.attr("position", u);
			}function o(t, e) {
				function i() {
					o.ignore = o.hoverIgnore, r.ignore = r.hoverIgnore;
				}function n() {
					o.ignore = o.normalIgnore, r.ignore = r.normalIgnore;
				}s.Group.call(this);var a = new s.Sector({ z2: 2 }),
				    o = new s.Polyline(),
				    r = new s.Text();this.add(a), this.add(o), this.add(r), this.updateData(t, e, !0), this.on("emphasis", i).on("normal", n).on("mouseover", i).on("mouseout", n);
			}function r(t, e, i, n, a) {
				var o = n.getModel("textStyle"),
				    r = "inside" === a || "inner" === a;return { fill: o.getTextColor() || (r ? "#fff" : t.getItemVisual(e, "color")), opacity: t.getItemVisual(e, "opacity"), textFont: o.getFont(), text: l.retrieve(t.hostModel.getFormattedLabel(e, i), t.getName(e)) };
			}var s = i(3),
			    l = i(1),
			    u = o.prototype;u.updateData = function (t, e, i) {
				function n() {
					r.stopAnimation(!0), r.animateTo({ shape: { r: h.r + 10 } }, 300, "elasticOut");
				}function o() {
					r.stopAnimation(!0), r.animateTo({ shape: { r: h.r } }, 300, "elasticOut");
				}var r = this.childAt(0),
				    u = t.hostModel,
				    c = t.getItemModel(e),
				    h = t.getItemLayout(e),
				    d = l.extend({}, h);if (d.label = null, i) {
					r.setShape(d);var f = u.getShallow("animationType");"scale" === f ? (r.shape.r = h.r0, s.initProps(r, { shape: { r: h.r } }, u, e)) : (r.shape.endAngle = h.startAngle, s.updateProps(r, {
						shape: { endAngle: h.endAngle } }, u, e));
				} else s.updateProps(r, { shape: d }, u, e);var p = c.getModel("itemStyle"),
				    g = t.getItemVisual(e, "color");r.useStyle(l.defaults({ lineJoin: "bevel", fill: g }, p.getModel("normal").getItemStyle())), r.hoverStyle = p.getModel("emphasis").getItemStyle(), a(this, t.getItemLayout(e), c.get("selected"), u.get("selectedOffset"), u.get("animation")), r.off("mouseover").off("mouseout").off("emphasis").off("normal"), c.get("hoverAnimation") && u.isAnimationEnabled() && r.on("mouseover", n).on("mouseout", o).on("emphasis", n).on("normal", o), this._updateLabel(t, e), s.setHoverStyle(this);
			}, u._updateLabel = function (t, e) {
				var i = this.childAt(1),
				    n = this.childAt(2),
				    a = t.hostModel,
				    o = t.getItemModel(e),
				    l = t.getItemLayout(e),
				    u = l.label,
				    c = t.getItemVisual(e, "color");s.updateProps(i, { shape: { points: u.linePoints || [[u.x, u.y], [u.x, u.y], [u.x, u.y]] } }, a, e), s.updateProps(n, { style: { x: u.x, y: u.y } }, a, e), n.attr({ style: { textVerticalAlign: u.verticalAlign, textAlign: u.textAlign, textFont: u.font }, rotation: u.rotation, origin: [u.x, u.y], z2: 10 });var h = o.getModel("label.normal"),
				    d = o.getModel("label.emphasis"),
				    f = o.getModel("labelLine.normal"),
				    p = o.getModel("labelLine.emphasis"),
				    g = h.get("position") || d.get("position");n.setStyle(r(t, e, "normal", h, g)), n.ignore = n.normalIgnore = !h.get("show"), n.hoverIgnore = !d.get("show"), i.ignore = i.normalIgnore = !f.get("show"), i.hoverIgnore = !p.get("show"), i.setStyle({ stroke: c, opacity: t.getItemVisual(e, "opacity") }), i.setStyle(f.getModel("lineStyle").getLineStyle()), n.hoverStyle = r(t, e, "emphasis", d, g), i.hoverStyle = p.getModel("lineStyle").getLineStyle();var m = f.get("smooth");m && m === !0 && (m = .4), i.setShape({ smooth: m });
			}, l.inherits(o, s.Group);var c = i(30).extend({ type: "pie", init: function init() {
					var t = new s.Group();this._sectorGroup = t;
				}, render: function render(t, e, i, a) {
					if (!a || a.from !== this.uid) {
						var r = t.getData(),
						    s = this._data,
						    u = this.group,
						    c = e.get("animation"),
						    h = !s,
						    d = t.get("animationType"),
						    f = l.curry(n, this.uid, t, c, i),
						    p = t.get("selectedMode");if (r.diff(s).add(function (t) {
							var e = new o(r, t);h && "scale" !== d && e.eachChild(function (t) {
								t.stopAnimation(!0);
							}), p && e.on("click", f), r.setItemGraphicEl(t, e), u.add(e);
						}).update(function (t, e) {
							var i = s.getItemGraphicEl(e);i.updateData(r, t), i.off("click"), p && i.on("click", f), u.add(i), r.setItemGraphicEl(t, i);
						}).remove(function (t) {
							var e = s.getItemGraphicEl(t);u.remove(e);
						}).execute(), c && h && r.count() > 0 && "scale" !== d) {
							var g = r.getItemLayout(0),
							    m = Math.max(i.getWidth(), i.getHeight()) / 2,
							    v = l.bind(u.removeClipPath, u);u.setClipPath(this._createClipPath(g.cx, g.cy, m, g.startAngle, g.clockwise, v, t));
						}this._data = r;
					}
				}, dispose: function dispose() {}, _createClipPath: function _createClipPath(t, e, i, n, a, o, r) {
					var l = new s.Sector({ shape: { cx: t, cy: e, r0: 0, r: i, startAngle: n, endAngle: n, clockwise: a } });return s.initProps(l, { shape: { endAngle: n + (a ? 1 : -1) * Math.PI * 2 } }, r, o), l;
				}, containPoint: function containPoint(t, e) {
					var i = e.getData(),
					    n = i.getItemLayout(0);if (n) {
						var a = t[0] - n.cx,
						    o = t[1] - n.cy,
						    r = Math.sqrt(a * a + o * o);return r <= n.r && r >= n.r0;
					}
				} });t.exports = c;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i, n, a, o, r) {
				function s(e, i, n, a) {
					for (var o = e; o < i; o++) {
						if (t[o].y += n, o > e && o + 1 < i && t[o + 1].y > t[o].y + t[o].height) return void l(o, n / 2);
					}l(i - 1, n / 2);
				}function l(e, i) {
					for (var n = e; n >= 0 && (t[n].y -= i, !(n > 0 && t[n].y > t[n - 1].y + t[n - 1].height)); n--) {}
				}function u(t, e, i, n, a, o) {
					for (var r = o > 0 ? e ? Number.MAX_VALUE : 0 : e ? Number.MAX_VALUE : 0, s = 0, l = t.length; s < l; s++) {
						if ("center" !== t[s].position) {
							var u = Math.abs(t[s].y - n),
							    c = t[s].len,
							    h = t[s].len2,
							    d = u < a + c ? Math.sqrt((a + c + h) * (a + c + h) - u * u) : Math.abs(t[s].x - i);e && d >= r && (d = r - 10), !e && d <= r && (d = r + 10), t[s].x = i + d * o, r = d;
						}
					}
				}t.sort(function (t, e) {
					return t.y - e.y;
				});for (var c, h = 0, d = t.length, f = [], p = [], g = 0; g < d; g++) {
					c = t[g].y - h, c < 0 && s(g, d, -c, a), h = t[g].y + t[g].height;
				}r - h < 0 && l(d - 1, h - r);for (var g = 0; g < d; g++) {
					t[g].y >= i ? p.push(t[g]) : f.push(t[g]);
				}u(f, !1, e, i, n, a), u(p, !0, e, i, n, a);
			}function a(t, e, i, a, o, r) {
				for (var s = [], l = [], u = 0; u < t.length; u++) {
					t[u].x < e ? s.push(t[u]) : l.push(t[u]);
				}n(l, e, i, a, 1, o, r), n(s, e, i, a, -1, o, r);for (var u = 0; u < t.length; u++) {
					var c = t[u].linePoints;if (c) {
						var h = c[1][0] - c[2][0];t[u].x < e ? c[2][0] = t[u].x + 3 : c[2][0] = t[u].x - 3, c[1][1] = c[2][1] = t[u].y, c[1][0] = c[2][0] + h;
					}
				}
			}var o = i(16);t.exports = function (t, e, i, n) {
				var r,
				    s,
				    l = t.getData(),
				    u = [],
				    c = !1;l.each(function (i) {
					var n,
					    a,
					    h,
					    d,
					    f = l.getItemLayout(i),
					    p = l.getItemModel(i),
					    g = p.getModel("label.normal"),
					    m = g.get("position") || p.get("label.emphasis.position"),
					    v = p.getModel("labelLine.normal"),
					    y = v.get("length"),
					    x = v.get("length2"),
					    _ = (f.startAngle + f.endAngle) / 2,
					    b = Math.cos(_),
					    w = Math.sin(_);r = f.cx, s = f.cy;var S = "inside" === m || "inner" === m;if ("center" === m) n = f.cx, a = f.cy, d = "center";else {
						var M = (S ? (f.r + f.r0) / 2 * b : f.r * b) + r,
						    I = (S ? (f.r + f.r0) / 2 * w : f.r * w) + s;if (n = M + 3 * b, a = I + 3 * w, !S) {
							var T = M + b * (y + e - f.r),
							    A = I + w * (y + e - f.r),
							    C = T + (b < 0 ? -1 : 1) * x,
							    L = A;n = C + (b < 0 ? -5 : 5), a = L, h = [[M, I], [T, A], [C, L]];
						}d = S ? "center" : b > 0 ? "left" : "right";
					}var D = g.getModel("textStyle").getFont(),
					    P = g.get("rotate") ? b < 0 ? -_ + Math.PI : -_ : 0,
					    k = t.getFormattedLabel(i, "normal") || l.getName(i),
					    O = o.getBoundingRect(k, D, d, "top");c = !!P, f.label = { x: n, y: a, position: m, height: O.height, len: y, len2: x, linePoints: h, textAlign: d, verticalAlign: "middle", font: D, rotation: P }, S || u.push(f.label);
				}), !c && t.get("avoidLabelOverlap") && a(u, r, s, e, i, n);
			};
		}, function (t, e, i) {
			var n = i(4),
			    a = n.parsePercent,
			    o = i(115),
			    r = i(1),
			    s = 2 * Math.PI,
			    l = Math.PI / 180;t.exports = function (t, e, i, u) {
				e.eachSeriesByType(t, function (t) {
					var e = t.get("center"),
					    u = t.get("radius");r.isArray(u) || (u = [0, u]), r.isArray(e) || (e = [e, e]);var c = i.getWidth(),
					    h = i.getHeight(),
					    d = Math.min(c, h),
					    f = a(e[0], c),
					    p = a(e[1], h),
					    g = a(u[0], d / 2),
					    m = a(u[1], d / 2),
					    v = t.getData(),
					    y = -t.get("startAngle") * l,
					    x = t.get("minAngle") * l,
					    _ = 0;v.each("value", function (t) {
						!isNaN(t) && _++;
					});var b = v.getSum("value"),
					    w = Math.PI / (b || _) * 2,
					    S = t.get("clockwise"),
					    M = t.get("roseType"),
					    I = t.get("stillShowZeroSum"),
					    T = v.getDataExtent("value");T[0] = 0;var A = s,
					    C = 0,
					    L = y,
					    D = S ? 1 : -1;if (v.each("value", function (t, e) {
						var i;if (isNaN(t)) return void v.setItemLayout(e, { angle: NaN, startAngle: NaN, endAngle: NaN, clockwise: S, cx: f, cy: p, r0: g, r: M ? NaN : m });i = "area" !== M ? 0 === b && I ? w : t * w : s / _, i < x ? (i = x, A -= x) : C += t;var a = L + D * i;v.setItemLayout(e, { angle: i, startAngle: L, endAngle: a, clockwise: S, cx: f, cy: p, r0: g, r: M ? n.linearMap(t, T, [g, m]) : m }), L = a;
					}, !0), A < s && _) if (A <= .001) {
						var P = s / _;v.each("value", function (t, e) {
							if (!isNaN(t)) {
								var i = v.getItemLayout(e);i.angle = P, i.startAngle = y + D * e * P, i.endAngle = y + D * (e + 1) * P;
							}
						});
					} else w = A / C, L = y, v.each("value", function (t, e) {
						if (!isNaN(t)) {
							var i = v.getItemLayout(e),
							    n = i.angle === x ? x : t * w;i.startAngle = L, i.endAngle = L + D * n, L += D * n;
						}
					});o(t, m, c, h);
				});
			};
		}, function (t, e, i) {
			"use strict";
			i(60), i(118);
		}, function (t, e, i) {
			var n = i(1),
			    a = i(3),
			    o = i(40),
			    r = i(41),
			    s = i(75),
			    l = o.ifIgnoreOnTick,
			    u = o.getInterval,
			    c = ["axisLine", "axisLabel", "axisTick", "axisName"],
			    h = ["splitArea", "splitLine"],
			    d = r.extend({ type: "cartesianAxis", axisPointerClass: "CartesianAxisPointer", render: function render(t, e, i, r) {
					this.group.removeAll();var l = this._axisGroup;if (this._axisGroup = new a.Group(), this.group.add(this._axisGroup), t.get("show")) {
						var u = t.getCoordSysModel(),
						    f = s.layout(u, t),
						    p = new o(t, f);n.each(c, p.add, p), this._axisGroup.add(p.getGroup()), n.each(h, function (e) {
							t.get(e + ".show") && this["_" + e](t, u, f.labelInterval);
						}, this), a.groupTransition(l, this._axisGroup, t), d.superCall(this, "render", t, e, i, r);
					}
				}, _splitLine: function _splitLine(t, e, i) {
					var o = t.axis;if (!o.scale.isBlank()) {
						var r = t.getModel("splitLine"),
						    s = r.getModel("lineStyle"),
						    c = s.get("color"),
						    h = u(r, i);c = n.isArray(c) ? c : [c];for (var d = e.coordinateSystem.getRect(), f = o.isHorizontal(), p = 0, g = o.getTicksCoords(), m = o.scale.getTicks(), v = [], y = [], x = s.getLineStyle(), _ = 0; _ < g.length; _++) {
							if (!l(o, _, h)) {
								var b = o.toGlobalCoord(g[_]);f ? (v[0] = b, v[1] = d.y, y[0] = b, y[1] = d.y + d.height) : (v[0] = d.x, v[1] = b, y[0] = d.x + d.width, y[1] = b);var w = p++ % c.length;this._axisGroup.add(new a.Line(a.subPixelOptimizeLine({ anid: "line_" + m[_], shape: { x1: v[0], y1: v[1], x2: y[0], y2: y[1] }, style: n.defaults({ stroke: c[w] }, x), silent: !0 })));
							}
						}
					}
				}, _splitArea: function _splitArea(t, e, i) {
					var o = t.axis;if (!o.scale.isBlank()) {
						var r = t.getModel("splitArea"),
						    s = r.getModel("areaStyle"),
						    c = s.get("color"),
						    h = e.coordinateSystem.getRect(),
						    d = o.getTicksCoords(),
						    f = o.scale.getTicks(),
						    p = o.toGlobalCoord(d[0]),
						    g = o.toGlobalCoord(d[0]),
						    m = 0,
						    v = u(r, i),
						    y = s.getAreaStyle();c = n.isArray(c) ? c : [c];for (var x = 1; x < d.length; x++) {
							if (!l(o, x, v)) {
								var _,
								    b,
								    w,
								    S,
								    M = o.toGlobalCoord(d[x]);o.isHorizontal() ? (_ = p, b = h.y, w = M - _, S = h.height) : (_ = h.x, b = g, w = h.width, S = M - b);var I = m++ % c.length;this._axisGroup.add(new a.Rect({ anid: "area_" + f[x], shape: { x: _, y: b, width: w, height: S }, style: n.defaults({ fill: c[I] }, y), silent: !0 })), p = _ + w, g = b + S;
							}
						}
					}
				} });d.extend({ type: "xAxis" }), d.extend({ type: "yAxis" });
		}, function (t, e, i) {
			"use strict";
			function n() {}function a(t, e, i, n) {
				o(f(i).lastProp, n) || (f(i).lastProp = n, e ? d.updateProps(i, n, t) : (i.stopAnimation(), i.attr(n)));
			}function o(t, e) {
				if (c.isObject(t) && c.isObject(e)) {
					var i = !0;return c.each(e, function (e, n) {
						i &= o(t[n], e);
					}), !!i;
				}return t === e;
			}function r(t, e) {
				t[e.get("label.show") ? "show" : "hide"]();
			}function s(t) {
				return { position: t.position.slice(), rotation: t.rotation || 0 };
			}function l(t, e) {
				var i = t.get("icon"),
				    n = { x: -1, y: -1, width: 2, height: 2 },
				    a = c.extend({ style: { strokeNoScale: !0 }, rectHover: !0, cursor: "move", draggable: !0 }, e);return 0 === i.indexOf("image://") ? (n.image = i.slice(8), a.style = n, new d.Image(a)) : d.makePath(i.replace("path://", ""), a, n, "center");
			}function u(t, e, i) {
				var n = e.get("z"),
				    a = e.get("zlevel");t && t.traverse(function (t) {
					"group" !== t.type && (null != n && (t.z = n), null != a && (t.zlevel = a), t.silent = i);
				});
			}var c = i(1),
			    h = i(15),
			    d = i(3),
			    f = i(5).makeGetter(),
			    p = i(45),
			    g = i(21),
			    m = i(37),
			    v = c.clone,
			    y = c.bind;n.prototype = { _group: null, _lastGraphicKey: null, _handle: null, _dragging: !1, _lastValue: null, _lastStatus: null, _payloadInfo: null, animationThreshold: 15, render: function render(t, e, i, n) {
					var o = e.get("value"),
					    r = e.get("status");if (this._axisModel = t, this._axisPointerModel = e, this._api = i, n || this._lastValue !== o || this._lastStatus !== r) {
						this._lastValue = o, this._lastStatus = r;var s = this._group,
						    l = this._handle;if (!r || "hide" === r) return s && s.hide(), void (l && l.hide());s && s.show(), l && l.show();var h = {};this.makeElOption(h, o, t, e, i);var f = h.graphicKey;f !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = f;var p = this._moveAnimation = this.determineAnimation(t, e);if (s) {
							var g = c.curry(a, e, p);this.updatePointerEl(s, h, g, e), this.updateLabelEl(s, h, g, e);
						} else s = this._group = new d.Group(), this.createPointerEl(s, h, t, e), this.createLabelEl(s, h, t, e), i.getZr().add(s);u(s, e, !0), this._renderHandle(o);
					}
				}, remove: function remove(t) {
					this.clear(t);
				}, dispose: function dispose(t) {
					this.clear(t);
				}, determineAnimation: function determineAnimation(t, e) {
					var i = e.get("animation"),
					    n = t.axis,
					    a = "category" === n.type,
					    o = e.get("snap");if (!o && !a) return !1;if ("auto" === i || null == i) {
						var r = this.animationThreshold;if (a && n.getBandWidth() > r) return !0;if (o) {
							var s = p.getAxisInfo(t).seriesDataCount,
							    l = n.getExtent();return Math.abs(l[0] - l[1]) / s > r;
						}return !1;
					}return i === !0;
				}, makeElOption: function makeElOption(t, e, i, n, a) {}, createPointerEl: function createPointerEl(t, e, i, n) {
					var a = e.pointer;if (a) {
						var o = f(t).pointerEl = new d[a.type](v(e.pointer));t.add(o);
					}
				}, createLabelEl: function createLabelEl(t, e, i, n) {
					if (e.label) {
						var a = f(t).labelEl = new d.Rect(v(e.label));t.add(a), r(a, n);
					}
				}, updatePointerEl: function updatePointerEl(t, e, i) {
					var n = f(t).pointerEl;n && (n.setStyle(e.pointer.style), i(n, { shape: e.pointer.shape }));
				}, updateLabelEl: function updateLabelEl(t, e, i, n) {
					var a = f(t).labelEl;a && (a.setStyle(e.label.style), i(a, { shape: e.label.shape, position: e.label.position }), r(a, n));
				}, _renderHandle: function _renderHandle(t) {
					if (!this._dragging && this.updateHandleTransform) {
						var e = this._axisPointerModel,
						    i = this._api.getZr(),
						    n = this._handle,
						    a = e.getModel("handle"),
						    o = e.get("status");if (!a.get("show") || !o || "hide" === o) return n && i.remove(n), void (this._handle = null);var r;this._handle || (r = !0, n = this._handle = l(a, { onmousemove: function onmousemove(t) {
								g.stop(t.event);
							}, onmousedown: y(this._onHandleDragMove, this, 0, 0), drift: y(this._onHandleDragMove, this), ondragend: y(this._onHandleDragEnd, this) }), i.add(n)), u(n, e, !1);var s = ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];n.setStyle(a.getItemStyle(null, s));var h = a.get("size");c.isArray(h) || (h = [h, h]), n.attr("scale", [h[0] / 2, h[1] / 2]), m.createOrUpdate(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, r);
					}
				}, _moveHandleToValue: function _moveHandleToValue(t, e) {
					a(this._axisPointerModel, !e && this._moveAnimation, this._handle, s(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
				}, _onHandleDragMove: function _onHandleDragMove(t, e) {
					var i = this._handle;if (i) {
						this._dragging = !0;var n = this.updateHandleTransform(s(i), [t, e], this._axisModel, this._axisPointerModel);this._payloadInfo = n, i.stopAnimation(), i.attr(s(n)), f(i).lastProp = null, this._doDispatchAxisPointer();
					}
				}, _doDispatchAxisPointer: function _doDispatchAxisPointer() {
					var t = this._handle;if (t) {
						var e = this._payloadInfo,
						    i = this._axisModel;this._api.dispatchAction({ type: "updateAxisPointer", x: e.cursorPoint[0], y: e.cursorPoint[1], tooltipOption: e.tooltipOption, axesInfo: [{ axisDim: i.axis.dim, axisIndex: i.componentIndex }] });
					}
				}, _onHandleDragEnd: function _onHandleDragEnd(t) {
					this._dragging = !1;var e = this._handle;if (e) {
						var i = this._axisPointerModel.get("value");this._moveHandleToValue(i), this._api.dispatchAction({ type: "hideTip" });
					}
				}, getHandleTransform: null, updateHandleTransform: null, clear: function clear(t) {
					this._lastValue = null, this._lastStatus = null;var e = t.getZr(),
					    i = this._group,
					    n = this._handle;e && i && (this._lastGraphicKey = null, i && e.remove(i), n && e.remove(n), this._group = null, this._handle = null, this._payloadInfo = null);
				}, doClear: function doClear() {}, buildLabel: function buildLabel(t, e, i) {
					return i = i || 0, { x: t[i], y: t[1 - i], width: e[i], height: e[1 - i] };
				} }, n.prototype.constructor = n, h.enableClassExtend(n), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				var i = {};return i[e.dim + "AxisIndex"] = e.index, t.getCartesian(i);
			}function a(t) {
				return "x" === t.dim ? 0 : 1;
			}var o = i(3),
			    r = i(119),
			    s = i(76),
			    l = i(75),
			    u = i(41),
			    c = r.extend({ makeElOption: function makeElOption(t, e, i, a, o) {
					var r = i.axis,
					    u = r.grid,
					    c = a.get("type"),
					    d = n(u, r).getOtherAxis(r).getGlobalExtent(),
					    f = r.toGlobalCoord(r.dataToCoord(e, !0));if (c && "none" !== c) {
						var p = s.buildElStyle(a),
						    g = h[c](r, f, d, p);g.style = p, t.graphicKey = g.type, t.pointer = g;
					}var m = l.layout(u.model, i);s.buildCartesianSingleLabelElOption(e, t, m, i, a, o);
				}, getHandleTransform: function getHandleTransform(t, e, i) {
					var n = l.layout(e.axis.grid.model, e, { labelInside: !1 });return n.labelMargin = i.get("handle.margin"), { position: s.getTransformedPosition(e.axis, t, n), rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0) };
				}, updateHandleTransform: function updateHandleTransform(t, e, i, a) {
					var o = i.axis,
					    r = o.grid,
					    s = o.getGlobalExtent(!0),
					    l = n(r, o).getOtherAxis(o).getGlobalExtent(),
					    u = "x" === o.dim ? 0 : 1,
					    c = t.position;c[u] += e[u], c[u] = Math.min(s[1], c[u]), c[u] = Math.max(s[0], c[u]);var h = (l[1] + l[0]) / 2,
					    d = [h, h];d[u] = c[u];var f = [{ verticalAlign: "middle" }, { align: "center" }];return { position: c, rotation: t.rotation, cursorPoint: d, tooltipOption: f[u] };
				} }),
			    h = { line: function line(t, e, i, n) {
					var r = s.makeLineShape([e, i[0]], [e, i[1]], a(t));return o.subPixelOptimizeLine({ shape: r, style: n }), { type: "Line", shape: r };
				}, shadow: function shadow(t, e, i, n) {
					var o = t.getBandWidth(),
					    r = i[1] - i[0];return { type: "Rect", shape: s.makeRectShape([e - o / 2, i[0]], [o, r], a(t)) };
				} };u.registerAxisPointerClass("CartesianAxisPointer", c), t.exports = c;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(5);t.exports = function (t, e) {
				var i,
				    o = [],
				    r = t.seriesIndex;if (null == r || !(i = e.getSeriesByIndex(r))) return { point: [] };var s = i.getData(),
				    l = a.queryDataIndex(s, t);if (null == l || n.isArray(l)) return { point: [] };var u = s.getItemGraphicEl(l),
				    c = i.coordinateSystem;if (i.getTooltipPosition) o = i.getTooltipPosition(l) || [];else if (c && c.dataToPoint) o = c.dataToPoint(s.getValues(n.map(c.dimensions, function (t) {
					return i.coordDimToDataDim(t)[0];
				}), l, !0)) || [];else if (u) {
					var h = u.getBoundingRect().clone();h.applyTransform(u.transform), o = [h.x + h.width / 2, h.y + h.height / 2];
				}return { point: o, el: u };
			};
		}, function (t, e, i) {
			function n(t, e) {
				function i(i, n) {
					t.on(i, function (i) {
						var o = s(e);h(c(t).records, function (t) {
							t && n(t, i, o.dispatchAction);
						}), a(o.pendings, e);
					});
				}c(t).initialized || (c(t).initialized = !0, i("click", u.curry(r, "click")), i("mousemove", u.curry(r, "mousemove")), i("globalout", o));
			}function a(t, e) {
				var i,
				    n = t.showTip.length,
				    a = t.hideTip.length;n ? i = t.showTip[n - 1] : a && (i = t.hideTip[a - 1]), i && (i.dispatchAction = null, e.dispatchAction(i));
			}function o(t, e, i) {
				t.handler("leave", null, i);
			}function r(t, e, i, n) {
				e.handler(t, i, n);
			}function s(t) {
				var e = { showTip: [], hideTip: [] },
				    i = function i(n) {
					var a = e[n.type];a ? a.push(n) : (n.dispatchAction = i, t.dispatchAction(n));
				};return { dispatchAction: i, pendings: e };
			}var l = i(9),
			    u = i(1),
			    c = i(5).makeGetter(),
			    h = u.each,
			    d = {};d.register = function (t, e, i) {
				if (!l.node) {
					var a = e.getZr();c(a).records || (c(a).records = {}), n(a, e);var o = c(a).records[t] || (c(a).records[t] = {});o.handler = i;
				}
			}, d.unregister = function (t, e) {
				if (!l.node) {
					var i = e.getZr(),
					    n = (c(i).records || {})[t];n && (c(i).records[t] = null);
				}
			}, t.exports = d;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(77),
			    o = i(2);o.registerAction("dataZoom", function (t, e) {
				var i = a.createLinkedNodesFinder(n.bind(e.eachComponent, e, "dataZoom"), a.eachAxisDim, function (t, e) {
					return t.get(e.axisIndex);
				}),
				    o = [];e.eachComponent({ mainType: "dataZoom", query: t }, function (t, e) {
					o.push.apply(o, i(t).nodes);
				}), n.each(o, function (e, i) {
					e.setRawRange({ start: t.start, end: t.end, startValue: t.startValue, endValue: t.endValue });
				});
			});
		}, function (t, e, i) {
			function n(t, e, i) {
				i.getAxisProxy(t.name, e).reset(i);
			}function a(t, e, i) {
				i.getAxisProxy(t.name, e).filterData(i);
			}var o = i(2);o.registerProcessor(function (t, e) {
				t.eachComponent("dataZoom", function (t) {
					t.eachTargetAxis(n), t.eachTargetAxis(a);
				}), t.eachComponent("dataZoom", function (t) {
					var e = t.findRepresentativeAxisProxy(),
					    i = e.getDataPercentWindow(),
					    n = e.getDataValueWindow();t.setRawRange({ start: i[0], end: i[1], startValue: n[0], endValue: n[1] }, !0);
				});
			});
		}, function (t, e, i) {
			function n(t) {
				var e = t[r];return e || (e = t[r] = [{}]), e;
			}var a = i(1),
			    o = a.each,
			    r = "\0_ec_hist_store",
			    s = { push: function push(t, e) {
					var i = n(t);o(e, function (e, n) {
						for (var a = i.length - 1; a >= 0; a--) {
							var o = i[a];if (o[n]) break;
						}if (a < 0) {
							var r = t.queryComponents({ mainType: "dataZoom", subType: "select", id: n })[0];if (r) {
								var s = r.getPercentRange();i[0][n] = { dataZoomId: n, start: s[0], end: s[1] };
							}
						}
					}), i.push(e);
				}, pop: function pop(t) {
					var e = n(t),
					    i = e[e.length - 1];e.length > 1 && e.pop();var a = {};return o(i, function (t, i) {
						for (var n = e.length - 1; n >= 0; n--) {
							var t = e[n][i];if (t) {
								a[i] = t;break;
							}
						}
					}), a;
				}, clear: function clear(t) {
					t[r] = null;
				}, count: function count(t) {
					return n(t).length;
				} };t.exports = s;
		}, function (t, e, i) {
			i(13).registerSubTypeDefaulter("dataZoom", function (t) {
				return "slider";
			});
		}, function (t, e, i) {
			function n(t) {
				V.call(this), this._zr = t, this.group = new G.Group(), this._brushType, this._brushOption, this._panels, this._track = [], this._dragging, this._covers = [], this._creatingCover, this._creatingPanel, this._enableGlobalPan, this._uid = "brushController_" + it++, this._handlers = {}, Z(nt, function (t, e) {
					this._handlers[e] = B.bind(t, this);
				}, this);
			}function a(t, e) {
				var i = t._zr;t._enableGlobalPan || H.take(i, J, t._uid), Z(t._handlers, function (t, e) {
					i.on(e, t);
				}), t._brushType = e.brushType, t._brushOption = B.merge(B.clone(et), e, !0);
			}function o(t) {
				var e = t._zr;H.release(e, J, t._uid), Z(t._handlers, function (t, i) {
					e.off(i, t);
				}), t._brushType = t._brushOption = null;
			}function r(t, e) {
				var i = at[e.brushType].createCover(t, e);return i.__brushOption = e, u(i, e), t.group.add(i), i;
			}function s(t, e) {
				var i = h(e);return i.endCreating && (i.endCreating(t, e), u(e, e.__brushOption)), e;
			}function l(t, e) {
				var i = e.__brushOption;h(e).updateCoverShape(t, e, i.range, i);
			}function u(t, e) {
				var i = e.z;null == i && (i = Y), t.traverse(function (t) {
					t.z = i, t.z2 = i;
				});
			}function c(t, e) {
				h(e).updateCommon(t, e), l(t, e);
			}function h(t) {
				return at[t.__brushOption.brushType];
			}function d(t, e, i) {
				var n = t._panels;if (!n) return !0;var a,
				    o = t._transform;return Z(n, function (t) {
					t.isTargetByCursor(e, i, o) && (a = t);
				}), a;
			}function f(t, e) {
				var i = t._panels;if (!i) return !0;var n = e.__brushOption.panelId;return null == n || i[n];
			}function p(t) {
				var e = t._covers,
				    i = e.length;return Z(e, function (e) {
					t.group.remove(e);
				}, t), e.length = 0, !!i;
			}function g(t, e) {
				var i = q(t._covers, function (t) {
					var e = t.__brushOption,
					    i = B.clone(e.range);return { brushType: e.brushType, panelId: e.panelId, range: i };
				});t.trigger("brush", i, { isEnd: !!e.isEnd, removeOnClick: !!e.removeOnClick });
			}function m(t) {
				var e = t._track;if (!e.length) return !1;var i = e[e.length - 1],
				    n = e[0],
				    a = i[0] - n[0],
				    o = i[1] - n[1],
				    r = X(a * a + o * o, .5);return r > $;
			}function v(t) {
				var e = t.length - 1;return e < 0 && (e = 0), [t[0], t[e]];
			}function y(t, e, i, n) {
				var a = new G.Group();return a.add(new G.Rect({ name: "main", style: w(i), silent: !0, draggable: !0, cursor: "move", drift: W(t, e, a, "nswe"), ondragend: W(g, e, { isEnd: !0 }) })), Z(n, function (i) {
					a.add(new G.Rect({ name: i, style: { opacity: 0 }, draggable: !0, silent: !0, invisible: !0, drift: W(t, e, a, i), ondragend: W(g, e, { isEnd: !0 }) }));
				}), a;
			}function x(t, e, i, n) {
				var a = n.brushStyle.lineWidth || 0,
				    o = U(a, K),
				    r = i[0][0],
				    s = i[1][0],
				    l = r - a / 2,
				    u = s - a / 2,
				    c = i[0][1],
				    h = i[1][1],
				    d = c - o + a / 2,
				    f = h - o + a / 2,
				    p = c - r,
				    g = h - s,
				    m = p + a,
				    v = g + a;b(t, e, "main", r, s, p, g), n.transformable && (b(t, e, "w", l, u, o, v), b(t, e, "e", d, u, o, v), b(t, e, "n", l, u, m, o), b(t, e, "s", l, f, m, o), b(t, e, "nw", l, u, o, o), b(t, e, "ne", d, u, o, o), b(t, e, "sw", l, f, o, o), b(t, e, "se", d, f, o, o));
			}function _(t, e) {
				var i = e.__brushOption,
				    n = i.transformable,
				    a = e.childAt(0);a.useStyle(w(i)), a.attr({ silent: !n, cursor: n ? "move" : "default" }), Z(["w", "e", "n", "s", "se", "sw", "ne", "nw"], function (i) {
					var a = e.childOfName(i),
					    o = I(t, i);a && a.attr({ silent: !n, invisible: !n, cursor: n ? tt[o] + "-resize" : null });
				});
			}function b(t, e, i, n, a, o, r) {
				var s = e.childOfName(i);s && s.setShape(D(L(t, e, [[n, a], [n + o, a + r]])));
			}function w(t) {
				return B.defaults({ strokeNoScale: !0 }, t.brushStyle);
			}function S(t, e, i, n) {
				var a = [j(t, i), j(e, n)],
				    o = [U(t, i), U(e, n)];return [[a[0], o[0]], [a[1], o[1]]];
			}function M(t) {
				return G.getTransform(t.group);
			}function I(t, e) {
				if (e.length > 1) {
					e = e.split("");var i = [I(t, e[0]), I(t, e[1])];return ("e" === i[0] || "w" === i[0]) && i.reverse(), i.join("");
				}var n = { w: "left", e: "right", n: "top", s: "bottom" },
				    a = { left: "w", right: "e", top: "n", bottom: "s" },
				    i = G.transformDirection(n[e], M(t));return a[i];
			}function T(t, e, i, n, a, o, r, s) {
				var l = n.__brushOption,
				    u = t(l.range),
				    h = C(i, o, r);Z(a.split(""), function (t) {
					var e = Q[t];u[e[0]][e[1]] += h[e[0]];
				}), l.range = e(S(u[0][0], u[1][0], u[0][1], u[1][1])), c(i, n), g(i, { isEnd: !1 });
			}function A(t, e, i, n, a) {
				var o = e.__brushOption.range,
				    r = C(t, i, n);Z(o, function (t) {
					t[0] += r[0], t[1] += r[1];
				}), c(t, e), g(t, { isEnd: !1 });
			}function C(t, e, i) {
				var n = t.group,
				    a = n.transformCoordToLocal(e, i),
				    o = n.transformCoordToLocal(0, 0);return [a[0] - o[0], a[1] - o[1]];
			}function L(t, e, i) {
				var n = f(t, e);return n && n !== !0 ? n.clipPath(i, t._transform) : B.clone(i);
			}function D(t) {
				var e = j(t[0][0], t[1][0]),
				    i = j(t[0][1], t[1][1]),
				    n = U(t[0][0], t[1][0]),
				    a = U(t[0][1], t[1][1]);return { x: e, y: i, width: n - e, height: a - i };
			}function P(t, e, i) {
				if (t._brushType) {
					var n = t._zr,
					    a = t._covers,
					    o = d(t, e, i);if (!t._dragging) for (var r = 0; r < a.length; r++) {
						var s = a[r].__brushOption;if (o && (o === !0 || s.panelId === o.panelId) && at[s.brushType].contain(a[r], i[0], i[1])) return;
					}o && n.setCursorStyle("crosshair");
				}
			}function k(t) {
				var e = t.event;e.preventDefault && e.preventDefault();
			}function O(t, e, i) {
				return t.childOfName("main").contain(e, i);
			}function z(t, e, i, n) {
				var a,
				    o = t._creatingCover,
				    u = t._creatingPanel,
				    c = t._brushOption;if (t._track.push(i.slice()), m(t) || o) {
					if (u && !o) {
						"single" === c.brushMode && p(t);var h = B.clone(c);h.brushType = E(h.brushType, u), h.panelId = u === !0 ? null : u.panelId, o = t._creatingCover = r(t, h), t._covers.push(o);
					}if (o) {
						var f = at[E(t._brushType, u)],
						    g = o.__brushOption;g.range = f.getCreatingRange(L(t, o, t._track)), n && (s(t, o), f.updateCommon(t, o)), l(t, o), a = { isEnd: n };
					}
				} else n && "single" === c.brushMode && c.removeOnClick && d(t, e, i) && p(t) && (a = { isEnd: n, removeOnClick: !0 });return a;
			}function E(t, e) {
				return "auto" === t ? e.defaultBrushType : t;
			}function R(t) {
				if (this._dragging) {
					k(t);var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY),
					    i = z(this, t, e, !0);this._dragging = !1, this._track = [], this._creatingCover = null, i && g(this, i);
				}
			}function N(t) {
				return { createCover: function createCover(e, i) {
						return y(W(T, function (e) {
							var i = [e, [0, 100]];return t && i.reverse(), i;
						}, function (e) {
							return e[t];
						}), e, i, [["w", "e"], ["n", "s"]][t]);
					}, getCreatingRange: function getCreatingRange(e) {
						var i = v(e),
						    n = j(i[0][t], i[1][t]),
						    a = U(i[0][t], i[1][t]);return [n, a];
					}, updateCoverShape: function updateCoverShape(e, i, n, a) {
						var o,
						    r = f(e, i);if (r !== !0 && r.getLinearBrushOtherExtent) o = r.getLinearBrushOtherExtent(t, e._transform);else {
							var s = e._zr;o = [0, [s.getWidth(), s.getHeight()][1 - t]];
						}var l = [n, o];t && l.reverse(), x(e, i, l, a);
					}, updateCommon: _, contain: O };
			}var V = i(23),
			    B = i(1),
			    G = i(3),
			    H = i(129),
			    F = i(48),
			    W = B.curry,
			    Z = B.each,
			    q = B.map,
			    j = Math.min,
			    U = Math.max,
			    X = Math.pow,
			    Y = 1e4,
			    $ = 6,
			    K = 6,
			    J = "globalPan",
			    Q = { w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1] },
			    tt = { w: "ew", e: "ew", n: "ns", s: "ns", ne: "nesw", sw: "nesw", nw: "nwse", se: "nwse" },
			    et = { brushStyle: { lineWidth: 2, stroke: "rgba(0,0,0,0.3)", fill: "rgba(0,0,0,0.1)" }, transformable: !0, brushMode: "single", removeOnClick: !1 },
			    it = 0;n.prototype = { constructor: n, enableBrush: function enableBrush(t) {
					return this._brushType && o(this), t.brushType && a(this, t), this;
				}, setPanels: function setPanels(t) {
					if (t && t.length) {
						var e = this._panels = {};B.each(t, function (t) {
							e[t.panelId] = B.clone(t);
						});
					} else this._panels = null;return this;
				}, mount: function mount(t) {
					t = t || {}, this._enableGlobalPan = t.enableGlobalPan;var e = this.group;return this._zr.add(e), e.attr({ position: t.position || [0, 0], rotation: t.rotation || 0, scale: t.scale || [1, 1] }), this._transform = e.getLocalTransform(), this;
				}, eachCover: function eachCover(t, e) {
					Z(this._covers, t, e);
				}, updateCovers: function updateCovers(t) {
					function e(t, e) {
						return (null != t.id ? t.id : o + e) + "-" + t.brushType;
					}function i(t, i) {
						return e(t.__brushOption, i);
					}function n(e, i) {
						var n = t[e];if (null != i && l[i] === d) u[e] = l[i];else {
							var a = u[e] = null != i ? (l[i].__brushOption = n, l[i]) : s(h, r(h, n));c(h, a);
						}
					}function a(t) {
						l[t] !== d && h.group.remove(l[t]);
					}t = B.map(t, function (t) {
						return B.merge(B.clone(et), t, !0);
					});var o = "\0-brush-index-",
					    l = this._covers,
					    u = this._covers = [],
					    h = this,
					    d = this._creatingCover;return new F(l, t, i, e).add(n).update(n).remove(a).execute(), this;
				}, unmount: function unmount() {
					return this.enableBrush(!1), p(this), this._zr.remove(this.group), this;
				}, dispose: function dispose() {
					this.unmount(), this.off();
				} }, B.mixin(n, V);var nt = { mousedown: function mousedown(t) {
					if (this._dragging) R.call(this, t);else if (!t.target || !t.target.draggable) {
						k(t);var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY);this._creatingCover = null;var i = this._creatingPanel = d(this, t, e);i && (this._dragging = !0, this._track = [e.slice()]);
					}
				}, mousemove: function mousemove(t) {
					var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY);if (P(this, t, e), this._dragging) {
						k(t);var i = z(this, t, e, !1);i && g(this, i);
					}
				}, mouseup: R },
			    at = { lineX: N(0), lineY: N(1), rect: { createCover: function createCover(t, e) {
						return y(W(T, function (t) {
							return t;
						}, function (t) {
							return t;
						}), t, e, ["w", "e", "n", "s", "se", "sw", "ne", "nw"]);
					}, getCreatingRange: function getCreatingRange(t) {
						var e = v(t);return S(e[1][0], e[1][1], e[0][0], e[0][1]);
					}, updateCoverShape: function updateCoverShape(t, e, i, n) {
						x(t, e, i, n);
					}, updateCommon: _, contain: O }, polygon: { createCover: function createCover(t, e) {
						var i = new G.Group();return i.add(new G.Polyline({ name: "main", style: w(e), silent: !0 })), i;
					}, getCreatingRange: function getCreatingRange(t) {
						return t;
					}, endCreating: function endCreating(t, e) {
						e.remove(e.childAt(0)), e.add(new G.Polygon({ name: "main", draggable: !0, drift: W(A, t, e), ondragend: W(g, t, { isEnd: !0 }) }));
					}, updateCoverShape: function updateCoverShape(t, e, i, n) {
						e.childAt(0).setShape({ points: L(t, e, i) });
					}, updateCommon: _, contain: O } };t.exports = n;
		}, function (t, e) {
			var i = {},
			    n = { axisPointer: 1, tooltip: 1, brush: 1 };i.onIrrelevantElement = function (t, e, i) {
				var a = e.getComponentByElement(t.topTarget),
				    o = a && a.coordinateSystem;return a && a !== i && !n[a.mainType] && o && o.model !== i;
			}, t.exports = i;
		}, function (t, e, i) {
			function n(t) {
				return t[a] || (t[a] = {});
			}var a = "\0_ec_interaction_mutex",
			    o = { take: function take(t, e, i) {
					var a = n(t);a[e] = i;
				}, release: function release(t, e, i) {
					var a = n(t),
					    o = a[e];o === i && (a[e] = null);
				}, isTaken: function isTaken(t, e) {
					return !!n(t)[e];
				} };i(2).registerAction({ type: "takeGlobalCursor", event: "globalCursorTaken", update: "update" }, function () {}), t.exports = o;
		}, function (t, e, i) {
			function n(t, e, i) {
				a.positionElement(t, e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }, e.get("padding"));
			}var a = i(12),
			    o = i(7),
			    r = i(3);t.exports = { layout: function layout(t, e, i) {
					var o = a.getLayoutRect(e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }, e.get("padding"));a.box(e.get("orient"), t, e.get("itemGap"), o.width, o.height), n(t, e, i);
				}, addBackground: function addBackground(t, e) {
					var i = o.normalizeCssArray(e.get("padding")),
					    n = t.getBoundingRect(),
					    a = e.getItemStyle(["color", "opacity"]);a.fill = e.get("backgroundColor");var s = new r.Rect({ shape: { x: n.x - i[3], y: n.y - i[0], width: n.width + i[1] + i[3], height: n.height + i[0] + i[2] }, style: a, silent: !0, z2: -1 });r.subPixelOptimizeRect(s), t.add(s);
				} };
		}, function (t, e, i) {
			var n = i(1),
			    a = i(33),
			    o = function o(t, e, i, n, _o2) {
				a.call(this, t, e, i), this.type = n || "value", this.position = _o2 || "bottom";
			};o.prototype = { constructor: o, index: 0, onZero: !1, model: null, isHorizontal: function isHorizontal() {
					var t = this.position;return "top" === t || "bottom" === t;
				}, getGlobalExtent: function getGlobalExtent(t) {
					var e = this.getExtent();return e[0] = this.toGlobalCoord(e[0]), e[1] = this.toGlobalCoord(e[1]), t && e[0] > e[1] && e.reverse(), e;
				}, getOtherAxis: function getOtherAxis() {
					this.grid.getOtherAxis();
				}, isLabelIgnored: function isLabelIgnored(t) {
					if ("category" === this.type) {
						var e = this.getLabelInterval();return "function" == typeof e && !e(t, this.scale.getLabel(t)) || t % (e + 1);
					}
				}, pointToData: function pointToData(t, e) {
					return this.coordToData(this.toLocalCoord(t["x" === this.dim ? 0 : 1]), e);
				}, toLocalCoord: null, toGlobalCoord: null }, n.inherits(o, a), t.exports = o;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return this._axes[t];
			}var a = i(1),
			    o = function o(t) {
				this._axes = {}, this._dimList = [], this.name = t || "";
			};o.prototype = { constructor: o, type: "cartesian", getAxis: function getAxis(t) {
					return this._axes[t];
				}, getAxes: function getAxes() {
					return a.map(this._dimList, n, this);
				}, getAxesByScale: function getAxesByScale(t) {
					return t = t.toLowerCase(), a.filter(this.getAxes(), function (e) {
						return e.scale.type === t;
					});
				}, addAxis: function addAxis(t) {
					var e = t.dim;this._axes[e] = t, this._dimList.push(e);
				}, dataToCoord: function dataToCoord(t) {
					return this._dataCoordConvert(t, "dataToCoord");
				}, coordToData: function coordToData(t) {
					return this._dataCoordConvert(t, "coordToData");
				}, _dataCoordConvert: function _dataCoordConvert(t, e) {
					for (var i = this._dimList, n = t instanceof Array ? [] : {}, a = 0; a < i.length; a++) {
						var o = i[a],
						    r = this._axes[o];n[o] = r[e](t[o]);
					}return n;
				} }, t.exports = o;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				o.call(this, t);
			}var a = i(1),
			    o = i(132);n.prototype = { constructor: n, type: "cartesian2d", dimensions: ["x", "y"], getBaseAxis: function getBaseAxis() {
					return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
				}, containPoint: function containPoint(t) {
					var e = this.getAxis("x"),
					    i = this.getAxis("y");return e.contain(e.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]));
				}, containData: function containData(t) {
					return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]);
				}, dataToPoints: function dataToPoints(t, e) {
					return t.mapArray(["x", "y"], function (t, e) {
						return this.dataToPoint([t, e]);
					}, e, this);
				}, dataToPoint: function dataToPoint(t, e) {
					var i = this.getAxis("x"),
					    n = this.getAxis("y");return [i.toGlobalCoord(i.dataToCoord(t[0], e)), n.toGlobalCoord(n.dataToCoord(t[1], e))];
				}, pointToData: function pointToData(t, e) {
					var i = this.getAxis("x"),
					    n = this.getAxis("y");return [i.coordToData(i.toLocalCoord(t[0]), e), n.coordToData(n.toLocalCoord(t[1]), e)];
				}, getOtherAxis: function getOtherAxis(t) {
					return this.getAxis("x" === t.dim ? "y" : "x");
				} }, a.inherits(n, o), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			i(60);var n = i(13);t.exports = n.extend({ type: "grid", dependencies: ["xAxis", "yAxis"], layoutMode: "box", coordinateSystem: null, defaultOption: { show: !1, zlevel: 0, z: 0, left: "10%", top: 60, right: "10%", bottom: 60, containLabel: !1, backgroundColor: "rgba(0,0,0,0)", borderWidth: 1, borderColor: "#ccc" } });
		}, function (t, e, i) {
			var n = i(28),
			    a = i(24),
			    o = i(18),
			    r = i(42),
			    s = i(10),
			    l = i(1);t.exports = { createList: function createList(t) {
					var e = t.get("data");return n(e, t, t.ecModel);
				}, completeDimensions: i(25), createSymbol: a.createSymbol, createScale: function createScale(t, e) {
					var i = e;e instanceof s || (i = new s(e), l.mixin(i, r));var n = o.createScaleByModel(i);return n.setExtent(t[0], t[1]), o.niceScaleExtent(n, i), n;
				}, mixinAxisModelCommonMethods: function mixinAxisModelCommonMethods(t) {
					l.mixin(t, r);
				} };
		}, function (t, e, i) {
			var n = i(3),
			    a = i(1),
			    o = Math.PI;t.exports = function (t, e) {
				e = e || {}, a.defaults(e, { text: "loading", color: "#c23531", textColor: "#000", maskColor: "rgba(255, 255, 255, 0.8)", zlevel: 0 });var i = new n.Rect({ style: { fill: e.maskColor }, zlevel: e.zlevel, z: 1e4 }),
				    r = new n.Arc({ shape: { startAngle: -o / 2, endAngle: -o / 2 + .1, r: 10 }, style: { stroke: e.color, lineCap: "round", lineWidth: 5 }, zlevel: e.zlevel, z: 10001 }),
				    s = new n.Rect({ style: { fill: "none", text: e.text, textPosition: "right", textDistance: 10, textFill: e.textColor }, zlevel: e.zlevel, z: 10001 });r.animateShape(!0).when(1e3, { endAngle: 3 * o / 2 }).start("circularInOut"), r.animateShape(!0).when(1e3, { startAngle: 3 * o / 2 }).delay(300).start("circularInOut");var l = new n.Group();return l.add(r), l.add(s), l.add(i), l.resize = function () {
					var e = t.getWidth() / 2,
					    n = t.getHeight() / 2;r.setShape({ cx: e, cy: n });var a = r.shape.r;s.setShape({ x: e - a, y: n - a, width: 2 * a, height: 2 * a }), i.setShape({ x: 0, y: 0, width: t.getWidth(), height: t.getHeight() });
				}, l.resize(), l;
			};
		}, function (t, e, i) {
			function n(t, e) {
				c.each(e, function (e, i) {
					x.hasClass(i) || ("object" == (typeof e === "undefined" ? "undefined" : _typeof(e)) ? t[i] = t[i] ? c.merge(t[i], e, !1) : c.clone(e) : null == t[i] && (t[i] = e));
				});
			}function a(t) {
				t = t, this.option = {}, this.option[b] = 1, this._componentsMap = c.createHashMap({ series: []
				}), this._seriesIndices = null, n(t, this._theme.option), c.merge(t, _, !1), this.mergeOption(t);
			}function o(t, e) {
				c.isArray(e) || (e = e ? [e] : []);var i = {};return f(e, function (e) {
					i[e] = (t.get(e) || []).slice();
				}), i;
			}function r(t, e, i) {
				var n = e.type ? e.type : i ? i.subType : x.determineSubType(t, e);return n;
			}function s(t) {
				return g(t, function (t) {
					return t.componentIndex;
				}) || [];
			}function l(t, e) {
				return e.hasOwnProperty("subType") ? p(t, function (t) {
					return t.subType === e.subType;
				}) : t;
			}function u(t) {}var c = i(1),
			    h = i(5),
			    d = i(10),
			    f = c.each,
			    p = c.filter,
			    g = c.map,
			    m = c.isArray,
			    v = c.indexOf,
			    y = c.isObject,
			    x = i(13),
			    _ = i(139),
			    b = "\0_ec_inner",
			    w = d.extend({ constructor: w, init: function init(t, e, i, n) {
					i = i || {}, this.option = null, this._theme = new d(i), this._optionManager = n;
				}, setOption: function setOption(t, e) {
					c.assert(!(b in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption(null);
				}, resetOption: function resetOption(t) {
					var e = !1,
					    i = this._optionManager;if (!t || "recreate" === t) {
						var n = i.mountOption("recreate" === t);this.option && "recreate" !== t ? (this.restoreData(), this.mergeOption(n)) : a.call(this, n), e = !0;
					}if ("timeline" !== t && "media" !== t || this.restoreData(), !t || "recreate" === t || "timeline" === t) {
						var o = i.getTimelineOption(this);o && (this.mergeOption(o), e = !0);
					}if (!t || "recreate" === t || "media" === t) {
						var r = i.getMediaOption(this, this._api);r.length && f(r, function (t) {
							this.mergeOption(t, e = !0);
						}, this);
					}return e;
				}, mergeOption: function mergeOption(t) {
					function e(e, a) {
						var l = h.normalizeToArray(t[e]),
						    u = h.mappingToExists(n.get(e), l);h.makeIdAndName(u), f(u, function (t, i) {
							var n = t.option;y(n) && (t.keyInfo.mainType = e, t.keyInfo.subType = r(e, n, t.exist));
						});var d = o(n, a);i[e] = [], n.set(e, []), f(u, function (t, a) {
							var o = t.exist,
							    r = t.option;if (c.assert(y(r) || o, "Empty component definition"), r) {
								var s = x.getClass(e, t.keyInfo.subType, !0);if (o && o instanceof s) o.name = t.keyInfo.name, o.mergeOption(r, this), o.optionUpdated(r, !1);else {
									var l = c.extend({ dependentModels: d, componentIndex: a }, t.keyInfo);o = new s(r, this, this, l), c.extend(o, l), o.init(r, this, this, l), o.optionUpdated(null, !0);
								}
							} else o.mergeOption({}, this), o.optionUpdated({}, !1);n.get(e)[a] = o, i[e][a] = o.option;
						}, this), "series" === e && (this._seriesIndices = s(n.get("series")));
					}var i = this.option,
					    n = this._componentsMap,
					    a = [];f(t, function (t, e) {
						null != t && (x.hasClass(e) ? a.push(e) : i[e] = null == i[e] ? c.clone(t) : c.merge(i[e], t, !0));
					}), x.topologicalTravel(a, x.getAllClassMainTypes(), e, this), this._seriesIndices = this._seriesIndices || [];
				}, getOption: function getOption() {
					var t = c.clone(this.option);return f(t, function (e, i) {
						if (x.hasClass(i)) {
							for (var e = h.normalizeToArray(e), n = e.length - 1; n >= 0; n--) {
								h.isIdInner(e[n]) && e.splice(n, 1);
							}t[i] = e;
						}
					}), delete t[b], t;
				}, getTheme: function getTheme() {
					return this._theme;
				}, getComponent: function getComponent(t, e) {
					var i = this._componentsMap.get(t);if (i) return i[e || 0];
				}, queryComponents: function queryComponents(t) {
					var e = t.mainType;if (!e) return [];var i = t.index,
					    n = t.id,
					    a = t.name,
					    o = this._componentsMap.get(e);if (!o || !o.length) return [];var r;if (null != i) m(i) || (i = [i]), r = p(g(i, function (t) {
						return o[t];
					}), function (t) {
						return !!t;
					});else if (null != n) {
						var s = m(n);r = p(o, function (t) {
							return s && v(n, t.id) >= 0 || !s && t.id === n;
						});
					} else if (null != a) {
						var u = m(a);r = p(o, function (t) {
							return u && v(a, t.name) >= 0 || !u && t.name === a;
						});
					} else r = o.slice();return l(r, t);
				}, findComponents: function findComponents(t) {
					function e(t) {
						var e = a + "Index",
						    i = a + "Id",
						    n = a + "Name";return !t || null == t[e] && null == t[i] && null == t[n] ? null : { mainType: a, index: t[e], id: t[i], name: t[n] };
					}function i(e) {
						return t.filter ? p(e, t.filter) : e;
					}var n = t.query,
					    a = t.mainType,
					    o = e(n),
					    r = o ? this.queryComponents(o) : this._componentsMap.get(a);return i(l(r, t));
				}, eachComponent: function eachComponent(t, e, i) {
					var n = this._componentsMap;if ("function" == typeof t) i = e, e = t, n.each(function (t, n) {
						f(t, function (t, a) {
							e.call(i, n, t, a);
						});
					});else if (c.isString(t)) f(n.get(t), e, i);else if (y(t)) {
						var a = this.findComponents(t);f(a, e, i);
					}
				}, getSeriesByName: function getSeriesByName(t) {
					var e = this._componentsMap.get("series");return p(e, function (e) {
						return e.name === t;
					});
				}, getSeriesByIndex: function getSeriesByIndex(t) {
					return this._componentsMap.get("series")[t];
				}, getSeriesByType: function getSeriesByType(t) {
					var e = this._componentsMap.get("series");return p(e, function (e) {
						return e.subType === t;
					});
				}, getSeries: function getSeries() {
					return this._componentsMap.get("series").slice();
				}, eachSeries: function eachSeries(t, e) {
					u(this), f(this._seriesIndices, function (i) {
						var n = this._componentsMap.get("series")[i];t.call(e, n, i);
					}, this);
				}, eachRawSeries: function eachRawSeries(t, e) {
					f(this._componentsMap.get("series"), t, e);
				}, eachSeriesByType: function eachSeriesByType(t, e, i) {
					u(this), f(this._seriesIndices, function (n) {
						var a = this._componentsMap.get("series")[n];a.subType === t && e.call(i, a, n);
					}, this);
				}, eachRawSeriesByType: function eachRawSeriesByType(t, e, i) {
					return f(this.getSeriesByType(t), e, i);
				}, isSeriesFiltered: function isSeriesFiltered(t) {
					return u(this), c.indexOf(this._seriesIndices, t.componentIndex) < 0;
				}, getCurrentSeriesIndices: function getCurrentSeriesIndices() {
					return (this._seriesIndices || []).slice();
				}, filterSeries: function filterSeries(t, e) {
					u(this);var i = p(this._componentsMap.get("series"), t, e);this._seriesIndices = s(i);
				}, restoreData: function restoreData() {
					var t = this._componentsMap;this._seriesIndices = s(t.get("series"));var e = [];t.each(function (t, i) {
						e.push(i);
					}), x.topologicalTravel(e, x.getAllClassMainTypes(), function (e, i) {
						f(t.get(e), function (t) {
							t.restoreData();
						});
					});
				} });c.mixin(w, i(62)), t.exports = w;
		}, function (t, e, i) {
			function n(t) {
				this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption;
			}function a(t, e, i) {
				var n,
				    a,
				    o = [],
				    r = [],
				    s = t.timeline;if (t.baseOption && (a = t.baseOption), (s || t.options) && (a = a || {}, o = (t.options || []).slice()), t.media) {
					a = a || {};var l = t.media;d(l, function (t) {
						t && t.option && (t.query ? r.push(t) : n || (n = t));
					});
				}return a || (a = t), a.timeline || (a.timeline = s), d([a].concat(o).concat(u.map(r, function (t) {
					return t.option;
				})), function (t) {
					d(e, function (e) {
						e(t, i);
					});
				}), { baseOption: a, timelineOptions: o, mediaDefault: n, mediaList: r };
			}function o(t, e, i) {
				var n = { width: e, height: i, aspectratio: e / i },
				    a = !0;return u.each(t, function (t, e) {
					var i = e.match(m);if (i && i[1] && i[2]) {
						var o = i[1],
						    s = i[2].toLowerCase();r(n[s], t, o) || (a = !1);
					}
				}), a;
			}function r(t, e, i) {
				return "min" === i ? t >= e : "max" === i ? t <= e : t === e;
			}function s(t, e) {
				return t.join(",") === e.join(",");
			}function l(t, e) {
				e = e || {}, d(e, function (e, i) {
					if (null != e) {
						var n = t[i];if (h.hasClass(i)) {
							e = c.normalizeToArray(e), n = c.normalizeToArray(n);var a = c.mappingToExists(n, e);t[i] = p(a, function (t) {
								return t.option && t.exist ? g(t.exist, t.option, !0) : t.exist || t.option;
							});
						} else t[i] = g(n, e, !0);
					}
				});
			}var u = i(1),
			    c = i(5),
			    h = i(13),
			    d = u.each,
			    f = u.clone,
			    p = u.map,
			    g = u.merge,
			    m = /^(min|max)?(.+)$/;n.prototype = { constructor: n, setOption: function setOption(t, e) {
					t = f(t, !0);var i = this._optionBackup,
					    n = a.call(this, t, e, !i);this._newBaseOption = n.baseOption, i ? (l(i.baseOption, n.baseOption), n.timelineOptions.length && (i.timelineOptions = n.timelineOptions), n.mediaList.length && (i.mediaList = n.mediaList), n.mediaDefault && (i.mediaDefault = n.mediaDefault)) : this._optionBackup = n;
				}, mountOption: function mountOption(t) {
					var e = this._optionBackup;return this._timelineOptions = p(e.timelineOptions, f), this._mediaList = p(e.mediaList, f), this._mediaDefault = f(e.mediaDefault), this._currentMediaIndices = [], f(t ? e.baseOption : this._newBaseOption);
				}, getTimelineOption: function getTimelineOption(t) {
					var e,
					    i = this._timelineOptions;if (i.length) {
						var n = t.getComponent("timeline");n && (e = f(i[n.getCurrentIndex()], !0));
					}return e;
				}, getMediaOption: function getMediaOption(t) {
					var e = this._api.getWidth(),
					    i = this._api.getHeight(),
					    n = this._mediaList,
					    a = this._mediaDefault,
					    r = [],
					    l = [];if (!n.length && !a) return l;for (var u = 0, c = n.length; u < c; u++) {
						o(n[u].query, e, i) && r.push(u);
					}return !r.length && a && (r = [-1]), r.length && !s(r, this._currentMediaIndices) && (l = p(r, function (t) {
						return f(t === -1 ? a.option : n[t].option);
					})), this._currentMediaIndices = r, l;
				} }, t.exports = n;
		}, function (t, e) {
			var i = "";"undefined" != typeof navigator && (i = navigator.platform || ""), t.exports = { color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"], textStyle: { fontFamily: i.match(/^Win/) ? "Microsoft YaHei" : "sans-serif", fontSize: 12, fontStyle: "normal", fontWeight: "normal" }, blendMode: null, animation: "auto", animationDuration: 1e3, animationDurationUpdate: 300, animationEasing: "exponentialOut", animationEasingUpdate: "cubicOut", animationThreshold: 2e3, progressiveThreshold: 3e3, progressive: 400, hoverLayerThreshold: 3e3, useUTC: !1 };
		}, function (t, e, i) {
			t.exports = { getAreaStyle: i(31)([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]]) };
		}, function (t, e) {
			t.exports = { getBoxLayoutParams: function getBoxLayoutParams() {
					return { left: this.get("left"), top: this.get("top"), right: this.get("right"), bottom: this.get("bottom"), width: this.get("width"), height: this.get("height") };
				} };
		}, function (t, e, i) {
			var n = i(31)([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["textPosition"], ["textAlign"]]);t.exports = { getItemStyle: function getItemStyle(t, e) {
					var i = n.call(this, t, e),
					    a = this.getBorderLineDash();return a && (i.lineDash = a), i;
				}, getBorderLineDash: function getBorderLineDash() {
					var t = this.get("borderType");return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1];
				} };
		}, function (t, e, i) {
			var n = i(31)([["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);t.exports = { getLineStyle: function getLineStyle(t) {
					var e = n.call(this, t),
					    i = this.getLineDash(e.lineWidth);return i && (e.lineDash = i), e;
				}, getLineDash: function getLineDash(t) {
					null == t && (t = 1);var e = this.get("type"),
					    i = Math.max(t, 2),
					    n = 4 * t;return "solid" === e || null == e ? null : "dashed" === e ? [n, n] : [i, i];
				} };
		}, function (t, e, i) {
			var n = i(16),
			    a = i(3);t.exports = { getTextColor: function getTextColor() {
					var t = this.ecModel;return this.getShallow("color") || t && t.get("textStyle.color");
				}, getFont: function getFont() {
					return a.getFont({ fontStyle: this.getShallow("fontStyle"), fontWeight: this.getShallow("fontWeight"), fontSize: this.getShallow("fontSize"), fontFamily: this.getShallow("fontFamily") }, this.ecModel);
				}, getTextRect: function getTextRect(t) {
					return n.getBoundingRect(t, this.getFont(), this.getShallow("align"), this.getShallow("baseline"));
				}, truncateText: function truncateText(t, e, i, a) {
					return n.truncateText(t, e, this.getFont(), i, a);
				} };
		}, function (t, e, i) {
			function n(t, e) {
				e = e.split(",");for (var i = t, n = 0; n < e.length && (i = i && i[e[n]], null != i); n++) {}return i;
			}function a(t, e, i, n) {
				e = e.split(",");for (var a, o = t, r = 0; r < e.length - 1; r++) {
					a = e[r], null == o[a] && (o[a] = {}), o = o[a];
				}(n || null == o[e[r]]) && (o[e[r]] = i);
			}function o(t) {
				h(l, function (e) {
					e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]]);
				});
			}var r = i(1),
			    s = i(146),
			    l = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]],
			    u = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"],
			    c = ["bar", "boxplot", "candlestick", "chord", "effectScatter", "funnel", "gauge", "lines", "graph", "heatmap", "line", "map", "parallel", "pie", "radar", "sankey", "scatter", "treemap"],
			    h = r.each;t.exports = function (t) {
				h(t.series, function (t) {
					if (r.isObject(t)) {
						var e = t.type;if (s(t), "pie" !== e && "gauge" !== e || null != t.clockWise && (t.clockwise = t.clockWise), "gauge" === e) {
							var i = n(t, "pointer.color");null != i && a(t, "itemStyle.normal.color", i);
						}for (var l = 0; l < c.length; l++) {
							if (c[l] === t.type) {
								o(t);break;
							}
						}
					}
				}), t.dataRange && (t.visualMap = t.dataRange), h(u, function (e) {
					var i = t[e];i && (r.isArray(i) || (i = [i]), h(i, function (t) {
						o(t);
					}));
				});
			};
		}, function (t, e, i) {
			function n(t) {
				var e = t && t.itemStyle;e && a.each(o, function (i) {
					var n = e.normal,
					    o = e.emphasis;n && n[i] && (t[i] = t[i] || {}, t[i].normal ? a.merge(t[i].normal, n[i]) : t[i].normal = n[i], n[i] = null), o && o[i] && (t[i] = t[i] || {}, t[i].emphasis ? a.merge(t[i].emphasis, o[i]) : t[i].emphasis = o[i], o[i] = null);
				});
			}var a = i(1),
			    o = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];t.exports = function (t) {
				if (t) {
					n(t), n(t.markPoint), n(t.markLine);var e = t.data;if (e) {
						for (var i = 0; i < e.length; i++) {
							n(e[i]);
						}var o = t.markPoint;if (o && o.data) for (var r = o.data, i = 0; i < r.length; i++) {
							n(r[i]);
						}var s = t.markLine;if (s && s.data) for (var l = s.data, i = 0; i < l.length; i++) {
							a.isArray(l[i]) ? (n(l[i][0]), n(l[i][1])) : n(l[i]);
						}
					}
				}
			};
		}, function (t, e) {
			var i = { average: function average(t) {
					for (var e = 0, i = 0, n = 0; n < t.length; n++) {
						isNaN(t[n]) || (e += t[n], i++);
					}return 0 === i ? NaN : e / i;
				}, sum: function sum(t) {
					for (var e = 0, i = 0; i < t.length; i++) {
						e += t[i] || 0;
					}return e;
				}, max: function max(t) {
					for (var e = -(1 / 0), i = 0; i < t.length; i++) {
						t[i] > e && (e = t[i]);
					}return e;
				}, min: function min(t) {
					for (var e = 1 / 0, i = 0; i < t.length; i++) {
						t[i] < e && (e = t[i]);
					}return e;
				}, nearest: function nearest(t) {
					return t[0];
				} },
			    n = function n(t, e) {
				return Math.round(t.length / 2);
			};t.exports = function (t, e, a) {
				e.eachSeriesByType(t, function (t) {
					var e = t.getData(),
					    a = t.get("sampling"),
					    o = t.coordinateSystem;if ("cartesian2d" === o.type && a) {
						var r = o.getBaseAxis(),
						    s = o.getOtherAxis(r),
						    l = r.getExtent(),
						    u = l[1] - l[0],
						    c = Math.round(e.count() / u);if (c > 1) {
							var h;"string" == typeof a ? h = i[a] : "function" == typeof a && (h = a), h && (e = e.downSample(s.dim, 1 / c, h, n), t.setData(e));
						}
					}
				}, this);
			};
		}, function (t, e, i) {
			function n(t, e) {
				return h(t, c(e));
			}var a = i(1),
			    o = i(34),
			    r = i(4),
			    s = i(43),
			    l = o.prototype,
			    u = s.prototype,
			    c = r.getPrecisionSafe,
			    h = r.round,
			    d = Math.floor,
			    f = Math.ceil,
			    p = Math.pow,
			    g = Math.log,
			    m = o.extend({ type: "log", base: 10, $constructor: function $constructor() {
					o.apply(this, arguments), this._originalScale = new s();
				}, getTicks: function getTicks() {
					var t = this._originalScale,
					    e = this._extent,
					    i = t.getExtent();return a.map(u.getTicks.call(this), function (a) {
						var o = r.round(p(this.base, a));return o = a === e[0] && t.__fixMin ? n(o, i[0]) : o, o = a === e[1] && t.__fixMax ? n(o, i[1]) : o;
					}, this);
				}, getLabel: u.getLabel, scale: function scale(t) {
					return t = l.scale.call(this, t), p(this.base, t);
				}, setExtent: function setExtent(t, e) {
					var i = this.base;t = g(t) / g(i), e = g(e) / g(i), u.setExtent.call(this, t, e);
				}, getExtent: function getExtent() {
					var t = this.base,
					    e = l.getExtent.call(this);e[0] = p(t, e[0]), e[1] = p(t, e[1]);var i = this._originalScale,
					    a = i.getExtent();return i.__fixMin && (e[0] = n(e[0], a[0])), i.__fixMax && (e[1] = n(e[1], a[1])), e;
				}, unionExtent: function unionExtent(t) {
					this._originalScale.unionExtent(t);var e = this.base;t[0] = g(t[0]) / g(e), t[1] = g(t[1]) / g(e), l.unionExtent.call(this, t);
				}, unionExtentFromData: function unionExtentFromData(t, e) {
					this.unionExtent(t.getDataExtent(e, !0, function (t) {
						return t > 0;
					}));
				}, niceTicks: function niceTicks(t) {
					t = t || 10;var e = this._extent,
					    i = e[1] - e[0];if (!(i === 1 / 0 || i <= 0)) {
						var n = r.quantity(i),
						    a = t / i * n;for (a <= .5 && (n *= 10); !isNaN(n) && Math.abs(n) < 1 && Math.abs(n) > 0;) {
							n *= 10;
						}var o = [r.round(f(e[0] / n) * n), r.round(d(e[1] / n) * n)];this._interval = n, this._niceExtent = o;
					}
				}, niceExtent: function niceExtent(t) {
					u.niceExtent.call(this, t);var e = this._originalScale;e.__fixMin = t.fixMin, e.__fixMax = t.fixMax;
				} });a.each(["contain", "normalize"], function (t) {
				m.prototype[t] = function (e) {
					return e = g(e) / g(this.base), l[t].call(this, e);
				};
			}), m.create = function () {
				return new m();
			}, t.exports = m;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(34),
			    o = a.prototype,
			    r = a.extend({ type: "ordinal", init: function init(t, e) {
					this._data = t, this._extent = e || [0, t.length - 1];
				}, parse: function parse(t) {
					return "string" == typeof t ? n.indexOf(this._data, t) : Math.round(t);
				}, contain: function contain(t) {
					return t = this.parse(t), o.contain.call(this, t) && null != this._data[t];
				}, normalize: function normalize(t) {
					return o.normalize.call(this, this.parse(t));
				}, scale: function scale(t) {
					return Math.round(o.scale.call(this, t));
				}, getTicks: function getTicks() {
					for (var t = [], e = this._extent, i = e[0]; i <= e[1];) {
						t.push(i), i++;
					}return t;
				}, getLabel: function getLabel(t) {
					return this._data[t];
				}, count: function count() {
					return this._extent[1] - this._extent[0] + 1;
				}, unionExtentFromData: function unionExtentFromData(t, e) {
					this.unionExtent(t.getDataExtent(e, !1));
				}, niceTicks: n.noop, niceExtent: n.noop });r.create = function () {
				return new r();
			}, t.exports = r;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(4),
			    o = i(7),
			    r = i(64),
			    s = i(43),
			    l = s.prototype,
			    u = Math.ceil,
			    c = Math.floor,
			    h = 1e3,
			    d = 60 * h,
			    f = 60 * d,
			    p = 24 * f,
			    g = function g(t, e, i, n) {
				for (; i < n;) {
					var a = i + n >>> 1;t[a][2] < e ? i = a + 1 : n = a;
				}return i;
			},
			    m = s.extend({ type: "time", getLabel: function getLabel(t) {
					var e = this._stepLvl,
					    i = new Date(t);return o.formatTime(e[0], i, this.getSetting("useUTC"));
				}, niceExtent: function niceExtent(t) {
					var e = this._extent;if (e[0] === e[1] && (e[0] -= p, e[1] += p), e[1] === -(1 / 0) && e[0] === 1 / 0) {
						var i = new Date();e[1] = new Date(i.getFullYear(), i.getMonth(), i.getDate()), e[0] = e[1] - p;
					}this.niceTicks(t.splitNumber);var n = this._interval;t.fixMin || (e[0] = a.round(c(e[0] / n) * n)), t.fixMax || (e[1] = a.round(u(e[1] / n) * n));
				}, niceTicks: function niceTicks(t) {
					var e = this.getSetting("useUTC") ? 0 : 60 * a.getTimezoneOffset() * 1e3;t = t || 10;var i = this._extent,
					    n = i[1] - i[0],
					    o = n / t,
					    s = v.length,
					    l = g(v, o, 0, s),
					    h = v[Math.min(l, s - 1)],
					    d = h[2];if ("year" === h[0]) {
						var f = n / d,
						    p = a.nice(f / t, !0);d *= p;
					}var m = [Math.round(u((i[0] - e) / d) * d + e), Math.round(c((i[1] - e) / d) * d + e)];r.fixExtent(m, i), this._stepLvl = h, this._interval = d, this._niceExtent = m;
				}, parse: function parse(t) {
					return +a.parseDate(t);
				} });n.each(["contain", "normalize"], function (t) {
				m.prototype[t] = function (e) {
					return l[t].call(this, this.parse(e));
				};
			});var v = [["hh:mm:ss", 1, h], ["hh:mm:ss", 5, 5 * h], ["hh:mm:ss", 10, 10 * h], ["hh:mm:ss", 15, 15 * h], ["hh:mm:ss", 30, 30 * h], ["hh:mm\nMM-dd", 1, d], ["hh:mm\nMM-dd", 5, 5 * d], ["hh:mm\nMM-dd", 10, 10 * d], ["hh:mm\nMM-dd", 15, 15 * d], ["hh:mm\nMM-dd", 30, 30 * d], ["hh:mm\nMM-dd", 1, f], ["hh:mm\nMM-dd", 2, 2 * f], ["hh:mm\nMM-dd", 6, 6 * f], ["hh:mm\nMM-dd", 12, 12 * f], ["MM-dd\nyyyy", 1, p], ["week", 7, 7 * p], ["month", 1, 31 * p], ["quarter", 3, 380 * p / 4], ["half-year", 6, 380 * p / 2], ["year", 1, 380 * p]];m.create = function (t) {
				return new m({ useUTC: t.ecModel.get("useUTC") });
			}, t.exports = m;
		}, function (t, e, i) {
			var n = i(39);t.exports = function (t) {
				function e(e) {
					var i = (e.visualColorAccessPath || "itemStyle.normal.color").split("."),
					    a = e.getData(),
					    o = e.get(i) || e.getColorFromPalette(e.get("name"));a.setVisual("color", o), t.isSeriesFiltered(e) || ("function" != typeof o || o instanceof n || a.each(function (t) {
						a.setItemVisual(t, "color", o(e.getDataParams(t)));
					}), a.each(function (t) {
						var e = a.getItemModel(t),
						    n = e.get(i, !0);null != n && a.setItemVisual(t, "color", n);
					}));
				}t.eachRawSeries(e);
			};
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				return { type: t, event: i, target: e.target, topTarget: e.topTarget, cancelBubble: !1, offsetX: i.zrX, offsetY: i.zrY, gestureEvent: i.gestureEvent, pinchX: i.pinchX, pinchY: i.pinchY, pinchScale: i.pinchScale, wheelDelta: i.zrDelta, zrByTouch: i.zrByTouch };
			}function a() {}function o(t, e, i) {
				if (t[t.rectHover ? "rectContain" : "contain"](e, i)) {
					for (var n, a = t; a;) {
						if (a.clipPath && !a.clipPath.contain(e, i)) return !1;a.silent && (n = !0), a = a.parent;
					}return !n || u;
				}return !1;
			}var r = i(1),
			    s = i(179),
			    l = i(23),
			    u = "silent";a.prototype.dispose = function () {};var c = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
			    h = function h(t, e, i, n) {
				l.call(this), this.storage = t, this.painter = e, this.painterRoot = n, i = i || new a(), this.proxy = i, i.handler = this, this._hovered = {}, this._lastTouchMoment, this._lastX, this._lastY, s.call(this), r.each(c, function (t) {
					i.on && i.on(t, this[t], this);
				}, this);
			};h.prototype = { constructor: h, mousemove: function mousemove(t) {
					var e = t.zrX,
					    i = t.zrY,
					    n = this._hovered,
					    a = this._hovered = this.findHover(e, i),
					    o = a.target,
					    r = n.target,
					    s = this.proxy;s.setCursor && s.setCursor(o ? o.cursor : "default"), r && o !== r && r.__zr && this.dispatchToElement(n, "mouseout", t), this.dispatchToElement(a, "mousemove", t), o && o !== r && this.dispatchToElement(a, "mouseover", t);
				}, mouseout: function mouseout(t) {
					this.dispatchToElement(this._hovered, "mouseout", t);var e,
					    i = t.toElement || t.relatedTarget;do {
						i = i && i.parentNode;
					} while (i && 9 != i.nodeType && !(e = i === this.painterRoot));!e && this.trigger("globalout", { event: t });
				}, resize: function resize(t) {
					this._hovered = {};
				}, dispatch: function dispatch(t, e) {
					var i = this[t];i && i.call(this, e);
				}, dispose: function dispose() {
					this.proxy.dispose(), this.storage = this.proxy = this.painter = null;
				}, setCursorStyle: function setCursorStyle(t) {
					var e = this.proxy;e.setCursor && e.setCursor(t);
				}, dispatchToElement: function dispatchToElement(t, e, i) {
					t = t || {};for (var a = "on" + e, o = n(e, t, i), r = t.target; r && (r[a] && (o.cancelBubble = r[a].call(r, o)), r.trigger(e, o), r = r.parent, !o.cancelBubble);) {}o.cancelBubble || (this.trigger(e, o), this.painter && this.painter.eachOtherLayer(function (t) {
						"function" == typeof t[a] && t[a].call(t, o), t.trigger && t.trigger(e, o);
					}));
				}, findHover: function findHover(t, e, i) {
					for (var n = this.storage.getDisplayList(), a = {}, r = n.length - 1; r >= 0; r--) {
						var s;if (n[r] !== i && !n[r].ignore && (s = o(n[r], t, e)) && (!a.topTarget && (a.topTarget = n[r]), s !== u)) {
							a.target = n[r];break;
						}
					}return a;
				} }, r.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function (t) {
				h.prototype[t] = function (e) {
					var i = this.findHover(e.zrX, e.zrY),
					    n = i.target;if ("mousedown" === t) this._downel = n, this._upel = n;else if ("mosueup" === t) this._upel = n;else if ("click" === t && this._downel !== this._upel) return;this.dispatchToElement(i, t, e);
				};
			}), r.mixin(h, l), r.mixin(h, s), t.exports = h;
		}, function (t, e, i) {
			function n() {
				return !1;
			}function a(t, e, i, n) {
				var a = document.createElement(e),
				    o = i.getWidth(),
				    r = i.getHeight(),
				    s = a.style;return s.position = "absolute", s.left = 0, s.top = 0, s.width = o + "px", s.height = r + "px", a.width = o * n, a.height = r * n, a.setAttribute("data-zr-dom-id", t), a;
			}var o = i(1),
			    r = i(35),
			    s = i(73),
			    l = i(72),
			    u = function u(t, e, i) {
				var s;i = i || r.devicePixelRatio, "string" == typeof t ? s = a(t, "canvas", e, i) : o.isObject(t) && (s = t, t = s.id), this.id = t, this.dom = s;var l = s.style;l && (s.onselectstart = n, l["-webkit-user-select"] = "none", l["user-select"] = "none", l["-webkit-touch-callout"] = "none", l["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", l.padding = 0, l.margin = 0, l["border-width"] = 0), this.domBack = null, this.ctxBack = null, this.painter = e, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = i;
			};u.prototype = { constructor: u, elCount: 0, __dirty: !0, initContext: function initContext() {
					this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
				}, createBackBuffer: function createBackBuffer() {
					var t = this.dpr;this.domBack = a("back-" + this.id, "canvas", this.painter, t), this.ctxBack = this.domBack.getContext("2d"), 1 != t && this.ctxBack.scale(t, t);
				}, resize: function resize(t, e) {
					var i = this.dpr,
					    n = this.dom,
					    a = n.style,
					    o = this.domBack;a.width = t + "px", a.height = e + "px", n.width = t * i, n.height = e * i, o && (o.width = t * i, o.height = e * i, 1 != i && this.ctxBack.scale(i, i));
				}, clear: function clear(t) {
					var e = this.dom,
					    i = this.ctx,
					    n = e.width,
					    a = e.height,
					    o = this.clearColor,
					    r = this.motionBlur && !t,
					    u = this.lastFrameAlpha,
					    c = this.dpr;if (r && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(e, 0, 0, n / c, a / c)), i.clearRect(0, 0, n, a), o) {
						var h;o.colorStops ? (h = o.__canvasGradient || s.getGradient(i, o, { x: 0, y: 0, width: n, height: a }), o.__canvasGradient = h) : o.image && (h = l.prototype.getCanvasPattern.call(o, i)), i.save(), i.fillStyle = h || o, i.fillRect(0, 0, n, a), i.restore();
					}if (r) {
						var d = this.domBack;i.save(), i.globalAlpha = u, i.drawImage(d, 0, 0, n, a), i.restore();
					}
				} }, t.exports = u;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return parseInt(t, 10);
			}function a(t) {
				return !!t && (!!t.__builtin__ || "function" == typeof t.resize && "function" == typeof t.refresh);
			}function o(t) {
				t.__unusedCount++;
			}function r(t) {
				1 == t.__unusedCount && t.clear();
			}function s(t, e, i) {
				return x.copy(t.getBoundingRect()), t.transform && x.applyTransform(t.transform), _.width = e, _.height = i, !x.intersect(_);
			}function l(t, e) {
				if (t == e) return !1;if (!t || !e || t.length !== e.length) return !0;for (var i = 0; i < t.length; i++) {
					if (t[i] !== e[i]) return !0;
				}
			}function u(t, e) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];n.setTransform(e), e.beginPath(), n.buildPath(e, n.shape), e.clip(), n.restoreTransform(e);
				}
			}function c(t, e) {
				var i = document.createElement("div");return i.style.cssText = ["position:relative", "overflow:hidden", "width:" + t + "px", "height:" + e + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";", i;
			}var h = i(35),
			    d = i(1),
			    f = i(52),
			    p = i(11),
			    g = i(51),
			    m = i(153),
			    v = i(68),
			    y = 5,
			    x = new p(0, 0, 0, 0),
			    _ = new p(0, 0, 0, 0),
			    b = function b(t, e, i) {
				var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();this._opts = i = d.extend({}, i || {}), this.dpr = i.devicePixelRatio || h.devicePixelRatio, this._singleCanvas = n, this.root = t;var a = t.style;a && (a["-webkit-tap-highlight-color"] = "transparent", a["-webkit-user-select"] = a["user-select"] = a["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e;var o = this._zlevelList = [],
				    r = this._layers = {};if (this._layerConfig = {}, n) {
					null != i.width && (t.width = i.width), null != i.height && (t.height = i.height);var s = t.width,
					    l = t.height;this._width = s, this._height = l;var u = new m(t, this, 1);u.initContext(), r[0] = u, o.push(0), this._domRoot = t;
				} else {
					this._width = this._getSize(0), this._height = this._getSize(1);var f = this._domRoot = c(this._width, this._height);t.appendChild(f);
				}this._progressiveLayers = [], this._hoverlayer, this._hoverElements = [];
			};b.prototype = { constructor: b, isSingleCanvas: function isSingleCanvas() {
					return this._singleCanvas;
				}, getViewportRoot: function getViewportRoot() {
					return this._domRoot;
				}, refresh: function refresh(t) {
					var e = this.storage.getDisplayList(!0),
					    i = this._zlevelList;this._paintList(e, t);for (var n = 0; n < i.length; n++) {
						var a = i[n],
						    o = this._layers[a];!o.__builtin__ && o.refresh && o.refresh();
					}return this.refreshHover(), this._progressiveLayers.length && this._startProgessive(), this;
				}, addHover: function addHover(t, e) {
					if (!t.__hoverMir) {
						var i = new t.constructor({ style: t.style, shape: t.shape });i.__from = t, t.__hoverMir = i, i.setStyle(e), this._hoverElements.push(i);
					}
				}, removeHover: function removeHover(t) {
					var e = t.__hoverMir,
					    i = this._hoverElements,
					    n = d.indexOf(i, e);n >= 0 && i.splice(n, 1), t.__hoverMir = null;
				}, clearHover: function clearHover(t) {
					for (var e = this._hoverElements, i = 0; i < e.length; i++) {
						var n = e[i].__from;n && (n.__hoverMir = null);
					}e.length = 0;
				}, refreshHover: function refreshHover() {
					var t = this._hoverElements,
					    e = t.length,
					    i = this._hoverlayer;if (i && i.clear(), e) {
						g(t, this.storage.displayableSortFunc), i || (i = this._hoverlayer = this.getLayer(1e5));var n = {};i.ctx.save();for (var a = 0; a < e;) {
							var o = t[a],
							    r = o.__from;r && r.__zr ? (a++, r.invisible || (o.transform = r.transform, o.invTransform = r.invTransform, o.__clipPaths = r.__clipPaths, this._doPaintEl(o, i, !0, n))) : (t.splice(a, 1), r.__hoverMir = null, e--);
						}i.ctx.restore();
					}
				}, _startProgessive: function _startProgessive() {
					function t() {
						i === e._progressiveToken && e.storage && (e._doPaintList(e.storage.getDisplayList()), e._furtherProgressive ? (e._progress++, v(t)) : e._progressiveToken = -1);
					}var e = this;if (e._furtherProgressive) {
						var i = e._progressiveToken = +new Date();e._progress++, v(t);
					}
				}, _clearProgressive: function _clearProgressive() {
					this._progressiveToken = -1, this._progress = 0, d.each(this._progressiveLayers, function (t) {
						t.__dirty && t.clear();
					});
				}, _paintList: function _paintList(t, e) {
					null == e && (e = !1), this._updateLayerStatus(t), this._clearProgressive(), this.eachBuiltinLayer(o), this._doPaintList(t, e), this.eachBuiltinLayer(r);
				}, _doPaintList: function _doPaintList(t, e) {
					function i(t) {
						var e = o.dpr || 1;o.save(), o.globalAlpha = 1, o.shadowBlur = 0, n.__dirty = !0, o.setTransform(1, 0, 0, 1, 0, 0), o.drawImage(t.dom, 0, 0, c * e, h * e), o.restore();
					}for (var n, a, o, r, s, l, u = 0, c = this._width, h = this._height, p = this._progress, g = 0, m = t.length; g < m; g++) {
						var v = t[g],
						    x = this._singleCanvas ? 0 : v.zlevel,
						    _ = v.__frame;if (_ < 0 && s && (i(s), s = null), a !== x && (o && o.restore(), r = {}, a = x, n = this.getLayer(a), n.__builtin__ || f("ZLevel " + a + " has been used by unkown layer " + n.id), o = n.ctx, o.save(), n.__unusedCount = 0, (n.__dirty || e) && n.clear()), n.__dirty || e) {
							if (_ >= 0) {
								if (!s) {
									if (s = this._progressiveLayers[Math.min(u++, y - 1)], s.ctx.save(), s.renderScope = {}, s && s.__progress > s.__maxProgress) {
										g = s.__nextIdxNotProg - 1;continue;
									}l = s.__progress, s.__dirty || (p = l), s.__progress = p + 1;
								}_ === p && this._doPaintEl(v, s, !0, s.renderScope);
							} else this._doPaintEl(v, n, e, r);v.__dirty = !1;
						}
					}s && i(s), o && o.restore(), this._furtherProgressive = !1, d.each(this._progressiveLayers, function (t) {
						t.__maxProgress >= t.__progress && (this._furtherProgressive = !0);
					}, this);
				}, _doPaintEl: function _doPaintEl(t, e, i, n) {
					var a = e.ctx,
					    o = t.transform;if ((e.__dirty || i) && !t.invisible && 0 !== t.style.opacity && (!o || o[0] || o[3]) && (!t.culling || !s(t, this._width, this._height))) {
						var r = t.__clipPaths;(n.prevClipLayer !== e || l(r, n.prevElClipPaths)) && (n.prevElClipPaths && (n.prevClipLayer.ctx.restore(), n.prevClipLayer = n.prevElClipPaths = null, n.prevEl = null), r && (a.save(), u(r, a), n.prevClipLayer = e, n.prevElClipPaths = r)), t.beforeBrush && t.beforeBrush(a), t.brush(a, n.prevEl || null), n.prevEl = t, t.afterBrush && t.afterBrush(a);
					}
				}, getLayer: function getLayer(t) {
					if (this._singleCanvas) return this._layers[0];var e = this._layers[t];return e || (e = new m("zr_" + t, this, this.dpr), e.__builtin__ = !0, this._layerConfig[t] && d.merge(e, this._layerConfig[t], !0), this.insertLayer(t, e), e.initContext()), e;
				}, insertLayer: function insertLayer(t, e) {
					var i = this._layers,
					    n = this._zlevelList,
					    o = n.length,
					    r = null,
					    s = -1,
					    l = this._domRoot;if (i[t]) return void f("ZLevel " + t + " has been used already");if (!a(e)) return void f("Layer of zlevel " + t + " is not valid");if (o > 0 && t > n[0]) {
						for (s = 0; s < o - 1 && !(n[s] < t && n[s + 1] > t); s++) {}r = i[n[s]];
					}if (n.splice(s + 1, 0, t), i[t] = e, !e.virtual) if (r) {
						var u = r.dom;u.nextSibling ? l.insertBefore(e.dom, u.nextSibling) : l.appendChild(e.dom);
					} else l.firstChild ? l.insertBefore(e.dom, l.firstChild) : l.appendChild(e.dom);
				}, eachLayer: function eachLayer(t, e) {
					var i,
					    n,
					    a = this._zlevelList;for (n = 0; n < a.length; n++) {
						i = a[n], t.call(e, this._layers[i], i);
					}
				}, eachBuiltinLayer: function eachBuiltinLayer(t, e) {
					var i,
					    n,
					    a,
					    o = this._zlevelList;for (a = 0; a < o.length; a++) {
						n = o[a], i = this._layers[n], i.__builtin__ && t.call(e, i, n);
					}
				}, eachOtherLayer: function eachOtherLayer(t, e) {
					var i,
					    n,
					    a,
					    o = this._zlevelList;for (a = 0; a < o.length; a++) {
						n = o[a], i = this._layers[n], i.__builtin__ || t.call(e, i, n);
					}
				}, getLayers: function getLayers() {
					return this._layers;
				}, _updateLayerStatus: function _updateLayerStatus(t) {
					var e = this._layers,
					    i = this._progressiveLayers,
					    n = {},
					    a = {};this.eachBuiltinLayer(function (t, e) {
						n[e] = t.elCount, t.elCount = 0, t.__dirty = !1;
					}), d.each(i, function (t, e) {
						a[e] = t.elCount, t.elCount = 0, t.__dirty = !1;
					});for (var o, r, s = 0, l = 0, u = 0, c = t.length; u < c; u++) {
						var h = t[u],
						    f = this._singleCanvas ? 0 : h.zlevel,
						    p = e[f],
						    g = h.progressive;if (p && (p.elCount++, p.__dirty = p.__dirty || h.__dirty), g >= 0) {
							r !== g && (r = g, l++);var v = h.__frame = l - 1;if (!o) {
								var x = Math.min(s, y - 1);o = i[x], o || (o = i[x] = new m("progressive", this, this.dpr), o.initContext()), o.__maxProgress = 0;
							}o.__dirty = o.__dirty || h.__dirty, o.elCount++, o.__maxProgress = Math.max(o.__maxProgress, v), o.__maxProgress >= o.__progress && (p.__dirty = !0);
						} else h.__frame = -1, o && (o.__nextIdxNotProg = u, s++, o = null);
					}o && (s++, o.__nextIdxNotProg = u), this.eachBuiltinLayer(function (t, e) {
						n[e] !== t.elCount && (t.__dirty = !0);
					}), i.length = Math.min(s, y), d.each(i, function (t, e) {
						a[e] !== t.elCount && (h.__dirty = !0), t.__dirty && (t.__progress = 0);
					});
				}, clear: function clear() {
					return this.eachBuiltinLayer(this._clearLayer), this;
				}, _clearLayer: function _clearLayer(t) {
					t.clear();
				}, configLayer: function configLayer(t, e) {
					if (e) {
						var i = this._layerConfig;i[t] ? d.merge(i[t], e, !0) : i[t] = e;var n = this._layers[t];n && d.merge(n, i[t], !0);
					}
				}, delLayer: function delLayer(t) {
					var e = this._layers,
					    i = this._zlevelList,
					    n = e[t];n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i.splice(d.indexOf(i, t), 1));
				}, resize: function resize(t, e) {
					var i = this._domRoot;i.style.display = "none";var n = this._opts;if (null != t && (n.width = t), null != e && (n.height = e), t = this._getSize(0), e = this._getSize(1), i.style.display = "", this._width != t || e != this._height) {
						i.style.width = t + "px", i.style.height = e + "px";for (var a in this._layers) {
							this._layers.hasOwnProperty(a) && this._layers[a].resize(t, e);
						}d.each(this._progressiveLayers, function (i) {
							i.resize(t, e);
						}), this.refresh(!0);
					}return this._width = t, this._height = e, this;
				}, clearLayer: function clearLayer(t) {
					var e = this._layers[t];e && e.clear();
				}, dispose: function dispose() {
					this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
				}, getRenderedCanvas: function getRenderedCanvas(t) {
					function e(t, e) {
						var n = r._zlevelList;null == t && (t = -(1 / 0));for (var a, o = 0; o < n.length; o++) {
							var s = n[o],
							    l = r._layers[s];if (!l.__builtin__ && s > t && s < e) {
								a = l;break;
							}
						}a && a.renderToCanvas && (i.ctx.save(), a.renderToCanvas(i.ctx), i.ctx.restore());
					}if (t = t || {}, this._singleCanvas) return this._layers[0].dom;var i = new m("image", this, t.pixelRatio || this.dpr);i.initContext(), i.clearColor = t.backgroundColor, i.clear();for (var n, a = this.storage.getDisplayList(!0), o = {}, r = this, s = 0; s < a.length; s++) {
						var l = a[s];l.zlevel !== n && (e(n, l.zlevel), n = l.zlevel), this._doPaintEl(l, i, !0, o);
					}return e(n, 1 / 0), i.dom;
				}, getWidth: function getWidth() {
					return this._width;
				}, getHeight: function getHeight() {
					return this._height;
				}, _getSize: function _getSize(t) {
					var e = this._opts,
					    i = ["width", "height"][t],
					    a = ["clientWidth", "clientHeight"][t],
					    o = ["paddingLeft", "paddingTop"][t],
					    r = ["paddingRight", "paddingBottom"][t];if (null != e[i] && "auto" !== e[i]) return parseFloat(e[i]);var s = this.root,
					    l = document.defaultView.getComputedStyle(s);return (s[a] || n(l[i]) || n(s.style[i])) - (n(l[o]) || 0) - (n(l[r]) || 0) | 0;
				}, pathToImage: function pathToImage(t, e) {
					e = e || this.dpr;var n = document.createElement("canvas"),
					    a = n.getContext("2d"),
					    o = t.getBoundingRect(),
					    r = t.style,
					    s = r.shadowBlur,
					    l = r.shadowOffsetX,
					    u = r.shadowOffsetY,
					    c = r.hasStroke() ? r.lineWidth : 0,
					    h = Math.max(c / 2, -l + s),
					    d = Math.max(c / 2, l + s),
					    f = Math.max(c / 2, -u + s),
					    p = Math.max(c / 2, u + s),
					    g = o.width + h + d,
					    m = o.height + f + p;n.width = g * e, n.height = m * e, a.scale(e, e), a.clearRect(0, 0, g, m), a.dpr = e;var v = { position: t.position, rotation: t.rotation, scale: t.scale };t.position = [h - o.x, f - o.y], t.rotation = 0, t.scale = [1, 1], t.updateTransform(), t && t.brush(a);var y = i(53),
					    x = new y({ style: { x: 0, y: 0, image: n } });return null != v.position && (x.position = t.position = v.position), null != v.rotation && (x.rotation = t.rotation = v.rotation), null != v.scale && (x.scale = t.scale = v.scale), x;
				} }, t.exports = b;
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel;
			}var a = i(1),
			    o = i(9),
			    r = i(36),
			    s = i(51),
			    l = function l() {
				this._roots = [], this._displayList = [], this._displayListLen = 0;
			};l.prototype = { constructor: l, traverse: function traverse(t, e) {
					for (var i = 0; i < this._roots.length; i++) {
						this._roots[i].traverse(t, e);
					}
				}, getDisplayList: function getDisplayList(t, e) {
					return e = e || !1, t && this.updateDisplayList(e), this._displayList;
				}, updateDisplayList: function updateDisplayList(t) {
					this._displayListLen = 0;for (var e = this._roots, i = this._displayList, a = 0, r = e.length; a < r; a++) {
						this._updateAndAddDisplayable(e[a], null, t);
					}i.length = this._displayListLen, o.canvasSupported && s(i, n);
				}, _updateAndAddDisplayable: function _updateAndAddDisplayable(t, e, i) {
					if (!t.ignore || i) {
						t.beforeUpdate(), t.__dirty && t.update(), t.afterUpdate();var n = t.clipPath;if (n) {
							e = e ? e.slice() : [];for (var a = n, o = t; a;) {
								a.parent = o, a.updateTransform(), e.push(a), o = a, a = a.clipPath;
							}
						}if (t.isGroup) {
							for (var r = t._children, s = 0; s < r.length; s++) {
								var l = r[s];t.__dirty && (l.__dirty = !0), this._updateAndAddDisplayable(l, e, i);
							}t.__dirty = !1;
						} else t.__clipPaths = e, this._displayList[this._displayListLen++] = t;
					}
				}, addRoot: function addRoot(t) {
					t.__storage !== this && (t instanceof r && t.addChildrenToStorage(this), this.addToStorage(t), this._roots.push(t));
				}, delRoot: function delRoot(t) {
					if (null == t) {
						for (var e = 0; e < this._roots.length; e++) {
							var i = this._roots[e];i instanceof r && i.delChildrenFromStorage(this);
						}return this._roots = [], this._displayList = [], void (this._displayListLen = 0);
					}if (t instanceof Array) for (var e = 0, n = t.length; e < n; e++) {
						this.delRoot(t[e]);
					} else {
						var o = a.indexOf(this._roots, t);o >= 0 && (this.delFromStorage(t), this._roots.splice(o, 1), t instanceof r && t.delChildrenFromStorage(this));
					}
				}, addToStorage: function addToStorage(t) {
					return t.__storage = this, t.dirty(!1), this;
				}, delFromStorage: function delFromStorage(t) {
					return t && (t.__storage = null), this;
				}, dispose: function dispose() {
					this._renderList = this._roots = null;
				}, displayableSortFunc: n }, t.exports = l;
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(21).Dispatcher,
			    o = i(68),
			    r = i(67),
			    s = function s(t) {
				t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function () {}, this._clips = [], this._running = !1, this._time, this._pausedTime, this._pauseStart, this._paused = !1, a.call(this);
			};s.prototype = { constructor: s, addClip: function addClip(t) {
					this._clips.push(t);
				}, addAnimator: function addAnimator(t) {
					t.animation = this;for (var e = t.getClips(), i = 0; i < e.length; i++) {
						this.addClip(e[i]);
					}
				}, removeClip: function removeClip(t) {
					var e = n.indexOf(this._clips, t);e >= 0 && this._clips.splice(e, 1);
				}, removeAnimator: function removeAnimator(t) {
					for (var e = t.getClips(), i = 0; i < e.length; i++) {
						this.removeClip(e[i]);
					}t.animation = null;
				}, _update: function _update() {
					for (var t = new Date().getTime() - this._pausedTime, e = t - this._time, i = this._clips, n = i.length, a = [], o = [], r = 0; r < n; r++) {
						var s = i[r],
						    l = s.step(t, e);l && (a.push(l), o.push(s));
					}for (var r = 0; r < n;) {
						i[r]._needsRemove ? (i[r] = i[n - 1], i.pop(), n--) : r++;
					}n = a.length;for (var r = 0; r < n; r++) {
						o[r].fire(a[r]);
					}this._time = t, this.onframe(e), this.trigger("frame", e), this.stage.update && this.stage.update();
				}, _startLoop: function _startLoop() {
					function t() {
						e._running && (o(t), !e._paused && e._update());
					}var e = this;this._running = !0, o(t);
				}, start: function start() {
					this._time = new Date().getTime(), this._pausedTime = 0, this._startLoop();
				}, stop: function stop() {
					this._running = !1;
				}, pause: function pause() {
					this._paused || (this._pauseStart = new Date().getTime(), this._paused = !0);
				}, resume: function resume() {
					this._paused && (this._pausedTime += new Date().getTime() - this._pauseStart, this._paused = !1);
				}, clear: function clear() {
					this._clips = [];
				}, animate: function animate(t, e) {
					e = e || {};var i = new r(t, e.loop, e.getter, e.setter);return this.addAnimator(i), i;
				} }, n.mixin(s, a), t.exports = s;
		}, function (t, e, i) {
			function n(t) {
				this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null != t.loop && t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart, this._pausedTime = 0, this._paused = !1;
			}var a = i(158);n.prototype = { constructor: n, step: function step(t, e) {
					if (this._initialized || (this._startTime = t + this._delay, this._initialized = !0), this._paused) return void (this._pausedTime += e);var i = (t - this._startTime - this._pausedTime) / this._life;if (!(i < 0)) {
						i = Math.min(i, 1);var n = this.easing,
						    o = "string" == typeof n ? a[n] : n,
						    r = "function" == typeof o ? o(i) : i;return this.fire("frame", r), 1 == i ? this.loop ? (this.restart(t), "restart") : (this._needsRemove = !0, "destroy") : null;
					}
				}, restart: function restart(t) {
					var e = (t - this._startTime - this._pausedTime) % this._life;this._startTime = t - e + this.gap, this._pausedTime = 0, this._needsRemove = !1;
				}, fire: function fire(t, e) {
					t = "on" + t, this[t] && this[t](this._target, e);
				}, pause: function pause() {
					this._paused = !0;
				}, resume: function resume() {
					this._paused = !1;
				} }, t.exports = n;
		}, function (t, e) {
			var i = { linear: function linear(t) {
					return t;
				}, quadraticIn: function quadraticIn(t) {
					return t * t;
				}, quadraticOut: function quadraticOut(t) {
					return t * (2 - t);
				}, quadraticInOut: function quadraticInOut(t) {
					return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1);
				}, cubicIn: function cubicIn(t) {
					return t * t * t;
				}, cubicOut: function cubicOut(t) {
					return --t * t * t + 1;
				}, cubicInOut: function cubicInOut(t) {
					return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2);
				}, quarticIn: function quarticIn(t) {
					return t * t * t * t;
				}, quarticOut: function quarticOut(t) {
					return 1 - --t * t * t * t;
				}, quarticInOut: function quarticInOut(t) {
					return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2);
				}, quinticIn: function quinticIn(t) {
					return t * t * t * t * t;
				}, quinticOut: function quinticOut(t) {
					return --t * t * t * t * t + 1;
				}, quinticInOut: function quinticInOut(t) {
					return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2);
				}, sinusoidalIn: function sinusoidalIn(t) {
					return 1 - Math.cos(t * Math.PI / 2);
				}, sinusoidalOut: function sinusoidalOut(t) {
					return Math.sin(t * Math.PI / 2);
				}, sinusoidalInOut: function sinusoidalInOut(t) {
					return .5 * (1 - Math.cos(Math.PI * t));
				}, exponentialIn: function exponentialIn(t) {
					return 0 === t ? 0 : Math.pow(1024, t - 1);
				}, exponentialOut: function exponentialOut(t) {
					return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
				}, exponentialInOut: function exponentialInOut(t) {
					return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2);
				}, circularIn: function circularIn(t) {
					return 1 - Math.sqrt(1 - t * t);
				}, circularOut: function circularOut(t) {
					return Math.sqrt(1 - --t * t);
				}, circularInOut: function circularInOut(t) {
					return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
				}, elasticIn: function elasticIn(t) {
					var e,
					    i = .1,
					    n = .4;return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n)));
				}, elasticOut: function elasticOut(t) {
					var e,
					    i = .1,
					    n = .4;return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / n) + 1);
				}, elasticInOut: function elasticInOut(t) {
					var e,
					    i = .1,
					    n = .4;return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * (i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n)) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n) * .5 + 1);
				}, backIn: function backIn(t) {
					var e = 1.70158;return t * t * ((e + 1) * t - e);
				}, backOut: function backOut(t) {
					var e = 1.70158;return --t * t * ((e + 1) * t + e) + 1;
				}, backInOut: function backInOut(t) {
					var e = 2.5949095;return (t *= 2) < 1 ? .5 * (t * t * ((e + 1) * t - e)) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2);
				}, bounceIn: function bounceIn(t) {
					return 1 - i.bounceOut(1 - t);
				}, bounceOut: function bounceOut(t) {
					return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
				}, bounceInOut: function bounceInOut(t) {
					return t < .5 ? .5 * i.bounceIn(2 * t) : .5 * i.bounceOut(2 * t - 1) + .5;
				} };t.exports = i;
		}, function (t, e, i) {
			var n = i(69).normalizeRadian,
			    a = 2 * Math.PI;t.exports = { containStroke: function containStroke(t, e, i, o, r, s, l, u, c) {
					if (0 === l) return !1;var h = l;u -= t, c -= e;var d = Math.sqrt(u * u + c * c);if (d - h > i || d + h < i) return !1;if (Math.abs(o - r) % a < 1e-4) return !0;if (s) {
						var f = o;o = n(r), r = n(f);
					} else o = n(o), r = n(r);o > r && (r += a);var p = Math.atan2(c, u);return p < 0 && (p += a), p >= o && p <= r || p + a >= o && p + a <= r;
				} };
		}, function (t, e, i) {
			var n = i(20);t.exports = { containStroke: function containStroke(t, e, i, a, o, r, s, l, u, c, h) {
					if (0 === u) return !1;var d = u;if (h > e + d && h > a + d && h > r + d && h > l + d || h < e - d && h < a - d && h < r - d && h < l - d || c > t + d && c > i + d && c > o + d && c > s + d || c < t - d && c < i - d && c < o - d && c < s - d) return !1;var f = n.cubicProjectPoint(t, e, i, a, o, r, s, l, c, h, null);return f <= d / 2;
				} };
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				return Math.abs(t - e) < x;
			}function a() {
				var t = b[0];b[0] = b[1], b[1] = t;
			}function o(t, e, i, n, o, r, s, l, u, c) {
				if (c > e && c > n && c > r && c > l || c < e && c < n && c < r && c < l) return 0;var h = g.cubicRootAt(e, n, r, l, c, _);if (0 === h) return 0;for (var d, f, p = 0, m = -1, v = 0; v < h; v++) {
					var y = _[v],
					    x = 0 === y || 1 === y ? .5 : 1,
					    w = g.cubicAt(t, i, o, s, y);w < u || (m < 0 && (m = g.cubicExtrema(e, n, r, l, b), b[1] < b[0] && m > 1 && a(), d = g.cubicAt(e, n, r, l, b[0]), m > 1 && (f = g.cubicAt(e, n, r, l, b[1]))), p += 2 == m ? y < b[0] ? d < e ? x : -x : y < b[1] ? f < d ? x : -x : l < f ? x : -x : y < b[0] ? d < e ? x : -x : l < d ? x : -x);
				}return p;
			}function r(t, e, i, n, a, o, r, s) {
				if (s > e && s > n && s > o || s < e && s < n && s < o) return 0;var l = g.quadraticRootAt(e, n, o, s, _);if (0 === l) return 0;var u = g.quadraticExtremum(e, n, o);if (u >= 0 && u <= 1) {
					for (var c = 0, h = g.quadraticAt(e, n, o, u), d = 0; d < l; d++) {
						var f = 0 === _[d] || 1 === _[d] ? .5 : 1,
						    p = g.quadraticAt(t, i, a, _[d]);p < r || (c += _[d] < u ? h < e ? f : -f : o < h ? f : -f);
					}return c;
				}var f = 0 === _[0] || 1 === _[0] ? .5 : 1,
				    p = g.quadraticAt(t, i, a, _[0]);return p < r ? 0 : o < e ? f : -f;
			}function s(t, e, i, n, a, o, r, s) {
				if (s -= e, s > i || s < -i) return 0;var l = Math.sqrt(i * i - s * s);_[0] = -l, _[1] = l;var u = Math.abs(n - a);if (u < 1e-4) return 0;if (u % y < 1e-4) {
					n = 0, a = y;var c = o ? 1 : -1;return r >= _[0] + t && r <= _[1] + t ? c : 0;
				}if (o) {
					var l = n;n = p(a), a = p(l);
				} else n = p(n), a = p(a);n > a && (a += y);for (var h = 0, d = 0; d < 2; d++) {
					var f = _[d];if (f + t > r) {
						var g = Math.atan2(s, f),
						    c = o ? 1 : -1;g < 0 && (g = y + g), (g >= n && g <= a || g + y >= n && g + y <= a) && (g > Math.PI / 2 && g < 1.5 * Math.PI && (c = -c), h += c);
					}
				}return h;
			}function l(t, e, i, a, l) {
				for (var c = 0, p = 0, g = 0, y = 0, x = 0, _ = 0; _ < t.length;) {
					var b = t[_++];switch (b === u.M && _ > 1 && (i || (c += m(p, g, y, x, a, l))), 1 == _ && (p = t[_], g = t[_ + 1], y = p, x = g), b) {case u.M:
							y = t[_++], x = t[_++], p = y, g = x;break;case u.L:
							if (i) {
								if (v(p, g, t[_], t[_ + 1], e, a, l)) return !0;
							} else c += m(p, g, t[_], t[_ + 1], a, l) || 0;p = t[_++], g = t[_++];break;case u.C:
							if (i) {
								if (h.containStroke(p, g, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], e, a, l)) return !0;
							} else c += o(p, g, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], a, l) || 0;p = t[_++], g = t[_++];break;case u.Q:
							if (i) {
								if (d.containStroke(p, g, t[_++], t[_++], t[_], t[_ + 1], e, a, l)) return !0;
							} else c += r(p, g, t[_++], t[_++], t[_], t[_ + 1], a, l) || 0;p = t[_++], g = t[_++];break;case u.A:
							var w = t[_++],
							    S = t[_++],
							    M = t[_++],
							    I = t[_++],
							    T = t[_++],
							    A = t[_++],
							    C = (t[_++], 1 - t[_++]),
							    L = Math.cos(T) * M + w,
							    D = Math.sin(T) * I + S;_ > 1 ? c += m(p, g, L, D, a, l) : (y = L, x = D);var P = (a - w) * I / M + w;if (i) {
								if (f.containStroke(w, S, I, T, T + A, C, e, P, l)) return !0;
							} else c += s(w, S, I, T, T + A, C, P, l);p = Math.cos(T + A) * M + w, g = Math.sin(T + A) * I + S;break;case u.R:
							y = p = t[_++], x = g = t[_++];var k = t[_++],
							    O = t[_++],
							    L = y + k,
							    D = x + O;if (i) {
								if (v(y, x, L, x, e, a, l) || v(L, x, L, D, e, a, l) || v(L, D, y, D, e, a, l) || v(y, D, y, x, e, a, l)) return !0;
							} else c += m(L, x, L, D, a, l), c += m(y, D, y, x, a, l);break;case u.Z:
							if (i) {
								if (v(p, g, y, x, e, a, l)) return !0;
							} else c += m(p, g, y, x, a, l);p = y, g = x;}
				}return i || n(g, x) || (c += m(p, g, y, x, a, l) || 0), 0 !== c;
			}var u = i(27).CMD,
			    c = i(97),
			    h = i(160),
			    d = i(98),
			    f = i(159),
			    p = i(69).normalizeRadian,
			    g = i(20),
			    m = i(99),
			    v = c.containStroke,
			    y = 2 * Math.PI,
			    x = 1e-4,
			    _ = [-1, -1, -1],
			    b = [-1, -1];t.exports = { contain: function contain(t, e, i) {
					return l(t, 0, !1, e, i);
				}, containStroke: function containStroke(t, e, i, n) {
					return l(t, e, !0, i, n);
				} };
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				var e = t[1][0] - t[0][0],
				    i = t[1][1] - t[0][1];return Math.sqrt(e * e + i * i);
			}function a(t) {
				return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2];
			}var o = i(21),
			    r = function r() {
				this._track = [];
			};r.prototype = { constructor: r, recognize: function recognize(t, e, i) {
					return this._doTrack(t, e, i), this._recognize(t);
				}, clear: function clear() {
					return this._track.length = 0, this;
				}, _doTrack: function _doTrack(t, e, i) {
					var n = t.touches;if (n) {
						for (var a = { points: [], touches: [], target: e, event: t }, r = 0, s = n.length; r < s; r++) {
							var l = n[r],
							    u = o.clientToLocal(i, l, {});a.points.push([u.zrX, u.zrY]), a.touches.push(l);
						}this._track.push(a);
					}
				}, _recognize: function _recognize(t) {
					for (var e in s) {
						if (s.hasOwnProperty(e)) {
							var i = s[e](this._track, t);if (i) return i;
						}
					}
				} };var s = { pinch: function pinch(t, e) {
					var i = t.length;if (i) {
						var o = (t[i - 1] || {}).points,
						    r = (t[i - 2] || {}).points || o;if (r && r.length > 1 && o && o.length > 1) {
							var s = n(o) / n(r);!isFinite(s) && (s = 1), e.pinchScale = s;var l = a(o);return e.pinchX = l[0], e.pinchY = l[1], { type: "pinch", target: t[0].target, event: e };
						}
					}
				} };t.exports = r;
		}, function (t, e, i) {
			function n(t) {
				return "mousewheel" === t && d.browser.firefox ? "DOMMouseScroll" : t;
			}function a(t, e, i) {
				var n = t._gestureMgr;"start" === i && n.clear();var a = n.recognize(e, t.handler.findHover(e.zrX, e.zrY, null).target, t.dom);if ("end" === i && n.clear(), a) {
					var o = a.type;e.gestureEvent = o, t.handler.dispatchToElement({ target: a.target }, o, a.event);
				}
			}function o(t) {
				t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(function () {
					t._touching = !1;
				}, 700);
			}function r(t) {
				var e = t.pointerType;return "pen" === e || "touch" === e;
			}function s(t) {
				function e(t, e) {
					return function () {
						if (!e._touching) return t.apply(e, arguments);
					};
				}c.each(x, function (e) {
					t._handlers[e] = c.bind(w[e], t);
				}), c.each(b, function (e) {
					t._handlers[e] = c.bind(w[e], t);
				}), c.each(y, function (i) {
					t._handlers[i] = e(w[i], t);
				});
			}function l(t) {
				function e(e, i) {
					c.each(e, function (e) {
						p(t, n(e), i._handlers[e]);
					}, i);
				}h.call(this), this.dom = t, this._touching = !1, this._touchTimer, this._gestureMgr = new f(), this._handlers = {}, s(this), d.pointerEventsSupported ? e(b, this) : (d.touchEventsSupported && e(x, this), e(y, this));
			}var u = i(21),
			    c = i(1),
			    h = i(23),
			    d = i(9),
			    f = i(162),
			    p = u.addEventListener,
			    g = u.removeEventListener,
			    m = u.normalizeEvent,
			    v = 300,
			    y = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
			    x = ["touchstart", "touchend", "touchmove"],
			    _ = { pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1 },
			    b = c.map(y, function (t) {
				var e = t.replace("mouse", "pointer");return _[e] ? e : t;
			}),
			    w = { mousemove: function mousemove(t) {
					t = m(this.dom, t), this.trigger("mousemove", t);
				}, mouseout: function mouseout(t) {
					t = m(this.dom, t);var e = t.toElement || t.relatedTarget;if (e != this.dom) for (; e && 9 != e.nodeType;) {
						if (e === this.dom) return;e = e.parentNode;
					}this.trigger("mouseout", t);
				}, touchstart: function touchstart(t) {
					t = m(this.dom, t), t.zrByTouch = !0, this._lastTouchMoment = new Date(), a(this, t, "start"), w.mousemove.call(this, t), w.mousedown.call(this, t), o(this);
				}, touchmove: function touchmove(t) {
					t = m(this.dom, t), t.zrByTouch = !0, a(this, t, "change"), w.mousemove.call(this, t), o(this);
				}, touchend: function touchend(t) {
					t = m(this.dom, t), t.zrByTouch = !0, a(this, t, "end"), w.mouseup.call(this, t), +new Date() - this._lastTouchMoment < v && w.click.call(this, t), o(this);
				}, pointerdown: function pointerdown(t) {
					w.mousedown.call(this, t);
				}, pointermove: function pointermove(t) {
					r(t) || w.mousemove.call(this, t);
				}, pointerup: function pointerup(t) {
					w.mouseup.call(this, t);
				}, pointerout: function pointerout(t) {
					r(t) || w.mouseout.call(this, t);
				} };c.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function (t) {
				w[t] = function (e) {
					e = m(this.dom, e), this.trigger(t, e);
				};
			});var S = l.prototype;S.dispose = function () {
				for (var t = y.concat(x), e = 0; e < t.length; e++) {
					var i = t[e];g(this.dom, n(i), this._handlers[i]);
				}
			}, S.setCursor = function (t) {
				this.dom.style.cursor = t || "default";
			}, c.mixin(l, h), t.exports = l;
		}, function (t, e, i) {
			var n = i(8);t.exports = n.extend({ type: "compound", shape: { paths: null }, _updatePathDirty: function _updatePathDirty() {
					for (var t = this.__dirtyPath, e = this.shape.paths, i = 0; i < e.length; i++) {
						t = t || e[i].__dirtyPath;
					}this.__dirtyPath = t, this.__dirty = this.__dirty || t;
				}, beforeBrush: function beforeBrush() {
					this._updatePathDirty();for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t.length; i++) {
						t[i].path || t[i].createPathProxy(), t[i].path.setScale(e[0], e[1]);
					}
				}, buildPath: function buildPath(t, e) {
					for (var i = e.paths || [], n = 0; n < i.length; n++) {
						i[n].buildPath(t, i[n].shape, !0);
					}
				}, afterBrush: function afterBrush() {
					for (var t = this.shape.paths, e = 0; e < t.length; e++) {
						t[e].__dirtyPath = !1;
					}
				}, getBoundingRect: function getBoundingRect() {
					return this._updatePathDirty(), n.prototype.getBoundingRect.call(this);
				} });
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(39),
			    o = function o(t, e, i, n, _o3) {
				this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == i ? .5 : i, this.type = "radial", this.global = _o3 || !1, a.call(this, n);
			};o.prototype = { constructor: o }, n.inherits(o, a), t.exports = o;
		}, function (t, e) {
			t.exports = { buildPath: function buildPath(t, e) {
					var i,
					    n,
					    a,
					    o,
					    r = e.x,
					    s = e.y,
					    l = e.width,
					    u = e.height,
					    c = e.r;l < 0 && (r += l, l = -l), u < 0 && (s += u, u = -u), "number" == typeof c ? i = n = a = o = c : c instanceof Array ? 1 === c.length ? i = n = a = o = c[0] : 2 === c.length ? (i = a = c[0], n = o = c[1]) : 3 === c.length ? (i = c[0], n = o = c[1], a = c[2]) : (i = c[0], n = c[1], a = c[2], o = c[3]) : i = n = a = o = 0;var h;i + n > l && (h = i + n, i *= l / h, n *= l / h), a + o > l && (h = a + o, a *= l / h, o *= l / h), n + a > u && (h = n + a, n *= u / h, a *= u / h), i + o > u && (h = i + o, i *= u / h, o *= u / h), t.moveTo(r + i, s), t.lineTo(r + l - n, s), 0 !== n && t.quadraticCurveTo(r + l, s, r + l, s + n), t.lineTo(r + l, s + u - a), 0 !== a && t.quadraticCurveTo(r + l, s + u, r + l - a, s + u), t.lineTo(r + o, s + u), 0 !== o && t.quadraticCurveTo(r, s + u, r, s + u - o), t.lineTo(r, s + i), 0 !== i && t.quadraticCurveTo(r, s, r + i, s);
				} };
		}, function (t, e, i) {
			var n = i(6),
			    a = n.min,
			    o = n.max,
			    r = n.scale,
			    s = n.distance,
			    l = n.add;t.exports = function (t, e, i, u) {
				var c,
				    h,
				    d,
				    f,
				    p = [],
				    g = [],
				    m = [],
				    v = [];if (u) {
					d = [1 / 0, 1 / 0], f = [-(1 / 0), -(1 / 0)];for (var y = 0, x = t.length; y < x; y++) {
						a(d, d, t[y]), o(f, f, t[y]);
					}a(d, d, u[0]), o(f, f, u[1]);
				}for (var y = 0, x = t.length; y < x; y++) {
					var _ = t[y];if (i) c = t[y ? y - 1 : x - 1], h = t[(y + 1) % x];else {
						if (0 === y || y === x - 1) {
							p.push(n.clone(t[y]));continue;
						}c = t[y - 1], h = t[y + 1];
					}n.sub(g, h, c), r(g, g, e);var b = s(_, c),
					    w = s(_, h),
					    S = b + w;0 !== S && (b /= S, w /= S), r(m, g, -b), r(v, g, w);var M = l([], _, m),
					    I = l([], _, v);u && (o(M, M, d), a(M, M, f), o(I, I, d), a(I, I, f)), p.push(M), p.push(I);
				}return i && p.push(p.shift()), p;
			};
		}, function (t, e, i) {
			function n(t, e, i, n, a, o, r) {
				var s = .5 * (i - t),
				    l = .5 * (n - e);return (2 * (e - i) + s + l) * r + (-3 * (e - i) - 2 * s - l) * o + s * a + e;
			}var a = i(6);t.exports = function (t, e) {
				for (var i = t.length, o = [], r = 0, s = 1; s < i; s++) {
					r += a.distance(t[s - 1], t[s]);
				}var l = r / 2;l = l < i ? i : l;for (var s = 0; s < l; s++) {
					var u,
					    c,
					    h,
					    d = s / (l - 1) * (e ? i : i - 1),
					    f = Math.floor(d),
					    p = d - f,
					    g = t[f % i];e ? (u = t[(f - 1 + i) % i], c = t[(f + 1) % i], h = t[(f + 2) % i]) : (u = t[0 === f ? f : f - 1], c = t[f > i - 2 ? i - 1 : f + 1], h = t[f > i - 3 ? i - 1 : f + 2]);var m = p * p,
					    v = p * m;o.push([n(u[0], g[0], c[0], h[0], p, m, v), n(u[1], g[1], c[1], h[1], p, m, v)]);
				}return o;
			};
		}, function (t, e, i) {
			t.exports = i(8).extend({ type: "arc", shape: { cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, style: { stroke: "#000", fill: null }, buildPath: function buildPath(t, e) {
					var i = e.cx,
					    n = e.cy,
					    a = Math.max(e.r, 0),
					    o = e.startAngle,
					    r = e.endAngle,
					    s = e.clockwise,
					    l = Math.cos(o),
					    u = Math.sin(o);t.moveTo(l * a + i, u * a + n), t.arc(i, n, a, o, r, !s);
				} });
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				var n = t.cpx2,
				    a = t.cpy2;return null === n || null === a ? [(i ? h : u)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? h : u)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? c : l)(t.x1, t.cpx1, t.x2, e), (i ? c : l)(t.y1, t.cpy1, t.y2, e)];
			}var a = i(20),
			    o = i(6),
			    r = a.quadraticSubdivide,
			    s = a.cubicSubdivide,
			    l = a.quadraticAt,
			    u = a.cubicAt,
			    c = a.quadraticDerivativeAt,
			    h = a.cubicDerivativeAt,
			    d = [];t.exports = i(8).extend({ type: "bezier-curve", shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1 }, style: { stroke: "#000", fill: null }, buildPath: function buildPath(t, e) {
					var i = e.x1,
					    n = e.y1,
					    a = e.x2,
					    o = e.y2,
					    l = e.cpx1,
					    u = e.cpy1,
					    c = e.cpx2,
					    h = e.cpy2,
					    f = e.percent;0 !== f && (t.moveTo(i, n), null == c || null == h ? (f < 1 && (r(i, l, a, f, d), l = d[1], a = d[2], r(n, u, o, f, d), u = d[1], o = d[2]), t.quadraticCurveTo(l, u, a, o)) : (f < 1 && (s(i, l, c, a, f, d), l = d[1], c = d[2], a = d[3], s(n, u, h, o, f, d), u = d[1], h = d[2], o = d[3]), t.bezierCurveTo(l, u, c, h, a, o)));
				}, pointAt: function pointAt(t) {
					return n(this.shape, t, !1);
				}, tangentAt: function tangentAt(t) {
					var e = n(this.shape, t, !0);return o.normalize(e, e);
				} });
		}, function (t, e, i) {
			"use strict";
			t.exports = i(8).extend({ type: "circle", shape: { cx: 0, cy: 0, r: 0 }, buildPath: function buildPath(t, e, i) {
					i && t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0);
				} });
		}, function (t, e, i) {
			t.exports = i(8).extend({ type: "line", shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1 }, style: { stroke: "#000", fill: null }, buildPath: function buildPath(t, e) {
					var i = e.x1,
					    n = e.y1,
					    a = e.x2,
					    o = e.y2,
					    r = e.percent;0 !== r && (t.moveTo(i, n), r < 1 && (a = i * (1 - r) + a * r, o = n * (1 - r) + o * r), t.lineTo(a, o));
				}, pointAt: function pointAt(t) {
					var e = this.shape;return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t];
				} });
		}, function (t, e, i) {
			var n = i(74);t.exports = i(8).extend({ type: "polygon", shape: { points: null, smooth: !1, smoothConstraint: null }, buildPath: function buildPath(t, e) {
					n.buildPath(t, e, !0);
				} });
		}, function (t, e, i) {
			var n = i(74);t.exports = i(8).extend({ type: "polyline", shape: { points: null, smooth: !1, smoothConstraint: null }, style: { stroke: "#000", fill: null }, buildPath: function buildPath(t, e) {
					n.buildPath(t, e, !1);
				} });
		}, function (t, e, i) {
			var n = i(166);t.exports = i(8).extend({ type: "rect", shape: { r: 0, x: 0, y: 0, width: 0, height: 0 }, buildPath: function buildPath(t, e) {
					var i = e.x,
					    a = e.y,
					    o = e.width,
					    r = e.height;e.r ? n.buildPath(t, e) : t.rect(i, a, o, r), t.closePath();
				} });
		}, function (t, e, i) {
			t.exports = i(8).extend({ type: "ring", shape: { cx: 0, cy: 0, r: 0, r0: 0 }, buildPath: function buildPath(t, e) {
					var i = e.cx,
					    n = e.cy,
					    a = 2 * Math.PI;t.moveTo(i + e.r, n), t.arc(i, n, e.r, 0, a, !1), t.moveTo(i + e.r0, n), t.arc(i, n, e.r0, 0, a, !0);
				} });
		}, function (t, e, i) {
			var n = i(9),
			    a = i(8),
			    o = [["shadowBlur", 0], ["shadowColor", "#000"], ["shadowOffsetX", 0], ["shadowOffsetY", 0]];t.exports = a.extend({ type: "sector", shape: { cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, brush: n.browser.ie && n.browser.version >= 11 ? function () {
					var t,
					    e = this.__clipPaths,
					    i = this.style;if (e) for (var n = 0; n < e.length; n++) {
						var r = e[n] && e[n].shape;if (r && r.startAngle === r.endAngle) {
							for (var s = 0; s < o.length; s++) {
								o[s][2] = i[o[s][0]], i[o[s][0]] = o[s][1];
							}t = !0;break;
						}
					}if (a.prototype.brush.apply(this, arguments), t) for (var s = 0; s < o.length; s++) {
						i[o[s][0]] = o[s][2];
					}
				} : a.prototype.brush, buildPath: function buildPath(t, e) {
					var i = e.cx,
					    n = e.cy,
					    a = Math.max(e.r0 || 0, 0),
					    o = Math.max(e.r, 0),
					    r = e.startAngle,
					    s = e.endAngle,
					    l = e.clockwise,
					    u = Math.cos(r),
					    c = Math.sin(r);t.moveTo(u * a + i, c * a + n), t.lineTo(u * o + i, c * o + n), t.arc(i, n, o, r, s, !l), t.lineTo(Math.cos(s) * a + i, Math.sin(s) * a + n), 0 !== a && t.arc(i, n, a, s, r, l), t.closePath();
				} });
		}, function (t, e, i) {
			"use strict";
			var n = i(67),
			    a = i(1),
			    o = a.isString,
			    r = a.isFunction,
			    s = a.isObject,
			    l = i(52),
			    u = function u() {
				this.animators = [];
			};u.prototype = { constructor: u, animate: function animate(t, e) {
					var i,
					    o = !1,
					    r = this,
					    s = this.__zr;if (t) {
						var u = t.split("."),
						    c = r;o = "shape" === u[0];for (var h = 0, d = u.length; h < d; h++) {
							c && (c = c[u[h]]);
						}c && (i = c);
					} else i = r;if (!i) return void l('Property "' + t + '" is not existed in element ' + r.id);var f = r.animators,
					    p = new n(i, e);return p.during(function (t) {
						r.dirty(o);
					}).done(function () {
						f.splice(a.indexOf(f, p), 1);
					}), f.push(p), s && s.animation.addAnimator(p), p;
				}, stopAnimation: function stopAnimation(t) {
					for (var e = this.animators, i = e.length, n = 0; n < i; n++) {
						e[n].stop(t);
					}return e.length = 0, this;
				}, animateTo: function animateTo(t, e, i, n, a) {
					function s() {
						u--, u || a && a();
					}o(i) ? (a = n, n = i, i = 0) : r(n) ? (a = n, n = "linear", i = 0) : r(i) ? (a = i, i = 0) : r(e) ? (a = e, e = 500) : e || (e = 500), this.stopAnimation(), this._animateToShallow("", this, t, e, i, n, a);var l = this.animators.slice(),
					    u = l.length;u || a && a();for (var c = 0; c < l.length; c++) {
						l[c].done(s).start(n);
					}
				}, _animateToShallow: function _animateToShallow(t, e, i, n, o) {
					var r = {},
					    l = 0;for (var u in i) {
						if (i.hasOwnProperty(u)) if (null != e[u]) s(i[u]) && !a.isArrayLike(i[u]) ? this._animateToShallow(t ? t + "." + u : u, e[u], i[u], n, o) : (r[u] = i[u], l++);else if (null != i[u]) if (t) {
							var c = {};c[t] = {}, c[t][u] = i[u], this.attr(c);
						} else this.attr(u, i[u]);
					}return l > 0 && this.animate(t, !1).when(null == n ? 500 : n, r).delay(o || 0), this;
				} }, t.exports = u;
		}, function (t, e) {
			function i() {
				this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this);
			}function n(t, e) {
				return { target: t, topTarget: e && e.topTarget };
			}i.prototype = { constructor: i, _dragStart: function _dragStart(t) {
					var e = t.target;e && e.draggable && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.dispatchToElement(n(e, t), "dragstart", t.event));
				}, _drag: function _drag(t) {
					var e = this._draggingTarget;if (e) {
						var i = t.offsetX,
						    a = t.offsetY,
						    o = i - this._x,
						    r = a - this._y;this._x = i, this._y = a, e.drift(o, r, t), this.dispatchToElement(n(e, t), "drag", t.event);var s = this.findHover(i, a, e).target,
						    l = this._dropTarget;this._dropTarget = s, e !== s && (l && s !== l && this.dispatchToElement(n(l, t), "dragleave", t.event), s && s !== l && this.dispatchToElement(n(s, t), "dragenter", t.event));
					}
				}, _dragEnd: function _dragEnd(t) {
					var e = this._draggingTarget;e && (e.dragging = !1), this.dispatchToElement(n(e, t), "dragend", t.event), this._dropTarget && this.dispatchToElement(n(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
				} }, t.exports = i;
		}, function (t, e, i) {
			function n(t, e, i, n, a, o, r, s, l, u, p) {
				var v = l * (f / 180),
				    y = d(v) * (t - i) / 2 + h(v) * (e - n) / 2,
				    x = -1 * h(v) * (t - i) / 2 + d(v) * (e - n) / 2,
				    _ = y * y / (r * r) + x * x / (s * s);_ > 1 && (r *= c(_), s *= c(_));var b = (a === o ? -1 : 1) * c((r * r * (s * s) - r * r * (x * x) - s * s * (y * y)) / (r * r * (x * x) + s * s * (y * y))) || 0,
				    w = b * r * x / s,
				    S = b * -s * y / r,
				    M = (t + i) / 2 + d(v) * w - h(v) * S,
				    I = (e + n) / 2 + h(v) * w + d(v) * S,
				    T = m([1, 0], [(y - w) / r, (x - S) / s]),
				    A = [(y - w) / r, (x - S) / s],
				    C = [(-1 * y - w) / r, (-1 * x - S) / s],
				    L = m(A, C);g(A, C) <= -1 && (L = f), g(A, C) >= 1 && (L = 0), 0 === o && L > 0 && (L -= 2 * f), 1 === o && L < 0 && (L += 2 * f), p.addData(u, M, I, r, s, T, L, v, o);
			}function a(t) {
				if (!t) return [];var e,
				    i = t.replace(/-/g, " -").replace(/  /g, " ").replace(/ /g, ",").replace(/,,/g, ",");for (e = 0; e < u.length; e++) {
					i = i.replace(new RegExp(u[e], "g"), "|" + u[e]);
				}var a,
				    o = i.split("|"),
				    r = 0,
				    l = 0,
				    c = new s(),
				    h = s.CMD;for (e = 1; e < o.length; e++) {
					var d,
					    f = o[e],
					    p = f.charAt(0),
					    g = 0,
					    m = f.slice(1).replace(/e,-/g, "e-").split(",");m.length > 0 && "" === m[0] && m.shift();for (var v = 0; v < m.length; v++) {
						m[v] = parseFloat(m[v]);
					}for (; g < m.length && !isNaN(m[g]) && !isNaN(m[0]);) {
						var y,
						    x,
						    _,
						    b,
						    w,
						    S,
						    M,
						    I = r,
						    T = l;switch (p) {case "l":
								r += m[g++], l += m[g++], d = h.L, c.addData(d, r, l);break;case "L":
								r = m[g++], l = m[g++], d = h.L, c.addData(d, r, l);break;case "m":
								r += m[g++], l += m[g++], d = h.M, c.addData(d, r, l), p = "l";break;case "M":
								r = m[g++], l = m[g++], d = h.M, c.addData(d, r, l), p = "L";break;case "h":
								r += m[g++], d = h.L, c.addData(d, r, l);break;case "H":
								r = m[g++], d = h.L, c.addData(d, r, l);break;case "v":
								l += m[g++], d = h.L, c.addData(d, r, l);break;case "V":
								l = m[g++], d = h.L, c.addData(d, r, l);break;case "C":
								d = h.C, c.addData(d, m[g++], m[g++], m[g++], m[g++], m[g++], m[g++]), r = m[g - 2], l = m[g - 1];break;case "c":
								d = h.C, c.addData(d, m[g++] + r, m[g++] + l, m[g++] + r, m[g++] + l, m[g++] + r, m[g++] + l), r += m[g - 2], l += m[g - 1];break;case "S":
								y = r, x = l;var A = c.len(),
								    C = c.data;a === h.C && (y += r - C[A - 4], x += l - C[A - 3]), d = h.C, I = m[g++], T = m[g++], r = m[g++], l = m[g++], c.addData(d, y, x, I, T, r, l);break;case "s":
								y = r, x = l;var A = c.len(),
								    C = c.data;a === h.C && (y += r - C[A - 4], x += l - C[A - 3]), d = h.C, I = r + m[g++], T = l + m[g++], r += m[g++], l += m[g++], c.addData(d, y, x, I, T, r, l);break;case "Q":
								I = m[g++], T = m[g++], r = m[g++], l = m[g++], d = h.Q, c.addData(d, I, T, r, l);break;case "q":
								I = m[g++] + r, T = m[g++] + l, r += m[g++], l += m[g++], d = h.Q, c.addData(d, I, T, r, l);break;case "T":
								y = r, x = l;var A = c.len(),
								    C = c.data;a === h.Q && (y += r - C[A - 4], x += l - C[A - 3]), r = m[g++], l = m[g++], d = h.Q, c.addData(d, y, x, r, l);break;case "t":
								y = r, x = l;var A = c.len(),
								    C = c.data;a === h.Q && (y += r - C[A - 4], x += l - C[A - 3]), r += m[g++], l += m[g++], d = h.Q, c.addData(d, y, x, r, l);break;case "A":
								_ = m[g++], b = m[g++], w = m[g++], S = m[g++], M = m[g++], I = r, T = l, r = m[g++], l = m[g++], d = h.A, n(I, T, r, l, S, M, _, b, w, d, c);break;case "a":
								_ = m[g++], b = m[g++], w = m[g++], S = m[g++], M = m[g++], I = r, T = l, r += m[g++], l += m[g++], d = h.A, n(I, T, r, l, S, M, _, b, w, d, c);}
					}"z" !== p && "Z" !== p || (d = h.Z, c.addData(d)), a = d;
				}return c.toStatic(), c;
			}function o(t, e) {
				var i = a(t);return e = e || {}, e.buildPath = function (t) {
					if (t.setData) {
						t.setData(i.data);var e = t.getContext();e && t.rebuildPath(e);
					} else {
						var e = t;i.rebuildPath(e);
					}
				}, e.applyTransform = function (t) {
					l(i, t), this.dirty(!0);
				}, e;
			}var r = i(8),
			    s = i(27),
			    l = i(181),
			    u = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"],
			    c = Math.sqrt,
			    h = Math.sin,
			    d = Math.cos,
			    f = Math.PI,
			    p = function p(t) {
				return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
			},
			    g = function g(t, e) {
				return (t[0] * e[0] + t[1] * e[1]) / (p(t) * p(e));
			},
			    m = function m(t, e) {
				return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(g(t, e));
			};t.exports = { createFromString: function createFromString(t, e) {
					return new r(o(t, e));
				}, extendFromString: function extendFromString(t, e) {
					return r.extend(o(t, e));
				}, mergePath: function mergePath(t, e) {
					for (var i = [], n = t.length, a = 0; a < n; a++) {
						var o = t[a];o.path || o.createPathProxy(), o.__dirtyPath && o.buildPath(o.path, o.shape, !0), i.push(o.path);
					}var s = new r(e);return s.createPathProxy(), s.buildPath = function (t) {
						t.appendPath(i);var e = t.getContext();e && t.rebuildPath(e);
					}, s;
				} };
		}, function (t, e, i) {
			function n(t, e) {
				var i,
				    n,
				    o,
				    c,
				    h,
				    d,
				    f = t.data,
				    p = a.M,
				    g = a.C,
				    m = a.L,
				    v = a.R,
				    y = a.A,
				    x = a.Q;for (o = 0, c = 0; o < f.length;) {
					switch (i = f[o++], c = o, n = 0, i) {case p:
							n = 1;break;case m:
							n = 1;break;case g:
							n = 3;break;case x:
							n = 2;break;case y:
							var _ = e[4],
							    b = e[5],
							    w = l(e[0] * e[0] + e[1] * e[1]),
							    S = l(e[2] * e[2] + e[3] * e[3]),
							    M = u(-e[1] / S, e[0] / w);f[o] *= w, f[o++] += _, f[o] *= S, f[o++] += b, f[o++] *= w, f[o++] *= S, f[o++] += M, f[o++] += M, o += 2, c = o;break;case v:
							d[0] = f[o++], d[1] = f[o++], r(d, d, e), f[c++] = d[0], f[c++] = d[1], d[0] += f[o++], d[1] += f[o++], r(d, d, e), f[c++] = d[0], f[c++] = d[1];}for (h = 0; h < n; h++) {
						var d = s[h];d[0] = f[o++], d[1] = f[o++], r(d, d, e), f[c++] = d[0], f[c++] = d[1];
					}
				}
			}var a = i(27).CMD,
			    o = i(6),
			    r = o.applyTransform,
			    s = [[], [], []],
			    l = Math.sqrt,
			    u = Math.atan2;t.exports = n;
		}, function (t, e, i) {
			if (!i(9).canvasSupported) {
				var n,
				    a = "urn:schemas-microsoft-com:vml",
				    o = window,
				    r = o.document,
				    s = !1;try {
					!r.namespaces.zrvml && r.namespaces.add("zrvml", a), n = function n(t) {
						return r.createElement("<zrvml:" + t + ' class="zrvml">');
					};
				} catch (l) {
					n = function n(t) {
						return r.createElement("<" + t + ' xmlns="' + a + '" class="zrvml">');
					};
				}var u = function u() {
					if (!s) {
						s = !0;var t = r.styleSheets;t.length < 31 ? r.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)");
					}
				};t.exports = { doc: r, initVML: u, createNode: n };
			}
		}, function (t, e, i) {
			"use strict";
			var n = i(14),
			    a = i(25),
			    o = i(313),
			    r = i(1),
			    s = { _baseAxisDim: null, getInitialData: function getInitialData(t, e) {
					var i,
					    o,
					    s = e.getComponent("xAxis", this.get("xAxisIndex")),
					    l = e.getComponent("yAxis", this.get("yAxisIndex")),
					    u = s.get("type"),
					    c = l.get("type");"category" === u ? (t.layout = "horizontal", i = s.getCategories(), o = !0) : "category" === c ? (t.layout = "vertical", i = l.getCategories(), o = !0) : t.layout = t.layout || "horizontal";var h = ["x", "y"],
					    d = "horizontal" === t.layout ? 0 : 1,
					    f = this._baseAxisDim = h[d],
					    p = h[1 - d],
					    g = t.data;o && r.each(g, function (t, e) {
						r.isArray(t) && t.unshift(e);
					});var m = [{ name: f, otherDims: { tooltip: !1 }, dimsDef: ["base"] }, { name: p, dimsDef: this.defaultValueDimensions.slice() }];m = a(m, g, { encodeDef: this.get("encode"), dimsDef: this.get("dimensions") });var v = new n(m, this);return v.initData(g, i ? i.slice() : null), v;
				}, getBaseAxis: function getBaseAxis() {
					var t = this._baseAxisDim;return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis;
				} },
			    l = { init: function init() {
					var t = this._whiskerBoxDraw = new o(this.getStyleUpdater());this.group.add(t.group);
				}, render: function render(t, e, i) {
					this._whiskerBoxDraw.updateData(t.getData());
				}, remove: function remove(t) {
					this._whiskerBoxDraw.remove();
				} };t.exports = { seriesModelMixin: s, viewMixin: l };
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = this._targetInfoList = [],
				    a = {},
				    r = o(e, t);p(_, function (t, e) {
					(!i || !i.include || g(i.include, e) >= 0) && t(r, n, a);
				});
			}function a(t) {
				return t[0] > t[1] && t.reverse(), t;
			}function o(t, e) {
				return d.parseFinder(t, e, { includeMainTypes: y });
			}function r(t, e, i, n) {
				var o = i.getAxis(["x", "y"][t]),
				    r = a(c.map([0, 1], function (t) {
					return e ? o.coordToData(o.toLocalCoord(n[t])) : o.toGlobalCoord(o.dataToCoord(n[t]));
				})),
				    s = [];return s[t] = r, s[1 - t] = [NaN, NaN], { values: r, xyMinMax: s };
			}function s(t, e, i, n) {
				return [e[0] - n[t] * i[0], e[1] - n[t] * i[1]];
			}function l(t, e) {
				var i = u(t),
				    n = u(e),
				    a = [i[0] / n[0], i[1] / n[1]];return isNaN(a[0]) && (a[0] = 1), isNaN(a[1]) && (a[1] = 1), a;
			}function u(t) {
				return t ? [t[0][1] - t[0][0], t[1][1] - t[1][0]] : [NaN, NaN];
			}var c = i(1),
			    h = i(3),
			    d = i(5),
			    f = i(185),
			    p = c.each,
			    g = c.indexOf,
			    m = c.curry,
			    v = ["dataToPoint", "pointToData"],
			    y = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"],
			    x = n.prototype;x.setOutputRanges = function (t, e) {
				this.matchOutputRanges(t, e, function (t, e, i) {
					if ((t.coordRanges || (t.coordRanges = [])).push(e), !t.coordRange) {
						t.coordRange = e;var n = S[t.brushType](0, i, e);t.__rangeOffset = { offset: M[t.brushType](n.values, t.range, [1, 1]), xyMinMax: n.xyMinMax };
					}
				});
			}, x.matchOutputRanges = function (t, e, i) {
				p(t, function (t) {
					var n = this.findTargetInfo(t, e);n && n !== !0 && c.each(n.coordSyses, function (n) {
						var a = S[t.brushType](1, n, t.range);i(t, a.values, n, e);
					});
				}, this);
			}, x.setInputRanges = function (t, e) {
				p(t, function (t) {
					var i = this.findTargetInfo(t, e);if (t.range = t.range || [], i && i !== !0) {
						t.panelId = i.panelId;var n = S[t.brushType](0, i.coordSys, t.coordRange),
						    a = t.__rangeOffset;t.range = a ? M[t.brushType](n.values, a.offset, l(n.xyMinMax, a.xyMinMax)) : n.values;
					}
				}, this);
			}, x.makePanelOpts = function (t, e) {
				return c.map(this._targetInfoList, function (i) {
					var n = i.getPanelRect();return { panelId: i.panelId, defaultBrushType: e && e(i), clipPath: f.makeRectPanelClipPath(n), isTargetByCursor: f.makeRectIsTargetByCursor(n, t, i.coordSysModel), getLinearBrushOtherExtent: f.makeLinearBrushOtherExtent(n) };
				});
			}, x.controlSeries = function (t, e, i) {
				var n = this.findTargetInfo(t, i);return n === !0 || n && g(n.coordSyses, e.coordinateSystem) >= 0;
			}, x.findTargetInfo = function (t, e) {
				for (var i = this._targetInfoList, n = o(e, t), a = 0; a < i.length; a++) {
					var r = i[a],
					    s = t.panelId;if (s) {
						if (r.panelId === s) return r;
					} else for (var a = 0; a < b.length; a++) {
						if (b[a](n, r)) return r;
					}
				}return !0;
			};var _ = { grid: function grid(t, e) {
					var i = t.xAxisModels,
					    n = t.yAxisModels,
					    a = t.gridModels,
					    o = c.createHashMap(),
					    r = {},
					    s = {};(i || n || a) && (p(i, function (t) {
						var e = t.axis.grid.model;o.set(e.id, e), r[e.id] = !0;
					}), p(n, function (t) {
						var e = t.axis.grid.model;o.set(e.id, e), s[e.id] = !0;
					}), p(a, function (t) {
						o.set(t.id, t), r[t.id] = !0, s[t.id] = !0;
					}), o.each(function (t) {
						var a = t.coordinateSystem,
						    o = [];p(a.getCartesians(), function (t, e) {
							(g(i, t.getAxis("x").model) >= 0 || g(n, t.getAxis("y").model) >= 0) && o.push(t);
						}), e.push({ panelId: "grid--" + t.id, gridModel: t, coordSysModel: t, coordSys: o[0], coordSyses: o, getPanelRect: w.grid, xAxisDeclared: r[t.id], yAxisDeclared: s[t.id] });
					}));
				}, geo: function geo(t, e) {
					p(t.geoModels, function (t) {
						var i = t.coordinateSystem;e.push({ panelId: "geo--" + t.id, geoModel: t, coordSysModel: t, coordSys: i, coordSyses: [i], getPanelRect: w.geo });
					});
				} },
			    b = [function (t, e) {
				var i = t.xAxisModel,
				    n = t.yAxisModel,
				    a = t.gridModel;return !a && i && (a = i.axis.grid.model), !a && n && (a = n.axis.grid.model), a && a === e.gridModel;
			}, function (t, e) {
				var i = t.geoModel;return i && i === e.geoModel;
			}],
			    w = { grid: function grid() {
					return this.coordSys.grid.getRect().clone();
				}, geo: function geo() {
					var t = this.coordSys,
					    e = t.getBoundingRect().clone();return e.applyTransform(h.getTransform(t)), e;
				} },
			    S = { lineX: m(r, 0), lineY: m(r, 1), rect: function rect(t, e, i) {
					var n = e[v[t]]([i[0][0], i[1][0]]),
					    o = e[v[t]]([i[0][1], i[1][1]]),
					    r = [a([n[0], o[0]]), a([n[1], o[1]])];return { values: r, xyMinMax: r };
				},
				polygon: function polygon(t, e, i) {
					var n = [[1 / 0, -(1 / 0)], [1 / 0, -(1 / 0)]],
					    a = c.map(i, function (i) {
						var a = e[v[t]](i);return n[0][0] = Math.min(n[0][0], a[0]), n[1][0] = Math.min(n[1][0], a[1]), n[0][1] = Math.max(n[0][1], a[0]), n[1][1] = Math.max(n[1][1], a[1]), a;
					});return { values: a, xyMinMax: n };
				} },
			    M = { lineX: m(s, 0), lineY: m(s, 1), rect: function rect(t, e, i) {
					return [[t[0][0] - i[0] * e[0][0], t[0][1] - i[0] * e[0][1]], [t[1][0] - i[1] * e[1][0], t[1][1] - i[1] * e[1][1]]];
				}, polygon: function polygon(t, e, i) {
					return c.map(t, function (t, n) {
						return [t[0] - i[0] * e[n][0], t[1] - i[1] * e[n][1]];
					});
				} };t.exports = n;
		}, function (t, e, i) {
			function n(t) {
				return o.create(t);
			}var a = i(128),
			    o = i(11),
			    r = i(3),
			    s = {};s.makeRectPanelClipPath = function (t) {
				return t = n(t), function (e, i) {
					return r.clipPointsByRect(e, t);
				};
			}, s.makeLinearBrushOtherExtent = function (t, e) {
				return t = n(t), function (i) {
					var n = null != e ? e : i,
					    a = n ? t.width : t.height,
					    o = n ? t.x : t.y;return [o, o + (a || 0)];
				};
			}, s.makeRectIsTargetByCursor = function (t, e, i) {
				return t = n(t), function (n, o, r) {
					return t.contain(o[0], o[1]) && !a.onIrrelevantElement(n, e, i);
				};
			}, t.exports = s;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t.get("boundingCoords");if (null != i) {
					var n = i[0],
					    a = i[1];isNaN(n[0]) || isNaN(n[1]) || isNaN(a[0]) || isNaN(a[1]) || this.setBoundingRect(n[0], n[1], a[0] - n[0], a[1] - n[1]);
				}var o,
				    s = this.getBoundingRect(),
				    u = t.get("layoutCenter"),
				    c = t.get("layoutSize"),
				    h = e.getWidth(),
				    d = e.getHeight(),
				    f = t.get("aspectScale") || .75,
				    p = s.width / s.height * f,
				    g = !1;u && c && (u = [l.parsePercent(u[0], h), l.parsePercent(u[1], d)], c = l.parsePercent(c, Math.min(h, d)), isNaN(u[0]) || isNaN(u[1]) || isNaN(c) || (g = !0));var m;if (g) {
					var m = {};p > 1 ? (m.width = c, m.height = c / p) : (m.height = c, m.width = c * p), m.y = u[1] - m.height / 2, m.x = u[0] - m.width / 2;
				} else o = t.getBoxLayoutParams(), o.aspect = p, m = r.getLayoutRect(o, { width: h, height: d });this.setViewRect(m.x, m.y, m.width, m.height), this.setCenter(t.get("center")), this.setZoom(t.get("zoom"));
			}function a(t, e) {
				s.each(e.get("geoCoord"), function (e, i) {
					t.addGeoCoord(i, e);
				});
			}var o = i(398),
			    r = i(12),
			    s = i(1),
			    l = i(4),
			    u = {},
			    c = { dimensions: o.prototype.dimensions, create: function create(t, e) {
					var i = [];t.eachComponent("geo", function (t, r) {
						var s = t.get("map"),
						    l = u[s],
						    c = new o(s + r, s, l && l.geoJson, l && l.specialAreas, t.get("nameMap"));c.zoomLimit = t.get("scaleLimit"), i.push(c), a(c, t), t.coordinateSystem = c, c.model = t, c.resize = n, c.resize(t, e);
					}), t.eachSeries(function (t) {
						var e = t.get("coordinateSystem");if ("geo" === e) {
							var n = t.get("geoIndex") || 0;t.coordinateSystem = i[n];
						}
					});var r = {};return t.eachSeriesByType("map", function (t) {
						if (!t.getHostGeoModel()) {
							var e = t.getMapType();r[e] = r[e] || [], r[e].push(t);
						}
					}), s.each(r, function (t, r) {
						var l = u[r],
						    c = s.map(t, function (t) {
							return t.get("nameMap");
						}),
						    h = new o(r, r, l && l.geoJson, l && l.specialAreas, s.mergeAll(c));h.zoomLimit = s.retrieve.apply(null, s.map(t, function (t) {
							return t.get("scaleLimit");
						})), i.push(h), h.resize = n, h.resize(t[0], e), s.each(t, function (t) {
							t.coordinateSystem = h, a(h, t);
						});
					}), i;
				}, registerMap: function registerMap(t, e, i) {
					e.geoJson && !e.features && (i = e.specialAreas, e = e.geoJson), "string" == typeof e && (e = "undefined" != typeof JSON && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")()), u[t] = { geoJson: e, specialAreas: i };
				}, getMap: function getMap(t) {
					return u[t];
				}, getFilledRegions: function getFilledRegions(t, e) {
					var i = (t || []).slice(),
					    n = c.getMap(e),
					    a = n && n.geoJson;if (!a) return t;for (var o = s.createHashMap(), r = a.features, l = 0; l < i.length; l++) {
						o.set(i[l].name, i[l]);
					}for (var l = 0; l < r.length; l++) {
						var u = r[l].properties.name;o.get(u) || i.push({ name: u });
					}return i;
				} },
			    h = i(2);h.registerMap = c.registerMap, h.getMap = c.getMap, h.parseGeoJSON = i(262), h.loadMap = function () {}, h.registerCoordinateSystem("geo", c), t.exports = c;
		}, function (t, e, i) {
			function n(t) {
				if (t) for (var e in t) {
					if (t.hasOwnProperty(e)) return !0;
				}
			}var a = i(1),
			    o = i(83),
			    r = a.each,
			    s = { createVisualMappings: function createVisualMappings(t, e, i) {
					function n() {
						var t = function t() {};t.prototype.__hidden = t.prototype;var e = new t();return e;
					}var s = {};return r(e, function (e) {
						var l = s[e] = n();r(t[e], function (t, n) {
							if (o.isValidType(n)) {
								var r = { type: n, visual: t };i && i(r, e), l[n] = new o(r), "opacity" === n && (r = a.clone(r), r.type = "colorAlpha", l.__hidden.__alphaForOpacity = new o(r));
							}
						});
					}), s;
				}, replaceVisualOption: function replaceVisualOption(t, e, i) {
					var o;a.each(i, function (t) {
						e.hasOwnProperty(t) && n(e[t]) && (o = !0);
					}), o && a.each(i, function (i) {
						e.hasOwnProperty(i) && n(e[i]) ? t[i] = a.clone(e[i]) : delete t[i];
					});
				}, applyVisual: function applyVisual(t, e, i, n, r, s) {
					function l(t) {
						return i.getItemVisual(d, t);
					}function u(t, e) {
						i.setItemVisual(d, t, e);
					}function c(t, a) {
						d = null == s ? t : a;var o = i.getRawDataItem(d);if (!o || o.visualMap !== !1) for (var c = n.call(r, t), f = e[c], p = h[c], g = 0, m = p.length; g < m; g++) {
							var v = p[g];f[v] && f[v].applyVisual(t, l, u);
						}
					}var h = {};a.each(t, function (t) {
						var i = o.prepareVisualTypes(e[t]);h[t] = i;
					});var d;null == s ? i.each(c, !0) : i.each([s], c, !0);
				} };t.exports = s;
		}, function (t, e) {
			function i() {
				throw new Error("setTimeout has not been defined");
			}function n() {
				throw new Error("clearTimeout has not been defined");
			}function a(t) {
				if (c === setTimeout) return setTimeout(t, 0);if ((c === i || !c) && setTimeout) return c = setTimeout, setTimeout(t, 0);try {
					return c(t, 0);
				} catch (e) {
					try {
						return c.call(null, t, 0);
					} catch (e) {
						return c.call(this, t, 0);
					}
				}
			}function o(t) {
				if (h === clearTimeout) return clearTimeout(t);if ((h === n || !h) && clearTimeout) return h = clearTimeout, clearTimeout(t);try {
					return h(t);
				} catch (e) {
					try {
						return h.call(null, t);
					} catch (e) {
						return h.call(this, t);
					}
				}
			}function r() {
				g && f && (g = !1, f.length ? p = f.concat(p) : m = -1, p.length && s());
			}function s() {
				if (!g) {
					var t = a(r);g = !0;for (var e = p.length; e;) {
						for (f = p, p = []; ++m < e;) {
							f && f[m].run();
						}m = -1, e = p.length;
					}f = null, g = !1, o(t);
				}
			}function l(t, e) {
				this.fun = t, this.array = e;
			}function u() {}var c,
			    h,
			    d = t.exports = {};!function () {
				try {
					c = "function" == typeof setTimeout ? setTimeout : i;
				} catch (t) {
					c = i;
				}try {
					h = "function" == typeof clearTimeout ? clearTimeout : n;
				} catch (t) {
					h = n;
				}
			}();var f,
			    p = [],
			    g = !1,
			    m = -1;d.nextTick = function (t) {
				var e = new Array(arguments.length - 1);if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) {
					e[i - 1] = arguments[i];
				}p.push(new l(t, e)), 1 !== p.length || g || a(s);
			}, l.prototype.run = function () {
				this.fun.apply(null, this.array);
			}, d.title = "browser", d.browser = !0, d.env = {}, d.argv = [], d.version = "", d.versions = {}, d.on = u, d.addListener = u, d.once = u, d.off = u, d.removeListener = u, d.removeAllListeners = u, d.emit = u, d.binding = function (t) {
				throw new Error("process.binding is not supported");
			}, d.cwd = function () {
				return "/";
			}, d.chdir = function (t) {
				throw new Error("process.chdir is not supported");
			}, d.umask = function () {
				return 0;
			};
		}, function (t, e, i) {
			function n() {
				this.group = new a.Group(), this._symbolEl = new r({});
			}var a = i(3),
			    o = i(24),
			    r = a.extendShape({ shape: { points: null, sizes: null }, symbolProxy: null, buildPath: function buildPath(t, e) {
					for (var i = e.points, n = e.sizes, a = this.symbolProxy, o = a.shape, r = 0; r < i.length; r++) {
						var s = i[r],
						    l = n[r];l[0] < 4 ? t.rect(s[0] - l[0] / 2, s[1] - l[1] / 2, l[0], l[1]) : (o.x = s[0] - l[0] / 2, o.y = s[1] - l[1] / 2, o.width = l[0], o.height = l[1], a.buildPath(t, o, !0));
					}
				}, findDataIndex: function findDataIndex(t, e) {
					for (var i = this.shape, n = i.points, a = i.sizes, o = n.length - 1; o >= 0; o--) {
						var r = n[o],
						    s = a[o],
						    l = r[0] - s[0] / 2,
						    u = r[1] - s[1] / 2;if (t >= l && e >= u && t <= l + s[0] && e <= u + s[1]) return o;
					}return -1;
				} }),
			    s = n.prototype;s.updateData = function (t) {
				this.group.removeAll();var e = this._symbolEl,
				    i = t.hostModel;e.setShape({ points: t.mapArray(t.getItemLayout), sizes: t.mapArray(function (e) {
						var i = t.getItemVisual(e, "symbolSize");return i instanceof Array || (i = [i, i]), i;
					}) }), e.symbolProxy = o.createSymbol(t.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor, e.useStyle(i.getModel("itemStyle.normal").getItemStyle(["color"]));var n = t.getVisual("color");n && e.setColor(n), e.seriesIndex = i.seriesIndex, e.on("mousemove", function (t) {
					e.dataIndex = null;var i = e.findDataIndex(t.offsetX, t.offsetY);i > 0 && (e.dataIndex = i);
				}), this.group.add(e);
			}, s.updateLayout = function (t) {
				var e = t.getData();this._symbolEl.setShape({ points: e.mapArray(e.getItemLayout) });
			}, s.remove = function () {
				this.group.removeAll();
			}, t.exports = n;
		}, function (t, e, i) {
			function n(t) {
				return isNaN(+t.cpx1) || isNaN(+t.cpy1);
			}var a = i(3),
			    o = i(6),
			    r = a.Line.prototype,
			    s = a.BezierCurve.prototype;t.exports = a.extendShape({ type: "ec-line", style: { stroke: "#000", fill: null }, shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1, cpx1: null, cpy1: null }, buildPath: function buildPath(t, e) {
					(n(e) ? r : s).buildPath(t, e);
				}, pointAt: function pointAt(t) {
					return n(this.shape) ? r.pointAt.call(this, t) : s.pointAt.call(this, t);
				}, tangentAt: function tangentAt(t) {
					var e = this.shape,
					    i = n(e) ? [e.x2 - e.x1, e.y2 - e.y1] : s.tangentAt.call(this, t);return o.normalize(i, i);
				} });
		}, function (t, e, i) {
			var n = i(1),
			    a = i(2);i(192), i(193), a.registerVisual(n.curry(i(50), "scatter", "circle", null)), a.registerLayout(n.curry(i(61), "scatter")), i(32);
		}, function (t, e, i) {
			"use strict";
			var n = i(28),
			    a = i(17);t.exports = a.extend({ type: "series.scatter", dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"], getInitialData: function getInitialData(t, e) {
					return n(t.data, this, e);
				}, brushSelector: "point", defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, symbolSize: 10, large: !1, largeThreshold: 2e3, itemStyle: { normal: { opacity: .8 } } } });
		}, function (t, e, i) {
			var n = i(44),
			    a = i(189);i(2).extendChartView({ type: "scatter", init: function init() {
					this._normalSymbolDraw = new n(), this._largeSymbolDraw = new a();
				}, render: function render(t, e, i) {
					var n = t.getData(),
					    a = this._largeSymbolDraw,
					    o = this._normalSymbolDraw,
					    r = this.group,
					    s = t.get("large") && n.count() > t.get("largeThreshold") ? a : o;this._symbolDraw = s, s.updateData(n), r.add(s.group), r.remove(s === a ? o.group : a.group);
				}, updateLayout: function updateLayout(t) {
					this._symbolDraw.updateLayout(t);
				}, remove: function remove(t, e) {
					this._symbolDraw && this._symbolDraw.remove(e, !0);
				}, dispose: function dispose() {} });
		}, function (t, e, i) {
			var n = i(2),
			    a = n.extendComponentModel({ type: "axisPointer", coordSysAxesInfo: null, defaultOption: { show: "auto", triggerOn: null, zlevel: 0, z: 50, type: "line", snap: !1, triggerTooltip: !0, value: null, status: null, link: [], animation: null, animationDurationUpdate: 200, lineStyle: { color: "#aaa", width: 1, type: "solid" }, shadowStyle: { color: "rgba(150,150,150,0.3)" }, label: { show: !0, formatter: null, precision: "auto", margin: 3, textStyle: { color: "#fff" }, padding: [5, 7, 5, 7], backgroundColor: "auto", borderColor: null, borderWidth: 0, shadowBlur: 3, shadowColor: "#aaa" }, handle: { show: !1, icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z", size: 45, margin: 50, color: "#333", shadowBlur: 3, shadowColor: "#aaa", shadowOffsetX: 0, shadowOffsetY: 2, throttle: 40 } } });t.exports = a;
		}, function (t, e, i) {
			var n = i(122),
			    a = i(2).extendComponentView({ type: "axisPointer", render: function render(t, e, i) {
					var a = e.getComponent("tooltip"),
					    o = t.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";n.register("axisPointer", i, function (t, e, i) {
						"none" !== o && ("leave" === t || o.indexOf(t) >= 0) && i({ type: "updateAxisPointer", currTrigger: t, x: e && e.offsetX, y: e && e.offsetY });
					});
				}, remove: function remove(t, e) {
					n.disopse(e.getZr(), "axisPointer"), a.superApply(this._model, "remove", arguments);
				}, dispose: function dispose(t, e) {
					n.unregister("axisPointer", e), a.superApply(this._model, "dispose", arguments);
				} });
		}, function (t, e, i) {
			function n(t, e, i, n, o, p, g, m) {
				n = n || {}, f(i) && (i = v({ seriesIndex: n.seriesIndex, dataIndex: n.dataIndex }, p).point);var _ = f(i),
				    b = n.axesInfo,
				    w = t.axesInfo,
				    S = "leave" === e || f(i),
				    M = {},
				    I = {},
				    T = { list: [], map: {} },
				    A = { showPointer: x(r, I), showTooltip: x(s, T) };y(t.coordSysMap, function (e, n) {
					var o = _ || e.containPoint(i);y(t.coordSysAxesInfo[n], function (t, e) {
						var n = t.axis,
						    r = h(b, t);if (!S && o && (!b || r)) {
							var s = r && r.value;null != s || _ || (s = n.pointToData(i)), null != s && a(t, s, A, !1, M);
						}
					});
				});var C = {};return y(w, function (t, e) {
					var i = t.linkGroup;i && !I[e] && y(i.axesInfo, function (e, n) {
						var a = I[n];if (e !== t && a) {
							var o = a.value;i.mapper && (o = t.axis.scale.parse(i.mapper(o, d(e), d(t)))), C[t.key] = o;
						}
					});
				}), y(C, function (t, e) {
					a(w[e], t, A, !0, M);
				}), l(I, w, M), u(T, i, m, o), c(w, o, g), M;
			}function a(t, e, i, n, a) {
				var r = t.axis;if (!r.scale.isBlank() && r.containData(e)) {
					if (!t.involveSeries) return void i.showPointer(t, e);var s = o(e, t),
					    l = s.payloadBatch,
					    u = s.snapToValue;l[0] && null == a.seriesIndex && p.extend(a, l[0]), !n && t.snap && r.containData(u) && null != u && (e = u), i.showPointer(t, e, l, a), i.showTooltip(t, s, u);
				}
			}function o(t, e) {
				var i = e.axis,
				    n = i.dim,
				    a = t,
				    o = [],
				    r = Number.MAX_VALUE,
				    s = -1;return y(e.seriesModels, function (e, l) {
					var u,
					    c,
					    h = e.coordDimToDataDim(n);if (e.getAxisTooltipData) {
						var d = e.getAxisTooltipData(h, t, i);c = d.dataIndices, u = d.nestestValue;
					} else {
						if (c = e.getData().indicesOfNearest(h[0], t, !1, "category" === i.type ? .5 : null), !c.length) return;u = e.getData().get(h[0], c[0]);
					}if (null != u && isFinite(u)) {
						var f = t - u,
						    p = Math.abs(f);p <= r && ((p < r || f >= 0 && s < 0) && (r = p, s = f, a = u, o.length = 0), y(c, function (t) {
							o.push({ seriesIndex: e.seriesIndex, dataIndexInside: t, dataIndex: e.getData().getRawIndex(t) });
						}));
					}
				}), { payloadBatch: o, snapToValue: a };
			}function r(t, e, i, n) {
				t[e.key] = { value: i, payloadBatch: n };
			}function s(t, e, i, n) {
				var a = i.payloadBatch,
				    o = e.axis,
				    r = o.model,
				    s = e.axisPointerModel;if (e.triggerTooltip && a.length) {
					var l = e.coordSys.model,
					    u = m.makeKey(l),
					    c = t.map[u];c || (c = t.map[u] = { coordSysId: l.id, coordSysIndex: l.componentIndex, coordSysType: l.type, coordSysMainType: l.mainType, dataByAxis: [] }, t.list.push(c)), c.dataByAxis.push({ axisDim: o.dim, axisIndex: r.componentIndex, axisType: r.type, axisId: r.id, value: n, valueLabelOpt: { precision: s.get("label.precision"), formatter: s.get("label.formatter") }, seriesDataIndices: a.slice() });
				}
			}function l(t, e, i) {
				var n = i.axesInfo = [];y(e, function (e, i) {
					var a = e.axisPointerModel.option,
					    o = t[i];o ? (!e.useHandle && (a.status = "show"), a.value = o.value, a.seriesDataIndices = (o.payloadBatch || []).slice()) : !e.useHandle && (a.status = "hide"), "show" === a.status && n.push({ axisDim: e.axis.dim, axisIndex: e.axis.model.componentIndex, value: a.value });
				});
			}function u(t, e, i, n) {
				if (f(e) || !t.list.length) return void n({ type: "hideTip" });var a = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};n({ type: "showTip", escapeConnect: !0, x: e[0], y: e[1], tooltipOption: i, dataIndexInside: a.dataIndexInside, dataIndex: a.dataIndex, seriesIndex: a.seriesIndex, dataByCoordSys: t.list });
			}function c(t, e, i) {
				var n = i.getZr(),
				    a = "axisPointerLastHighlights",
				    o = _(n)[a] || {},
				    r = _(n)[a] = {};y(t, function (t, e) {
					var i = t.axisPointerModel.option;"show" === i.status && y(i.seriesDataIndices, function (t) {
						var e = t.seriesIndex + " | " + t.dataIndex;r[e] = t;
					});
				});var s = [],
				    l = [];p.each(o, function (t, e) {
					!r[e] && l.push(t);
				}), p.each(r, function (t, e) {
					!o[e] && s.push(t);
				}), l.length && i.dispatchAction({ type: "downplay", escapeConnect: !0, batch: l }), s.length && i.dispatchAction({ type: "highlight", escapeConnect: !0, batch: s });
			}function h(t, e) {
				for (var i = 0; i < (t || []).length; i++) {
					var n = t[i];if (e.axis.dim === n.axisDim && e.axis.model.componentIndex === n.axisIndex) return n;
				}
			}function d(t) {
				var e = t.axis.model,
				    i = {},
				    n = i.axisDim = t.axis.dim;return i.axisIndex = i[n + "AxisIndex"] = e.componentIndex, i.axisName = i[n + "AxisName"] = e.name, i.axisId = i[n + "AxisId"] = e.id, i;
			}function f(t) {
				return !t || null == t[0] || isNaN(t[0]) || null == t[1] || isNaN(t[1]);
			}var p = i(1),
			    g = i(5),
			    m = i(45),
			    v = i(121),
			    y = p.each,
			    x = p.curry,
			    _ = g.makeGetter();t.exports = n;
		}, function (t, e, i) {
			i(126), i(46), i(47), i(203), i(204), i(199), i(200), i(124), i(123);
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = [1 / 0, -(1 / 0)];return c(i, function (t) {
					var i = t.getData();i && c(t.coordDimToDataDim(e), function (t) {
						var e = i.getDataExtent(t);e[0] < n[0] && (n[0] = e[0]), e[1] > n[1] && (n[1] = e[1]);
					});
				}), n[1] < n[0] && (n = [NaN, NaN]), a(t, n), n;
			}function a(t, e) {
				var i = t.getAxisModel(),
				    n = i.getMin(!0),
				    a = "category" === i.get("type"),
				    o = a && (i.get("data") || []).length;null != n && "dataMin" !== n ? e[0] = n : a && (e[0] = o > 0 ? 0 : NaN);var r = i.getMax(!0);return null != r && "dataMax" !== r ? e[1] = r : a && (e[1] = o > 0 ? o - 1 : NaN), i.get("scale", !0) || (e[0] > 0 && (e[0] = 0), e[1] < 0 && (e[1] = 0)), e;
			}function o(t, e) {
				var i = t.getAxisModel(),
				    n = t._percentWindow,
				    a = t._valueWindow;if (n) {
					var o = l.getPixelPrecision(a, [0, 500]),
					    r = e || 0 === n[0] && 100 === n[1];i.setRange(r ? null : +a[0].toFixed(o), r ? null : +a[1].toFixed(o));
				}
			}function r(t) {
				var e = t._minMaxSpan = {},
				    i = t._dataZoomModel;c(["min", "max"], function (n) {
					e[n + "Span"] = i.get(n + "Span");var a = i.get(n + "ValueSpan");null != a && (e[n + "ValueSpan"] = a, a = t.getAxisModel().axis.scale.parse(a), null != a && (e[n + "Span"] = l.linearMap(a, t._dataExtent, [0, 100], !0)));
				});
			}var s = i(1),
			    l = i(4),
			    u = i(77),
			    c = s.each,
			    h = l.asc,
			    d = function d(t, e, i, n) {
				this._dimName = t, this._axisIndex = e, this._valueWindow, this._percentWindow, this._dataExtent, this._minMaxSpan, this.ecModel = n, this._dataZoomModel = i;
			};d.prototype = { constructor: d, hostedBy: function hostedBy(t) {
					return this._dataZoomModel === t;
				}, getDataValueWindow: function getDataValueWindow() {
					return this._valueWindow.slice();
				}, getDataPercentWindow: function getDataPercentWindow() {
					return this._percentWindow.slice();
				}, getTargetSeriesModels: function getTargetSeriesModels() {
					var t = [],
					    e = this.ecModel;return e.eachSeries(function (i) {
						if (u.isCoordSupported(i.get("coordinateSystem"))) {
							var n = this._dimName,
							    a = e.queryComponents({ mainType: n + "Axis", index: i.get(n + "AxisIndex"), id: i.get(n + "AxisId") })[0];this._axisIndex === (a && a.componentIndex) && t.push(i);
						}
					}, this), t;
				}, getAxisModel: function getAxisModel() {
					return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
				}, getOtherAxisModel: function getOtherAxisModel() {
					var t,
					    e,
					    i = this._dimName,
					    n = this.ecModel,
					    a = this.getAxisModel(),
					    o = "x" === i || "y" === i;o ? (e = "gridIndex", t = "x" === i ? "y" : "x") : (e = "polarIndex", t = "angle" === i ? "radius" : "angle");var r;return n.eachComponent(t + "Axis", function (t) {
						(t.get(e) || 0) === (a.get(e) || 0) && (r = t);
					}), r;
				}, getMinMaxSpan: function getMinMaxSpan() {
					return s.clone(this._minMaxSpan);
				}, calculateDataWindow: function calculateDataWindow(t) {
					var e = this._dataExtent,
					    i = this.getAxisModel(),
					    n = i.axis.scale,
					    a = this._dataZoomModel.getRangePropMode(),
					    o = [0, 100],
					    r = [t.start, t.end],
					    s = [];return c(["startValue", "endValue"], function (e) {
						s.push(null != t[e] ? n.parse(t[e]) : null);
					}), c([0, 1], function (t) {
						var i = s[t],
						    u = r[t];"percent" === a[t] ? (null == u && (u = o[t]), i = n.parse(l.linearMap(u, o, e, !0))) : u = l.linearMap(i, e, o, !0), s[t] = i, r[t] = u;
					}), { valueWindow: h(s), percentWindow: h(r) };
				}, reset: function reset(t) {
					if (t === this._dataZoomModel) {
						this._dataExtent = n(this, this._dimName, this.getTargetSeriesModels());var e = this.calculateDataWindow(t.option);this._valueWindow = e.valueWindow, this._percentWindow = e.percentWindow, r(this), o(this);
					}
				}, restore: function restore(t) {
					t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, o(this, !0));
				}, filterData: function filterData(t) {
					function e(t) {
						return t >= o[0] && t <= o[1];
					}if (t === this._dataZoomModel) {
						var i = this._dimName,
						    n = this.getTargetSeriesModels(),
						    a = t.get("filterMode"),
						    o = this._valueWindow;if ("none" !== a) {
							var r = this.getOtherAxisModel();t.get("$fromToolbox") && r && "category" === r.get("type") && (a = "empty"), c(n, function (t) {
								var n = t.getData(),
								    r = t.coordDimToDataDim(i);"weakFilter" === a ? n && n.filterSelf(function (t) {
									for (var e, i, a, s = 0; s < r.length; s++) {
										var l = n.get(r[s], t),
										    u = !isNaN(l),
										    c = l < o[0],
										    h = l > o[1];if (u && !c && !h) return !0;u && (a = !0), c && (e = !0), h && (i = !0);
									}return a && e && i;
								}) : n && c(r, function (i) {
									"empty" === a ? t.setData(n.map(i, function (t) {
										return e(t) ? t : NaN;
									})) : n.filterSelf(i, e);
								});
							});
						}
					}
				} }, t.exports = d;
		}, function (t, e, i) {
			t.exports = i(46).extend({ type: "dataZoom.inside", defaultOption: { disabled: !1, zoomLock: !1, zoomOnMouseWheel: !0, moveOnMouseMove: !0, preventDefaultMouseMove: !0 } });
		}, function (t, e, i) {
			var n = i(47),
			    a = i(1),
			    o = i(56),
			    r = i(205),
			    s = a.bind,
			    l = n.extend({ type: "dataZoom.inside", init: function init(t, e) {
					this._range;
				}, render: function render(t, e, i, n) {
					l.superApply(this, "render", arguments), r.shouldRecordRange(n, t.id) && (this._range = t.getPercentRange()), a.each(this.getTargetCoordInfo(), function (e, n) {
						var o = a.map(e, function (t) {
							return r.generateCoordId(t.model);
						});a.each(e, function (e) {
							var a = e.model,
							    l = t.option;r.register(i, { coordId: r.generateCoordId(a), allCoordIds: o, containsPoint: function containsPoint(t, e, i) {
									return a.coordinateSystem.containPoint([e, i]);
								}, dataZoomId: t.id, throttleRate: t.get("throttle", !0), panGetRange: s(this._onPan, this, e, n), zoomGetRange: s(this._onZoom, this, e, n), zoomLock: l.zoomLock, disabled: l.disabled, roamControllerOpt: { zoomOnMouseWheel: l.zoomOnMouseWheel, moveOnMouseMove: l.moveOnMouseMove, preventDefaultMouseMove: l.preventDefaultMouseMove } });
						}, this);
					}, this);
				}, dispose: function dispose() {
					r.unregister(this.api, this.dataZoomModel.id), l.superApply(this, "dispose", arguments), this._range = null;
				}, _onPan: function _onPan(t, e, i, n, a, r, s, l, c) {
					var h = this._range.slice(),
					    d = t.axisModels[0];if (d) {
						var f = u[e]([r, s], [l, c], d, i, t),
						    p = f.signal * (h[1] - h[0]) * f.pixel / f.pixelLength;return o(p, h, [0, 100], "all"), this._range = h;
					}
				}, _onZoom: function _onZoom(t, e, i, n, a, r) {
					var s = this._range.slice(),
					    l = t.axisModels[0];if (l) {
						var c = u[e](null, [a, r], l, i, t),
						    h = (c.pixel - c.pixelStart) / c.pixelLength * (s[1] - s[0]) + s[0];n = Math.max(1 / n, 0), s[0] = (s[0] - h) * n + h, s[1] = (s[1] - h) * n + h;var d = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();return o(0, s, [0, 100], 0, d.minSpan, d.maxSpan), this._range = s;
					}
				} }),
			    u = { grid: function grid(t, e, i, n, a) {
					var o = i.axis,
					    r = {},
					    s = a.model.coordinateSystem.getRect();return t = t || [0, 0], "x" === o.dim ? (r.pixel = e[0] - t[0], r.pixelLength = s.width, r.pixelStart = s.x, r.signal = o.inverse ? 1 : -1) : (r.pixel = e[1] - t[1], r.pixelLength = s.height, r.pixelStart = s.y, r.signal = o.inverse ? -1 : 1), r;
				}, polar: function polar(t, e, i, n, a) {
					var o = i.axis,
					    r = {},
					    s = a.model.coordinateSystem,
					    l = s.getRadiusAxis().getExtent(),
					    u = s.getAngleAxis().getExtent();return t = t ? s.pointToCoord(t) : [0, 0], e = s.pointToCoord(e), "radiusAxis" === i.mainType ? (r.pixel = e[0] - t[0], r.pixelLength = l[1] - l[0], r.pixelStart = l[0], r.signal = o.inverse ? 1 : -1) : (r.pixel = e[1] - t[1], r.pixelLength = u[1] - u[0], r.pixelStart = u[0], r.signal = o.inverse ? -1 : 1), r;
				}, singleAxis: function singleAxis(t, e, i, n, a) {
					var o = i.axis,
					    r = a.model.coordinateSystem.getRect(),
					    s = {};return t = t || [0, 0], "horizontal" === o.orient ? (s.pixel = e[0] - t[0], s.pixelLength = r.width, s.pixelStart = r.x, s.signal = o.inverse ? 1 : -1) : (s.pixel = e[1] - t[1], s.pixelLength = r.height, s.pixelStart = r.y, s.signal = o.inverse ? -1 : 1), s;
				} };t.exports = l;
		}, function (t, e, i) {
			var n = i(46);t.exports = n.extend({ type: "dataZoom.select" });
		}, function (t, e, i) {
			t.exports = i(47).extend({ type: "dataZoom.select" });
		}, function (t, e, i) {
			var n = i(46),
			    a = n.extend({ type: "dataZoom.slider", layoutMode: "box", defaultOption: { show: !0, right: "ph", top: "ph", width: "ph", height: "ph", left: null, bottom: null, backgroundColor: "rgba(47,69,84,0)", dataBackground: { lineStyle: { color: "#2f4554", width: .5, opacity: .3 }, areaStyle: { color: "rgba(47,69,84,0.3)", opacity: .3 } }, borderColor: "#ddd", fillerColor: "rgba(167,183,204,0.4)", handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z", handleSize: "100%", handleStyle: { color: "#a7b7cc" }, labelPrecision: null, labelFormatter: null, showDetail: !0, showDataShadow: "auto", realtime: !0, zoomLock: !1, textStyle: { color: "#333" } } });t.exports = a;
		}, function (t, e, i) {
			function n(t) {
				var e = { x: "y", y: "x", radius: "angle", angle: "radius" };return e[t];
			}var a = i(1),
			    o = i(3),
			    r = i(37),
			    s = i(47),
			    l = o.Rect,
			    u = i(4),
			    c = u.linearMap,
			    h = i(12),
			    d = i(56),
			    f = i(21),
			    p = u.asc,
			    g = a.bind,
			    m = a.each,
			    v = 7,
			    y = 1,
			    x = 30,
			    _ = "horizontal",
			    b = "vertical",
			    w = 5,
			    S = ["line", "bar", "candlestick", "scatter"],
			    M = s.extend({ type: "dataZoom.slider", init: function init(t, e) {
					this._displayables = {}, this._orient, this._range, this._handleEnds, this._size, this._handleWidth, this._handleHeight, this._location, this._dragging, this._dataShadowInfo, this.api = e;
				}, render: function render(t, e, i, n) {
					return M.superApply(this, "render", arguments), r.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"), this._orient = t.get("orient"), this.dataZoomModel.get("show") === !1 ? void this.group.removeAll() : (n && "dataZoom" === n.type && n.from === this.uid || this._buildView(), void this._updateView());
				}, remove: function remove() {
					M.superApply(this, "remove", arguments), r.clear(this, "_dispatchZoomAction");
				}, dispose: function dispose() {
					M.superApply(this, "dispose", arguments), r.clear(this, "_dispatchZoomAction");
				}, _buildView: function _buildView() {
					var t = this.group;t.removeAll(), this._resetLocation(), this._resetInterval();var e = this._displayables.barGroup = new o.Group();this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(e), this._positionGroup();
				}, _resetLocation: function _resetLocation() {
					var t = this.dataZoomModel,
					    e = this.api,
					    i = this._findCoordRect(),
					    n = { width: e.getWidth(), height: e.getHeight() },
					    o = this._orient === _ ? { right: n.width - i.x - i.width, top: n.height - x - v, width: i.width, height: x } : { right: v, top: i.y, width: x, height: i.height },
					    r = h.getLayoutParams(t.option);a.each(["right", "top", "width", "height"], function (t) {
						"ph" === r[t] && (r[t] = o[t]);
					});var s = h.getLayoutRect(r, n, t.padding);this._location = { x: s.x, y: s.y }, this._size = [s.width, s.height], this._orient === b && this._size.reverse();
				}, _positionGroup: function _positionGroup() {
					var t = this.group,
					    e = this._location,
					    i = this._orient,
					    n = this.dataZoomModel.getFirstTargetAxisModel(),
					    a = n && n.get("inverse"),
					    o = this._displayables.barGroup,
					    r = (this._dataShadowInfo || {}).otherAxisInverse;o.attr(i !== _ || a ? i === _ && a ? { scale: r ? [-1, 1] : [-1, -1] } : i !== b || a ? { scale: r ? [-1, -1] : [-1, 1], rotation: Math.PI / 2 } : { scale: r ? [1, -1] : [1, 1], rotation: Math.PI / 2 } : { scale: r ? [1, 1] : [1, -1] });var s = t.getBoundingRect([o]);t.attr("position", [e.x - s.x, e.y - s.y]);
				}, _getViewExtent: function _getViewExtent() {
					return [0, this._size[0]];
				}, _renderBackground: function _renderBackground() {
					var t = this.dataZoomModel,
					    e = this._size,
					    i = this._displayables.barGroup;i.add(new l({ silent: !0, shape: { x: 0, y: 0, width: e[0], height: e[1] }, style: { fill: t.get("backgroundColor") }, z2: -40 })), i.add(new l({ shape: { x: 0, y: 0, width: e[0], height: e[1] }, style: { fill: "transparent" }, z2: 0, onclick: a.bind(this._onClickPanelClick, this) }));
				}, _renderDataShadow: function _renderDataShadow() {
					var t = this._dataShadowInfo = this._prepareDataShadowInfo();if (t) {
						var e = this._size,
						    i = t.series,
						    n = i.getRawData(),
						    r = i.getShadowDim ? i.getShadowDim() : t.otherDim;if (null != r) {
							var s = n.getDataExtent(r),
							    l = .3 * (s[1] - s[0]);s = [s[0] - l, s[1] + l];var u,
							    h = [0, e[1]],
							    d = [0, e[0]],
							    f = [[e[0], 0], [0, 0]],
							    p = [],
							    g = d[1] / (n.count() - 1),
							    m = 0,
							    v = Math.round(n.count() / e[0]);n.each([r], function (t, e) {
								if (v > 0 && e % v) return void (m += g);var i = null == t || isNaN(t) || "" === t,
								    n = i ? 0 : c(t, s, h, !0);i && !u && e ? (f.push([f[f.length - 1][0], 0]), p.push([p[p.length - 1][0], 0])) : !i && u && (f.push([m, 0]), p.push([m, 0])), f.push([m, n]), p.push([m, n]), m += g, u = i;
							});var y = this.dataZoomModel;this._displayables.barGroup.add(new o.Polygon({ shape: { points: f }, style: a.defaults({ fill: y.get("dataBackgroundColor") }, y.getModel("dataBackground.areaStyle").getAreaStyle()), silent: !0, z2: -20 })), this._displayables.barGroup.add(new o.Polyline({ shape: { points: p }, style: y.getModel("dataBackground.lineStyle").getLineStyle(), silent: !0, z2: -19 }));
						}
					}
				}, _prepareDataShadowInfo: function _prepareDataShadowInfo() {
					var t = this.dataZoomModel,
					    e = t.get("showDataShadow");if (e !== !1) {
						var i,
						    o = this.ecModel;return t.eachTargetAxis(function (r, s) {
							var l = t.getAxisProxy(r.name, s).getTargetSeriesModels();a.each(l, function (t) {
								if (!(i || e !== !0 && a.indexOf(S, t.get("type")) < 0)) {
									var l,
									    u = o.getComponent(r.axis, s).axis,
									    c = n(r.name),
									    h = t.coordinateSystem;null != c && h.getOtherAxis && (l = h.getOtherAxis(u).inverse), i = { thisAxis: u, series: t, thisDim: r.name, otherDim: c, otherAxisInverse: l };
								}
							}, this);
						}, this), i;
					}
				}, _renderHandle: function _renderHandle() {
					var t = this._displayables,
					    e = t.handles = [],
					    i = t.handleLabels = [],
					    n = this._displayables.barGroup,
					    a = this._size,
					    r = this.dataZoomModel;n.add(t.filler = new l({ draggable: !0, cursor: "move", drift: g(this._onDragMove, this, "all"), onmousemove: function onmousemove(t) {
							f.stop(t.event);
						}, ondragstart: g(this._showDataInfo, this, !0), ondragend: g(this._onDragEnd, this), onmouseover: g(this._showDataInfo, this, !0), onmouseout: g(this._showDataInfo, this, !1), style: { fill: r.get("fillerColor"), textPosition: "inside" } })), n.add(new l(o.subPixelOptimizeRect({ silent: !0, shape: { x: 0, y: 0, width: a[0], height: a[1] }, style: { stroke: r.get("dataBackgroundColor") || r.get("borderColor"), lineWidth: y, fill: "rgba(0,0,0,0)" } })));var s = r.get("handleIcon");m([0, 1], function (t) {
						var a = { style: { strokeNoScale: !0 }, rectHover: !0, cursor: "vertical" === this._orient ? "ns-resize" : "ew-resize", draggable: !0, drift: g(this._onDragMove, this, t), onmousemove: function onmousemove(t) {
								f.stop(t.event);
							}, ondragend: g(this._onDragEnd, this), onmouseover: g(this._showDataInfo, this, !0), onmouseout: g(this._showDataInfo, this, !1) },
						    l = { x: -1, y: 0, width: 2, height: 2 },
						    c = 0 === s.indexOf("image://") ? (l.image = s.slice(8), a.style = l, new o.Image(a)) : o.makePath(s.replace("path://", ""), a, l, "center"),
						    h = c.getBoundingRect();this._handleHeight = u.parsePercent(r.get("handleSize"), this._size[1]), this._handleWidth = h.width / h.height * this._handleHeight, c.setStyle(r.getModel("handleStyle").getItemStyle());var d = r.get("handleColor");null != d && (c.style.fill = d), n.add(e[t] = c);var p = r.textStyleModel;this.group.add(i[t] = new o.Text({ silent: !0, invisible: !0, style: { x: 0, y: 0, text: "", textVerticalAlign: "middle", textAlign: "center", fill: p.getTextColor(), textFont: p.getFont() }, z2: 10 }));
					}, this);
				}, _resetInterval: function _resetInterval() {
					var t = this._range = this.dataZoomModel.getPercentRange(),
					    e = this._getViewExtent();this._handleEnds = [c(t[0], [0, 100], e, !0), c(t[1], [0, 100], e, !0)];
				}, _updateInterval: function _updateInterval(t, e) {
					var i = this.dataZoomModel,
					    n = this._handleEnds,
					    a = this._getViewExtent(),
					    o = i.findRepresentativeAxisProxy().getMinMaxSpan(),
					    r = [0, 100];d(e, n, a, i.get("zoomLock") ? "all" : t, null != o.minSpan ? c(o.minSpan, r, a, !0) : null, null != o.maxSpan ? c(o.maxSpan, r, a, !0) : null), this._range = p([c(n[0], a, r, !0), c(n[1], a, r, !0)]);
				}, _updateView: function _updateView(t) {
					var e = this._displayables,
					    i = this._handleEnds,
					    n = p(i.slice()),
					    a = this._size;m([0, 1], function (t) {
						var n = e.handles[t],
						    o = this._handleHeight;n.attr({ scale: [o / 2, o / 2], position: [i[t], a[1] / 2 - o / 2] });
					}, this), e.filler.setShape({ x: n[0], y: 0, width: n[1] - n[0], height: a[1] }), this._updateDataInfo(t);
				}, _updateDataInfo: function _updateDataInfo(t) {
					function e(t) {
						var e = o.getTransform(n.handles[t].parent, this.group),
						    i = o.transformDirection(0 === t ? "right" : "left", e),
						    l = this._handleWidth / 2 + w,
						    u = o.applyTransform([d[t] + (0 === t ? -l : l), this._size[1] / 2], e);a[t].setStyle({ x: u[0], y: u[1], textVerticalAlign: r === _ ? "middle" : i, textAlign: r === _ ? i : "center", text: s[t] });
					}var i = this.dataZoomModel,
					    n = this._displayables,
					    a = n.handleLabels,
					    r = this._orient,
					    s = ["", ""];if (i.get("showDetail")) {
						var l = i.findRepresentativeAxisProxy();if (l) {
							var u = l.getAxisModel().axis,
							    c = this._range,
							    h = t ? l.calculateDataWindow({ start: c[0], end: c[1] }).valueWindow : l.getDataValueWindow();s = [this._formatLabel(h[0], u), this._formatLabel(h[1], u)];
						}
					}var d = p(this._handleEnds.slice());e.call(this, 0), e.call(this, 1);
				}, _formatLabel: function _formatLabel(t, e) {
					var i = this.dataZoomModel,
					    n = i.get("labelFormatter"),
					    o = i.get("labelPrecision");null != o && "auto" !== o || (o = e.getPixelPrecision());var r = null == t || isNaN(t) ? "" : "category" === e.type || "time" === e.type ? e.scale.getLabel(Math.round(t)) : t.toFixed(Math.min(o, 20));return a.isFunction(n) ? n(t, r) : a.isString(n) ? n.replace("{value}", r) : r;
				}, _showDataInfo: function _showDataInfo(t) {
					t = this._dragging || t;var e = this._displayables.handleLabels;e[0].attr("invisible", !t), e[1].attr("invisible", !t);
				}, _onDragMove: function _onDragMove(t, e, i) {
					this._dragging = !0;var n = this._displayables.barGroup.getLocalTransform(),
					    a = o.applyTransform([e, i], n, !0);this._updateInterval(t, a[0]);var r = this.dataZoomModel.get("realtime");this._updateView(!r), r && r && this._dispatchZoomAction();
				}, _onDragEnd: function _onDragEnd() {
					this._dragging = !1, this._showDataInfo(!1), this._dispatchZoomAction();
				}, _onClickPanelClick: function _onClickPanelClick(t) {
					var e = this._size,
					    i = this._displayables.barGroup.transformCoordToLocal(t.offsetX, t.offsetY);if (!(i[0] < 0 || i[0] > e[0] || i[1] < 0 || i[1] > e[1])) {
						var n = this._handleEnds,
						    a = (n[0] + n[1]) / 2;this._updateInterval("all", i[0] - a), this._updateView(), this._dispatchZoomAction();
					}
				}, _dispatchZoomAction: function _dispatchZoomAction() {
					var t = this._range;this.api.dispatchAction({ type: "dataZoom", from: this.uid, dataZoomId: this.dataZoomModel.id, start: t[0], end: t[1] });
				}, _findCoordRect: function _findCoordRect() {
					var t;if (m(this.getTargetCoordInfo(), function (e) {
						if (!t && e.length) {
							var i = e[0].model.coordinateSystem;t = i.getRect && i.getRect();
						}
					}), !t) {
						var e = this.api.getWidth(),
						    i = this.api.getHeight();t = { x: .2 * e, y: .2 * i, width: .6 * e, height: .6 * i };
					}return t;
				} });t.exports = M;
		}, function (t, e, i) {
			function n(t) {
				var e = t.getZr();return e[p] || (e[p] = {});
			}function a(t, e) {
				var i = new h(t.getZr());return i.on("pan", f(r, e)), i.on("zoom", f(s, e)), i;
			}function o(t) {
				c.each(t, function (e, i) {
					e.count || (e.controller.dispose(), delete t[i]);
				});
			}function r(t, e, i, n, a, o, r) {
				l(t, function (s) {
					return s.panGetRange(t.controller, e, i, n, a, o, r);
				});
			}function s(t, e, i, n) {
				l(t, function (a) {
					return a.zoomGetRange(t.controller, e, i, n);
				});
			}function l(t, e) {
				var i = [];c.each(t.dataZoomInfos, function (t) {
					var n = e(t);n && i.push({ dataZoomId: t.dataZoomId, start: n[0], end: n[1] });
				}), t.dispatchAction(i);
			}function u(t, e) {
				t.dispatchAction({ type: "dataZoom", batch: e });
			}var c = i(1),
			    h = i(95),
			    d = i(37),
			    f = c.curry,
			    p = "\0_ec_dataZoom_roams",
			    g = { register: function register(t, e) {
					var i = n(t),
					    r = e.dataZoomId,
					    s = e.coordId;c.each(i, function (t, i) {
						var n = t.dataZoomInfos;n[r] && c.indexOf(e.allCoordIds, s) < 0 && (delete n[r], t.count--);
					}), o(i);var l = i[s];l || (l = i[s] = { coordId: s, dataZoomInfos: {}, count: 0 }, l.controller = a(t, l), l.dispatchAction = c.curry(u, t)), l.controller.enable(!e.disabled && (!e.zoomLock || "move"), e.roamControllerOpt), l.controller.setPointerChecker(e.containsPoint), d.createOrUpdate(l, "dispatchAction", e.throttleRate, "fixRate"), !l.dataZoomInfos[r] && l.count++, l.dataZoomInfos[r] = e;
				}, unregister: function unregister(t, e) {
					var i = n(t);c.each(i, function (t) {
						t.controller.dispose();var i = t.dataZoomInfos;i[e] && (delete i[e], t.count--);
					}), o(i);
				}, shouldRecordRange: function shouldRecordRange(t, e) {
					if (t && "dataZoom" === t.type && t.batch) for (var i = 0, n = t.batch.length; i < n; i++) {
						if (t.batch[i].dataZoomId === e) return !1;
					}return !0;
				}, generateCoordId: function generateCoordId(t) {
					return t.type + "\0_" + t.id;
				} };t.exports = g;
		}, function (t, e, i) {
			i(126), i(46), i(47), i(201), i(202), i(124), i(123);
		}, function (t, e, i) {
			function n(t, e, i, n) {
				var a = i.type,
				    o = f[a.charAt(0).toUpperCase() + a.slice(1)],
				    r = new o(i);e.add(r), n.set(t, r), r.__ecGraphicId = t;
			}function a(t, e) {
				var i = t && t.parent;i && ("group" === t.type && t.traverse(function (t) {
					a(t, e);
				}), e.removeKey(t.__ecGraphicId), i.remove(t));
			}function o(t) {
				return t = h.extend({}, t), h.each(["id", "parentId", "$action", "hv", "bounding"].concat(p.LOCATION_PARAMS), function (e) {
					delete t[e];
				}), t;
			}function r(t, e) {
				var i;return h.each(e, function (e) {
					null != t[e] && "auto" !== t[e] && (i = !0);
				}), i;
			}function s(t, e) {
				var i = t.exist;if (e.id = t.keyInfo.id, !e.type && i && (e.type = i.type), null == e.parentId) {
					var n = e.parentOption;n ? e.parentId = n.id : i && (e.parentId = i.parentId);
				}e.parentOption = null;
			}function l(t, e, i) {
				var n = h.extend({}, i),
				    a = t[e],
				    o = i.$action || "merge";if ("merge" === o) {
					if (a) {
						h.merge(a, n, !0), p.mergeLayoutParam(a, n, { ignoreSize: !0 }), p.copyLayoutParams(i, a);
					} else t[e] = n;
				} else "replace" === o ? t[e] = n : "remove" === o && a && (t[e] = null);
			}function u(t, e) {
				t && (t.hv = e.hv = [r(e, ["left", "right"]), r(e, ["top", "bottom"])], "group" === t.type && (null == t.width && (t.width = e.width = 0), null == t.height && (t.height = e.height = 0)));
			}var c = i(2),
			    h = i(1),
			    d = i(5),
			    f = i(3),
			    p = i(12);c.registerPreprocessor(function (t) {
				var e = t.graphic;h.isArray(e) ? e[0] && e[0].elements ? t.graphic = [t.graphic[0]] : t.graphic = [{ elements: e }] : e && !e.elements && (t.graphic = [{ elements: [e] }]);
			});var g = c.extendComponentModel({ type: "graphic", defaultOption: { elements: [], parentId: null }, _elOptionsToUpdate: null, mergeOption: function mergeOption(t) {
					var e = this.option.elements;this.option.elements = null, g.superApply(this, "mergeOption", arguments), this.option.elements = e;
				}, optionUpdated: function optionUpdated(t, e) {
					var i = this.option,
					    n = (e ? i : t).elements,
					    a = i.elements = e ? [] : i.elements,
					    o = [];this._flatten(n, o);var r = d.mappingToExists(a, o);d.makeIdAndName(r);var c = this._elOptionsToUpdate = [];h.each(r, function (t, e) {
						var i = t.option;i && (c.push(i), s(t, i), l(a, e, i), u(a[e], i));
					}, this);for (var f = a.length - 1; f >= 0; f--) {
						null == a[f] ? a.splice(f, 1) : delete a[f].$action;
					}
				}, _flatten: function _flatten(t, e, i) {
					h.each(t, function (t) {
						if (t) {
							i && (t.parentOption = i), e.push(t);var n = t.children;"group" === t.type && n && this._flatten(n, e, t), delete t.children;
						}
					}, this);
				}, useElOptionsToUpdate: function useElOptionsToUpdate() {
					var t = this._elOptionsToUpdate;return this._elOptionsToUpdate = null, t;
				} });c.extendComponentView({ type: "graphic", init: function init(t, e) {
					this._elMap = h.createHashMap(), this._lastGraphicModel;
				}, render: function render(t, e, i) {
					t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t, i), this._relocate(t, i);
				}, _updateElements: function _updateElements(t, e) {
					var i = t.useElOptionsToUpdate();if (i) {
						var r = this._elMap,
						    s = this.group;h.each(i, function (t) {
							var e = t.$action,
							    i = t.id,
							    l = r.get(i),
							    u = t.parentId,
							    c = null != u ? r.get(u) : s;t.hv && t.hv[1] && "text" === t.type && (t.style = h.defaults({ textBaseline: "middle" }, t.style), t.style.textVerticalAlign = null);var d = o(t);e && "merge" !== e ? "replace" === e ? (a(l, r), n(i, c, d, r)) : "remove" === e && a(l, r) : l ? l.attr(d) : n(i, c, d, r);var f = r.get(i);f && (f.__ecGraphicWidth = t.width, f.__ecGraphicHeight = t.height);
						});
					}
				}, _relocate: function _relocate(t, e) {
					for (var i = t.option.elements, n = this.group, a = this._elMap, o = i.length - 1; o >= 0; o--) {
						var r = i[o],
						    s = a.get(r.id);if (s) {
							var l = s.parent,
							    u = l === n ? { width: e.getWidth(), height: e.getHeight() } : { width: l.__ecGraphicWidth || 0, height: l.__ecGraphicHeight || 0 };p.positionElement(s, r, u, null, { hv: r.hv, boundingMode: r.bounding });
						}
					}
				}, _clear: function _clear() {
					var t = this._elMap;t.each(function (e) {
						a(e, t);
					}), this._elMap = h.createHashMap();
				}, dispose: function dispose() {
					this._clear();
				} });
		}, function (t, e, i) {
			i(32), i(120), i(55);
		}, function (t, e, i) {
			i(210), i(212), i(211);var n = i(2);n.registerProcessor(i(213));
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(10),
			    o = i(2).extendComponentModel({ type: "legend", dependencies: ["series"], layoutMode: { type: "box", ignoreSize: !0 }, init: function init(t, e, i) {
					this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {};
				}, mergeOption: function mergeOption(t) {
					o.superCall(this, "mergeOption", t);
				}, optionUpdated: function optionUpdated() {
					this._updateData(this.ecModel);var t = this._data;if (t[0] && "single" === this.get("selectedMode")) {
						for (var e = !1, i = 0; i < t.length; i++) {
							var n = t[i].get("name");if (this.isSelected(n)) {
								this.select(n), e = !0;break;
							}
						}!e && this.select(t[0].get("name"));
					}
				}, _updateData: function _updateData(t) {
					var e = n.map(this.get("data") || [], function (t) {
						return "string" != typeof t && "number" != typeof t || (t = { name: t }), new a(t, this, this.ecModel);
					}, this);this._data = e;var i = n.map(t.getSeries(), function (t) {
						return t.name;
					});t.eachSeries(function (t) {
						if (t.legendDataProvider) {
							var e = t.legendDataProvider();i = i.concat(e.mapArray(e.getName));
						}
					}), this._availableNames = i;
				}, getData: function getData() {
					return this._data;
				}, select: function select(t) {
					var e = this.option.selected,
					    i = this.get("selectedMode");if ("single" === i) {
						var a = this._data;n.each(a, function (t) {
							e[t.get("name")] = !1;
						});
					}e[t] = !0;
				}, unSelect: function unSelect(t) {
					"single" !== this.get("selectedMode") && (this.option.selected[t] = !1);
				}, toggleSelected: function toggleSelected(t) {
					var e = this.option.selected;e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t);
				}, isSelected: function isSelected(t) {
					var e = this.option.selected;return !(e.hasOwnProperty(t) && !e[t]) && n.indexOf(this._availableNames, t) >= 0;
				}, defaultOption: { zlevel: 0, z: 4, show: !0, orient: "horizontal", left: "center", top: "top", align: "auto", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, itemWidth: 25, itemHeight: 14, inactiveColor: "#ccc", textStyle: { color: "#333" }, selectedMode: !0, tooltip: { show: !1 } } });t.exports = o;
		}, function (t, e, i) {
			function n(t, e) {
				e.dispatchAction({ type: "legendToggleSelect", name: t });
			}function a(t, e, i) {
				var n = i.getZr().storage.getDisplayList()[0];n && n.useHoverLayer || t.get("legendHoverLink") && i.dispatchAction({ type: "highlight", seriesName: t.name, name: e });
			}function o(t, e, i) {
				var n = i.getZr().storage.getDisplayList()[0];n && n.useHoverLayer || t.get("legendHoverLink") && i.dispatchAction({ type: "downplay", seriesName: t.name, name: e });
			}var r = i(1),
			    s = i(24),
			    l = i(3),
			    u = i(130),
			    c = r.curry;t.exports = i(2).extendComponentView({ type: "legend", init: function init() {
					this._symbolTypeStore = {};
				}, render: function render(t, e, i) {
					var s = this.group;if (s.removeAll(), t.get("show")) {
						var h = t.get("selectedMode"),
						    d = t.get("align");"auto" === d && (d = "right" === t.get("left") && "vertical" === t.get("orient") ? "right" : "left");var f = r.createHashMap();r.each(t.getData(), function (r) {
							var u = r.get("name");if ("" === u || "\n" === u) return void s.add(new l.Group({ newline: !0 }));var p = e.getSeriesByName(u)[0];if (!f.get(u)) if (p) {
								var g = p.getData(),
								    m = g.getVisual("color");"function" == typeof m && (m = m(p.getDataParams(0)));var v = g.getVisual("legendSymbol") || "roundRect",
								    y = g.getVisual("symbol"),
								    x = this._createItem(u, r, t, v, y, d, m, h);x.on("click", c(n, u, i)).on("mouseover", c(a, p, null, i)).on("mouseout", c(o, p, null, i)), f.set(u, !0);
							} else e.eachRawSeries(function (e) {
								if (!f.get(u) && e.legendDataProvider) {
									var s = e.legendDataProvider(),
									    l = s.indexOfName(u);if (l < 0) return;var p = s.getItemVisual(l, "color"),
									    g = "roundRect",
									    m = this._createItem(u, r, t, g, null, d, p, h);m.on("click", c(n, u, i)).on("mouseover", c(a, e, u, i)).on("mouseout", c(o, e, u, i)), f.set(u, !0);
								}
							}, this);
						}, this), u.layout(s, t, i), u.addBackground(s, t);
					}
				}, _createItem: function _createItem(t, e, i, n, a, o, u, c) {
					var h = i.get("itemWidth"),
					    d = i.get("itemHeight"),
					    f = i.get("inactiveColor"),
					    p = i.isSelected(t),
					    g = new l.Group(),
					    m = e.getModel("textStyle"),
					    v = e.get("icon"),
					    y = e.getModel("tooltip"),
					    x = y.parentModel;if (n = v || n, g.add(s.createSymbol(n, 0, 0, h, d, p ? u : f)), !v && a && (a !== n || "none" == a)) {
						var _ = .8 * d;"none" === a && (a = "circle"), g.add(s.createSymbol(a, (h - _) / 2, (d - _) / 2, _, _, p ? u : f));
					}var b = "left" === o ? h + 5 : -5,
					    w = o,
					    S = i.get("formatter"),
					    M = t;"string" == typeof S && S ? M = S.replace("{name}", null != t ? t : "") : "function" == typeof S && (M = S(t));var I = new l.Text({ style: { text: M, x: b, y: d / 2, fill: p ? m.getTextColor() : f, textFont: m.getFont(), textAlign: w, textVerticalAlign: "middle" } });g.add(I);var T = new l.Rect({ shape: g.getBoundingRect(), invisible: !0, tooltip: y.get("show") ? r.extend({ content: t, formatter: x.get("formatter", !0) || function () {
								return t;
							}, formatterParams: { componentType: "legend", legendIndex: i.componentIndex, name: t, $vars: ["name"] } }, y.option) : null });return g.add(T), g.eachChild(function (t) {
						t.silent = !0;
					}), T.silent = !c, this.group.add(g), l.setHoverStyle(g), g;
				} });
		}, function (t, e, i) {
			function n(t, e, i) {
				var n,
				    a = {},
				    r = "toggleSelected" === t;return i.eachComponent("legend", function (i) {
					r && null != n ? i[n ? "select" : "unSelect"](e.name) : (i[t](e.name), n = i.isSelected(e.name));var s = i.getData();o.each(s, function (t) {
						var e = t.get("name");if ("\n" !== e && "" !== e) {
							var n = i.isSelected(e);a.hasOwnProperty(e) ? a[e] = a[e] && n : a[e] = n;
						}
					});
				}), { name: e.name, selected: a };
			}var a = i(2),
			    o = i(1);a.registerAction("legendToggleSelect", "legendselectchanged", o.curry(n, "toggleSelected")), a.registerAction("legendSelect", "legendselected", o.curry(n, "select")), a.registerAction("legendUnSelect", "legendunselected", o.curry(n, "unSelect"));
		}, function (t, e) {
			t.exports = function (t) {
				var e = t.findComponents({ mainType: "legend" });e && e.length && t.filterSeries(function (t) {
					for (var i = 0; i < e.length; i++) {
						if (!e[i].isSelected(t.name)) return !1;
					}return !0;
				});
			};
		}, function (t, e, i) {
			i(217), i(218), i(2).registerPreprocessor(function (t) {
				t.markArea = t.markArea || {};
			});
		}, function (t, e, i) {
			i(219), i(220), i(2).registerPreprocessor(function (t) {
				t.markLine = t.markLine || {};
			});
		}, function (t, e, i) {
			i(221), i(222), i(2).registerPreprocessor(function (t) {
				t.markPoint = t.markPoint || {};
			});
		}, function (t, e, i) {
			t.exports = i(79).extend({ type: "markArea", defaultOption: { zlevel: 0, z: 1, tooltip: { trigger: "item" }, animation: !1, label: { normal: { show: !0, position: "top" }, emphasis: { show: !0, position: "top" } }, itemStyle: { normal: { borderWidth: 0 } } } });
		}, function (t, e, i) {
			function n(t) {
				return !isNaN(t) && !isFinite(t);
			}function a(t, e, i, a) {
				var o = 1 - t;return n(e[o]) && n(i[o]);
			}function o(t, e) {
				var i = e.coord[0],
				    n = e.coord[1];return !("cartesian2d" !== t.type || !i || !n || !a(1, i, n, t) && !a(0, i, n, t)) || f.dataFilter(t, { coord: i, x: e.x0, y: e.y0 }) || f.dataFilter(t, { coord: n, x: e.x1, y: e.y1 });
			}function r(t, e, i, a, o) {
				var r,
				    s = a.coordinateSystem,
				    l = t.getItemModel(e),
				    u = c.parsePercent(l.get(i[0]), o.getWidth()),
				    h = c.parsePercent(l.get(i[1]), o.getHeight());if (isNaN(u) || isNaN(h)) {
					if (a.getMarkerPosition) r = a.getMarkerPosition(t.getValues(i, e));else {
						var d = t.get(i[0], e),
						    f = t.get(i[1], e);r = s.dataToPoint([d, f], !0);
					}if ("cartesian2d" === s.type) {
						var p = s.getAxis("x"),
						    g = s.getAxis("y"),
						    d = t.get(i[0], e),
						    f = t.get(i[1], e);n(d) ? r[0] = p.toGlobalCoord(p.getExtent()["x0" === i[0] ? 0 : 1]) : n(f) && (r[1] = g.toGlobalCoord(g.getExtent()["y0" === i[1] ? 0 : 1]));
					}isNaN(u) || (r[0] = u), isNaN(h) || (r[1] = h);
				} else r = [u, h];return r;
			}function s(t, e, i) {
				var n,
				    a,
				    r = ["x0", "y0", "x1", "y1"];t ? (n = l.map(t && t.dimensions, function (t) {
					var i = e.getData().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};return i.name = t, i;
				}), a = new u(l.map(r, function (t, e) {
					return { name: t, type: n[e % 2].type };
				}), i)) : (n = [{ name: "value", type: "float" }], a = new u(n, i));var s = l.map(i.get("data"), l.curry(p, e, t, i));t && (s = l.filter(s, l.curry(o, t)));var c = t ? function (t, e, i, n) {
					return t.coord[Math.floor(n / 2)][n % 2];
				} : function (t) {
					return t.value;
				};return a.initData(s, null, c), a.hasItemOption = !0, a;
			}var l = i(1),
			    u = i(14),
			    c = i(4),
			    h = i(3),
			    d = i(22),
			    f = i(81),
			    p = function p(t, e, i, n) {
				var a = f.dataTransform(t, n[0]),
				    o = f.dataTransform(t, n[1]),
				    r = l.retrieve,
				    s = a.coord,
				    u = o.coord;s[0] = r(s[0], -(1 / 0)), s[1] = r(s[1], -(1 / 0)), u[0] = r(u[0], 1 / 0), u[1] = r(u[1], 1 / 0);var c = l.mergeAll([{}, a, o]);return c.coord = [a.coord, o.coord], c.x0 = a.x, c.y0 = a.y, c.x1 = o.x, c.y1 = o.y, c;
			},
			    g = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];i(80).extend({ type: "markArea", updateLayout: function updateLayout(t, e, i) {
					e.eachSeries(function (t) {
						var e = t.markAreaModel;if (e) {
							var n = e.getData();n.each(function (e) {
								var a = l.map(g, function (a) {
									return r(n, e, a, t, i);
								});n.setItemLayout(e, a);var o = n.getItemGraphicEl(e);o.setShape("points", a);
							});
						}
					}, this);
				}, renderSeries: function renderSeries(t, e, i, n) {
					var a = t.coordinateSystem,
					    o = t.name,
					    u = t.getData(),
					    c = this.markerGroupMap,
					    f = c.get(o) || c.set(o, { group: new h.Group() });this.group.add(f.group), f.__keep = !0;var p = s(a, t, e);e.setData(p), p.each(function (e) {
						p.setItemLayout(e, l.map(g, function (i) {
							return r(p, e, i, t, n);
						})), p.setItemVisual(e, { color: u.getVisual("color") });
					}), p.diff(f.__data).add(function (t) {
						var e = new h.Polygon({ shape: { points: p.getItemLayout(t) } });p.setItemGraphicEl(t, e), f.group.add(e);
					}).update(function (t, i) {
						var n = f.__data.getItemGraphicEl(i);h.updateProps(n, { shape: { points: p.getItemLayout(t) } }, e, t), f.group.add(n), p.setItemGraphicEl(t, n);
					}).remove(function (t) {
						var e = f.__data.getItemGraphicEl(t);f.group.remove(e);
					}).execute(), p.eachItemGraphicEl(function (t, i) {
						var n = p.getItemModel(i),
						    a = n.getModel("label.normal"),
						    o = n.getModel("label.emphasis"),
						    r = p.getItemVisual(i, "color");t.useStyle(l.defaults(n.getModel("itemStyle.normal").getItemStyle(), { fill: d.modifyAlpha(r, .4), stroke: r })), t.hoverStyle = n.getModel("itemStyle.normal").getItemStyle();var s = p.getName(i) || "",
						    u = r || t.style.fill;a.getShallow("show") ? (h.setText(t.style, a, u), t.style.text = l.retrieve(e.getFormattedLabel(i, "normal"), s)) : t.style.text = "", o.getShallow("show") ? (h.setText(t.hoverStyle, o, u), t.hoverStyle.text = l.retrieve(e.getFormattedLabel(i, "emphasis"), s)) : t.hoverStyle.text = "", h.setHoverStyle(t, {}), t.dataModel = e;
					}), f.__data = p, f.group.silent = e.get("silent") || t.get("silent");
				} });
		}, function (t, e, i) {
			t.exports = i(79).extend({ type: "markLine", defaultOption: { zlevel: 0, z: 5, symbol: ["circle", "arrow"], symbolSize: [8, 16], precision: 2, tooltip: { trigger: "item" }, label: { normal: { show: !0, position: "end" }, emphasis: { show: !0 } }, lineStyle: { normal: { type: "dashed" }, emphasis: { width: 3 } }, animationEasing: "linear" } });
		}, function (t, e, i) {
			function n(t) {
				return !isNaN(t) && !isFinite(t);
			}function a(t, e, i, a) {
				var o = 1 - t,
				    r = a.dimensions[t];return n(e[o]) && n(i[o]) && e[t] === i[t] && a.getAxis(r).containData(e[t]);
			}function o(t, e) {
				if ("cartesian2d" === t.type) {
					var i = e[0].coord,
					    n = e[1].coord;if (i && n && (a(1, i, n, t) || a(0, i, n, t))) return !0;
				}return h.dataFilter(t, e[0]) && h.dataFilter(t, e[1]);
			}function r(t, e, i, a, o) {
				var r,
				    s = a.coordinateSystem,
				    l = t.getItemModel(e),
				    u = c.parsePercent(l.get("x"), o.getWidth()),
				    h = c.parsePercent(l.get("y"), o.getHeight());if (isNaN(u) || isNaN(h)) {
					if (a.getMarkerPosition) r = a.getMarkerPosition(t.getValues(t.dimensions, e));else {
						var d = s.dimensions,
						    f = t.get(d[0], e),
						    p = t.get(d[1], e);r = s.dataToPoint([f, p]);
					}if ("cartesian2d" === s.type) {
						var g = s.getAxis("x"),
						    m = s.getAxis("y"),
						    d = s.dimensions;n(t.get(d[0], e)) ? r[0] = g.toGlobalCoord(g.getExtent()[i ? 0 : 1]) : n(t.get(d[1], e)) && (r[1] = m.toGlobalCoord(m.getExtent()[i ? 0 : 1]));
					}isNaN(u) || (r[0] = u), isNaN(h) || (r[1] = h);
				} else r = [u, h];t.setItemLayout(e, r);
			}function s(t, e, i) {
				var n;n = t ? l.map(t && t.dimensions, function (t) {
					var i = e.getData().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};return i.name = t, i;
				}) : [{ name: "value", type: "float" }];var a = new u(n, i),
				    r = new u(n, i),
				    s = new u([], i),
				    c = l.map(i.get("data"), l.curry(f, e, t, i));t && (c = l.filter(c, l.curry(o, t)));var d = t ? h.dimValueGetter : function (t) {
					return t.value;
				};return a.initData(l.map(c, function (t) {
					return t[0];
				}), null, d), r.initData(l.map(c, function (t) {
					return t[1];
				}), null, d), s.initData(l.map(c, function (t) {
					return t[2];
				})), s.hasItemOption = !0, { from: a, to: r, line: s };
			}var l = i(1),
			    u = i(14),
			    c = i(4),
			    h = i(81),
			    d = i(107),
			    f = function f(t, e, i, n) {
				var a = t.getData(),
				    o = n.type;if (!l.isArray(n) && ("min" === o || "max" === o || "average" === o || null != n.xAxis || null != n.yAxis)) {
					var r, s, u;if (null != n.yAxis || null != n.xAxis) s = null != n.yAxis ? "y" : "x", r = e.getAxis(s), u = l.retrieve(n.yAxis, n.xAxis);else {
						var c = h.getAxisInfo(n, a, e, t);s = c.valueDataDim, r = c.valueAxis, u = h.numCalculate(a, s, o);
					}var d = "x" === s ? 0 : 1,
					    f = 1 - d,
					    p = l.clone(n),
					    g = {};p.type = null, p.coord = [], g.coord = [], p.coord[f] = -(1 / 0), g.coord[f] = 1 / 0;var m = i.get("precision");m >= 0 && "number" == typeof u && (u = +u.toFixed(m)), p.coord[d] = g.coord[d] = u, n = [p, g, { type: o, valueIndex: n.valueIndex, value: u }];
				}return n = [h.dataTransform(t, n[0]), h.dataTransform(t, n[1]), l.extend({}, n[2])], n[2].type = n[2].type || "", l.merge(n[2], n[0]), l.merge(n[2], n[1]), n;
			};i(80).extend({ type: "markLine", updateLayout: function updateLayout(t, e, i) {
					e.eachSeries(function (t) {
						var e = t.markLineModel;if (e) {
							var n = e.getData(),
							    a = e.__from,
							    o = e.__to;a.each(function (e) {
								r(a, e, !0, t, i), r(o, e, !1, t, i);
							}), n.each(function (t) {
								n.setItemLayout(t, [a.getItemLayout(t), o.getItemLayout(t)]);
							}), this.markerGroupMap.get(t.name).updateLayout();
						}
					}, this);
				}, renderSeries: function renderSeries(t, e, i, n) {
					function a(e, i, a) {
						var o = e.getItemModel(i);r(e, i, a, t, n), e.setItemVisual(i, { symbolSize: o.get("symbolSize") || x[a ? 0 : 1], symbol: o.get("symbol", !0) || y[a ? 0 : 1], color: o.get("itemStyle.normal.color") || c.getVisual("color") });
					}var o = t.coordinateSystem,
					    u = t.name,
					    c = t.getData(),
					    h = this.markerGroupMap,
					    f = h.get(u) || h.set(u, new d());this.group.add(f.group);var p = s(o, t, e),
					    g = p.from,
					    m = p.to,
					    v = p.line;e.__from = g, e.__to = m, e.setData(v);var y = e.get("symbol"),
					    x = e.get("symbolSize");l.isArray(y) || (y = [y, y]), "number" == typeof x && (x = [x, x]), p.from.each(function (t) {
						a(g, t, !0), a(m, t, !1);
					}), v.each(function (t) {
						var e = v.getItemModel(t).get("lineStyle.normal.color");v.setItemVisual(t, { color: e || g.getItemVisual(t, "color") }), v.setItemLayout(t, [g.getItemLayout(t), m.getItemLayout(t)]), v.setItemVisual(t, { fromSymbolSize: g.getItemVisual(t, "symbolSize"), fromSymbol: g.getItemVisual(t, "symbol"), toSymbolSize: m.getItemVisual(t, "symbolSize"), toSymbol: m.getItemVisual(t, "symbol") });
					}), f.updateData(v), p.line.eachItemGraphicEl(function (t, i) {
						t.traverse(function (t) {
							t.dataModel = e;
						});
					}), f.__keep = !0, f.group.silent = e.get("silent") || t.get("silent");
				} });
		}, function (t, e, i) {
			t.exports = i(79).extend({ type: "markPoint", defaultOption: { zlevel: 0, z: 5, symbol: "pin", symbolSize: 50, tooltip: { trigger: "item" }, label: { normal: { show: !0, position: "inside" }, emphasis: { show: !0 } }, itemStyle: { normal: { borderWidth: 2 } } } });
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = e.coordinateSystem;t.each(function (a) {
					var o,
					    r = t.getItemModel(a),
					    l = s.parsePercent(r.get("x"), i.getWidth()),
					    u = s.parsePercent(r.get("y"), i.getHeight());if (isNaN(l) || isNaN(u)) {
						if (e.getMarkerPosition) o = e.getMarkerPosition(t.getValues(t.dimensions, a));else if (n) {
							var c = t.get(n.dimensions[0], a),
							    h = t.get(n.dimensions[1], a);o = n.dataToPoint([c, h]);
						}
					} else o = [l, u];isNaN(l) || (o[0] = l), isNaN(u) || (o[1] = u), t.setItemLayout(a, o);
				});
			}function a(t, e, i) {
				var n;n = t ? r.map(t && t.dimensions, function (t) {
					var i = e.getData().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};return i.name = t, i;
				}) : [{ name: "value", type: "float" }];var a = new l(n, i),
				    o = r.map(i.get("data"), r.curry(u.dataTransform, e));return t && (o = r.filter(o, r.curry(u.dataFilter, t))), a.initData(o, null, t ? u.dimValueGetter : function (t) {
					return t.value;
				}), a;
			}var o = i(44),
			    r = i(1),
			    s = i(4),
			    l = i(14),
			    u = i(81);i(80).extend({ type: "markPoint", updateLayout: function updateLayout(t, e, i) {
					e.eachSeries(function (t) {
						var e = t.markPointModel;e && (n(e.getData(), t, i), this.markerGroupMap.get(t.name).updateLayout(e));
					}, this);
				}, renderSeries: function renderSeries(t, e, i, r) {
					var s = t.coordinateSystem,
					    l = t.name,
					    u = t.getData(),
					    c = this.markerGroupMap,
					    h = c.get(l) || c.set(l, new o()),
					    d = a(s, t, e);e.setData(d), n(e.getData(), t, r), d.each(function (t) {
						var i = d.getItemModel(t),
						    n = i.getShallow("symbolSize");"function" == typeof n && (n = n(e.getRawValue(t), e.getDataParams(t))), d.setItemVisual(t, { symbolSize: n, color: i.get("itemStyle.normal.color") || u.getVisual("color"), symbol: i.getShallow("symbol") });
					}), h.updateData(d), this.group.add(h.group), d.eachItemGraphicEl(function (t) {
						t.traverse(function (t) {
							t.dataModel = e;
						});
					}), h.__keep = !0, h.group.silent = e.get("silent") || t.get("silent");
				} });
		}, function (t, e, i) {
			"use strict";
			var n = i(2),
			    a = i(3),
			    o = i(12);n.extendComponentModel({ type: "title", layoutMode: { type: "box", ignoreSize: !0 }, defaultOption: { zlevel: 0, z: 6, show: !0, text: "", target: "blank", subtext: "", subtarget: "blank", left: 0, top: 0, backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, textStyle: { fontSize: 18, fontWeight: "bolder", color: "#333" }, subtextStyle: { color: "#aaa" } } }), n.extendComponentView({ type: "title", render: function render(t, e, i) {
					if (this.group.removeAll(), t.get("show")) {
						var n = this.group,
						    r = t.getModel("textStyle"),
						    s = t.getModel("subtextStyle"),
						    l = t.get("textAlign"),
						    u = t.get("textBaseline"),
						    c = new a.Text({ style: { text: t.get("text"), textFont: r.getFont(), fill: r.getTextColor() }, z2: 10 }),
						    h = c.getBoundingRect(),
						    d = t.get("subtext"),
						    f = new a.Text({ style: { text: d, textFont: s.getFont(), fill: s.getTextColor(), y: h.height + t.get("itemGap"), textBaseline: "top" }, z2: 10 }),
						    p = t.get("link"),
						    g = t.get("sublink");c.silent = !p, f.silent = !g, p && c.on("click", function () {
							window.open(p, "_" + t.get("target"));
						}), g && f.on("click", function () {
							window.open(g, "_" + t.get("subtarget"));
						}), n.add(c), d && n.add(f);var m = n.getBoundingRect(),
						    v = t.getBoxLayoutParams();v.width = m.width, v.height = m.height;var y = o.getLayoutRect(v, { width: i.getWidth(), height: i.getHeight() }, t.get("padding"));l || (l = t.get("left") || t.get("right"), "middle" === l && (l = "center"), "right" === l ? y.x += y.width : "center" === l && (y.x += y.width / 2)), u || (u = t.get("top") || t.get("bottom"), "center" === u && (u = "middle"), "bottom" === u ? y.y += y.height : "middle" === u && (y.y += y.height / 2), u = u || "top"), n.attr("position", [y.x, y.y]);var x = { textAlign: l, textVerticalAlign: u };c.setStyle(x), f.setStyle(x), m = n.getBoundingRect();var _ = y.margin,
						    b = t.getItemStyle(["color", "opacity"]);b.fill = t.get("backgroundColor");var w = new a.Rect({ shape: { x: m.x - _[3], y: m.y - _[0], width: m.width + _[1] + _[3], height: m.height + _[0] + _[2] }, style: b, silent: !0 });a.subPixelOptimizeRect(w), n.add(w);
					}
				} });
		}, function (t, e, i) {
			i(225), i(226), i(231), i(229), i(227), i(228), i(230);
		}, function (t, e, i) {
			var n = i(29),
			    a = i(1),
			    o = i(2).extendComponentModel({ type: "toolbox", layoutMode: { type: "box", ignoreSize: !0 }, mergeDefaultAndTheme: function mergeDefaultAndTheme(t) {
					o.superApply(this, "mergeDefaultAndTheme", arguments), a.each(this.option.feature, function (t, e) {
						var i = n.get(e);i && a.merge(t, i.defaultOption);
					});
				}, defaultOption: { show: !0, z: 6, zlevel: 0, orient: "horizontal", left: "right", top: "top", backgroundColor: "transparent", borderColor: "#ccc", borderWidth: 0, padding: 5, itemSize: 15, itemGap: 8, showTitle: !0, iconStyle: { normal: { borderColor: "#666", color: "none" }, emphasis: { borderColor: "#3E98C5" } } } });t.exports = o;
		}, function (t, e, i) {
			(function (e) {
				function n(t) {
					return 0 === t.indexOf("my");
				}var a = i(29),
				    o = i(1),
				    r = i(3),
				    s = i(10),
				    l = i(48),
				    u = i(130),
				    c = i(16);t.exports = i(2).extendComponentView({ type: "toolbox", render: function render(t, e, i, h) {
						function d(o, r) {
							var l,
							    u = y[o],
							    c = y[r],
							    d = m[u],
							    p = new s(d, t, t.ecModel);if (u && !c) {
								if (n(u)) l = { model: p, onclick: p.option.onclick, featureName: u };else {
									var g = a.get(u);if (!g) return;l = new g(p, e, i);
								}v[u] = l;
							} else {
								if (l = v[c], !l) return;l.model = p, l.ecModel = e, l.api = i;
							}return !u && c ? void (l.dispose && l.dispose(e, i)) : !p.get("show") || l.unusable ? void (l.remove && l.remove(e, i)) : (f(p, l, u), p.setIconStatus = function (t, e) {
								var i = this.option,
								    n = this.iconPaths;i.iconStatus = i.iconStatus || {}, i.iconStatus[t] = e, n[t] && n[t].trigger(e);
							}, void (l.render && l.render(p, e, i, h)));
						}function f(n, a, s) {
							var l = n.getModel("iconStyle"),
							    u = a.getIcons ? a.getIcons() : n.get("icon"),
							    c = n.get("title") || {};if ("string" == typeof u) {
								var h = u,
								    d = c;u = {}, c = {}, u[s] = h, c[s] = d;
							}var f = n.iconPaths = {};o.each(u, function (s, u) {
								var h = l.getModel("normal").getItemStyle(),
								    d = l.getModel("emphasis").getItemStyle(),
								    m = { x: -g / 2, y: -g / 2, width: g, height: g },
								    v = 0 === s.indexOf("image://") ? (m.image = s.slice(8), new r.Image({ style: m })) : r.makePath(s.replace("path://", ""), { style: h, hoverStyle: d, rectHover: !0 }, m, "center");r.setHoverStyle(v), t.get("showTitle") && (v.__title = c[u], v.on("mouseover", function () {
									var t = l.getModel("emphasis").getItemStyle();v.setStyle({ text: c[u], textPosition: t.textPosition || "bottom", textFill: t.fill || t.stroke || "#000", textAlign: t.textAlign || "center" });
								}).on("mouseout", function () {
									v.setStyle({ textFill: null });
								})), v.trigger(n.get("iconStatus." + u) || "normal"), p.add(v), v.on("click", o.bind(a.onclick, a, e, i, u)), f[u] = v;
							});
						}var p = this.group;if (p.removeAll(), t.get("show")) {
							var g = +t.get("itemSize"),
							    m = t.get("feature") || {},
							    v = this._features || (this._features = {}),
							    y = [];o.each(m, function (t, e) {
								y.push(e);
							}), new l(this._featureNames || [], y).add(d).update(d).remove(o.curry(d, null)).execute(), this._featureNames = y, u.layout(p, t, i), u.addBackground(p, t), p.eachChild(function (t) {
								var e = t.__title,
								    n = t.hoverStyle;if (n && e) {
									var a = c.getBoundingRect(e, n.font),
									    o = t.position[0] + p.position[0],
									    r = t.position[1] + p.position[1] + g,
									    s = !1;r + a.height > i.getHeight() && (n.textPosition = "top", s = !0);var l = s ? -5 - a.height : g + 8;o + a.width / 2 > i.getWidth() ? (n.textPosition = ["100%", l], n.textAlign = "right") : o - a.width / 2 < 0 && (n.textPosition = [0, l], n.textAlign = "left");
								}
							});
						}
					}, updateView: function updateView(t, e, i, n) {
						o.each(this._features, function (t) {
							t.updateView && t.updateView(t.model, e, i, n);
						});
					}, updateLayout: function updateLayout(t, e, i, n) {
						o.each(this._features, function (t) {
							t.updateLayout && t.updateLayout(t.model, e, i, n);
						});
					}, remove: function remove(t, e) {
						o.each(this._features, function (i) {
							i.remove && i.remove(t, e);
						}), this.group.removeAll();
					}, dispose: function dispose(t, e) {
						o.each(this._features, function (i) {
							i.dispose && i.dispose(t, e);
						});
					} });
			}).call(e, i(188));
		}, function (t, e, i) {
			function n(t) {
				var e = {},
				    i = [],
				    n = [];return t.eachRawSeries(function (t) {
					var a = t.coordinateSystem;if (!a || "cartesian2d" !== a.type && "polar" !== a.type) i.push(t);else {
						var o = a.getBaseAxis();if ("category" === o.type) {
							var r = o.dim + "_" + o.index;e[r] || (e[r] = { categoryAxis: o, valueAxis: a.getOtherAxis(o), series: [] }, n.push({ axisDim: o.dim, axisIndex: o.index })), e[r].series.push(t);
						} else i.push(t);
					}
				}), { seriesGroupByCategoryAxis: e, other: i, meta: n };
			}function a(t) {
				var e = [];return p.each(t, function (t, i) {
					var n = t.categoryAxis,
					    a = t.valueAxis,
					    o = a.dim,
					    r = [" "].concat(p.map(t.series, function (t) {
						return t.name;
					})),
					    s = [n.model.getCategories()];p.each(t.series, function (t) {
						s.push(t.getRawData().mapArray(o, function (t) {
							return t;
						}));
					});for (var l = [r.join(v)], u = 0; u < s[0].length; u++) {
						for (var c = [], h = 0; h < s.length; h++) {
							c.push(s[h][u]);
						}l.push(c.join(v));
					}e.push(l.join("\n"));
				}), e.join("\n\n" + m + "\n\n");
			}function o(t) {
				return p.map(t, function (t) {
					var e = t.getRawData(),
					    i = [t.name],
					    n = [];return e.each(e.dimensions, function () {
						for (var t = arguments.length, a = arguments[t - 1], o = e.getName(a), r = 0; r < t - 1; r++) {
							n[r] = arguments[r];
						}i.push((o ? o + v : "") + n.join(v));
					}), i.join("\n");
				}).join("\n\n" + m + "\n\n");
			}function r(t) {
				var e = n(t);return { value: p.filter([a(e.seriesGroupByCategoryAxis), o(e.other)], function (t) {
						return t.replace(/[\n\t\s]/g, "");
					}).join("\n\n" + m + "\n\n"), meta: e.meta };
			}function s(t) {
				return t.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
			}function l(t) {
				var e = t.slice(0, t.indexOf("\n"));if (e.indexOf(v) >= 0) return !0;
			}function u(t) {
				for (var e = t.split(/\n+/g), i = s(e.shift()).split(y), n = [], a = p.map(i, function (t) {
					return { name: t, data: [] };
				}), o = 0; o < e.length; o++) {
					var r = s(e[o]).split(y);n.push(r.shift());for (var l = 0; l < r.length; l++) {
						a[l] && (a[l].data[o] = r[l]);
					}
				}return { series: a, categories: n };
			}function c(t) {
				for (var e = t.split(/\n+/g), i = s(e.shift()), n = [], a = 0; a < e.length; a++) {
					var o,
					    r = s(e[a]).split(y),
					    l = "",
					    u = !1;isNaN(r[0]) ? (u = !0, l = r[0], r = r.slice(1), n[a] = { name: l, value: [] }, o = n[a].value) : o = n[a] = [];for (var c = 0; c < r.length; c++) {
						o.push(+r[c]);
					}1 === o.length && (u ? n[a].value = o[0] : n[a] = o[0]);
				}return { name: i, data: n };
			}function h(t, e) {
				var i = t.split(new RegExp("\n*" + m + "\n*", "g")),
				    n = { series: [] };return p.each(i, function (t, i) {
					if (l(t)) {
						var a = u(t),
						    o = e[i],
						    r = o.axisDim + "Axis";o && (n[r] = n[r] || [], n[r][o.axisIndex] = { data: a.categories }, n.series = n.series.concat(a.series));
					} else {
						var a = c(t);n.series.push(a);
					}
				}), n;
			}function d(t) {
				this._dom = null, this.model = t;
			}function f(t, e) {
				return p.map(t, function (t, i) {
					var n = e && e[i];return p.isObject(n) && !p.isArray(n) ? (p.isObject(t) && !p.isArray(t) && (t = t.value), p.defaults({ value: t }, n)) : t;
				});
			}var p = i(1),
			    g = i(21),
			    m = new Array(60).join("-"),
			    v = "\t",
			    y = new RegExp("[" + v + "]+", "g");d.defaultOption = { show: !0, readOnly: !1, optionToContent: null, contentToOption: null, icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28", title: "", lang: ["", "", ""], backgroundColor: "#fff", textColor: "#000", textareaColor: "#fff", textareaBorderColor: "#333", buttonColor: "#c23531", buttonTextColor: "#fff" }, d.prototype.onclick = function (t, e) {
				function i() {
					n.removeChild(o), M._dom = null;
				}var n = e.getDom(),
				    a = this.model;this._dom && n.removeChild(this._dom);var o = document.createElement("div");o.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;", o.style.backgroundColor = a.get("backgroundColor") || "#fff";var s = document.createElement("h4"),
				    l = a.get("lang") || [];s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin: 10px 20px;", s.style.color = a.get("textColor");var u = document.createElement("div"),
				    c = document.createElement("textarea");u.style.cssText = "display:block;width:100%;overflow:auto;";var d = a.get("optionToContent"),
				    f = a.get("contentToOption"),
				    m = r(t);if ("function" == typeof d) {
					var y = d(e.getOption());"string" == typeof y ? u.innerHTML = y : p.isDom(y) && u.appendChild(y);
				} else u.appendChild(c), c.readOnly = a.get("readOnly"), c.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;", c.style.color = a.get("textColor"), c.style.borderColor = a.get("textareaBorderColor"), c.style.backgroundColor = a.get("textareaColor"), c.value = m.value;var x = m.meta,
				    _ = document.createElement("div");_.style.cssText = "position:absolute;bottom:0;left:0;right:0;";var b = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px",
				    w = document.createElement("div"),
				    S = document.createElement("div");b += ";background-color:" + a.get("buttonColor"), b += ";color:" + a.get("buttonTextColor");var M = this;g.addEventListener(w, "click", i), g.addEventListener(S, "click", function () {
					var t;try {
						t = "function" == typeof f ? f(u, e.getOption()) : h(c.value, x);
					} catch (n) {
						throw i(), new Error("Data view format error " + n);
					}t && e.dispatchAction({ type: "changeDataView", newOption: t }), i();
				}), w.innerHTML = l[1], S.innerHTML = l[2], S.style.cssText = b, w.style.cssText = b, !a.get("readOnly") && _.appendChild(S), _.appendChild(w), g.addEventListener(c, "keydown", function (t) {
					if (9 === (t.keyCode || t.which)) {
						var e = this.value,
						    i = this.selectionStart,
						    n = this.selectionEnd;this.value = e.substring(0, i) + v + e.substring(n), this.selectionStart = this.selectionEnd = i + 1, g.stop(t);
					}
				}), o.appendChild(s), o.appendChild(u), o.appendChild(_), u.style.height = n.clientHeight - 80 + "px", n.appendChild(o), this._dom = o;
			}, d.prototype.remove = function (t, e) {
				this._dom && e.getDom().removeChild(this._dom);
			}, d.prototype.dispose = function (t, e) {
				this.remove(t, e);
			}, i(29).register("dataView", d), i(2).registerAction({ type: "changeDataView", event: "dataViewChanged", update: "prepareAndUpdate" }, function (t, e) {
				var i = [];p.each(t.newOption.series, function (t) {
					var n = e.getSeriesByName(t.name)[0];if (n) {
						var a = n.get("data");i.push({ name: t.name, data: f(t.data, a) });
					} else i.push(p.extend({ type: "scatter" }, t));
				}), e.mergeOption(p.defaults({ series: i }, t.newOption));
			}), t.exports = d;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				(this._brushController = new l(i.getZr())).on("brush", s.bind(this._onBrush, this)).mount(), this._isZoomActive;
			}function a(t) {
				var e = {};return s.each(["xAxisIndex", "yAxisIndex"], function (i) {
					e[i] = t[i], null == e[i] && (e[i] = "all"), (e[i] === !1 || "none" === e[i]) && (e[i] = []);
				}), e;
			}function o(t, e) {
				t.setIconStatus("back", c.count(e) > 1 ? "emphasis" : "normal");
			}function r(t, e, i, n, o) {
				var r = i._isZoomActive;n && "takeGlobalCursor" === n.type && (r = "dataZoomSelect" === n.key && n.dataZoomSelectActive), i._isZoomActive = r, t.setIconStatus("zoom", r ? "emphasis" : "normal");var s = new u(a(t.option), e, { include: ["grid"] });i._brushController.setPanels(s.makePanelOpts(o, function (t) {
					return t.xAxisDeclared && !t.yAxisDeclared ? "lineX" : !t.xAxisDeclared && t.yAxisDeclared ? "lineY" : "rect";
				})).enableBrush(!!r && { brushType: "auto", brushStyle: { lineWidth: 0, fill: "rgba(0,0,0,0.2)" } });
			}var s = i(1),
			    l = i(127),
			    u = i(184),
			    c = i(125),
			    h = i(56),
			    d = s.each;i(206);var f = "\0_ec_\0toolbox-dataZoom_";n.defaultOption = { show: !0, icon: { zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1", back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26" }, title: { zoom: "", back: "" } };var p = n.prototype;p.render = function (t, e, i, n) {
				this.model = t, this.ecModel = e, this.api = i, r(t, e, this, n, i), o(t, e);
			}, p.onclick = function (t, e, i) {
				g[i].call(this);
			}, p.remove = function (t, e) {
				this._brushController.unmount();
			}, p.dispose = function (t, e) {
				this._brushController.dispose();
			};var g = { zoom: function zoom() {
					var t = !this._isZoomActive;this.api.dispatchAction({ type: "takeGlobalCursor", key: "dataZoomSelect", dataZoomSelectActive: t });
				}, back: function back() {
					this._dispatchZoomAction(c.pop(this.ecModel));
				} };p._onBrush = function (t, e) {
				function i(t, e, i) {
					var a = e.getAxis(t),
					    s = a.model,
					    l = n(t, s, r),
					    u = l.findRepresentativeAxisProxy(s).getMinMaxSpan();null == u.minValueSpan && null == u.maxValueSpan || (i = h(0, i.slice(), a.scale.getExtent(), 0, u.minValueSpan, u.maxValueSpan)), l && (o[l.id] = { dataZoomId: l.id, startValue: i[0], endValue: i[1] });
				}function n(t, e, i) {
					var n;return i.eachComponent({ mainType: "dataZoom", subType: "select" }, function (i) {
						var a = i.getAxisModel(t, e.componentIndex);a && (n = i);
					}), n;
				}if (e.isEnd && t.length) {
					var o = {},
					    r = this.ecModel;this._brushController.updateCovers([]);var s = new u(a(this.model.option), r, { include: ["grid"] });s.matchOutputRanges(t, r, function (t, e, n) {
						if ("cartesian2d" === n.type) {
							var a = t.brushType;"rect" === a ? (i("x", n, e[0]), i("y", n, e[1])) : i({ lineX: "x", lineY: "y" }[a], n, e);
						}
					}), c.push(r, o), this._dispatchZoomAction(o);
				}
			}, p._dispatchZoomAction = function (t) {
				var e = [];d(t, function (t, i) {
					e.push(s.clone(t));
				}), e.length && this.api.dispatchAction({ type: "dataZoom", from: this.uid, batch: e });
			}, i(29).register("dataZoom", n), i(2).registerPreprocessor(function (t) {
				function e(t, e) {
					if (e) {
						var a = t + "Index",
						    o = e[a];null == o || "all" == o || s.isArray(o) || (o = o === !1 || "none" === o ? [] : [o]), i(t, function (e, i) {
							if (null == o || "all" == o || s.indexOf(o, i) !== -1) {
								var r = { type: "select", $fromToolbox: !0, id: f + t + i };r[a] = i, n.push(r);
							}
						});
					}
				}function i(e, i) {
					var n = t[e];s.isArray(n) || (n = n ? [n] : []), d(n, i);
				}if (t) {
					var n = t.dataZoom || (t.dataZoom = []);s.isArray(n) || (t.dataZoom = n = [n]);var a = t.toolbox;if (a && (s.isArray(a) && (a = a[0]), a && a.feature)) {
						var o = a.feature.dataZoom;e("xAxis", o), e("yAxis", o);
					}
				}
			}), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				this.model = t;
			}var a = i(1);n.defaultOption = { show: !0, type: [], icon: { line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4", bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7", stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z", tiled: "M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z" }, title: { line: "", bar: "", stack: "", tiled: "" }, option: {}, seriesIndex: {} };var o = n.prototype;o.getIcons = function () {
				var t = this.model,
				    e = t.get("icon"),
				    i = {};return a.each(t.get("type"), function (t) {
					e[t] && (i[t] = e[t]);
				}), i;
			};var r = { line: function line(t, e, i, n) {
					if ("bar" === t) return a.merge({ id: e, type: "line", data: i.get("data"), stack: i.get("stack"), markPoint: i.get("markPoint"), markLine: i.get("markLine") }, n.get("option.line") || {}, !0);
				}, bar: function bar(t, e, i, n) {
					if ("line" === t) return a.merge({ id: e, type: "bar", data: i.get("data"), stack: i.get("stack"), markPoint: i.get("markPoint"), markLine: i.get("markLine") }, n.get("option.bar") || {}, !0);
				}, stack: function stack(t, e, i, n) {
					if ("line" === t || "bar" === t) return a.merge({ id: e, stack: "__ec_magicType_stack__" }, n.get("option.stack") || {}, !0);
				}, tiled: function tiled(t, e, i, n) {
					if ("line" === t || "bar" === t) return a.merge({ id: e, stack: "" }, n.get("option.tiled") || {}, !0);
				} },
			    s = [["line", "bar"], ["stack", "tiled"]];o.onclick = function (t, e, i) {
				var n = this.model,
				    o = n.get("seriesIndex." + i);if (r[i]) {
					var l = { series: [] },
					    u = function u(e) {
						var o = e.subType,
						    s = e.id,
						    u = r[i](o, s, e, n);u && (a.defaults(u, e.option), l.series.push(u));var c = e.coordinateSystem;if (c && "cartesian2d" === c.type && ("line" === i || "bar" === i)) {
							var h = c.getAxesByScale("ordinal")[0];if (h) {
								var d = h.dim,
								    f = d + "Axis",
								    p = t.queryComponents({ mainType: f, index: e.get(name + "Index"), id: e.get(name + "Id") })[0],
								    g = p.componentIndex;l[f] = l[f] || [];for (var m = 0; m <= g; m++) {
									l[f][g] = l[f][g] || {};
								}l[f][g].boundaryGap = "bar" === i;
							}
						}
					};a.each(s, function (t) {
						a.indexOf(t, i) >= 0 && a.each(t, function (t) {
							n.setIconStatus(t, "normal");
						});
					}), n.setIconStatus(i, "emphasis"), t.eachComponent({ mainType: "series", query: null == o ? null : { seriesIndex: o } }, u), e.dispatchAction({ type: "changeMagicType", currentType: i, newOption: l });
				}
			};var l = i(2);l.registerAction({ type: "changeMagicType", event: "magicTypeChanged", update: "prepareAndUpdate" }, function (t, e) {
				e.mergeOption(t.newOption);
			}), i(29).register("magicType", n), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				this.model = t;
			}var a = i(125);n.defaultOption = { show: !0, icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5", title: "" };var o = n.prototype;o.onclick = function (t, e, i) {
				a.clear(t), e.dispatchAction({ type: "restore", from: this.uid });
			}, i(29).register("restore", n), i(2).registerAction({ type: "restore", event: "restore", update: "prepareAndUpdate" }, function (t, e) {
				e.resetOption("recreate");
			}), t.exports = n;
		}, function (t, e, i) {
			function n(t) {
				this.model = t;
			}var a = i(9);n.defaultOption = { show: !0, icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0", title: "", type: "png", name: "", excludeComponents: ["toolbox"], pixelRatio: 1, lang: [""] }, n.prototype.unusable = !a.canvasSupported;var o = n.prototype;o.onclick = function (t, e) {
				var i = this.model,
				    n = i.get("name") || t.get("title.0.text") || "echarts",
				    o = document.createElement("a"),
				    r = i.get("type", !0) || "png";o.download = n + "." + r, o.target = "_blank";var s = e.getConnectedDataURL({ type: r, backgroundColor: i.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff", excludeComponents: i.get("excludeComponents"), pixelRatio: i.get("pixelRatio") });if (o.href = s, "function" != typeof MouseEvent || a.browser.ie || a.browser.edge) {
					var l = i.get("lang"),
					    u = '<body style="margin:0;"><img src="' + s + '" style="max-width:100%;" title="' + (l && l[0] || "") + '" /></body>',
					    c = window.open();c.document.write(u);
				} else {
					var h = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !1 });o.dispatchEvent(h);
				}
			}, i(29).register("saveAsImage", n), t.exports = n;
		}, function (t, e, i) {
			i(55), i(234), i(235), i(2).registerAction({ type: "showTip", event: "showTip", update: "tooltip:manuallyShowTip" }, function () {}), i(2).registerAction({ type: "hideTip", event: "hideTip", update: "tooltip:manuallyHideTip" }, function () {});
		}, function (t, e, i) {
			function n(t) {
				var e = "cubic-bezier(0.23, 1, 0.32, 1)",
				    i = "left " + t + "s " + e + ",top " + t + "s " + e;return s.map(p, function (t) {
					return t + "transition:" + i;
				}).join(";");
			}function a(t) {
				var e = [],
				    i = t.get("fontSize"),
				    n = t.getTextColor();return n && e.push("color:" + n), e.push("font:" + t.getFont()), i && e.push("line-height:" + Math.round(3 * i / 2) + "px"), h(["decoration", "align"], function (i) {
					var n = t.get(i);n && e.push("text-" + i + ":" + n);
				}), e.join(";");
			}function o(t) {
				var e = [],
				    i = t.get("transitionDuration"),
				    o = t.get("backgroundColor"),
				    r = t.getModel("textStyle"),
				    s = t.get("padding");return i && e.push(n(i)), o && (f.canvasSupported ? e.push("background-Color:" + o) : (e.push("background-Color:#" + l.toHex(o)), e.push("filter:alpha(opacity=70)"))), h(["width", "color", "radius"], function (i) {
					var n = "border-" + i,
					    a = d(n),
					    o = t.get(a);null != o && e.push(n + ":" + o + ("color" === i ? "" : "px"));
				}), e.push(a(r)), null != s && e.push("padding:" + c.normalizeCssArray(s).join("px ") + "px"), e.join(";") + ";";
			}function r(t, e) {
				var i = document.createElement("div"),
				    n = this._zr = e.getZr();this.el = i, this._x = e.getWidth() / 2, this._y = e.getHeight() / 2, t.appendChild(i), this._container = t, this._show = !1, this._hideTimeout;var a = this;i.onmouseenter = function () {
					a._enterable && (clearTimeout(a._hideTimeout), a._show = !0), a._inContent = !0;
				}, i.onmousemove = function (e) {
					if (e = e || window.event, !a._enterable) {
						var i = n.handler;u.normalizeEvent(t, e, !0), i.dispatch("mousemove", e);
					}
				}, i.onmouseleave = function () {
					a._enterable && a._show && a.hideLater(a._hideDelay), a._inContent = !1;
				};
			}var s = i(1),
			    l = i(22),
			    u = i(21),
			    c = i(7),
			    h = s.each,
			    d = c.toCamelCase,
			    f = i(9),
			    p = ["", "-webkit-", "-moz-", "-o-"],
			    g = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";r.prototype = { constructor: r, _enterable: !0, update: function update() {
					var t = this._container,
					    e = t.currentStyle || document.defaultView.getComputedStyle(t),
					    i = t.style;"absolute" !== i.position && "absolute" !== e.position && (i.position = "relative");
				}, show: function show(t) {
					clearTimeout(this._hideTimeout);var e = this.el;e.style.cssText = g + o(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""), e.style.display = e.innerHTML ? "block" : "none", this._show = !0;
				}, setContent: function setContent(t) {
					this.el.innerHTML = null == t ? "" : t;
				}, setEnterable: function setEnterable(t) {
					this._enterable = t;
				}, getSize: function getSize() {
					var t = this.el;return [t.clientWidth, t.clientHeight];
				}, moveTo: function moveTo(t, e) {
					var i,
					    n = this._zr;n && n.painter && (i = n.painter.getViewportRoot()) && (t += i.offsetLeft || 0, e += i.offsetTop || 0);var a = this.el.style;a.left = t + "px", a.top = e + "px", this._x = t, this._y = e;
				}, hide: function hide() {
					this.el.style.display = "none", this._show = !1;
				}, hideLater: function hideLater(t) {
					!this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(s.bind(this.hide, this), t)) : this.hide());
				}, isShow: function isShow() {
					return this._show;
				} }, t.exports = r;
		}, function (t, e, i) {
			i(2).extendComponentModel({ type: "tooltip", dependencies: ["axisPointer"], defaultOption: { zlevel: 0, z: 8, show: !0, showContent: !0, trigger: "item", triggerOn: "mousemove|click", alwaysShowContent: !1, displayMode: "single", confine: !1, showDelay: 0, hideDelay: 100, transitionDuration: .4, enterable: !1, backgroundColor: "rgba(50,50,50,0.7)", borderColor: "#333", borderRadius: 4, borderWidth: 0, padding: 5, extraCssText: "", axisPointer: { type: "line", axis: "auto", animation: "auto", animationDurationUpdate: 200, animationEasingUpdate: "exponentialOut", crossStyle: { color: "#999", width: 1, type: "dashed", textStyle: {} } }, textStyle: { color: "#fff", fontSize: 14 } } });
		}, function (t, e, i) {
			function n(t) {
				for (var e = t.pop(); t.length;) {
					var i = t.pop();i && (i instanceof v && (i = i.get("tooltip", !0)), "string" == typeof i && (i = { formatter: i }), e = new v(i, e, e.ecModel));
				}return e;
			}function a(t, e) {
				return t.dispatchAction || c.bind(e.dispatchAction, e);
			}function o(t, e, i, n, a, o, r) {
				var s = i.clientWidth,
				    l = i.clientHeight;return null != o && (t + s + o > n ? t -= s + o : t += o), null != r && (e + l + r > a ? e -= l + r : e += r), [t, e];
			}function r(t, e, i, n, a) {
				var o = i.clientWidth,
				    r = i.clientHeight;return t = Math.min(t + o, n) - o, e = Math.min(e + r, a) - r, t = Math.max(t, 0), e = Math.max(e, 0), [t, e];
			}function s(t, e, i) {
				var n = i[0],
				    a = i[1],
				    o = 5,
				    r = 0,
				    s = 0,
				    l = e.width,
				    u = e.height;switch (t) {case "inside":
						r = e.x + l / 2 - n / 2, s = e.y + u / 2 - a / 2;break;case "top":
						r = e.x + l / 2 - n / 2, s = e.y - a - o;break;case "bottom":
						r = e.x + l / 2 - n / 2, s = e.y + u + o;break;case "left":
						r = e.x - n - o, s = e.y + u / 2 - a / 2;break;case "right":
						r = e.x + l + o, s = e.y + u / 2 - a / 2;}return [r, s];
			}function l(t) {
				return "center" === t || "middle" === t;
			}var u = i(233),
			    c = i(1),
			    h = i(7),
			    d = i(4),
			    f = i(3),
			    p = i(121),
			    g = i(12),
			    m = i(9),
			    v = i(10),
			    y = i(122),
			    x = i(18),
			    _ = i(76),
			    b = c.bind,
			    w = c.each,
			    S = d.parsePercent,
			    M = new f.Rect({ shape: { x: -1, y: -1, width: 2, height: 2 } });i(2).extendComponentView({ type: "tooltip", init: function init(t, e) {
					if (!m.node) {
						var i = new u(e.getDom(), e);this._tooltipContent = i;
					}
				}, render: function render(t, e, i) {
					if (!m.node) {
						this.group.removeAll(), this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastDataByCoordSys = null, this._alwaysShowContent = t.get("alwaysShowContent");var n = this._tooltipContent;n.update(), n.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow();
					}
				}, _initGlobalListener: function _initGlobalListener() {
					var t = this._tooltipModel,
					    e = t.get("triggerOn");y.register("itemTooltip", this._api, b(function (t, i, n) {
						"none" !== e && (e.indexOf(t) >= 0 ? this._tryShow(i, n) : "leave" === t && this._hide(n));
					}, this));
				}, _keepShow: function _keepShow() {
					var t = this._tooltipModel,
					    e = this._ecModel,
					    i = this._api;if (null != this._lastX && null != this._lastY && "none" !== t.get("triggerOn")) {
						var n = this;clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function () {
							n.manuallyShowTip(t, e, i, { x: n._lastX, y: n._lastY });
						});
					}
				}, manuallyShowTip: function manuallyShowTip(t, e, i, n) {
					if (n.from !== this.uid && !m.node) {
						var o = a(n, i);this._ticket = "";var r = n.dataByCoordSys;if (n.tooltip && null != n.x && null != n.y) {
							var s = M;s.position = [n.x, n.y], s.update(), s.tooltip = n.tooltip, this._tryShow({ offsetX: n.x, offsetY: n.y, target: s }, o);
						} else if (r) this._tryShow({ offsetX: n.x, offsetY: n.y, position: n.position, event: {}, dataByCoordSys: n.dataByCoordSys, tooltipOption: n.tooltipOption }, o);else if (null != n.seriesIndex) {
							if (this._manuallyAxisShowTip(t, e, i, n)) return;var l = p(n, e),
							    u = l.point[0],
							    c = l.point[1];null != u && null != c && this._tryShow({ offsetX: u, offsetY: c, position: n.position, target: l.el, event: {} }, o);
						} else null != n.x && null != n.y && (i.dispatchAction({ type: "updateAxisPointer", x: n.x, y: n.y }), this._tryShow({ offsetX: n.x, offsetY: n.y, position: n.position, target: i.getZr().findHover(n.x, n.y).target, event: {} }, o));
					}
				}, manuallyHideTip: function manuallyHideTip(t, e, i, n) {
					var o = this._tooltipContent;this._alwaysShowContent || o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = null, n.from !== this.uid && this._hide(a(n, i));
				}, _manuallyAxisShowTip: function _manuallyAxisShowTip(t, e, i, a) {
					var o = a.seriesIndex,
					    r = a.dataIndex,
					    s = e.getComponent("axisPointer").coordSysAxesInfo;if (null != o && null != r && null != s) {
						var l = e.getSeriesByIndex(o);if (l) {
							var u = l.getData(),
							    t = n([u.getItemModel(r), l, (l.coordinateSystem || {}).model, t]);if ("axis" === t.get("trigger")) return i.dispatchAction({ type: "updateAxisPointer", seriesIndex: o, dataIndex: r }), !0;
						}
					}
				}, _tryShow: function _tryShow(t, e) {
					var i = t.target,
					    n = this._tooltipModel;if (n) {
						this._lastX = t.offsetX, this._lastY = t.offsetY;var a = t.dataByCoordSys;a && a.length ? this._showAxisTooltip(a, t) : i && null != i.dataIndex ? (this._lastDataByCoordSys = null, this._showSeriesItemTooltip(t, i, e)) : i && i.tooltip ? (this._lastDataByCoordSys = null, this._showComponentItemTooltip(t, i, e)) : (this._lastDataByCoordSys = null, this._hide(e));
					}
				}, _showOrMove: function _showOrMove(t, e) {
					var i = t.get("showDelay");e = c.bind(e, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(e, i) : e();
				}, _showAxisTooltip: function _showAxisTooltip(t, e) {
					var i = this._ecModel,
					    a = this._tooltipModel,
					    o = [e.offsetX, e.offsetY],
					    r = [],
					    s = [],
					    l = n([e.tooltipOption, a]);w(t, function (t) {
						w(t.dataByAxis, function (t) {
							var e = i.getComponent(t.axisDim + "Axis", t.axisIndex),
							    n = t.value,
							    a = [];if (e && null != n) {
								var o = _.getValueLabel(n, e.axis, i, t.seriesDataIndices, t.valueLabelOpt);c.each(t.seriesDataIndices, function (r) {
									var l = i.getSeriesByIndex(r.seriesIndex),
									    u = r.dataIndexInside,
									    c = l && l.getDataParams(u);c.axisDim = t.axisDim, c.axisIndex = t.axisIndex, c.axisType = t.axisType, c.axisId = t.axisId, c.axisValue = x.getAxisRawValue(e.axis, n), c.axisValueLabel = o, c && (s.push(c), a.push(l.formatTooltip(u, !0)));
								});var l = o;r.push((l ? h.encodeHTML(l) + "<br />" : "") + a.join("<br />"));
							}
						});
					}, this), r.reverse(), r = r.join("<br /><br />");var u = e.position;this._showOrMove(l, function () {
						this._updateContentNotChangedOnAxis(t) ? this._updatePosition(l, u, o[0], o[1], this._tooltipContent, s) : this._showTooltipContent(l, r, s, Math.random(), o[0], o[1], u);
					});
				}, _showSeriesItemTooltip: function _showSeriesItemTooltip(t, e, i) {
					var a = this._ecModel,
					    o = e.seriesIndex,
					    r = a.getSeriesByIndex(o),
					    s = e.dataModel || r,
					    l = e.dataIndex,
					    u = e.dataType,
					    c = s.getData(),
					    h = n([c.getItemModel(l), s, r && (r.coordinateSystem || {}).model, this._tooltipModel]),
					    d = h.get("trigger");if (null == d || "item" === d) {
						var f = s.getDataParams(l, u),
						    p = s.formatTooltip(l, !1, u),
						    g = "item_" + s.name + "_" + l;this._showOrMove(h, function () {
							this._showTooltipContent(h, p, f, g, t.offsetX, t.offsetY, t.position, t.target);
						}), i({ type: "showTip", dataIndexInside: l, dataIndex: c.getRawIndex(l), seriesIndex: o, from: this.uid });
					}
				}, _showComponentItemTooltip: function _showComponentItemTooltip(t, e, i) {
					var n = e.tooltip;if ("string" == typeof n) {
						var a = n;n = { content: a, formatter: a };
					}var o = new v(n, this._tooltipModel, this._ecModel),
					    r = o.get("content"),
					    s = Math.random();this._showOrMove(o, function () {
						this._showTooltipContent(o, r, o.get("formatterParams") || {}, s, t.offsetX, t.offsetY, t.position, e);
					}), i({ type: "showTip", from: this.uid });
				}, _showTooltipContent: function _showTooltipContent(t, e, i, n, a, o, r, s) {
					if (this._ticket = "", t.get("showContent") && t.get("show")) {
						var l = this._tooltipContent,
						    u = t.get("formatter");r = r || t.get("position");var c = e;if (u && "string" == typeof u) c = h.formatTpl(u, i, !0);else if ("function" == typeof u) {
							var d = b(function (e, n) {
								e === this._ticket && (l.setContent(n), this._updatePosition(t, r, a, o, l, i, s));
							}, this);this._ticket = n, c = u(i, n, d);
						}l.setContent(c), l.show(t), this._updatePosition(t, r, a, o, l, i, s);
					}
				}, _updatePosition: function _updatePosition(t, e, i, n, a, u, h) {
					var d = this._api.getWidth(),
					    f = this._api.getHeight();e = e || t.get("position");var p = a.getSize(),
					    m = t.get("align"),
					    v = t.get("verticalAlign"),
					    y = h && h.getBoundingRect().clone();if (h && y.applyTransform(h.transform), "function" == typeof e && (e = e([i, n], u, a.el, y, { viewSize: [d, f], contentSize: p.slice() })), c.isArray(e)) i = S(e[0], d), n = S(e[1], f);else if (c.isObject(e)) {
						e.width = p[0], e.height = p[1];var x = g.getLayoutRect(e, { width: d, height: f });i = x.x, n = x.y, m = null, v = null;
					} else if ("string" == typeof e && h) {
						var _ = s(e, y, p);i = _[0], n = _[1];
					} else {
						var _ = o(i, n, a.el, d, f, m ? null : 20, v ? null : 20);i = _[0], n = _[1];
					}if (m && (i -= l(m) ? p[0] / 2 : "right" === m ? p[0] : 0), v && (n -= l(v) ? p[1] / 2 : "bottom" === v ? p[1] : 0), t.get("confine")) {
						var _ = r(i, n, a.el, d, f);i = _[0], n = _[1];
					}a.moveTo(i, n);
				}, _updateContentNotChangedOnAxis: function _updateContentNotChangedOnAxis(t) {
					var e = this._lastDataByCoordSys,
					    i = !!e && e.length === t.length;return i && w(e, function (e, n) {
						var a = e.dataByAxis || {},
						    o = t[n] || {},
						    r = o.dataByAxis || [];i &= a.length === r.length, i && w(a, function (t, e) {
							var n = r[e] || {},
							    a = t.seriesDataIndices || [],
							    o = n.seriesDataIndices || [];i &= t.value === n.value && t.axisType === n.axisType && t.axisId === n.axisId && a.length === o.length, i && w(a, function (t, e) {
								var n = o[e];i &= t.seriesIndex === n.seriesIndex && t.dataIndex === n.dataIndex;
							});
						});
					}), this._lastDataByCoordSys = t, !!i;
				}, _hide: function _hide(t) {
					this._lastDataByCoordSys = null, t({ type: "hideTip", from: this.uid });
				}, dispose: function dispose(t, e) {
					m.node || (this._tooltipContent.hide(), y.unregister("itemTooltip", e));
				} });
		}, function (t, e, i) {
			function n(t, e) {
				var i = t.get("center"),
				    n = t.get("radius"),
				    a = e.getWidth(),
				    o = e.getHeight(),
				    r = s.parsePercent;this.cx = r(i[0], a), this.cy = r(i[1], o);var l = this.getRadiusAxis(),
				    u = Math.min(a, o) / 2;l.setExtent(0, r(n, u));
			}function a(t, e) {
				var i = this,
				    n = i.getAngleAxis(),
				    a = i.getRadiusAxis();if (n.scale.setExtent(1 / 0, -(1 / 0)), a.scale.setExtent(1 / 0, -(1 / 0)), t.eachSeries(function (t) {
					if (t.coordinateSystem === i) {
						var e = t.getData();a.scale.unionExtentFromData(e, "radius"), n.scale.unionExtentFromData(e, "angle");
					}
				}), u(n.scale, n.model), u(a.scale, a.model), "category" === n.type && !n.onBand) {
					var o = n.getExtent(),
					    r = 360 / n.scale.count();n.inverse ? o[1] += r : o[1] -= r, n.setExtent(o[0], o[1]);
				}
			}function o(t, e) {
				if (t.type = e.get("type"), t.scale = l.createScaleByModel(e), t.onBand = e.get("boundaryGap") && "category" === t.type, "angleAxis" === e.mainType) {
					var i = e.get("startAngle");t.inverse = e.get("inverse") ^ e.get("clockwise"), t.setExtent(i, i + (t.inverse ? -360 : 360));
				}e.axis = t, t.model = e;
			}var r = i(411),
			    s = i(4),
			    l = (i(1), i(18)),
			    u = l.niceScaleExtent;i(412);var c = { dimensions: r.prototype.dimensions, create: function create(t, e) {
					var i = [];return t.eachComponent("polar", function (t, s) {
						var l = new r(s);l.resize = n, l.update = a;var u = l.getRadiusAxis(),
						    c = l.getAngleAxis(),
						    h = t.findAxisModel("radiusAxis"),
						    d = t.findAxisModel("angleAxis");o(u, h), o(c, d), l.resize(t, e), i.push(l), t.coordinateSystem = l, l.model = t;
					}), t.eachSeries(function (e) {
						if ("polar" === e.get("coordinateSystem")) {
							var i = t.queryComponents({ mainType: "polar", index: e.get("polarIndex"), id: e.get("polarId") })[0];e.coordinateSystem = i.coordinateSystem;
						}
					}), i;
				} };i(26).register("polar", c);
		}, function (t, e, i) {
			function n(t) {
				return parseInt(t, 10);
			}function a(t, e) {
				s.initVML(), this.root = t, this.storage = e;var i = document.createElement("div"),
				    n = document.createElement("div");i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", n.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(i), this._vmlRoot = n, this._vmlViewport = i, this.resize();var a = e.delFromStorage,
				    o = e.addToStorage;e.delFromStorage = function (t) {
					a.call(e, t), t && t.onRemove && t.onRemove(n);
				}, e.addToStorage = function (t) {
					t.onAdd && t.onAdd(n), o.call(e, t);
				}, this._firstPaint = !0;
			}function o(t) {
				return function () {
					r('In IE8.0 VML mode painter not support method "' + t + '"');
				};
			}var r = i(52),
			    s = i(182);a.prototype = { constructor: a, getViewportRoot: function getViewportRoot() {
					return this._vmlViewport;
				}, refresh: function refresh() {
					var t = this.storage.getDisplayList(!0, !0);this._paintList(t);
				}, _paintList: function _paintList(t) {
					for (var e = this._vmlRoot, i = 0; i < t.length; i++) {
						var n = t[i];n.invisible || n.ignore ? (n.__alreadyNotVisible || n.onRemove(e), n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e), n.__alreadyNotVisible = !1, n.__dirty && (n.beforeBrush && n.beforeBrush(), (n.brushVML || n.brush).call(n, e), n.afterBrush && n.afterBrush())), n.__dirty = !1;
					}this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1);
				}, resize: function resize(t, e) {
					var t = null == t ? this._getWidth() : t,
					    e = null == e ? this._getHeight() : e;if (this._width != t || this._height != e) {
						this._width = t, this._height = e;var i = this._vmlViewport.style;i.width = t + "px", i.height = e + "px";
					}
				}, dispose: function dispose() {
					this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this.storage = null;
				}, getWidth: function getWidth() {
					return this._width;
				}, getHeight: function getHeight() {
					return this._height;
				}, clear: function clear() {
					this._vmlViewport && this.root.removeChild(this._vmlViewport);
				}, _getWidth: function _getWidth() {
					var t = this.root,
					    e = t.currentStyle;return (t.clientWidth || n(e.width)) - n(e.paddingLeft) - n(e.paddingRight) | 0;
				}, _getHeight: function _getHeight() {
					var t = this.root,
					    e = t.currentStyle;return (t.clientHeight || n(e.height)) - n(e.paddingTop) - n(e.paddingBottom) | 0;
				} };for (var l = ["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], u = 0; u < l.length; u++) {
				var c = l[u];a.prototype[c] = o(c);
			}t.exports = a;
		}, function (t, e, i) {
			if (!i(9).canvasSupported) {
				var n = i(6),
				    a = i(11),
				    o = i(27).CMD,
				    r = i(22),
				    s = i(16),
				    l = i(87),
				    u = i(38),
				    c = i(53),
				    h = i(86),
				    d = i(8),
				    f = i(27),
				    p = i(39),
				    g = i(182),
				    m = Math.round,
				    v = Math.sqrt,
				    y = Math.abs,
				    x = Math.cos,
				    _ = Math.sin,
				    b = Math.max,
				    w = n.applyTransform,
				    S = ",",
				    M = "progid:DXImageTransform.Microsoft",
				    I = 21600,
				    T = I / 2,
				    A = 1e5,
				    C = 1e3,
				    L = function L(t) {
					t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = I + "," + I, t.coordorigin = "0,0";
				},
				    D = function D(t) {
					return String(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
				},
				    P = function P(t, e, i) {
					return "rgb(" + [t, e, i].join(",") + ")";
				},
				    k = function k(t, e) {
					e && t && e.parentNode !== t && t.appendChild(e);
				},
				    O = function O(t, e) {
					e && t && e.parentNode === t && t.removeChild(e);
				},
				    z = function z(t, e, i) {
					return (parseFloat(t) || 0) * A + (parseFloat(e) || 0) * C + i;
				},
				    E = function E(t, e) {
					return "string" == typeof t ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t;
				},
				    R = function R(t, e, i) {
					var n = r.parse(e);i = +i, isNaN(i) && (i = 1), n && (t.color = P(n[0], n[1], n[2]), t.opacity = i * n[3]);
				},
				    N = function N(t) {
					var e = r.parse(t);return [P(e[0], e[1], e[2]), e[3]];
				},
				    V = function V(t, e, i) {
					var n = e.fill;if (null != n) if (n instanceof p) {
						var a,
						    o = 0,
						    r = [0, 0],
						    s = 0,
						    l = 1,
						    u = i.getBoundingRect(),
						    c = u.width,
						    h = u.height;if ("linear" === n.type) {
							a = "gradient";var d = i.transform,
							    f = [n.x * c, n.y * h],
							    g = [n.x2 * c, n.y2 * h];d && (w(f, f, d), w(g, g, d));var m = g[0] - f[0],
							    v = g[1] - f[1];o = 180 * Math.atan2(m, v) / Math.PI, o < 0 && (o += 360), o < 1e-6 && (o = 0);
						} else {
							a = "gradientradial";var f = [n.x * c, n.y * h],
							    d = i.transform,
							    y = i.scale,
							    x = c,
							    _ = h;r = [(f[0] - u.x) / x, (f[1] - u.y) / _], d && w(f, f, d), x /= y[0] * I, _ /= y[1] * I;var S = b(x, _);s = 0 / S, l = 2 * n.r / S - s;
						}var M = n.colorStops.slice();M.sort(function (t, e) {
							return t.offset - e.offset;
						});for (var T = M.length, A = [], C = [], L = 0; L < T; L++) {
							var D = M[L],
							    P = N(D.color);C.push(D.offset * l + s + " " + P[0]), 0 !== L && L !== T - 1 || A.push(P);
						}if (T >= 2) {
							var k = A[0][0],
							    O = A[1][0],
							    z = A[0][1] * e.opacity,
							    E = A[1][1] * e.opacity;t.type = a, t.method = "none", t.focus = "100%", t.angle = o, t.color = k, t.color2 = O, t.colors = C.join(","), t.opacity = E, t.opacity2 = z;
						}"radial" === a && (t.focusposition = r.join(","));
					} else R(t, n, e.opacity);
				},
				    B = function B(t, e) {
					null != e.lineDash && (t.dashstyle = e.lineDash.join(" ")), null == e.stroke || e.stroke instanceof p || R(t, e.stroke, e.opacity);
				},
				    G = function G(t, e, i, n) {
					var a = "fill" == e,
					    o = t.getElementsByTagName(e)[0];null != i[e] && "none" !== i[e] && (a || !a && i.lineWidth) ? (t[a ? "filled" : "stroked"] = "true", i[e] instanceof p && O(t, o), o || (o = g.createNode(e)), a ? V(o, i, n) : B(o, i), k(t, o)) : (t[a ? "filled" : "stroked"] = "false", O(t, o));
				},
				    H = [[], [], []],
				    F = function F(t, e) {
					var i,
					    n,
					    a,
					    r,
					    s,
					    l,
					    u = o.M,
					    c = o.C,
					    h = o.L,
					    d = o.A,
					    f = o.Q,
					    p = [];for (r = 0; r < t.length;) {
						switch (a = t[r++], n = "", i = 0, a) {case u:
								n = " m ", i = 1, s = t[r++], l = t[r++], H[0][0] = s, H[0][1] = l;break;case h:
								n = " l ", i = 1, s = t[r++], l = t[r++], H[0][0] = s, H[0][1] = l;break;case f:case c:
								n = " c ", i = 3;var g,
								    y,
								    b = t[r++],
								    M = t[r++],
								    A = t[r++],
								    C = t[r++];a === f ? (g = A, y = C, A = (A + 2 * b) / 3, C = (C + 2 * M) / 3, b = (s + 2 * b) / 3, M = (l + 2 * M) / 3) : (g = t[r++], y = t[r++]), H[0][0] = b, H[0][1] = M, H[1][0] = A, H[1][1] = C, H[2][0] = g, H[2][1] = y, s = g, l = y;break;case d:
								var L = 0,
								    D = 0,
								    P = 1,
								    k = 1,
								    O = 0;e && (L = e[4], D = e[5], P = v(e[0] * e[0] + e[1] * e[1]), k = v(e[2] * e[2] + e[3] * e[3]), O = Math.atan2(-e[1] / k, e[0] / P));var z = t[r++],
								    E = t[r++],
								    R = t[r++],
								    N = t[r++],
								    V = t[r++] + O,
								    B = t[r++] + V + O;r++;var G = t[r++],
								    F = z + x(V) * R,
								    W = E + _(V) * N,
								    b = z + x(B) * R,
								    M = E + _(B) * N,
								    Z = G ? " wa " : " at ";Math.abs(F - b) < 1e-4 && (Math.abs(B - V) > .01 ? G && (F += 270 / I) : Math.abs(W - E) < 1e-4 ? G && F < z || !G && F > z ? M -= 270 / I : M += 270 / I : G && W < E || !G && W > E ? b += 270 / I : b -= 270 / I), p.push(Z, m(((z - R) * P + L) * I - T), S, m(((E - N) * k + D) * I - T), S, m(((z + R) * P + L) * I - T), S, m(((E + N) * k + D) * I - T), S, m((F * P + L) * I - T), S, m((W * k + D) * I - T), S, m((b * P + L) * I - T), S, m((M * k + D) * I - T)), s = b, l = M;break;case o.R:
								var q = H[0],
								    j = H[1];q[0] = t[r++], q[1] = t[r++], j[0] = q[0] + t[r++], j[1] = q[1] + t[r++], e && (w(q, q, e), w(j, j, e)), q[0] = m(q[0] * I - T), j[0] = m(j[0] * I - T), q[1] = m(q[1] * I - T), j[1] = m(j[1] * I - T), p.push(" m ", q[0], S, q[1], " l ", j[0], S, q[1], " l ", j[0], S, j[1], " l ", q[0], S, j[1]);break;case o.Z:
								p.push(" x ");}if (i > 0) {
							p.push(n);for (var U = 0; U < i; U++) {
								var X = H[U];e && w(X, X, e), p.push(m(X[0] * I - T), S, m(X[1] * I - T), U < i - 1 ? S : "");
							}
						}
					}return p.join("");
				};d.prototype.brushVML = function (t) {
					var e = this.style,
					    i = this._vmlEl;i || (i = g.createNode("shape"), L(i), this._vmlEl = i), G(i, "fill", e, this), G(i, "stroke", e, this);var n = this.transform,
					    a = null != n,
					    o = i.getElementsByTagName("stroke")[0];if (o) {
						var r = e.lineWidth;if (a && !e.strokeNoScale) {
							var s = n[0] * n[3] - n[1] * n[2];r *= v(y(s));
						}o.weight = r + "px";
					}var l = this.path || (this.path = new f());this.__dirtyPath && (l.beginPath(), this.buildPath(l, this.shape), l.toStatic(), this.__dirtyPath = !1), i.path = F(l.data, this.transform), i.style.zIndex = z(this.zlevel, this.z, this.z2), k(t, i), null != e.text ? this.drawRectText(t, this.getBoundingRect()) : this.removeRectText(t);
				}, d.prototype.onRemove = function (t) {
					O(t, this._vmlEl), this.removeRectText(t);
				}, d.prototype.onAdd = function (t) {
					k(t, this._vmlEl), this.appendRectText(t);
				};var W = function W(t) {
					return "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && t.tagName && "IMG" === t.tagName.toUpperCase();
				};c.prototype.brushVML = function (t) {
					var e,
					    i,
					    n = this.style,
					    a = n.image;if (W(a)) {
						var o = a.src;if (o === this._imageSrc) e = this._imageWidth, i = this._imageHeight;else {
							var r = a.runtimeStyle,
							    s = r.width,
							    l = r.height;r.width = "auto", r.height = "auto", e = a.width, i = a.height, r.width = s, r.height = l, this._imageSrc = o, this._imageWidth = e, this._imageHeight = i;
						}a = o;
					} else a === this._imageSrc && (e = this._imageWidth, i = this._imageHeight);if (a) {
						var u = n.x || 0,
						    c = n.y || 0,
						    h = n.width,
						    d = n.height,
						    f = n.sWidth,
						    p = n.sHeight,
						    y = n.sx || 0,
						    x = n.sy || 0,
						    _ = f && p,
						    I = this._vmlEl;I || (I = g.doc.createElement("div"), L(I), this._vmlEl = I);var T,
						    A = I.style,
						    C = !1,
						    D = 1,
						    P = 1;if (this.transform && (T = this.transform, D = v(T[0] * T[0] + T[1] * T[1]), P = v(T[2] * T[2] + T[3] * T[3]), C = T[1] || T[2]), C) {
							var O = [u, c],
							    E = [u + h, c],
							    R = [u, c + d],
							    N = [u + h, c + d];w(O, O, T), w(E, E, T), w(R, R, T), w(N, N, T);var V = b(O[0], E[0], R[0], N[0]),
							    B = b(O[1], E[1], R[1], N[1]),
							    G = [];G.push("M11=", T[0] / D, S, "M12=", T[2] / P, S, "M21=", T[1] / D, S, "M22=", T[3] / P, S, "Dx=", m(u * D + T[4]), S, "Dy=", m(c * P + T[5])), A.padding = "0 " + m(V) + "px " + m(B) + "px 0", A.filter = M + ".Matrix(" + G.join("") + ", SizingMethod=clip)";
						} else T && (u = u * D + T[4], c = c * P + T[5]), A.filter = "", A.left = m(u) + "px", A.top = m(c) + "px";var H = this._imageEl,
						    F = this._cropEl;H || (H = g.doc.createElement("div"), this._imageEl = H);var Z = H.style;if (_) {
							if (e && i) Z.width = m(D * e * h / f) + "px", Z.height = m(P * i * d / p) + "px";else {
								var q = new Image(),
								    j = this;q.onload = function () {
									q.onload = null, e = q.width, i = q.height, Z.width = m(D * e * h / f) + "px", Z.height = m(P * i * d / p) + "px", j._imageWidth = e, j._imageHeight = i, j._imageSrc = a;
								}, q.src = a;
							}F || (F = g.doc.createElement("div"), F.style.overflow = "hidden", this._cropEl = F);var U = F.style;U.width = m((h + y * h / f) * D), U.height = m((d + x * d / p) * P), U.filter = M + ".Matrix(Dx=" + -y * h / f * D + ",Dy=" + -x * d / p * P + ")", F.parentNode || I.appendChild(F), H.parentNode != F && F.appendChild(H);
						} else Z.width = m(D * h) + "px", Z.height = m(P * d) + "px", I.appendChild(H), F && F.parentNode && (I.removeChild(F), this._cropEl = null);var X = "",
						    Y = n.opacity;Y < 1 && (X += ".Alpha(opacity=" + m(100 * Y) + ") "), X += M + ".AlphaImageLoader(src=" + a + ", SizingMethod=scale)", Z.filter = X, I.style.zIndex = z(this.zlevel, this.z, this.z2), k(t, I), null != n.text && this.drawRectText(t, this.getBoundingRect());
					}
				}, c.prototype.onRemove = function (t) {
					O(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t);
				}, c.prototype.onAdd = function (t) {
					k(t, this._vmlEl), this.appendRectText(t);
				};var Z,
				    q = "normal",
				    j = {},
				    U = 0,
				    X = 100,
				    Y = document.createElement("div"),
				    $ = function $(t) {
					var e = j[t];if (!e) {
						U > X && (U = 0, j = {});var i,
						    n = Y.style;try {
							n.font = t, i = n.fontFamily.split(",")[0];
						} catch (a) {}e = { style: n.fontStyle || q, variant: n.fontVariant || q, weight: n.fontWeight || q, size: 0 | parseFloat(n.fontSize || 12), family: i || "Microsoft YaHei" }, j[t] = e, U++;
					}return e;
				};s.measureText = function (t, e) {
					var i = g.doc;Z || (Z = i.createElement("div"), Z.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", g.doc.body.appendChild(Z));try {
						Z.style.font = e;
					} catch (n) {}return Z.innerHTML = "", Z.appendChild(i.createTextNode(t)), { width: Z.offsetWidth };
				};for (var K = new a(), J = function J(t, e, i, n) {
					var a = this.style,
					    o = a.text;if (null != o && (o += ""), o) {
						var r,
						    l,
						    u = a.textAlign,
						    c = $(a.textFont),
						    h = c.style + " " + c.variant + " " + c.weight + " " + c.size + 'px "' + c.family + '"',
						    d = a.textBaseline,
						    f = a.textVerticalAlign;i = i || s.getBoundingRect(o, h, u, d);var p = this.transform;if (p && !n && (K.copy(e), K.applyTransform(p), e = K), n) r = e.x, l = e.y;else {
							var v = a.textPosition,
							    y = a.textDistance;if (v instanceof Array) r = e.x + E(v[0], e.width), l = e.y + E(v[1], e.height), u = u || "left", d = d || "top";else {
								var x = s.adjustTextPositionOnRect(v, e, i, y);r = x.x, l = x.y, u = u || x.textAlign, d = d || x.textBaseline;
							}
						}if (f) {
							switch (f) {case "middle":
									l -= i.height / 2;break;case "bottom":
									l -= i.height;}d = "top";
						}var _ = c.size;switch (d) {case "hanging":case "top":
								l += _ / 1.75;break;case "middle":
								break;default:
								l -= _ / 2.25;}switch (u) {case "left":
								break;case "center":
								r -= i.width / 2;break;case "right":
								r -= i.width;}var b,
						    M,
						    I,
						    T = g.createNode,
						    A = this._textVmlEl;A ? (I = A.firstChild, b = I.nextSibling, M = b.nextSibling) : (A = T("line"), b = T("path"), M = T("textpath"), I = T("skew"), M.style["v-text-align"] = "left", L(A), b.textpathok = !0, M.on = !0, A.from = "0 0", A.to = "1000 0.05", k(A, I), k(A, b), k(A, M), this._textVmlEl = A);var C = [r, l],
						    P = A.style;p && n ? (w(C, C, p), I.on = !0, I.matrix = p[0].toFixed(3) + S + p[2].toFixed(3) + S + p[1].toFixed(3) + S + p[3].toFixed(3) + ",0,0", I.offset = (m(C[0]) || 0) + "," + (m(C[1]) || 0), I.origin = "0 0", P.left = "0px", P.top = "0px") : (I.on = !1, P.left = m(r) + "px", P.top = m(l) + "px"), M.string = D(o);try {
							M.style.font = h;
						} catch (O) {}G(A, "fill", { fill: n ? a.fill : a.textFill, opacity: a.opacity }, this), G(A, "stroke", { stroke: n ? a.stroke : a.textStroke, opacity: a.opacity, lineDash: a.lineDash }, this), A.style.zIndex = z(this.zlevel, this.z, this.z2), k(t, A);
					}
				}, Q = function Q(t) {
					O(t, this._textVmlEl), this._textVmlEl = null;
				}, tt = function tt(t) {
					k(t, this._textVmlEl);
				}, et = [l, u, c, d, h], it = 0; it < et.length; it++) {
					var nt = et[it].prototype;nt.drawRectText = J, nt.removeRectText = Q, nt.appendRectText = tt;
				}h.prototype.brushVML = function (t) {
					var e = this.style;null != e.text ? this.drawRectText(t, { x: e.x || 0, y: e.y || 0, width: 0, height: 0 }, this.getBoundingRect(), !0) : this.removeRectText(t);
				}, h.prototype.onRemove = function (t) {
					this.removeRectText(t);
				}, h.prototype.onAdd = function (t) {
					this.appendRectText(t);
				};
			}
		}, function (t, e, i) {
			i(238), i(88).registerPainter("vml", i(237));
		}, function (t, e, i) {
			var n = i(1),
			    a = i(241),
			    o = i(2);o.registerAction({ type: "geoRoam", event: "geoRoam", update: "updateLayout" }, function (t, e) {
				var i = t.componentType || "series";e.eachComponent({ mainType: i, query: t }, function (e) {
					var o = e.coordinateSystem;if ("geo" === o.type) {
						var r = a.updateCenterAndZoom(o, t, e.get("scaleLimit"));e.setCenter && e.setCenter(r.center), e.setZoom && e.setZoom(r.zoom), "series" === i && n.each(e.seriesGroup, function (t) {
							t.setCenter(r.center), t.setZoom(r.zoom);
						});
					}
				});
			});
		}, function (t, e) {
			var i = {};i.updateCenterAndZoom = function (t, e, i) {
				var n = t.getZoom(),
				    a = t.getCenter(),
				    o = e.zoom,
				    r = t.dataToPoint(a);if (null != e.dx && null != e.dy) {
					r[0] -= e.dx, r[1] -= e.dy;var a = t.pointToData(r);t.setCenter(a);
				}if (null != o) {
					if (i) {
						var s = i.min || 0,
						    l = i.max || 1 / 0;o = Math.max(Math.min(n * o, l), s) / n;
					}t.scale[0] *= o, t.scale[1] *= o;var u = t.position,
					    c = (e.originX - u[0]) * (o - 1),
					    h = (e.originY - u[1]) * (o - 1);u[0] -= c, u[1] -= h, t.updateTransform();var a = t.pointToData(r);t.setCenter(a), t.setZoom(o * n);
				}return { center: t.getCenter(), zoom: t.getZoom() };
			}, t.exports = i;
		}, function (t, e, i) {
			var n = i(6);t.exports = function (t) {
				var e = t.coordinateSystem;if (!e || "view" === e.type) {
					var i = e.getBoundingRect(),
					    a = t.getData(),
					    o = a.graph,
					    r = 0,
					    s = a.getSum("value"),
					    l = 2 * Math.PI / (s || a.count()),
					    u = i.width / 2 + i.x,
					    c = i.height / 2 + i.y,
					    h = Math.min(i.width, i.height) / 2;o.eachNode(function (t) {
						var e = t.getValue("value");r += l * (s ? e : 1) / 2, t.setLayout([h * Math.cos(r) + u, h * Math.sin(r) + c]), r += l * (s ? e : 1) / 2;
					}), a.setLayout({ cx: u, cy: c }), o.eachEdge(function (t) {
						var e,
						    i = t.getModel().get("lineStyle.normal.curveness") || 0,
						    a = n.clone(t.node1.getLayout()),
						    o = n.clone(t.node2.getLayout()),
						    r = (a[0] + o[0]) / 2,
						    s = (a[1] + o[1]) / 2;+i && (i *= 3, e = [u * i + r * (1 - i), c * i + s * (1 - i)]), t.setLayout([a, o, e]);
					});
				}
			};
		}, function (t, e, i) {
			var n = i(6);t.exports = function (t) {
				t.eachEdge(function (t) {
					var e = t.getModel().get("lineStyle.normal.curveness") || 0,
					    i = n.clone(t.node1.getLayout()),
					    a = n.clone(t.node2.getLayout()),
					    o = [i, a];+e && o.push([(i[0] + a[0]) / 2 - (i[1] - a[1]) * e, (i[1] + a[1]) / 2 - (a[0] - i[0]) * e]), t.setLayout(o);
				});
			};
		}, function (t, e, i) {
			var n = i(243);t.exports = function (t) {
				var e = t.coordinateSystem;if (!e || "view" === e.type) {
					var i = t.getGraph();i.eachNode(function (t) {
						var e = t.getModel();t.setLayout([+e.get("x"), +e.get("y")]);
					}), n(i);
				}
			};
		}, function (t, e, i) {
			function n(t, e, i) {
				a.Group.call(this), this.add(this.createLine(t, e, i)), this._updateEffectSymbol(t, e);
			}var a = i(3),
			    o = i(106),
			    r = i(1),
			    s = i(24),
			    l = i(6),
			    u = i(20),
			    c = n.prototype;c.createLine = function (t, e, i) {
				return new o(t, e, i);
			}, c._updateEffectSymbol = function (t, e) {
				var i = t.getItemModel(e),
				    n = i.getModel("effect"),
				    a = n.get("symbolSize"),
				    o = n.get("symbol");r.isArray(a) || (a = [a, a]);var l = n.get("color") || t.getItemVisual(e, "color"),
				    u = this.childAt(1);this._symbolType !== o && (this.remove(u), u = s.createSymbol(o, -.5, -.5, 1, 1, l), u.z2 = 100, u.culling = !0, this.add(u)), u && (u.setStyle("shadowColor", l), u.setStyle(n.getItemStyle(["color"])), u.attr("scale", a), u.setColor(l), u.attr("scale", a), this._symbolType = o, this._updateEffectAnimation(t, n, e));
			}, c._updateEffectAnimation = function (t, e, i) {
				var n = this.childAt(1);if (n) {
					var a = this,
					    o = t.getItemLayout(i),
					    s = 1e3 * e.get("period"),
					    l = e.get("loop"),
					    u = e.get("constantSpeed"),
					    c = r.retrieve(e.get("delay"), function (e) {
						return e / t.count() * s / 3;
					}),
					    h = "function" == typeof c;if (n.ignore = !0, this.updateAnimationPoints(n, o), u > 0 && (s = this.getLineLength(n) / u * 1e3), s !== this._period || l !== this._loop) {
						n.stopAnimation();var d = c;h && (d = c(i)), n.__t > 0 && (d = -s * n.__t), n.__t = 0;var f = n.animate("", l).when(s, { __t: 1 }).delay(d).during(function () {
							a.updateSymbolPosition(n);
						});l || f.done(function () {
							a.remove(n);
						}), f.start();
					}this._period = s, this._loop = l;
				}
			}, c.getLineLength = function (t) {
				return l.dist(t.__p1, t.__cp1) + l.dist(t.__cp1, t.__p2);
			}, c.updateAnimationPoints = function (t, e) {
				t.__p1 = e[0], t.__p2 = e[1], t.__cp1 = e[2] || [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2];
			}, c.updateData = function (t, e, i) {
				this.childAt(0).updateData(t, e, i), this._updateEffectSymbol(t, e);
			}, c.updateSymbolPosition = function (t) {
				var e = t.__p1,
				    i = t.__p2,
				    n = t.__cp1,
				    a = t.__t,
				    o = t.position,
				    r = u.quadraticAt,
				    s = u.quadraticDerivativeAt;o[0] = r(e[0], n[0], i[0], a), o[1] = r(e[1], n[1], i[1], a);var l = s(e[0], n[0], i[0], a),
				    c = s(e[1], n[1], i[1], a);t.rotation = -Math.atan2(c, l) - Math.PI / 2, t.ignore = !1;
			}, c.updateLayout = function (t, e) {
				this.childAt(0).updateLayout(t, e);var i = t.getItemModel(e).getModel("effect");this._updateEffectAnimation(t, i, e);
			}, r.inherits(n, a.Group), t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i) {
				a.Group.call(this), this._createPolyline(t, e, i);
			}var a = i(3),
			    o = i(1),
			    r = n.prototype;r._createPolyline = function (t, e, i) {
				var n = t.getItemLayout(e),
				    o = new a.Polyline({ shape: { points: n } });this.add(o), this._updateCommonStl(t, e, i);
			}, r.updateData = function (t, e, i) {
				var n = t.hostModel,
				    o = this.childAt(0),
				    r = { shape: { points: t.getItemLayout(e) } };a.updateProps(o, r, n, e), this._updateCommonStl(t, e, i);
			}, r._updateCommonStl = function (t, e, i) {
				var n = this.childAt(0),
				    r = t.getItemModel(e),
				    s = t.getItemVisual(e, "color"),
				    l = i && i.lineStyle,
				    u = i && i.hoverLineStyle;i && !t.hasItemOption || (l = r.getModel("lineStyle.normal").getLineStyle(), u = r.getModel("lineStyle.emphasis").getLineStyle()), n.useStyle(o.defaults({ strokeNoScale: !0, fill: "none", stroke: s }, l)), n.hoverStyle = u, a.setHoverStyle(this);
			}, r.updateLayout = function (t, e) {
				var i = this.childAt(0);i.setShape("points", t.getItemLayout(e));
			}, o.inherits(n, a.Group), t.exports = n;
		}, function (t, e, i) {
			var n = i(14),
			    a = i(423),
			    o = i(264),
			    r = i(25),
			    s = i(26),
			    l = i(1),
			    u = i(28);t.exports = function (t, e, i, c, h) {
				for (var d = new a(c), f = 0; f < t.length; f++) {
					d.addNode(l.retrieve(t[f].id, t[f].name, f), f);
				}for (var p = [], g = [], m = 0, f = 0; f < e.length; f++) {
					var v = e[f],
					    y = v.source,
					    x = v.target;d.addEdge(y, x, m) && (g.push(v), p.push(l.retrieve(v.id, y + " > " + x)), m++);
				}var _,
				    b = i.get("coordinateSystem");if ("cartesian2d" === b || "polar" === b) _ = u(t, i, i.ecModel);else {
					var w = s.get(b),
					    S = r((w && "view" !== w.type ? w.dimensions || [] : []).concat(["value"]), t);_ = new n(S, i), _.initData(t);
				}var M = new n(["value"], i);return M.initData(g, p), h && h(_, M), o({ mainData: _, struct: d, structAttr: "graph", datas: { node: _, edge: M }, datasAttr: { node: "data", edge: "edgeData" } }), d.update(), d;
			};
		}, function (t, e, i) {
			var n = i(1),
			    a = {};a.layout = function (t, e) {
				e = e || {};var i = t.coordinateSystem,
				    a = t.axis,
				    o = {},
				    r = a.position,
				    s = a.orient,
				    l = i.getRect(),
				    u = [l.x, l.x + l.width, l.y, l.y + l.height],
				    c = { horizontal: { top: u[2], bottom: u[3] }, vertical: { left: u[0], right: u[1] } };o.position = ["vertical" === s ? c.vertical[r] : u[0], "horizontal" === s ? c.horizontal[r] : u[3]];var h = { horizontal: 0, vertical: 1 };o.rotation = Math.PI / 2 * h[s];var d = { top: -1, bottom: 1, right: 1, left: -1 };o.labelDirection = o.tickDirection = o.nameDirection = d[r], t.get("axisTick.inside") && (o.tickDirection = -o.tickDirection), n.retrieve(e.labelInside, t.get("axisLabel.inside")) && (o.labelDirection = -o.labelDirection);var f = e.rotate;return null == f && (f = t.get("axisLabel.rotate")), o.labelRotation = "top" === r ? -f : f, o.labelInterval = a.getLabelInterval(), o.z2 = 1, o;
			}, t.exports = a;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t.getItemStyle(),
				    n = t.get("areaColor");return null != n && (i.fill = n), i;
			}function a(t, e, i, n, a) {
				i.off("click"), i.off("mousedown"), e.get("selectedMode") && (i.on("mousedown", function () {
					t._mouseDownFlag = !0;
				}), i.on("click", function (r) {
					if (t._mouseDownFlag) {
						t._mouseDownFlag = !1;for (var s = r.target; !s.__regions;) {
							s = s.parent;
						}if (s) {
							var l = { type: ("geo" === e.mainType ? "geo" : "map") + "ToggleSelect", batch: h.map(s.__regions, function (t) {
									return { name: t.name, from: a.uid };
								}) };l[e.mainType + "Id"] = e.id, n.dispatchAction(l), o(e, i);
						}
					}
				}));
			}function o(t, e) {
				e.eachChild(function (e) {
					h.each(e.__regions, function (i) {
						e.trigger(t.isSelected(i.name) ? "emphasis" : "normal");
					});
				});
			}function r(t, e) {
				var i = new c.Group();this._controller = new s(t.getZr()), this._controllerHost = { target: e ? i : null }, this.group = i, this._updateGroup = e, this._mouseDownFlag;
			}var s = i(95),
			    l = i(250),
			    u = i(128),
			    c = i(3),
			    h = i(1);r.prototype = { constructor: r, draw: function draw(t, e, i, r, s) {
					var l = "geo" === t.mainType,
					    u = t.getData && t.getData();l && e.eachComponent({ mainType: "series", subType: "map" }, function (e) {
						u || e.getHostGeoModel() !== t || (u = e.getData());
					});var d = t.coordinateSystem,
					    f = this.group,
					    p = d.scale,
					    g = { position: d.position, scale: p };!f.childAt(0) || s ? f.attr(g) : c.updateProps(f, g, t), f.removeAll();var m = ["itemStyle", "normal"],
					    v = ["itemStyle", "emphasis"],
					    y = ["label", "normal"],
					    x = ["label", "emphasis"],
					    _ = h.createHashMap();h.each(d.regions, function (e) {
						var i = _.get(e.name) || _.set(e.name, new c.Group()),
						    a = new c.CompoundPath({ shape: { paths: [] } });i.add(a);var o,
						    r = t.getRegionModel(e.name) || t,
						    s = r.getModel(m),
						    d = r.getModel(v),
						    g = n(s, p),
						    b = n(d, p),
						    w = r.getModel(y),
						    S = r.getModel(x);if (u) {
							o = u.indexOfName(e.name);var M = u.getItemVisual(o, "color", !0);M && (g.fill = M);
						}var I = w.getModel("textStyle"),
						    T = S.getModel("textStyle");h.each(e.geometries, function (t) {
							if ("polygon" === t.type) {
								a.shape.paths.push(new c.Polygon({ shape: { points: t.exterior } }));for (var e = 0; e < (t.interiors ? t.interiors.length : 0); e++) {
									a.shape.paths.push(new c.Polygon({ shape: { points: t.interiors[e] } }));
								}
							}
						}), a.setStyle(g), a.style.strokeNoScale = !0, a.culling = !0;var A = w.get("show"),
						    C = S.get("show"),
						    L = u && isNaN(u.get("value", o)),
						    D = u && u.getItemLayout(o);if (l || L && (A || C) || D && D.showLabel) {
							var P = u ? o : e.name,
							    k = t.getFormattedLabel(P, "normal"),
							    O = t.getFormattedLabel(P, "emphasis"),
							    z = new c.Text({ style: { text: A ? k || e.name : "", fill: I.getTextColor(), textFont: I.getFont(), textAlign: "center", textVerticalAlign: "middle" }, hoverStyle: { text: C ? O || e.name : "", fill: T.getTextColor(), textFont: T.getFont() }, position: e.center.slice(), scale: [1 / p[0], 1 / p[1]], z2: 10, silent: !0 });i.add(z);
						}if (u) u.setItemGraphicEl(o, i);else {
							var r = t.getRegionModel(e.name);a.eventData = { componentType: "geo", geoIndex: t.componentIndex, name: e.name, region: r && r.option || {} };
						}var E = i.__regions || (i.__regions = []);E.push(e), c.setHoverStyle(i, b, { hoverSilentOnTouch: !!t.get("selectedMode") }), f.add(i);
					}), this._updateController(t, e, i), a(this, t, f, i, r), o(t, f);
				}, remove: function remove() {
					this.group.removeAll(), this._controller.dispose(), this._controllerHost = {};
				}, _updateController: function _updateController(t, e, i) {
					function n() {
						var e = { type: "geoRoam", componentType: s };return e[s + "Id"] = t.id, e;
					}var a = t.coordinateSystem,
					    o = this._controller,
					    r = this._controllerHost;r.zoomLimit = t.get("scaleLimit"), r.zoom = a.getZoom(), o.enable(t.get("roam") || !1);var s = t.mainType;o.off("pan").on("pan", function (t, e) {
						this._mouseDownFlag = !1, l.updateViewOnPan(r, t, e), i.dispatchAction(h.extend(n(), { dx: t, dy: e }));
					}, this), o.off("zoom").on("zoom", function (t, e, a) {
						if (this._mouseDownFlag = !1, l.updateViewOnZoom(r, t, e, a), i.dispatchAction(h.extend(n(), { zoom: t, originX: e, originY: a })), this._updateGroup) {
							var o = this.group,
							    s = o.scale;o.traverse(function (t) {
								"text" === t.type && t.attr("scale", [1 / s[0], 1 / s[1]]);
							});
						}
					}, this), o.setPointerChecker(function (e, n, o) {
						return a.getViewRectAfterRoam().contain(n, o) && !u.onIrrelevantElement(e, i, t);
					});
				} }, t.exports = r;
		}, function (t, e) {
			var i = {};i.updateViewOnPan = function (t, e, i) {
				var n = t.target,
				    a = n.position;a[0] += e, a[1] += i, n.dirty();
			}, i.updateViewOnZoom = function (t, e, i, n) {
				var a = t.target,
				    o = t.zoomLimit,
				    r = a.position,
				    s = a.scale,
				    l = t.zoom = t.zoom || 1;if (l *= e, o) {
					var u = o.min || 0,
					    c = o.max || 1 / 0;l = Math.max(Math.min(c, l), u);
				}var h = l / t.zoom;t.zoom = l, r[0] -= (i - r[0]) * (h - 1), r[1] -= (n - r[1]) * (h - 1), s[0] *= h, s[1] *= h, a.dirty();
			}, t.exports = i;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t._model;return i.get("axisExpandable") && i.get("axisExpandTriggerOn") === e;
			}i(263), i(407), i(372);var a = i(2),
			    o = i(1),
			    r = i(37),
			    s = 5;a.extendComponentView({ type: "parallel", render: function render(t, e, i) {
					this._model = t, this._api = i, this._handlers || (this._handlers = {}, o.each(l, function (t, e) {
						i.getZr().on(e, this._handlers[e] = o.bind(t, this));
					}, this)), r.createOrUpdate(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate");
				}, dispose: function dispose(t, e) {
					o.each(this._handlers, function (t, i) {
						e.getZr().off(i, t);
					}), this._handlers = null;
				}, _throttledDispatchExpand: function _throttledDispatchExpand(t) {
					this._dispatchExpand(t);
				}, _dispatchExpand: function _dispatchExpand(t) {
					t && this._api.dispatchAction(o.extend({ type: "parallelAxisExpand" }, t));
				} });var l = { mousedown: function mousedown(t) {
					n(this, "click") && (this._mouseDownPoint = [t.offsetX, t.offsetY]);
				}, mouseup: function mouseup(t) {
					var e = this._mouseDownPoint;if (n(this, "click") && e) {
						var i = [t.offsetX, t.offsetY],
						    a = Math.pow(e[0] - i[0], 2) + Math.pow(e[1] - i[1], 2);if (a > s) return;var o = this._model.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]);"none" !== o.behavior && this._dispatchExpand({ axisExpandWindow: o.axisExpandWindow });
					}this._mouseDownPoint = null;
				}, mousemove: function mousemove(t) {
					if (!this._mouseDownPoint && n(this, "mousemove")) {
						var e = this._model,
						    i = e.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]),
						    a = i.behavior;"jump" === a && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand("none" === a ? null : { axisExpandWindow: i.axisExpandWindow, animation: "jump" === a && null });
					}
				} };a.registerPreprocessor(i(408));
		}, function (t, e, i) {
			i(422), i(357), i(418), i(55), i(360);var n = i(2);n.extendComponentView({ type: "single" });
		}, function (t, e, i) {
			var n = i(2),
			    a = i(1),
			    o = i(9),
			    r = i(266),
			    s = i(83),
			    l = i(187),
			    u = s.mapVisual,
			    c = i(5),
			    h = s.eachVisual,
			    d = i(4),
			    f = a.isArray,
			    p = a.each,
			    g = d.asc,
			    m = d.linearMap,
			    v = a.noop,
			    y = ["#f6efa6", "#d88273", "#bf444c"],
			    x = n.extendComponentModel({ type: "visualMap", dependencies: ["series"], stateList: ["inRange", "outOfRange"], replacableOptionKeys: ["inRange", "outOfRange", "target", "controller", "color"], dataBound: [-(1 / 0), 1 / 0], layoutMode: { type: "box", ignoreSize: !0 }, defaultOption: { show: !0, zlevel: 0, z: 4, seriesIndex: null, min: 0, max: 200, dimension: null, inRange: null, outOfRange: null, left: 0, right: null, top: null, bottom: 0, itemWidth: null, itemHeight: null, inverse: !1, orient: "vertical", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", contentColor: "#5793f3", inactiveColor: "#aaa", borderWidth: 0, padding: 5, textGap: 10, precision: 0, color: null, formatter: null, text: null, textStyle: { color: "#333" } }, init: function init(t, e, i) {
					this._dataExtent, this.targetVisuals = {}, this.controllerVisuals = {}, this.textStyleModel, this.itemSize, this.mergeDefaultAndTheme(t, i);
				}, optionUpdated: function optionUpdated(t, e) {
					var i = this.option;o.canvasSupported || (i.realtime = !1), !e && l.replaceVisualOption(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
				}, resetVisual: function resetVisual(t) {
					var e = this.stateList;t = a.bind(t, this), this.controllerVisuals = l.createVisualMappings(this.option.controller, e, t), this.targetVisuals = l.createVisualMappings(this.option.target, e, t);
				}, resetTargetSeries: function resetTargetSeries() {
					var t = this.option,
					    e = null == t.seriesIndex;t.seriesIndex = e ? [] : c.normalizeToArray(t.seriesIndex), e && this.ecModel.eachSeries(function (e, i) {
						t.seriesIndex.push(i);
					});
				}, eachTargetSeries: function eachTargetSeries(t, e) {
					a.each(this.option.seriesIndex, function (i) {
						t.call(e, this.ecModel.getSeriesByIndex(i));
					}, this);
				}, isTargetSeries: function isTargetSeries(t) {
					var e = !1;return this.eachTargetSeries(function (i) {
						i === t && (e = !0);
					}), e;
				}, formatValueText: function formatValueText(t, e, i) {
					function n(t) {
						return t === u[0] ? "min" : t === u[1] ? "max" : (+t).toFixed(l);
					}var o,
					    r,
					    s = this.option,
					    l = s.precision,
					    u = this.dataBound,
					    c = s.formatter;return i = i || ["<", ">"], a.isArray(t) && (t = t.slice(), o = !0), r = e ? t : o ? [n(t[0]), n(t[1])] : n(t), a.isString(c) ? c.replace("{value}", o ? r[0] : r).replace("{value2}", o ? r[1] : r) : a.isFunction(c) ? o ? c(t[0], t[1]) : c(t) : o ? t[0] === u[0] ? i[0] + " " + r[1] : t[1] === u[1] ? i[1] + " " + r[0] : r[0] + " - " + r[1] : r;
				}, resetExtent: function resetExtent() {
					var t = this.option,
					    e = g([t.min, t.max]);this._dataExtent = e;
				}, getDataDimension: function getDataDimension(t) {
					var e = this.option.dimension;return null != e ? e : t.dimensions.length - 1;
				}, getExtent: function getExtent() {
					return this._dataExtent.slice();
				}, completeVisualOption: function completeVisualOption() {
					function t(t) {
						f(n.color) && !t.inRange && (t.inRange = { color: n.color.slice().reverse() }), t.inRange = t.inRange || { color: y }, p(this.stateList, function (e) {
							var i = t[e];if (a.isString(i)) {
								var n = r.get(i, "active", d);n ? (t[e] = {}, t[e][i] = n) : delete t[e];
							}
						}, this);
					}function e(t, e, i) {
						var n = t[e],
						    a = t[i];n && !a && (a = t[i] = {}, p(n, function (t, e) {
							if (s.isValidType(e)) {
								var i = r.get(e, "inactive", d);null != i && (a[e] = i, "color" !== e || a.hasOwnProperty("opacity") || a.hasOwnProperty("colorAlpha") || (a.opacity = [0, 0]));
							}
						}));
					}function i(t) {
						var e = (t.inRange || {}).symbol || (t.outOfRange || {}).symbol,
						    i = (t.inRange || {}).symbolSize || (t.outOfRange || {}).symbolSize,
						    n = this.get("inactiveColor");p(this.stateList, function (o) {
							var r = this.itemSize,
							    s = t[o];s || (s = t[o] = { color: d ? n : [n] }), null == s.symbol && (s.symbol = e && a.clone(e) || (d ? "roundRect" : ["roundRect"])), null == s.symbolSize && (s.symbolSize = i && a.clone(i) || (d ? r[0] : [r[0], r[0]])), s.symbol = u(s.symbol, function (t) {
								return "none" === t || "square" === t ? "roundRect" : t;
							});var l = s.symbolSize;if (null != l) {
								var c = -(1 / 0);h(l, function (t) {
									t > c && (c = t);
								}), s.symbolSize = u(l, function (t) {
									return m(t, [0, c], [0, r[0]], !0);
								});
							}
						}, this);
					}var n = this.option,
					    o = { inRange: n.inRange, outOfRange: n.outOfRange },
					    l = n.target || (n.target = {}),
					    c = n.controller || (n.controller = {});a.merge(l, o), a.merge(c, o);var d = this.isCategory();t.call(this, l), t.call(this, c), e.call(this, l, "inRange", "outOfRange"), i.call(this, c);
				}, resetItemSize: function resetItemSize() {
					this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
				}, isCategory: function isCategory() {
					return !!this.option.categories;
				}, setSelected: v, getValueState: v, getVisualMeta: v });t.exports = x;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(3),
			    o = i(7),
			    r = i(12),
			    s = i(2),
			    l = i(83);t.exports = s.extendComponentView({ type: "visualMap", autoPositionValues: { left: 1, right: 1, top: 1, bottom: 1 }, init: function init(t, e) {
					this.ecModel = t, this.api = e, this.visualMapModel;
				}, render: function render(t, e, i, n) {
					return this.visualMapModel = t, t.get("show") === !1 ? void this.group.removeAll() : void this.doRender.apply(this, arguments);
				}, renderBackground: function renderBackground(t) {
					var e = this.visualMapModel,
					    i = o.normalizeCssArray(e.get("padding") || 0),
					    n = t.getBoundingRect();t.add(new a.Rect({ z2: -1, silent: !0, shape: { x: n.x - i[3], y: n.y - i[0], width: n.width + i[3] + i[1], height: n.height + i[0] + i[2] }, style: { fill: e.get("backgroundColor"), stroke: e.get("borderColor"), lineWidth: e.get("borderWidth") } }));
				}, getControllerVisual: function getControllerVisual(t, e, i) {
					function a(t) {
						return u[t];
					}function o(t, e) {
						u[t] = e;
					}i = i || {};var r = i.forceState,
					    s = this.visualMapModel,
					    u = {};if ("symbol" === e && (u.symbol = s.get("itemSymbol")), "color" === e) {
						var c = s.get("contentColor");u.color = c;
					}var h = s.controllerVisuals[r || s.getValueState(t)],
					    d = l.prepareVisualTypes(h);return n.each(d, function (n) {
						var r = h[n];i.convertOpacityToAlpha && "opacity" === n && (n = "colorAlpha", r = h.__alphaForOpacity), l.dependsOn(n, e) && r && r.applyVisual(t, a, o);
					}), u[e];
				}, positionGroup: function positionGroup(t) {
					var e = this.visualMapModel,
					    i = this.api;r.positionElement(t, e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() });
				}, doRender: n.noop });
		}, function (t, e, i) {
			var n = i(1),
			    a = i(12),
			    o = { getItemAlign: function getItemAlign(t, e, i) {
					var n = t.option,
					    o = n.align;if (null != o && "auto" !== o) return o;for (var r = { width: e.getWidth(), height: e.getHeight() }, s = "horizontal" === n.orient ? 1 : 0, l = [["left", "right", "width"], ["top", "bottom", "height"]], u = l[s], c = [0, null, 10], h = {}, d = 0; d < 3; d++) {
						h[l[1 - s][d]] = c[d], h[u[d]] = 2 === d ? i[0] : n[u[d]];
					}var f = [["x", "width", 3], ["y", "height", 0]][s],
					    p = a.getLayoutRect(h, r, n.padding);return u[(p.margin[f[2]] || 0) + p[f[0]] + .5 * p[f[1]] < .5 * r[f[1]] ? 0 : 1];
				}, convertDataIndex: function convertDataIndex(t) {
					return n.each(t || [], function (e) {
						null != t.dataIndex && (t.dataIndexInside = t.dataIndex, t.dataIndex = null);
					}), t;
				} };t.exports = o;
		}, function (t, e, i) {
			function n(t, e) {
				return t && t.hasOwnProperty && t.hasOwnProperty(e);
			}var a = i(1),
			    o = a.each;t.exports = function (t) {
				var e = t && t.visualMap;a.isArray(e) || (e = e ? [e] : []), o(e, function (t) {
					if (t) {
						n(t, "splitList") && !n(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);var e = t.pieces;e && a.isArray(e) && o(e, function (t) {
							a.isObject(t) && (n(t, "start") && !n(t, "min") && (t.min = t.start), n(t, "end") && !n(t, "max") && (t.max = t.end));
						});
					}
				});
			};
		}, function (t, e, i) {
			i(13).registerSubTypeDefaulter("visualMap", function (t) {
				return t.categories || (t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) && !t.calculable ? "piecewise" : "continuous";
			});
		}, function (t, e, i) {
			function n(t, e) {
				t.eachTargetSeries(function (e) {
					var i = e.getData();s.applyVisual(t.stateList, t.targetVisuals, i, t.getValueState, t, t.getDataDimension(i));
				});
			}function a(t) {
				t.eachSeries(function (e) {
					var i = e.getData(),
					    n = [];t.eachComponent("visualMap", function (t) {
						if (t.isTargetSeries(e)) {
							var a = t.getVisualMeta(u.bind(o, null, e, t)) || { stops: [], outerColors: [] };a.dimension = t.getDataDimension(i), n.push(a);
						}
					}), e.getData().setVisual("visualMeta", n);
				});
			}function o(t, e, i, n) {
				function a(t) {
					return u[t];
				}function o(t, e) {
					u[t] = e;
				}for (var r = e.targetVisuals[n], s = l.prepareVisualTypes(r), u = { color: t.getData().getVisual("color") }, c = 0, h = s.length; c < h; c++) {
					var d = s[c],
					    f = r["opacity" === d ? "__alphaForOpacity" : d];f && f.applyVisual(i, a, o);
				}return u.color;
			}var r = i(2),
			    s = i(187),
			    l = i(83),
			    u = i(1);r.registerVisual(r.PRIORITY.VISUAL.COMPONENT, function (t) {
				t.eachComponent("visualMap", function (e) {
					n(e, t);
				}), a(t);
			});
		}, function (t, e, i) {
			var n = i(2),
			    a = { type: "selectDataRange", event: "dataRangeSelected", update: "update" };n.registerAction(a, function (t, e) {
				e.eachComponent({ mainType: "visualMap", query: t }, function (e) {
					e.setSelected(t.selected);
				});
			});
		}, function (t, e, i) {
			function n() {
				l.call(this);
			}function a(t) {
				this.name = t, this.zoomLimit, l.call(this), this._roamTransform = new n(), this._viewTransform = new n(), this._center, this._zoom;
			}function o(t, e, i, n) {
				var a = i.seriesModel,
				    o = a ? a.coordinateSystem : null;return o === this ? o[t](n) : null;
			}var r = i(6),
			    s = i(19),
			    l = i(58),
			    u = i(1),
			    c = i(11),
			    h = r.applyTransform;u.mixin(n, l), a.prototype = { constructor: a, type: "view", dimensions: ["x", "y"], setBoundingRect: function setBoundingRect(t, e, i, n) {
					return this._rect = new c(t, e, i, n), this._rect;
				}, getBoundingRect: function getBoundingRect() {
					return this._rect;
				}, setViewRect: function setViewRect(t, e, i, n) {
					this.transformTo(t, e, i, n), this._viewRect = new c(t, e, i, n);
				}, transformTo: function transformTo(t, e, i, n) {
					var a = this.getBoundingRect(),
					    o = this._viewTransform;o.transform = a.calculateTransform(new c(t, e, i, n)), o.decomposeTransform(), this._updateTransform();
				}, setCenter: function setCenter(t) {
					t && (this._center = t, this._updateCenterAndZoom());
				}, setZoom: function setZoom(t) {
					t = t || 1;var e = this.zoomLimit;e && (null != e.max && (t = Math.min(e.max, t)), null != e.min && (t = Math.max(e.min, t))), this._zoom = t, this._updateCenterAndZoom();
				}, getDefaultCenter: function getDefaultCenter() {
					var t = this.getBoundingRect(),
					    e = t.x + t.width / 2,
					    i = t.y + t.height / 2;return [e, i];
				}, getCenter: function getCenter() {
					return this._center || this.getDefaultCenter();
				}, getZoom: function getZoom() {
					return this._zoom || 1;
				}, getRoamTransform: function getRoamTransform() {
					return this._roamTransform;
				}, _updateCenterAndZoom: function _updateCenterAndZoom() {
					var t = this._viewTransform.getLocalTransform(),
					    e = this._roamTransform,
					    i = this.getDefaultCenter(),
					    n = this.getCenter(),
					    a = this.getZoom();n = r.applyTransform([], n, t), i = r.applyTransform([], i, t), e.origin = n, e.position = [i[0] - n[0], i[1] - n[1]], e.scale = [a, a], this._updateTransform();
				}, _updateTransform: function _updateTransform() {
					var t = this._roamTransform,
					    e = this._viewTransform;e.parent = t, t.updateTransform(), e.updateTransform(), e.transform && s.copy(this.transform || (this.transform = []), e.transform), this.transform ? (this.invTransform = this.invTransform || [], s.invert(this.invTransform, this.transform)) : this.invTransform = null, this.decomposeTransform();
				}, getViewRect: function getViewRect() {
					return this._viewRect;
				}, getViewRectAfterRoam: function getViewRectAfterRoam() {
					var t = this.getBoundingRect().clone();return t.applyTransform(this.transform), t;
				}, dataToPoint: function dataToPoint(t) {
					var e = this.transform;return e ? h([], t, e) : [t[0], t[1]];
				}, pointToData: function pointToData(t) {
					var e = this.invTransform;return e ? h([], t, e) : [t[0], t[1]];
				}, convertToPixel: u.curry(o, "dataToPoint"), convertFromPixel: u.curry(o, "pointToData"), containPoint: function containPoint(t) {
					return this.getViewRectAfterRoam().contain(t[0], t[1]);
				} }, u.mixin(a, l), t.exports = a;
		}, function (t, e, i) {
			function n(t, e, i) {
				if (this.name = t, this.geometries = e, i) i = [i[0], i[1]];else {
					var n = this.getBoundingRect();i = [n.x + n.width / 2, n.y + n.height / 2];
				}this.center = i;
			}var a = i(267),
			    o = i(11),
			    r = i(85),
			    s = i(6);n.prototype = { constructor: n, properties: null, getBoundingRect: function getBoundingRect() {
					var t = this._rect;if (t) return t;for (var e = Number.MAX_VALUE, i = [e, e], n = [-e, -e], a = [], l = [], u = this.geometries, c = 0; c < u.length; c++) {
						if ("polygon" === u[c].type) {
							var h = u[c].exterior;r.fromPoints(h, a, l), s.min(i, i, a), s.max(n, n, l);
						}
					}return 0 === c && (i[0] = i[1] = n[0] = n[1] = 0), this._rect = new o(i[0], i[1], n[0] - i[0], n[1] - i[1]);
				}, contain: function contain(t) {
					var e = this.getBoundingRect(),
					    i = this.geometries;if (!e.contain(t[0], t[1])) return !1;t: for (var n = 0, o = i.length; n < o; n++) {
						if ("polygon" === i[n].type) {
							var r = i[n].exterior,
							    s = i[n].interiors;if (a.contain(r, t[0], t[1])) {
								for (var l = 0; l < (s ? s.length : 0); l++) {
									if (a.contain(s[l])) continue t;
								}return !0;
							}
						}
					}return !1;
				}, transformTo: function transformTo(t, e, i, n) {
					var a = this.getBoundingRect(),
					    r = a.width / a.height;i ? n || (n = i / r) : i = r * n;for (var l = new o(t, e, i, n), u = a.calculateTransform(l), c = this.geometries, h = 0; h < c.length; h++) {
						if ("polygon" === c[h].type) {
							for (var d = c[h].exterior, f = c[h].interiors, p = 0; p < d.length; p++) {
								s.applyTransform(d[p], d[p], u);
							}for (var g = 0; g < (f ? f.length : 0); g++) {
								for (var p = 0; p < f[g].length; p++) {
									s.applyTransform(f[g][p], f[g][p], u);
								}
							}
						}
					}a = this._rect, a.copy(l), this.center = [a.x + a.width / 2, a.y + a.height / 2];
				} }, t.exports = n;
		}, function (t, e, i) {
			function n(t) {
				if (!t.UTF8Encoding) return t;var e = t.UTF8Scale;null == e && (e = 1024);for (var i = t.features, n = 0; n < i.length; n++) {
					for (var o = i[n], r = o.geometry, s = r.coordinates, l = r.encodeOffsets, u = 0; u < s.length; u++) {
						var c = s[u];if ("Polygon" === r.type) s[u] = a(c, l[u], e);else if ("MultiPolygon" === r.type) for (var h = 0; h < c.length; h++) {
							var d = c[h];c[h] = a(d, l[u][h], e);
						}
					}
				}return t.UTF8Encoding = !1, t;
			}function a(t, e, i) {
				for (var n = [], a = e[0], o = e[1], r = 0; r < t.length; r += 2) {
					var s = t.charCodeAt(r) - 64,
					    l = t.charCodeAt(r + 1) - 64;s = s >> 1 ^ -(1 & s), l = l >> 1 ^ -(1 & l), s += a, l += o, a = s, o = l, n.push([s / i, l / i]);
				}return n;
			}var o = i(1),
			    r = i(261);t.exports = function (t) {
				return n(t), o.map(o.filter(t.features, function (t) {
					return t.geometry && t.properties && t.geometry.coordinates.length > 0;
				}), function (t) {
					var e = t.properties,
					    i = t.geometry,
					    n = i.coordinates,
					    a = [];"Polygon" === i.type && a.push({ type: "polygon", exterior: n[0], interiors: n.slice(1) }), "MultiPolygon" === i.type && o.each(n, function (t) {
						t[0] && a.push({ type: "polygon", exterior: t[0], interiors: t.slice(1) });
					});var s = new r(e.name, a, e.cp);return s.properties = e, s;
				});
			};
		}, function (t, e, i) {
			function n(t, e) {
				var i = [];return t.eachComponent("parallel", function (n, o) {
					var r = new a(n, t, e);r.name = "parallel_" + o, r.resize(n, e), n.coordinateSystem = r, r.model = n, i.push(r);
				}), t.eachSeries(function (e) {
					if ("parallel" === e.get("coordinateSystem")) {
						var i = t.queryComponents({ mainType: "parallel", index: e.get("parallelIndex"), id: e.get("parallelId") })[0];e.coordinateSystem = i.coordinateSystem;
					}
				}), i;
			}var a = i(405);i(26).register("parallel", { create: n });
		}, function (t, e, i) {
			function n(t) {
				var e = t.mainData,
				    i = t.datas;i || (i = { main: e }, t.datasAttr = { main: "data" }), t.datas = t.mainData = null, u(e, i, t), d(i, function (i) {
					d(e.TRANSFERABLE_METHODS, function (e) {
						i.wrapMethod(e, h.curry(a, t));
					});
				}), e.wrapMethod("cloneShallow", h.curry(r, t)), d(e.CHANGABLE_METHODS, function (i) {
					e.wrapMethod(i, h.curry(o, t));
				}), h.assert(i[e.dataType] === e);
			}function a(t, e) {
				if (l(this)) {
					var i = h.extend({}, this[f]);i[this.dataType] = e, u(e, i, t);
				} else c(e, this.dataType, this[p], t);return e;
			}function o(t, e) {
				return t.struct && t.struct.update(this), e;
			}function r(t, e) {
				return d(e[f], function (i, n) {
					i !== e && c(i.cloneShallow(), n, e, t);
				}), e;
			}function s(t) {
				var e = this[p];return null == t || null == e ? e : e[f][t];
			}function l(t) {
				return t[p] === t;
			}function u(t, e, i) {
				t[f] = {}, d(e, function (e, n) {
					c(e, n, t, i);
				});
			}function c(t, e, i, n) {
				i[f][e] = t, t[p] = i, t.dataType = e, n.struct && (t[n.structAttr] = n.struct, n.struct[n.datasAttr[e]] = t), t.getLinkedData = s;
			}var h = i(1),
			    d = h.each,
			    f = "\0__link_datas",
			    p = "\0__link_mainData";t.exports = n;
		}, function (t, e, i) {
			function n() {
				function t(e, n) {
					if (n >= i.length) return e;for (var o = -1, r = e.length, s = i[n++], l = {}, u = {}; ++o < r;) {
						var c = s(e[o]),
						    h = u[c];h ? h.push(e[o]) : u[c] = [e[o]];
					}return a.each(u, function (e, i) {
						l[i] = t(e, n);
					}), l;
				}function e(t, o) {
					if (o >= i.length) return t;var r = [],
					    s = n[o++];return a.each(t, function (t, i) {
						r.push({ key: i, values: e(t, o) });
					}), s ? r.sort(function (t, e) {
						return s(t.key, e.key);
					}) : r;
				}var i = [],
				    n = [];return { key: function key(t) {
						return i.push(t), this;
					}, sortKeys: function sortKeys(t) {
						return n[i.length - 1] = t, this;
					}, entries: function entries(i) {
						return e(t(i, 0), 0);
					} };
			}var a = i(1);t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = { get: function get(t, e, i) {
					var a = n.clone((o[t] || {})[e]);return i && n.isArray(a) ? a[a.length - 1] : a;
				} },
			    o = { color: { active: ["#006edd", "#e0ffff"], inactive: ["rgba(0,0,0,0)"] }, colorHue: { active: [0, 360], inactive: [0, 0] }, colorSaturation: { active: [.3, 1], inactive: [0, 0] }, colorLightness: { active: [.9, .5], inactive: [0, 0] }, colorAlpha: { active: [.3, 1], inactive: [0, 0] }, opacity: { active: [.3, 1], inactive: [0, 0] }, symbol: { active: ["circle", "roundRect", "diamond"], inactive: ["none"] }, symbolSize: { active: [10, 50], inactive: [0, 0] } };t.exports = a;
		}, function (t, e, i) {
			function n(t, e) {
				return Math.abs(t - e) < r;
			}function a(t, e, i) {
				var a = 0,
				    r = t[0];if (!r) return !1;for (var s = 1; s < t.length; s++) {
					var l = t[s];a += o(r[0], r[1], l[0], l[1], e, i), r = l;
				}var u = t[0];return n(r[0], u[0]) && n(r[1], u[1]) || (a += o(r[0], r[1], u[0], u[1], e, i)), 0 !== a;
			}var o = i(99),
			    r = 1e-8;t.exports = { contain: a };
		}, function (t, e, i) {
			var n = i(90).extend({ type: "series.pictorialBar", dependencies: ["grid"], defaultOption: { symbol: "circle", symbolSize: null, symbolRotate: null, symbolPosition: null, symbolOffset: null, symbolMargin: null, symbolRepeat: !1, symbolRepeatDirection: "end", symbolClip: !1, symbolBoundingData: null, symbolPatternSize: 400, barGap: "-100%", progressive: 0, hoverAnimation: !1 }, getInitialData: function getInitialData(t) {
					return t.stack = null, n.superApply(this, "getInitialData", arguments);
				} });t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i, n) {
				var l = t.getItemLayout(e),
				    u = i.get("symbolRepeat"),
				    c = i.get("symbolClip"),
				    h = i.get("symbolPosition") || "start",
				    d = i.get("symbolRotate"),
				    f = (d || 0) * Math.PI / 180 || 0,
				    p = i.get("symbolPatternSize") || 2,
				    g = i.isAnimationEnabled(),
				    m = { dataIndex: e, layout: l, itemModel: i, symbolType: t.getItemVisual(e, "symbol") || "circle", color: t.getItemVisual(e, "color"), symbolClip: c, symbolRepeat: u, symbolRepeatDirection: i.get("symbolRepeatDirection"), symbolPatternSize: p, rotation: f, animationModel: g ? i : null, hoverAnimation: g && i.get("hoverAnimation"), z2: i.getShallow("z", !0) || 0 };a(i, u, l, n, m), o(t, e, l, u, c, m.boundingLength, m.pxSign, p, n, m), r(i, m.symbolScale, f, n, m);var v = m.symbolSize,
				    y = i.get("symbolOffset");return I.isArray(y) && (y = [D(y[0], v[0]), D(y[1], v[1])]), s(i, v, l, u, c, y, h, m.valueLineWidth, m.boundingLength, m.repeatCutLength, n, m), m;
			}function a(t, e, i, n, a) {
				var o = n.valueDim,
				    r = t.get("symbolBoundingData"),
				    s = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()),
				    l = s.toGlobalCoord(s.dataToCoord(0)),
				    u = a.boundingLength = null != r ? s.toGlobalCoord(s.dataToCoord(s.scale.parse(r))) - l : e ? n.coordSysExtent[o.index][1 - +(i[o.wh] <= 0)] - l : i[o.wh];e && (a.repeatCutLength = i[o.wh]), a.pxSign = u > 0 ? 1 : u < 0 ? -1 : 0;
			}function o(t, e, i, n, a, o, r, s, l, u) {
				var c = l.valueDim,
				    h = l.categoryDim,
				    d = Math.abs(i[h.wh]),
				    f = t.getItemVisual(e, "symbolSize");I.isArray(f) ? f = f.slice() : (null == f && (f = "100%"), f = [f, f]), f[h.index] = D(f[h.index], d), f[c.index] = D(f[c.index], n ? d : Math.abs(o)), u.symbolSize = f;var p = u.symbolScale = [f[0] / s, f[1] / s];p[c.index] *= (l.isHorizontal ? -1 : 1) * r;
			}function r(t, e, i, n, a) {
				var o = t.get(P) || 0;o && (O.attr({ scale: e.slice(), rotation: i }), O.updateTransform(), o /= O.getLineScale(), o *= e[n.valueDim.index]), a.valueLineWidth = o;
			}function s(t, e, i, n, a, o, r, s, l, u, c, h) {
				var d = c.categoryDim,
				    f = c.valueDim,
				    p = h.pxSign,
				    g = Math.max(e[f.index] + s, 0),
				    m = g;if (n) {
					var v = Math.abs(l),
					    y = I.retrieve(t.get("symbolMargin"), "15%") + "",
					    x = !1;y.lastIndexOf("!") === y.length - 1 && (x = !0, y = y.slice(0, y.length - 1)), y = D(y, e[f.index]);var _ = Math.max(g + 2 * y, 0),
					    b = x ? 0 : 2 * y,
					    w = C.isNumeric(n),
					    S = w ? n : M((v + b) / _),
					    T = v - S * g;y = T / 2 / (x ? S : S - 1), _ = g + 2 * y, b = x ? 0 : 2 * y, w || "fixed" === n || (S = u ? M((Math.abs(u) + b) / _) : 0), m = S * _ - b, h.repeatTimes = S, h.symbolMargin = y;
				}var A = p * (m / 2),
				    L = h.pathPosition = [];L[d.index] = i[d.wh] / 2, L[f.index] = "start" === r ? A : "end" === r ? l - A : l / 2, o && (L[0] += o[0], L[1] += o[1]);var P = h.bundlePosition = [];P[d.index] = i[d.xy], P[f.index] = i[f.xy];var k = h.barRectShape = I.extend({}, i);k[f.wh] = p * Math.max(Math.abs(i[f.wh]), Math.abs(L[f.index] + A)), k[d.wh] = i[d.wh];var O = h.clipShape = {};O[d.xy] = -i[d.xy], O[d.wh] = c.ecSize[d.wh], O[f.xy] = 0, O[f.wh] = i[f.wh];
			}function l(t) {
				var e = t.symbolPatternSize,
				    i = A.createSymbol(t.symbolType, -e / 2, -e / 2, e, e, t.color);return i.attr({ culling: !0 }), "image" !== i.type && i.setStyle({ strokeNoScale: !0 }), i;
			}function u(t, e, i, n) {
				function a(t) {
					var e = h.slice(),
					    n = i.pxSign,
					    a = t;return ("start" === i.symbolRepeatDirection ? n > 0 : n < 0) && (a = f - 1 - t), e[d.index] = g * (a - f / 2 + .5) + h[d.index], { position: e, scale: i.symbolScale.slice(), rotation: i.rotation };
				}function o() {
					b(t, function (t) {
						t.trigger("emphasis");
					});
				}function r() {
					b(t, function (t) {
						t.trigger("normal");
					});
				}var s = t.__pictorialBundle,
				    u = i.symbolSize,
				    c = i.valueLineWidth,
				    h = i.pathPosition,
				    d = e.valueDim,
				    f = i.repeatTimes || 0,
				    p = 0,
				    g = u[e.valueDim.index] + c + 2 * i.symbolMargin;for (b(t, function (t) {
					t.__pictorialAnimationIndex = p, t.__pictorialRepeatTimes = f, p < f ? w(t, null, a(p), i, n) : w(t, null, { scale: [0, 0] }, i, n, function () {
						s.remove(t);
					}), m(t, i), p++;
				}); p < f; p++) {
					var v = l(i);v.__pictorialAnimationIndex = p, v.__pictorialRepeatTimes = f, s.add(v);var y = a(p, !0);w(v, { position: y.position, scale: [0, 0] }, { scale: y.scale, rotation: y.rotation }, i, n), v.on("mouseover", o).on("mouseout", r), m(v, i);
				}
			}function c(t, e, i, n) {
				function a() {
					this.trigger("emphasis");
				}function o() {
					this.trigger("normal");
				}var r = t.__pictorialBundle,
				    s = t.__pictorialMainPath;s ? w(s, null, { position: i.pathPosition.slice(), scale: i.symbolScale.slice(), rotation: i.rotation }, i, n) : (s = t.__pictorialMainPath = l(i), r.add(s), w(s, { position: i.pathPosition.slice(), scale: [0, 0], rotation: i.rotation }, { scale: i.symbolScale.slice() }, i, n), s.on("mouseover", a).on("mouseout", o)), m(s, i);
			}function h(t, e, i) {
				var n = I.extend({}, e.barRectShape),
				    a = t.__pictorialBarRect;a ? w(a, null, { shape: n }, e, i) : (a = t.__pictorialBarRect = new T.Rect({ z2: 2, shape: n, silent: !0, style: { stroke: "transparent", fill: "transparent", lineWidth: 0 } }), t.add(a));
			}function d(t, e, i, n) {
				if (i.symbolClip) {
					var a = t.__pictorialClipPath,
					    o = I.extend({}, i.clipShape),
					    r = e.valueDim,
					    s = i.animationModel,
					    l = i.dataIndex;if (a) T.updateProps(a, { shape: o }, s, l);else {
						o[r.wh] = 0, a = new T.Rect({ shape: o }), t.__pictorialBundle.setClipPath(a), t.__pictorialClipPath = a;var u = {};u[r.wh] = i.clipShape[r.wh], T[n ? "updateProps" : "initProps"](a, { shape: u }, s, l);
					}
				}
			}function f(t, e) {
				var i = t.getItemModel(e);return i.getAnimationDelayParams = p, i.isAnimationEnabled = g, i;
			}function p(t) {
				return { index: t.__pictorialAnimationIndex, count: t.__pictorialRepeatTimes };
			}function g() {
				return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
			}function m(t, e) {
				t.off("emphasis").off("normal");var i = e.symbolScale.slice();e.hoverAnimation && t.on("emphasis", function () {
					this.animateTo({ scale: [1.1 * i[0], 1.1 * i[1]] }, 400, "elasticOut");
				}).on("normal", function () {
					this.animateTo({ scale: i.slice() }, 400, "elasticOut");
				});
			}function v(t, e, i, n) {
				var a = new T.Group(),
				    o = new T.Group();return a.add(o), a.__pictorialBundle = o, o.attr("position", i.bundlePosition.slice()), i.symbolRepeat ? u(a, e, i) : c(a, e, i), h(a, i, n), d(a, e, i, n), a.__pictorialShapeStr = _(t, i), a.__pictorialSymbolMeta = i, a;
			}function y(t, e, i) {
				var n = i.animationModel,
				    a = i.dataIndex,
				    o = t.__pictorialBundle;T.updateProps(o, { position: i.bundlePosition.slice() }, n, a), i.symbolRepeat ? u(t, e, i, !0) : c(t, e, i, !0), h(t, i, !0), d(t, e, i, !0);
			}function x(t, e, i, n) {
				var a = n.__pictorialBarRect;a && (a.style.text = "");
				var o = [];b(n, function (t) {
					o.push(t);
				}), n.__pictorialMainPath && o.push(n.__pictorialMainPath), n.__pictorialClipPath && (i = null), I.each(o, function (t) {
					T.updateProps(t, { scale: [0, 0] }, i, e, function () {
						n.parent && n.parent.remove(n);
					});
				}), t.setItemGraphicEl(e, null);
			}function _(t, e) {
				return [t.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":");
			}function b(t, e, i) {
				I.each(t.__pictorialBundle.children(), function (n) {
					n !== t.__pictorialBarRect && e.call(i, n);
				});
			}function w(t, e, i, n, a, o) {
				e && t.attr(e), n.symbolClip && !a ? i && t.attr(i) : i && T[a ? "updateProps" : "initProps"](t, i, n.animationModel, n.dataIndex, o);
			}function S(t, e, i) {
				var n = i.color,
				    a = i.dataIndex,
				    o = i.itemModel,
				    r = o.getModel("itemStyle.normal").getItemStyle(["color"]),
				    s = o.getModel("itemStyle.emphasis").getItemStyle();b(t, function (t) {
					t.setColor(n), t.setStyle(I.defaults({ fill: n, opacity: i.opacity }, r)), T.setHoverStyle(t, s), t.z2 = i.z2;
				});var l = {},
				    u = e.valueDim.posDesc[+(i.boundingLength > 0)],
				    c = t.__pictorialBarRect;L.setLabel(c.style, l, o, n, e.seriesModel, a, u), T.setHoverStyle(c, l);
			}function M(t) {
				var e = Math.round(t);return Math.abs(t - e) < 1e-4 ? e : Math.ceil(t);
			}var I = i(1),
			    T = i(3),
			    A = i(24),
			    C = i(4),
			    L = i(91),
			    D = C.parsePercent,
			    P = ["itemStyle", "normal", "borderWidth"],
			    k = [{ xy: "x", wh: "width", index: 0, posDesc: ["left", "right"] }, { xy: "y", wh: "height", index: 1, posDesc: ["top", "bottom"] }],
			    O = new T.Circle(),
			    z = i(2).extendChartView({ type: "pictorialBar", render: function render(t, e, i) {
					var a = this.group,
					    o = t.getData(),
					    r = this._data,
					    s = t.coordinateSystem,
					    l = s.getBaseAxis(),
					    u = !!l.isHorizontal(),
					    c = s.grid.getRect(),
					    h = { ecSize: { width: i.getWidth(), height: i.getHeight() }, seriesModel: t, coordSys: s, coordSysExtent: [[c.x, c.x + c.width], [c.y, c.y + c.height]], isHorizontal: u, valueDim: k[+u], categoryDim: k[1 - u] };return o.diff(r).add(function (t) {
						if (o.hasValue(t)) {
							var e = f(o, t),
							    i = n(o, t, e, h),
							    r = v(o, h, i);o.setItemGraphicEl(t, r), a.add(r), S(r, h, i);
						}
					}).update(function (t, e) {
						var i = r.getItemGraphicEl(e);if (!o.hasValue(t)) return void a.remove(i);var s = f(o, t),
						    l = n(o, t, s, h),
						    u = _(o, l);i && u !== i.__pictorialShapeStr && (a.remove(i), o.setItemGraphicEl(t, null), i = null), i ? y(i, h, l) : i = v(o, h, l, !0), o.setItemGraphicEl(t, i), i.__pictorialSymbolMeta = l, a.add(i), S(i, h, l);
					}).remove(function (t) {
						var e = r.getItemGraphicEl(t);e && x(r, t, e.__pictorialSymbolMeta.animationModel, e);
					}).execute(), this._data = o, this.group;
				}, dispose: I.noop, remove: function remove(t, e) {
					var i = this.group,
					    n = this._data;t.get("animation") ? n && n.eachItemGraphicEl(function (e) {
						x(n, e.dataIndex, t, e);
					}) : i.removeAll();
				} });t.exports = z;
		}, function (t, e, i) {
			var n = i(2);i(271), i(272), n.registerVisual(i(274)), n.registerLayout(i(273));
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(17),
			    o = i(183),
			    r = a.extend({ type: "series.boxplot", dependencies: ["xAxis", "yAxis", "grid"], defaultValueDimensions: ["min", "Q1", "median", "Q3", "max"], dimensions: null, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, hoverAnimation: !0, layout: null, boxWidth: [7, 50], itemStyle: { normal: { color: "#fff", borderWidth: 1 }, emphasis: { borderWidth: 2, shadowBlur: 5, shadowOffsetX: 2, shadowOffsetY: 2, shadowColor: "rgba(0,0,0,0.4)" } }, animationEasing: "elasticOut", animationDuration: 800 } });n.mixin(r, o.seriesModelMixin, !0), t.exports = r;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				var n = e.getItemModel(i),
				    a = n.getModel(u),
				    o = e.getItemVisual(i, "color"),
				    s = a.getItemStyle(["borderColor"]),
				    l = t.childAt(t.whiskerIndex);l.style.set(s), l.style.stroke = o, l.dirty();var h = t.childAt(t.bodyIndex);h.style.set(s), h.style.stroke = o, h.dirty();var d = n.getModel(c).getItemStyle();r.setHoverStyle(t, d);
			}var a = i(1),
			    o = i(30),
			    r = i(3),
			    s = i(183),
			    l = o.extend({ type: "boxplot", getStyleUpdater: function getStyleUpdater() {
					return n;
				}, dispose: a.noop });a.mixin(l, s.viewMixin, !0);var u = ["itemStyle", "normal"],
			    c = ["itemStyle", "emphasis"];t.exports = l;
		}, function (t, e, i) {
			function n(t) {
				var e = [],
				    i = [];return t.eachSeriesByType("boxplot", function (t) {
					var n = t.getBaseAxis(),
					    a = r.indexOf(i, n);a < 0 && (a = i.length, i[a] = n, e[a] = { axis: n, seriesModels: [] }), e[a].seriesModels.push(t);
				}), e;
			}function a(t) {
				var e,
				    i,
				    n = t.axis,
				    a = t.seriesModels,
				    o = a.length,
				    s = t.boxWidthList = [],
				    c = t.boxOffsetList = [],
				    h = [];if ("category" === n.type) i = n.getBandWidth();else {
					var d = 0;u(a, function (t) {
						d = Math.max(d, t.getData().count());
					}), e = n.getExtent(), Math.abs(e[1] - e[0]) / d;
				}u(a, function (t) {
					var e = t.get("boxWidth");r.isArray(e) || (e = [e, e]), h.push([l(e[0], i) || 0, l(e[1], i) || 0]);
				});var f = .8 * i - 2,
				    p = f / o * .3,
				    g = (f - p * (o - 1)) / o,
				    m = g / 2 - f / 2;u(a, function (t, e) {
					c.push(m), m += p + g, s.push(Math.min(Math.max(g, h[e][0]), h[e][1]));
				});
			}function o(t, e, i) {
				var n,
				    a = t.coordinateSystem,
				    o = t.getData(),
				    s = i / 2,
				    l = t.get("layout"),
				    u = "horizontal" === l ? 0 : 1,
				    c = 1 - u,
				    h = ["x", "y"],
				    d = [];r.each(o.dimensions, function (t) {
					var e = o.getDimensionInfo(t),
					    i = e.coordDim;i === h[c] ? d.push(t) : i === h[u] && (n = t);
				}), null == n || d.length < 5 || o.each([n].concat(d), function () {
					function t(t) {
						var i = [];i[u] = h, i[c] = t;var n;return isNaN(h) || isNaN(t) ? n = [NaN, NaN] : (n = a.dataToPoint(i), n[u] += e), n;
					}function i(t, e) {
						var i = t.slice(),
						    n = t.slice();i[u] += s, n[u] -= s, e ? y.push(i, n) : y.push(n, i);
					}function n(t) {
						var e = [t.slice(), t.slice()];e[0][u] -= s, e[1][u] += s, v.push(e);
					}var r = arguments,
					    h = r[0],
					    f = r[d.length + 1],
					    p = t(r[3]),
					    g = t(r[1]),
					    m = t(r[5]),
					    v = [[g, t(r[2])], [m, t(r[4])]];n(g), n(m), n(p);var y = [];i(v[0][1], 0), i(v[1][1], 1), o.setItemLayout(f, { chartLayout: l, initBaseline: p[c], median: p, bodyEnds: y, whiskerEnds: v });
				});
			}var r = i(1),
			    s = i(4),
			    l = s.parsePercent,
			    u = r.each;t.exports = function (t) {
				var e = n(t);u(e, function (t) {
					var e = t.seriesModels;e.length && (a(t), u(e, function (e, i) {
						o(e, t.boxOffsetList[i], t.boxWidthList[i]);
					}));
				});
			};
		}, function (t, e) {
			var i = ["itemStyle", "normal", "borderColor"];t.exports = function (t, e) {
				var n = t.get("color");t.eachRawSeriesByType("boxplot", function (e) {
					var a = n[e.seriesIndex % n.length],
					    o = e.getData();o.setVisual({ legendSymbol: "roundRect", color: e.get(i) || a }), t.isSeriesFiltered(e) || o.each(function (t) {
						var e = o.getItemModel(t);o.setItemVisual(t, { color: e.get(i, !0) });
					});
				});
			};
		}, function (t, e, i) {
			var n = i(2);i(276), i(277), n.registerPreprocessor(i(280)), n.registerVisual(i(279)), n.registerLayout(i(278));
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(17),
			    o = i(183),
			    r = a.extend({ type: "series.candlestick", dependencies: ["xAxis", "yAxis", "grid"], defaultValueDimensions: ["open", "close", "lowest", "highest"], dimensions: null, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, hoverAnimation: !0, layout: null, itemStyle: { normal: { color: "#c23531", color0: "#314656", borderWidth: 1, borderColor: "#c23531", borderColor0: "#314656" }, emphasis: { borderWidth: 2 } }, barMaxWidth: null, barMinWidth: null, barWidth: null, animationUpdate: !1, animationEasing: "linear", animationDuration: 300 }, getShadowDim: function getShadowDim() {
					return "open";
				}, brushSelector: function brushSelector(t, e, i) {
					var n = e.getItemLayout(t);return i.rect(n.brushRect);
				} });n.mixin(r, o.seriesModelMixin, !0), t.exports = r;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				var n = e.getItemModel(i),
				    a = n.getModel(u),
				    o = e.getItemVisual(i, "color"),
				    s = e.getItemVisual(i, "borderColor") || o,
				    l = a.getItemStyle(["color", "color0", "borderColor", "borderColor0"]),
				    h = t.childAt(t.whiskerIndex);h.useStyle(l), h.style.stroke = s;var d = t.childAt(t.bodyIndex);d.useStyle(l), d.style.fill = o, d.style.stroke = s;var f = n.getModel(c).getItemStyle();r.setHoverStyle(t, f);
			}var a = i(1),
			    o = i(30),
			    r = i(3),
			    s = i(183),
			    l = o.extend({ type: "candlestick", getStyleUpdater: function getStyleUpdater() {
					return n;
				}, dispose: a.noop });a.mixin(l, s.viewMixin, !0);var u = ["itemStyle", "normal"],
			    c = ["itemStyle", "emphasis"];t.exports = l;
		}, function (t, e, i) {
			function n(t, e) {
				var i,
				    n = t.getBaseAxis(),
				    a = "category" === n.type ? n.getBandWidth() : (i = n.getExtent(), Math.abs(i[1] - i[0]) / e.count()),
				    s = r(o(t.get("barMaxWidth"), a), a),
				    l = r(o(t.get("barMinWidth"), 1), a),
				    u = t.get("barWidth");return null != u ? r(u, a) : Math.max(Math.min(a / 2, s), l);
			}var a = i(1),
			    o = i(1).retrieve,
			    r = i(4).parsePercent;t.exports = function (t) {
				t.eachSeriesByType("candlestick", function (t) {
					var e,
					    i = t.coordinateSystem,
					    o = t.getData(),
					    r = n(t, o),
					    s = t.get("layout"),
					    l = "horizontal" === s ? 0 : 1,
					    u = 1 - l,
					    c = ["x", "y"],
					    h = [];a.each(o.dimensions, function (t) {
						var i = o.getDimensionInfo(t),
						    n = i.coordDim;n === c[u] ? h.push(t) : n === c[l] && (e = t);
					}), null == e || h.length < 4 || o.each([e].concat(h), function () {
						function t(t) {
							var e = [];return e[l] = c, e[u] = t, isNaN(c) || isNaN(t) ? [NaN, NaN] : i.dataToPoint(e);
						}function e(t, e) {
							var i = t.slice(),
							    n = t.slice();i[l] += r / 2, n[l] -= r / 2, e ? M.push(i, n) : M.push(n, i);
						}function n() {
							var e = t(Math.min(f, p, g, m)),
							    i = t(Math.max(f, p, g, m));return e[l] -= r / 2, i[l] -= r / 2, { x: e[0], y: e[1], width: u ? r : i[0] - e[0], height: u ? i[1] - e[1] : r };
						}var a = arguments,
						    c = a[0],
						    d = a[h.length + 1],
						    f = a[1],
						    p = a[2],
						    g = a[3],
						    m = a[4],
						    v = Math.min(f, p),
						    y = Math.max(f, p),
						    x = t(v),
						    _ = t(y),
						    b = t(g),
						    w = t(m),
						    S = [[w, _], [b, x]],
						    M = [];e(_, 0), e(x, 1), o.setItemLayout(d, { chartLayout: s, sign: f > p ? -1 : f < p ? 1 : 0, initBaseline: f > p ? _[u] : x[u], bodyEnds: M, whiskerEnds: S, brushRect: n() });
					}, !0);
				});
			};
		}, function (t, e) {
			var i = ["itemStyle", "normal", "borderColor"],
			    n = ["itemStyle", "normal", "borderColor0"],
			    a = ["itemStyle", "normal", "color"],
			    o = ["itemStyle", "normal", "color0"];t.exports = function (t, e) {
				t.eachRawSeriesByType("candlestick", function (e) {
					var r = e.getData();r.setVisual({ legendSymbol: "roundRect" }), t.isSeriesFiltered(e) || r.each(function (t) {
						var e = r.getItemModel(t),
						    s = r.getItemLayout(t).sign;r.setItemVisual(t, { color: e.get(s > 0 ? a : o), borderColor: e.get(s > 0 ? i : n) });
					});
				});
			};
		}, function (t, e, i) {
			var n = i(1);t.exports = function (t) {
				t && n.isArray(t.series) && n.each(t.series, function (t) {
					n.isObject(t) && "k" === t.type && (t.type = "candlestick");
				});
			};
		}, function (t, e, i) {
			function n(t) {
				var e,
				    i = t.type;if ("path" === i) {
					var n = t.shape;e = d.makePath(n.pathData, null, { x: n.x || 0, y: n.y || 0, width: n.width || 0, height: n.height || 0 }, "center"), e.__customPathData = t.pathData;
				} else if ("image" === i) e = new d.Image({}), e.__customImagePath = t.style.image;else if ("text" === i) e = new d.Text({}), e.__customText = t.style.text;else {
					var a = d[i.charAt(0).toUpperCase() + i.slice(1)];e = new a();
				}return e.__customGraphicType = i, e;
			}function a(t, e, i, n, a, r) {
				var s = {},
				    l = i.style || {};if (i.shape && (s.shape = h.clone(i.shape)), i.position && (s.position = i.position.slice()), i.scale && (s.scale = i.scale.slice()), i.origin && (s.origin = i.origin.slice()), i.rotation && (s.rotation = i.rotation), "image" === t.type && i.style) {
					var u = s.style = {};h.each(["x", "y", "width", "height"], function (e) {
						o(e, u, l, t.style, r);
					});
				}if ("text" === t.type && i.style) {
					var u = s.style = {};h.each(["x", "y"], function (e) {
						o(e, u, l, t.style, r);
					});
				}if ("group" !== t.type && (t.useStyle(l), r)) {
					t.style.opacity = 0;var c = l.opacity;null == c && (c = 1), d.initProps(t, { style: { opacity: c } }, n, e);
				}r ? t.attr(s) : d.updateProps(t, s, n, e), t.attr({ z2: i.z2 || 0, silent: i.silent }), t.styleEmphasis !== !1 && d.setHoverStyle(t, t.styleEmphasis);
			}function o(t, e, i, n, a) {
				null == i[t] || a || (e[t] = i[t], i[t] = n[t]);
			}function r(t, e, i, n) {
				function a(t) {
					null == t && (t = w), O && (S = e.getItemModel(t), M = S.getModel(y), I = S.getModel(x), T = f.findLabelValueDim(e), A = e.getItemVisual(t, "color"), O = !1);
				}function o(t, i) {
					return null == i && (i = w), e.get(e.getDimension(t || 0), i);
				}function r(i, n) {
					null == n && (n = w), a(n);var o = S.getModel(m).getItemStyle();null != A && (o.fill = A);var r = e.getItemVisual(n, "opacity");return null != r && (o.opacity = r), f.setTextToStyle(e, n, T, o, t, M, A), i && h.extend(o, i), o;
				}function l(i, n) {
					null == n && (n = w), a(n);var o = S.getModel(v).getItemStyle();return f.setTextToStyle(e, n, T, o, t, I, A), i && h.extend(o, i), o;
				}function u(t, i) {
					return null == i && (i = w), e.getItemVisual(i, t);
				}function c(t) {
					if (L.getBaseAxis) {
						var e = L.getBaseAxis();return g.getLayoutOnAxis(h.defaults({ axis: e }, t), n);
					}
				}function p() {
					return i.getCurrentSeriesIndices();
				}function b(t) {
					return d.getFont(t, i);
				}var w,
				    S,
				    M,
				    I,
				    T,
				    A,
				    C = t.get("renderItem"),
				    L = t.coordinateSystem,
				    D = _[L.type](L),
				    P = h.defaults({ getWidth: n.getWidth, getHeight: n.getHeight, getZr: n.getZr, getDevicePixelRatio: n.getDevicePixelRatio, value: o, style: r, styleEmphasis: l, visual: u, barLayout: c, currentSeriesIndices: p, font: b }, D.api),
				    k = { context: {}, seriesId: t.id, seriesName: t.name, seriesIndex: t.seriesIndex, coordSys: D.coordSys, dataInsideLength: e.count(), encode: s(t.getData()) },
				    O = !0;return function (t) {
					return w = t, O = !0, C && C(h.defaults({ dataIndexInside: t, dataIndex: e.getRawIndex(t) }, k), P) || {};
				};
			}function s(t) {
				var e = {};return h.each(t.dimensions, function (i, n) {
					var a = t.getDimensionInfo(i);if (!a.isExtraCoord) {
						var o = a.coordDim,
						    r = e[o] = e[o] || [];r[a.coordDimIndex] = n;
					}
				}), e;
			}function l(t, e, i, n, a, o) {
				t = u(t, e, i, n, a, o), t && o.setItemGraphicEl(e, t);
			}function u(t, e, i, o, r, s) {
				var l = i.type;if (!t || l === t.__customGraphicType || "path" === l && i.pathData === t.__customPathData || "image" === l && i.style.image === t.__customImagePath || "text" === l && i.style.text === t.__customText || (r.remove(t), t = null), null != l) {
					var c = !t;return !t && (t = n(i)), a(t, e, i, o, s, c), "group" === l && h.each(i.children, function (i, n) {
						u(t.childAt(n), e, i, o, t, s);
					}), r.add(t), t;
				}
			}var c = i(2),
			    h = i(1),
			    d = i(3),
			    f = i(92),
			    p = i(28),
			    g = i(82),
			    m = ["itemStyle", "normal"],
			    v = ["itemStyle", "emphasis"],
			    y = ["label", "normal"],
			    x = ["label", "emphasis"],
			    _ = { cartesian2d: i(397), geo: i(403), singleAxis: i(421), polar: i(414), calendar: i(396) };c.extendSeriesModel({ type: "series.custom", dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"], defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: !0 }, getInitialData: function getInitialData(t, e) {
					return p(t.data, this, e);
				} }), c.extendChartView({ type: "custom", _data: null, render: function render(t, e, i) {
					var n = this._data,
					    a = t.getData(),
					    o = this.group,
					    s = r(t, a, e, i);a.diff(n).add(function (e) {
						a.hasValue(e) && l(null, e, s(e), t, o, a);
					}).update(function (e, i) {
						var r = n.getItemGraphicEl(i);a.hasValue(e) ? l(r, e, s(e), t, o, a) : r && o.remove(r);
					}).remove(function (t) {
						var e = n.getItemGraphicEl(t);e && o.remove(e);
					}).execute(), this._data = a;
				} });
		}, function (t, e, i) {
			var n = i(1),
			    a = i(2);i(283), i(284), a.registerVisual(n.curry(i(50), "effectScatter", "circle", null)), a.registerLayout(n.curry(i(61), "effectScatter"));
		}, function (t, e, i) {
			"use strict";
			var n = i(28),
			    a = i(17);t.exports = a.extend({ type: "series.effectScatter", dependencies: ["grid", "polar"], getInitialData: function getInitialData(t, e) {
					var i = n(t.data, this, e);return i;
				}, brushSelector: "point", defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: !0, effectType: "ripple", progressive: 0, showEffectOn: "render", rippleEffect: { period: 4, scale: 2.5, brushType: "fill" }, symbolSize: 10 } });
		}, function (t, e, i) {
			var n = i(44),
			    a = i(311);i(2).extendChartView({ type: "effectScatter", init: function init() {
					this._symbolDraw = new n(a);
				}, render: function render(t, e, i) {
					var n = t.getData(),
					    a = this._symbolDraw;a.updateData(n), this.group.add(a.group);
				}, updateLayout: function updateLayout() {
					this._symbolDraw.updateLayout();
				}, remove: function remove(t, e) {
					this._symbolDraw && this._symbolDraw.remove(e);
				}, dispose: function dispose() {} });
		}, function (t, e, i) {
			var n = i(1),
			    a = i(2);i(286), i(287), a.registerVisual(n.curry(i(84), "funnel")), a.registerLayout(i(288)), a.registerProcessor(n.curry(i(63), "funnel"));
		}, function (t, e, i) {
			"use strict";
			var n = i(14),
			    a = i(5),
			    o = i(25),
			    r = i(2).extendSeriesModel({ type: "series.funnel", init: function init(t) {
					r.superApply(this, "init", arguments), this.legendDataProvider = function () {
						return this.getRawData();
					}, this._defaultLabelLine(t);
				}, getInitialData: function getInitialData(t, e) {
					var i = o(["value"], t.data),
					    a = new n(i, this);return a.initData(t.data), a;
				}, _defaultLabelLine: function _defaultLabelLine(t) {
					a.defaultEmphasis(t.labelLine, ["show"]);var e = t.labelLine.normal,
					    i = t.labelLine.emphasis;e.show = e.show && t.label.normal.show, i.show = i.show && t.label.emphasis.show;
				}, getDataParams: function getDataParams(t) {
					var e = this.getData(),
					    i = r.superCall(this, "getDataParams", t),
					    n = e.getSum("value");return i.percent = n ? +(e.get("value", t) / n * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
				}, defaultOption: { zlevel: 0, z: 2, legendHoverLink: !0, left: 80, top: 60, right: 80, bottom: 60, minSize: "0%", maxSize: "100%", sort: "descending", gap: 0, funnelAlign: "center", label: { normal: { show: !0, position: "outer" }, emphasis: { show: !0 } }, labelLine: { normal: { show: !0, length: 20, lineStyle: { width: 1, type: "solid" } }, emphasis: {} }, itemStyle: { normal: { borderColor: "#fff", borderWidth: 1 }, emphasis: {} } } });t.exports = r;
		}, function (t, e, i) {
			function n(t, e) {
				function i() {
					r.ignore = r.hoverIgnore, s.ignore = s.hoverIgnore;
				}function n() {
					r.ignore = r.normalIgnore, s.ignore = s.normalIgnore;
				}o.Group.call(this);var a = new o.Polygon(),
				    r = new o.Polyline(),
				    s = new o.Text();this.add(a), this.add(r), this.add(s), this.updateData(t, e, !0), this.on("emphasis", i).on("normal", n).on("mouseover", i).on("mouseout", n);
			}function a(t, e, i, n) {
				var a = n.getModel("textStyle"),
				    o = n.get("position"),
				    s = "inside" === o || "inner" === o || "center" === o;return { fill: a.getTextColor() || (s ? "#fff" : t.getItemVisual(e, "color")), textFont: a.getFont(), text: r.retrieve(t.hostModel.getFormattedLabel(e, i), t.getName(e)) };
			}var o = i(3),
			    r = i(1),
			    s = n.prototype,
			    l = ["itemStyle", "normal", "opacity"];s.updateData = function (t, e, i) {
				var n = this.childAt(0),
				    a = t.hostModel,
				    s = t.getItemModel(e),
				    u = t.getItemLayout(e),
				    c = t.getItemModel(e).get(l);c = null == c ? 1 : c, n.useStyle({}), i ? (n.setShape({ points: u.points }), n.setStyle({ opacity: 0 }), o.initProps(n, { style: { opacity: c } }, a, e)) : o.updateProps(n, { style: { opacity: c }, shape: { points: u.points } }, a, e);var h = s.getModel("itemStyle"),
				    d = t.getItemVisual(e, "color");n.setStyle(r.defaults({ lineJoin: "round", fill: d }, h.getModel("normal").getItemStyle(["opacity"]))), n.hoverStyle = h.getModel("emphasis").getItemStyle(), this._updateLabel(t, e), o.setHoverStyle(this);
			}, s._updateLabel = function (t, e) {
				var i = this.childAt(1),
				    n = this.childAt(2),
				    r = t.hostModel,
				    s = t.getItemModel(e),
				    l = t.getItemLayout(e),
				    u = l.label,
				    c = t.getItemVisual(e, "color");o.updateProps(i, { shape: { points: u.linePoints || u.linePoints } }, r, e), o.updateProps(n, { style: { x: u.x, y: u.y } }, r, e), n.attr({ style: { textAlign: u.textAlign, textVerticalAlign: u.verticalAlign, textFont: u.font }, rotation: u.rotation, origin: [u.x, u.y], z2: 10 });var h = s.getModel("label.normal"),
				    d = s.getModel("label.emphasis"),
				    f = s.getModel("labelLine.normal"),
				    p = s.getModel("labelLine.emphasis");n.setStyle(a(t, e, "normal", h)), n.ignore = n.normalIgnore = !h.get("show"), n.hoverIgnore = !d.get("show"), i.ignore = i.normalIgnore = !f.get("show"), i.hoverIgnore = !p.get("show"), i.setStyle({ stroke: c }), i.setStyle(f.getModel("lineStyle").getLineStyle()), n.hoverStyle = a(t, e, "emphasis", d), i.hoverStyle = p.getModel("lineStyle").getLineStyle();
			}, r.inherits(n, o.Group);var u = i(30).extend({ type: "funnel", render: function render(t, e, i) {
					var a = t.getData(),
					    o = this._data,
					    r = this.group;a.diff(o).add(function (t) {
						var e = new n(a, t);a.setItemGraphicEl(t, e), r.add(e);
					}).update(function (t, e) {
						var i = o.getItemGraphicEl(e);i.updateData(a, t), r.add(i), a.setItemGraphicEl(t, i);
					}).remove(function (t) {
						var e = o.getItemGraphicEl(t);r.remove(e);
					}).execute(), this._data = a;
				}, remove: function remove() {
					this.group.removeAll(), this._data = null;
				}, dispose: function dispose() {} });t.exports = u;
		}, function (t, e, i) {
			function n(t, e) {
				return r.getLayoutRect(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() });
			}function a(t, e) {
				for (var i = t.mapArray("value", function (t) {
					return t;
				}), n = [], a = "ascending" === e, o = 0, r = t.count(); o < r; o++) {
					n[o] = o;
				}return "function" == typeof e ? n.sort(e) : "none" !== e && n.sort(function (t, e) {
					return a ? i[t] - i[e] : i[e] - i[t];
				}), n;
			}function o(t) {
				t.each(function (e) {
					var i,
					    n,
					    a,
					    o,
					    r = t.getItemModel(e),
					    s = r.getModel("label.normal"),
					    l = s.get("position"),
					    u = r.getModel("labelLine.normal"),
					    c = t.getItemLayout(e),
					    h = c.points,
					    d = "inner" === l || "inside" === l || "center" === l;if (d) n = (h[0][0] + h[1][0] + h[2][0] + h[3][0]) / 4, a = (h[0][1] + h[1][1] + h[2][1] + h[3][1]) / 4, i = "center", o = [[n, a], [n, a]];else {
						var f,
						    p,
						    g,
						    m = u.get("length");"left" === l ? (f = (h[3][0] + h[0][0]) / 2, p = (h[3][1] + h[0][1]) / 2, g = f - m, n = g - 5, i = "right") : (f = (h[1][0] + h[2][0]) / 2, p = (h[1][1] + h[2][1]) / 2, g = f + m, n = g + 5, i = "left");var v = p;o = [[f, p], [g, v]], a = v;
					}c.label = { linePoints: o, x: n, y: a, verticalAlign: "middle", textAlign: i, inside: d };
				});
			}var r = i(12),
			    s = i(4),
			    l = s.parsePercent;t.exports = function (t, e, i) {
				t.eachSeriesByType("funnel", function (t) {
					var i = t.getData(),
					    r = t.get("sort"),
					    u = n(t, e),
					    c = a(i, r),
					    h = [l(t.get("minSize"), u.width), l(t.get("maxSize"), u.width)],
					    d = i.getDataExtent("value"),
					    f = t.get("min"),
					    p = t.get("max");null == f && (f = Math.min(d[0], 0)), null == p && (p = d[1]);var g = t.get("funnelAlign"),
					    m = t.get("gap"),
					    v = (u.height - m * (i.count() - 1)) / i.count(),
					    y = u.y,
					    x = function x(t, e) {
						var n,
						    a = i.get("value", t) || 0,
						    o = s.linearMap(a, [f, p], h, !0);switch (g) {case "left":
								n = u.x;break;case "center":
								n = u.x + (u.width - o) / 2;break;case "right":
								n = u.x + u.width - o;}return [[n, e], [n + o, e]];
					};"ascending" === r && (v = -v, m = -m, y += u.height, c = c.reverse());for (var _ = 0; _ < c.length; _++) {
						var b = c[_],
						    w = c[_ + 1],
						    S = x(b, y),
						    M = x(w, y + v);y += v + m, i.setItemLayout(b, { points: S.concat(M.slice().reverse()) });
					}o(i);
				});
			};
		}, function (t, e, i) {
			i(290), i(291);
		}, function (t, e, i) {
			var n = i(14),
			    a = i(17),
			    o = i(1),
			    r = a.extend({ type: "series.gauge", getInitialData: function getInitialData(t, e) {
					var i = new n(["value"], this),
					    a = t.data || [];return o.isArray(a) || (a = [a]), i.initData(a), i;
				}, defaultOption: { zlevel: 0, z: 2, center: ["50%", "50%"], legendHoverLink: !0, radius: "75%", startAngle: 225, endAngle: -45, clockwise: !0, min: 0, max: 100, splitNumber: 10, axisLine: { show: !0, lineStyle: { color: [[.2, "#91c7ae"], [.8, "#63869e"], [1, "#c23531"]], width: 30 } }, splitLine: { show: !0, length: 30, lineStyle: { color: "#eee", width: 2, type: "solid" } }, axisTick: { show: !0, splitNumber: 5, length: 8, lineStyle: { color: "#eee", width: 1, type: "solid" } }, axisLabel: { show: !0, distance: 5, textStyle: { color: "auto" } }, pointer: { show: !0, length: "80%", width: 8 }, itemStyle: { normal: { color: "auto" } }, title: { show: !0, offsetCenter: [0, "-40%"], textStyle: { color: "#333", fontSize: 15 } }, detail: { show: !0, backgroundColor: "rgba(0,0,0,0)", borderWidth: 0, borderColor: "#ccc", width: 100, height: 40, offsetCenter: [0, "40%"], textStyle: { color: "auto", fontSize: 30 } } } });t.exports = r;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t.get("center"),
				    n = e.getWidth(),
				    a = e.getHeight(),
				    o = Math.min(n, a),
				    r = l(i[0], e.getWidth()),
				    s = l(i[1], e.getHeight()),
				    u = l(t.get("radius"), o / 2);return { cx: r, cy: s, r: u };
			}function a(t, e) {
				return e && ("string" == typeof e ? t = e.replace("{value}", null != t ? t : "") : "function" == typeof e && (t = e(t))), t;
			}var o = i(292),
			    r = i(3),
			    s = i(4),
			    l = s.parsePercent,
			    u = 2 * Math.PI,
			    c = i(30).extend({ type: "gauge", render: function render(t, e, i) {
					this.group.removeAll();var a = t.get("axisLine.lineStyle.color"),
					    o = n(t, i);this._renderMain(t, e, i, a, o);
				}, dispose: function dispose() {}, _renderMain: function _renderMain(t, e, i, n, a) {
					for (var o = this.group, s = t.getModel("axisLine"), l = s.getModel("lineStyle"), c = t.get("clockwise"), h = -t.get("startAngle") / 180 * Math.PI, d = -t.get("endAngle") / 180 * Math.PI, f = (d - h) % u, p = h, g = l.get("width"), m = 0; m < n.length; m++) {
						var v = Math.min(Math.max(n[m][0], 0), 1),
						    d = h + f * v,
						    y = new r.Sector({ shape: { startAngle: p, endAngle: d, cx: a.cx, cy: a.cy, clockwise: c, r0: a.r - g, r: a.r }, silent: !0 });y.setStyle({ fill: n[m][1] }), y.setStyle(l.getLineStyle(["color", "borderWidth", "borderColor"])), o.add(y), p = d;
					}var x = function x(t) {
						if (t <= 0) return n[0][1];for (var e = 0; e < n.length; e++) {
							if (n[e][0] >= t && (0 === e ? 0 : n[e - 1][0]) < t) return n[e][1];
						}return n[e - 1][1];
					};if (!c) {
						var _ = h;h = d, d = _;
					}this._renderTicks(t, e, i, x, a, h, d, c), this._renderPointer(t, e, i, x, a, h, d, c), this._renderTitle(t, e, i, x, a), this._renderDetail(t, e, i, x, a);
				}, _renderTicks: function _renderTicks(t, e, i, n, o, u, c, h) {
					for (var d = this.group, f = o.cx, p = o.cy, g = o.r, m = +t.get("min"), v = +t.get("max"), y = t.getModel("splitLine"), x = t.getModel("axisTick"), _ = t.getModel("axisLabel"), b = t.get("splitNumber"), w = x.get("splitNumber"), S = l(y.get("length"), g), M = l(x.get("length"), g), I = u, T = (c - u) / b, A = T / w, C = y.getModel("lineStyle").getLineStyle(), L = x.getModel("lineStyle").getLineStyle(), D = _.getModel("textStyle"), P = 0; P <= b; P++) {
						var k = Math.cos(I),
						    O = Math.sin(I);if (y.get("show")) {
							var z = new r.Line({ shape: { x1: k * g + f, y1: O * g + p, x2: k * (g - S) + f, y2: O * (g - S) + p }, style: C, silent: !0 });"auto" === C.stroke && z.setStyle({ stroke: n(P / b) }), d.add(z);
						}if (_.get("show")) {
							var E = a(s.round(P / b * (v - m) + m), _.get("formatter")),
							    R = _.get("distance"),
							    N = new r.Text({ style: { text: E, x: k * (g - S - R) + f, y: O * (g - S - R) + p, fill: D.getTextColor(), textFont: D.getFont(), textVerticalAlign: O < -.4 ? "top" : O > .4 ? "bottom" : "middle", textAlign: k < -.4 ? "left" : k > .4 ? "right" : "center" }, silent: !0 });"auto" === N.style.fill && N.setStyle({ fill: n(P / b) }), d.add(N);
						}if (x.get("show") && P !== b) {
							for (var V = 0; V <= w; V++) {
								var k = Math.cos(I),
								    O = Math.sin(I),
								    B = new r.Line({ shape: { x1: k * g + f, y1: O * g + p, x2: k * (g - M) + f, y2: O * (g - M) + p }, silent: !0, style: L });"auto" === L.stroke && B.setStyle({ stroke: n((P + V / w) / b) }), d.add(B), I += A;
							}I -= A;
						} else I += T;
					}
				}, _renderPointer: function _renderPointer(t, e, i, n, a, u, c, h) {
					var d = this.group,
					    f = this._data;if (!t.get("pointer.show")) return void (f && f.eachItemGraphicEl(function (t) {
						d.remove(t);
					}));var p = [+t.get("min"), +t.get("max")],
					    g = [u, c],
					    m = t.getData();m.diff(f).add(function (e) {
						var i = new o({ shape: { angle: u } });r.initProps(i, { shape: { angle: s.linearMap(m.get("value", e), p, g, !0) } }, t), d.add(i), m.setItemGraphicEl(e, i);
					}).update(function (e, i) {
						var n = f.getItemGraphicEl(i);r.updateProps(n, { shape: { angle: s.linearMap(m.get("value", e), p, g, !0) } }, t), d.add(n), m.setItemGraphicEl(e, n);
					}).remove(function (t) {
						var e = f.getItemGraphicEl(t);d.remove(e);
					}).execute(), m.eachItemGraphicEl(function (t, e) {
						var i = m.getItemModel(e),
						    o = i.getModel("pointer");t.setShape({ x: a.cx, y: a.cy, width: l(o.get("width"), a.r), r: l(o.get("length"), a.r) }), t.useStyle(i.getModel("itemStyle.normal").getItemStyle()), "auto" === t.style.fill && t.setStyle("fill", n(s.linearMap(m.get("value", e), p, [0, 1], !0))), r.setHoverStyle(t, i.getModel("itemStyle.emphasis").getItemStyle());
					}), this._data = m;
				}, _renderTitle: function _renderTitle(t, e, i, n, a) {
					var o = t.getModel("title");if (o.get("show")) {
						var u = o.getModel("textStyle"),
						    c = o.get("offsetCenter"),
						    h = a.cx + l(c[0], a.r),
						    d = a.cy + l(c[1], a.r),
						    f = new r.Text({ style: { x: h, y: d, text: t.getData().getName(0), fill: u.getTextColor(), textFont: u.getFont(), textAlign: "center", textVerticalAlign: "middle" } });if ("auto" === f.style.fill) {
							var p = +t.get("min"),
							    g = +t.get("max"),
							    m = t.getData().get("value", 0);f.setStyle("fill", n(s.linearMap(m, [p, g], [0, 1], !0)));
						}this.group.add(f);
					}
				}, _renderDetail: function _renderDetail(t, e, i, n, o) {
					var u = t.getModel("detail"),
					    c = +t.get("min"),
					    h = +t.get("max");if (u.get("show")) {
						var d = u.getModel("textStyle"),
						    f = u.get("offsetCenter"),
						    p = o.cx + l(f[0], o.r),
						    g = o.cy + l(f[1], o.r),
						    m = l(u.get("width"), o.r),
						    v = l(u.get("height"), o.r),
						    y = t.getData().get("value", 0),
						    x = new r.Rect({ shape: { x: p - m / 2, y: g - v / 2, width: m, height: v }, style: { text: a(y, u.get("formatter")), fill: u.get("backgroundColor"), textFill: d.getTextColor(), textFont: d.getFont() } });"auto" === x.style.textFill && x.setStyle("textFill", n(s.linearMap(y, [c, h], [0, 1], !0))), x.setStyle(u.getItemStyle(["color"])), this.group.add(x);
					}
				} });t.exports = c;
		}, function (t, e, i) {
			t.exports = i(8).extend({ type: "echartsGaugePointer", shape: { angle: 0, width: 10, r: 10, x: 0, y: 0 }, buildPath: function buildPath(t, e) {
					var i = Math.cos,
					    n = Math.sin,
					    a = e.r,
					    o = e.width,
					    r = e.angle,
					    s = e.x - i(r) * o * (o >= a / 3 ? 1 : 2),
					    l = e.y - n(r) * o * (o >= a / 3 ? 1 : 2);r = e.angle - Math.PI / 2, t.moveTo(s, l), t.lineTo(e.x + i(r) * o, e.y + n(r) * o), t.lineTo(e.x + i(e.angle) * a, e.y + n(e.angle) * a), t.lineTo(e.x - i(r) * o, e.y - n(r) * o), t.lineTo(s, l);
				} });
		}, function (t, e, i) {
			var n = i(2),
			    a = i(1);i(294), i(295), i(304), n.registerProcessor(i(297)), n.registerVisual(a.curry(i(50), "graph", "circle", null)), n.registerVisual(i(298)), n.registerVisual(i(301)), n.registerLayout(i(305)), n.registerLayout(i(299)), n.registerLayout(i(303)), n.registerCoordinateSystem("graphView", { create: i(300) });
		}, function (t, e, i) {
			"use strict";
			var n = i(14),
			    a = i(1),
			    o = i(5),
			    r = i(10),
			    s = i(7),
			    l = i(247),
			    u = i(2).extendSeriesModel({ type: "series.graph", init: function init(t) {
					u.superApply(this, "init", arguments), this.legendDataProvider = function () {
						return this._categoriesData;
					}, this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
				}, mergeOption: function mergeOption(t) {
					u.superApply(this, "mergeOption", arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
				}, mergeDefaultAndTheme: function mergeDefaultAndTheme(t) {
					u.superApply(this, "mergeDefaultAndTheme", arguments), o.defaultEmphasis(t.edgeLabel, o.LABEL_OPTIONS);
				}, getInitialData: function getInitialData(t, e) {
					function i(t, i) {
						function n(t) {
							return t = this.parsePath(t), t && "label" === t[0] ? s : this.parentModel;
						}t.wrapMethod("getItemModel", function (t) {
							var e = o._categoriesModels,
							    i = t.getShallow("category"),
							    n = e[i];return n && (n.parentModel = t.parentModel, t.parentModel = n), t;
						});var a = o.getModel("edgeLabel"),
						    s = new r({ label: a.option }, a.parentModel, e);i.wrapMethod("getItemModel", function (t) {
							return t.customizeGetParent(n), t;
						});
					}var n = t.edges || t.links || [],
					    a = t.data || t.nodes || [],
					    o = this;if (a && n) return l(a, n, this, !0, i).data;
				}, getGraph: function getGraph() {
					return this.getData().graph;
				}, getEdgeData: function getEdgeData() {
					return this.getGraph().edgeData;
				}, getCategoriesData: function getCategoriesData() {
					return this._categoriesData;
				}, formatTooltip: function formatTooltip(t, e, i) {
					if ("edge" === i) {
						var n = this.getData(),
						    a = this.getDataParams(t, i),
						    o = n.graph.getEdgeByIndex(t),
						    r = n.getName(o.node1.dataIndex),
						    l = n.getName(o.node2.dataIndex),
						    c = [];return null != r && c.push(r), null != l && c.push(l), c = s.encodeHTML(c.join(" > ")), a.value && (c += " : " + s.encodeHTML(a.value)), c;
					}return u.superApply(this, "formatTooltip", arguments);
				}, _updateCategoriesData: function _updateCategoriesData() {
					var t = a.map(this.option.categories || [], function (t) {
						return null != t.value ? t : a.extend({ value: 0 }, t);
					}),
					    e = new n(["value"], this);e.initData(t), this._categoriesData = e, this._categoriesModels = e.mapArray(function (t) {
						return e.getItemModel(t, !0);
					});
				}, setZoom: function setZoom(t) {
					this.option.zoom = t;
				}, setCenter: function setCenter(t) {
					this.option.center = t;
				}, isAnimationEnabled: function isAnimationEnabled() {
					return u.superCall(this, "isAnimationEnabled") && !("force" === this.get("layout") && this.get("force.layoutAnimation"));
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "view", legendHoverLink: !0, hoverAnimation: !0, layout: null, focusNodeAdjacency: !1, circular: { rotateLabel: !1 }, force: { initLayout: null, repulsion: [0, 50], gravity: .1, edgeLength: 30, layoutAnimation: !0 }, left: "center", top: "center", symbol: "circle", symbolSize: 10, edgeSymbol: ["none", "none"], edgeSymbolSize: 10, edgeLabel: { normal: { position: "middle" }, emphasis: {} }, draggable: !1, roam: !1, center: null, zoom: 1, nodeScaleRatio: .6, label: { normal: { show: !1, formatter: "{b}" }, emphasis: { show: !0 } }, itemStyle: { normal: {}, emphasis: {} }, lineStyle: { normal: { color: "#aaa", width: 1, curveness: 0, opacity: .5 }, emphasis: {} } } });t.exports = u;
		}, function (t, e, i) {
			function n(t, e) {
				return t.getVisual("opacity") || t.getModel().get(e);
			}var a = i(44),
			    o = i(107),
			    r = i(95),
			    s = i(250),
			    l = i(128),
			    u = i(3),
			    c = i(296),
			    h = i(1),
			    d = ["itemStyle", "normal", "opacity"],
			    f = ["lineStyle", "normal", "opacity"];i(2).extendChartView({ type: "graph", init: function init(t, e) {
					var i = new a(),
					    n = new o(),
					    s = this.group;this._controller = new r(e.getZr()), this._controllerHost = { target: s }, s.add(i.group), s.add(n.group), this._symbolDraw = i, this._lineDraw = n, this._firstRender = !0;
				}, render: function render(t, e, i) {
					var n = t.coordinateSystem;this._model = t, this._nodeScaleRatio = t.get("nodeScaleRatio");var a = this._symbolDraw,
					    o = this._lineDraw,
					    r = this.group;if ("view" === n.type) {
						var s = { position: n.position, scale: n.scale };this._firstRender ? r.attr(s) : u.updateProps(r, s, t);
					}c(t.getGraph(), this._getNodeGlobalScale(t));var l = t.getData();a.updateData(l);var h = t.getEdgeData();o.updateData(h), this._updateNodeAndLinkScale(), this._updateController(t, e, i), clearTimeout(this._layoutTimeout);var d = t.forceLayout,
					    f = t.get("force.layoutAnimation");d && this._startForceLayoutIteration(d, f), l.eachItemGraphicEl(function (e, n) {
						var a = l.getItemModel(n);e.off("drag").off("dragend");var o = l.getItemModel(n).get("draggable");o && e.on("drag", function () {
							d && (d.warmUp(), !this._layouting && this._startForceLayoutIteration(d, f), d.setFixed(n), l.setItemLayout(n, e.position));
						}, this).on("dragend", function () {
							d && d.setUnfixed(n);
						}, this), e.setDraggable(o && d), e.off("mouseover", e.__focusNodeAdjacency), e.off("mouseout", e.__unfocusNodeAdjacency), a.get("focusNodeAdjacency") && (e.on("mouseover", e.__focusNodeAdjacency = function () {
							i.dispatchAction({ type: "focusNodeAdjacency", seriesId: t.id, dataIndex: e.dataIndex });
						}), e.on("mouseout", e.__unfocusNodeAdjacency = function () {
							i.dispatchAction({ type: "unfocusNodeAdjacency", seriesId: t.id });
						}));
					}, this);var p = "circular" === t.get("layout") && t.get("circular.rotateLabel"),
					    g = l.getLayout("cx"),
					    m = l.getLayout("cy");l.eachItemGraphicEl(function (t, e) {
						var i = t.getSymbolPath();if (p) {
							var n = l.getItemLayout(e),
							    a = Math.atan2(n[1] - m, n[0] - g);a < 0 && (a = 2 * Math.PI + a);var o = n[0] < g;o && (a -= Math.PI);var r = o ? "left" : "right";i.setStyle({ textRotation: a, textPosition: r }), i.hoverStyle && (i.hoverStyle.textPosition = r);
						} else i.setStyle({ textRotation: 0 });
					}), this._firstRender = !1;
				}, dispose: function dispose() {
					this._controller && this._controller.dispose(), this._controllerHost = {};
				}, focusNodeAdjacency: function focusNodeAdjacency(t, e, i, a) {
					function o(t, e) {
						var i = n(t, e),
						    a = t.getGraphicEl();null == i && (i = 1), a.traverse(function (t) {
							t.trigger("normal"), "group" !== t.type && t.setStyle("opacity", .1 * i);
						});
					}function r(t, e) {
						var i = n(t, e),
						    a = t.getGraphicEl();a.traverse(function (t) {
							t.trigger("emphasis"), "group" !== t.type && t.setStyle("opacity", i);
						});
					}var s = this._model.getData(),
					    l = a.dataIndex,
					    u = s.getItemGraphicEl(l);if (u) {
						var c = s.graph,
						    p = u.dataType;if (null !== l && "edge" !== p) {
							c.eachNode(function (t) {
								o(t, d);
							}), c.eachEdge(function (t) {
								o(t, f);
							});var g = c.getNodeByIndex(l);r(g, d), h.each(g.edges, function (t) {
								t.dataIndex < 0 || (r(t, f), r(t.node1, d), r(t.node2, d));
							});
						}
					}
				}, unfocusNodeAdjacency: function unfocusNodeAdjacency(t, e, i, a) {
					var o = this._model.getData().graph;o.eachNode(function (t) {
						var e = n(t, d);t.getGraphicEl().traverse(function (t) {
							t.trigger("normal"), "group" !== t.type && t.setStyle("opacity", e);
						});
					}), o.eachEdge(function (t) {
						var e = n(t, f);t.getGraphicEl().traverse(function (t) {
							t.trigger("normal"), "group" !== t.type && t.setStyle("opacity", e);
						});
					});
				}, _startForceLayoutIteration: function _startForceLayoutIteration(t, e) {
					var i = this;!function n() {
						t.step(function (t) {
							i.updateLayout(i._model), (i._layouting = !t) && (e ? i._layoutTimeout = setTimeout(n, 16) : n());
						});
					}();
				}, _updateController: function _updateController(t, e, i) {
					var n = this._controller,
					    a = this._controllerHost,
					    o = this.group;return n.setPointerChecker(function (e, n, a) {
						var r = o.getBoundingRect();return r.applyTransform(o.transform), r.contain(n, a) && !l.onIrrelevantElement(e, i, t);
					}), "view" !== t.coordinateSystem.type ? void n.disable() : (n.enable(t.get("roam")), a.zoomLimit = t.get("scaleLimit"), a.zoom = t.coordinateSystem.getZoom(), void n.off("pan").off("zoom").on("pan", function (e, n) {
						s.updateViewOnPan(a, e, n), i.dispatchAction({ seriesId: t.id, type: "graphRoam", dx: e, dy: n });
					}).on("zoom", function (e, n, o) {
						s.updateViewOnZoom(a, e, n, o), i.dispatchAction({ seriesId: t.id, type: "graphRoam", zoom: e, originX: n, originY: o }), this._updateNodeAndLinkScale(), c(t.getGraph(), this._getNodeGlobalScale(t)), this._lineDraw.updateLayout();
					}, this));
				}, _updateNodeAndLinkScale: function _updateNodeAndLinkScale() {
					var t = this._model,
					    e = t.getData(),
					    i = this._getNodeGlobalScale(t),
					    n = [i, i];e.eachItemGraphicEl(function (t, e) {
						t.attr("scale", n);
					});
				}, _getNodeGlobalScale: function _getNodeGlobalScale(t) {
					var e = t.coordinateSystem;if ("view" !== e.type) return 1;var i = this._nodeScaleRatio,
					    n = e.scale,
					    a = n && n[0] || 1,
					    o = e.getZoom(),
					    r = (o - 1) * i + 1;return r / a;
				}, updateLayout: function updateLayout(t) {
					c(t.getGraph(), this._getNodeGlobalScale(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
				}, remove: function remove(t, e) {
					this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
				} });
		}, function (t, e, i) {
			function n(t, e, i) {
				for (var n, a = t[0], o = t[1], d = t[2], f = 1 / 0, p = i * i, g = .1, m = .1; m <= .9; m += .1) {
					r[0] = u(a[0], o[0], d[0], m), r[1] = u(a[1], o[1], d[1], m);var v = h(c(r, e) - p);v < f && (f = v, n = m);
				}for (var y = 0; y < 32; y++) {
					var x = n + g;s[0] = u(a[0], o[0], d[0], n), s[1] = u(a[1], o[1], d[1], n), l[0] = u(a[0], o[0], d[0], x), l[1] = u(a[1], o[1], d[1], x);var v = c(s, e) - p;if (h(v) < .01) break;var _ = c(l, e) - p;g /= 2, v < 0 ? _ >= 0 ? n += g : n -= g : _ >= 0 ? n -= g : n += g;
				}return n;
			}var a = i(20),
			    o = i(6),
			    r = [],
			    s = [],
			    l = [],
			    u = a.quadraticAt,
			    c = o.distSquare,
			    h = Math.abs;t.exports = function (t, e) {
				function i(t) {
					var e = t.getVisual("symbolSize");return e instanceof Array && (e = (e[0] + e[1]) / 2), e;
				}var r = [],
				    s = a.quadraticSubdivide,
				    l = [[], [], []],
				    u = [[], []],
				    c = [];e /= 2, t.eachEdge(function (t, a) {
					var h = t.getLayout(),
					    d = t.getVisual("fromSymbol"),
					    f = t.getVisual("toSymbol");h.__original || (h.__original = [o.clone(h[0]), o.clone(h[1])], h[2] && h.__original.push(o.clone(h[2])));var p = h.__original;if (null != h[2]) {
						if (o.copy(l[0], p[0]), o.copy(l[1], p[2]), o.copy(l[2], p[1]), d && "none" != d) {
							var g = i(t.node1),
							    m = n(l, p[0], g * e);s(l[0][0], l[1][0], l[2][0], m, r), l[0][0] = r[3], l[1][0] = r[4], s(l[0][1], l[1][1], l[2][1], m, r), l[0][1] = r[3], l[1][1] = r[4];
						}if (f && "none" != f) {
							var g = i(t.node2),
							    m = n(l, p[1], g * e);s(l[0][0], l[1][0], l[2][0], m, r), l[1][0] = r[1], l[2][0] = r[2], s(l[0][1], l[1][1], l[2][1], m, r), l[1][1] = r[1], l[2][1] = r[2];
						}o.copy(h[0], l[0]), o.copy(h[1], l[2]), o.copy(h[2], l[1]);
					} else {
						if (o.copy(u[0], p[0]), o.copy(u[1], p[1]), o.sub(c, u[1], u[0]), o.normalize(c, c), d && "none" != d) {
							var g = i(t.node1);o.scaleAndAdd(u[0], u[0], c, g * e);
						}if (f && "none" != f) {
							var g = i(t.node2);o.scaleAndAdd(u[1], u[1], c, -g * e);
						}o.copy(h[0], u[0]), o.copy(h[1], u[1]);
					}
				});
			};
		}, function (t, e) {
			t.exports = function (t) {
				var e = t.findComponents({ mainType: "legend" });e && e.length && t.eachSeriesByType("graph", function (t) {
					var i = t.getCategoriesData(),
					    n = t.getGraph(),
					    a = n.data,
					    o = i.mapArray(i.getName);a.filterSelf(function (t) {
						var i = a.getItemModel(t),
						    n = i.getShallow("category");if (null != n) {
							"number" == typeof n && (n = o[n]);for (var r = 0; r < e.length; r++) {
								if (!e[r].isSelected(n)) return !1;
							}
						}return !0;
					});
				}, this);
			};
		}, function (t, e) {
			t.exports = function (t) {
				var e = {};t.eachSeriesByType("graph", function (t) {
					var i = t.getCategoriesData(),
					    n = t.getData(),
					    a = {};i.each(function (n) {
						var o = i.getName(n);a["ec-" + o] = n;var r = i.getItemModel(n),
						    s = r.get("itemStyle.normal.color") || t.getColorFromPalette(o, e);i.setItemVisual(n, "color", s);
					}), i.count() && n.each(function (t) {
						var e = n.getItemModel(t),
						    o = e.getShallow("category");null != o && ("string" == typeof o && (o = a["ec-" + o]), n.getItemVisual(t, "color", !0) || n.setItemVisual(t, "color", i.getItemVisual(o, "color")));
					});
				});
			};
		}, function (t, e, i) {
			var n = i(242);t.exports = function (t) {
				t.eachSeriesByType("graph", function (t) {
					"circular" === t.get("layout") && n(t);
				});
			};
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = t.getBoxLayoutParams();return n.aspect = i, o.getLayoutRect(n, { width: e.getWidth(), height: e.getHeight() });
			}var a = i(260),
			    o = i(12),
			    r = i(85);t.exports = function (t, e) {
				var i = [];return t.eachSeriesByType("graph", function (t) {
					var o = t.get("coordinateSystem");if (!o || "view" === o) {
						var s = t.getData(),
						    l = s.mapArray(function (t) {
							var e = s.getItemModel(t);return [+e.get("x"), +e.get("y")];
						}),
						    u = [],
						    c = [];r.fromPoints(l, u, c), c[0] - u[0] === 0 && (c[0] += 1, u[0] -= 1), c[1] - u[1] === 0 && (c[1] += 1, u[1] -= 1);var h = (c[0] - u[0]) / (c[1] - u[1]),
						    d = n(t, e, h);isNaN(h) && (u = [d.x, d.y], c = [d.x + d.width, d.y + d.height]);var f = c[0] - u[0],
						    p = c[1] - u[1],
						    g = d.width,
						    m = d.height,
						    v = t.coordinateSystem = new a();v.zoomLimit = t.get("scaleLimit"), v.setBoundingRect(u[0], u[1], f, p), v.setViewRect(d.x, d.y, g, m), v.setCenter(t.get("center")), v.setZoom(t.get("zoom")), i.push(v);
					}
				}), i;
			};
		}, function (t, e) {
			function i(t) {
				return t instanceof Array || (t = [t, t]), t;
			}t.exports = function (t) {
				t.eachSeriesByType("graph", function (t) {
					var e = t.getGraph(),
					    n = t.getEdgeData(),
					    a = i(t.get("edgeSymbol")),
					    o = i(t.get("edgeSymbolSize")),
					    r = "lineStyle.normal.color".split("."),
					    s = "lineStyle.normal.opacity".split(".");n.setVisual("fromSymbol", a && a[0]), n.setVisual("toSymbol", a && a[1]), n.setVisual("fromSymbolSize", o && o[0]), n.setVisual("toSymbolSize", o && o[1]), n.setVisual("color", t.get(r)), n.setVisual("opacity", t.get(s)), n.each(function (t) {
						var a = n.getItemModel(t),
						    o = e.getEdgeByIndex(t),
						    l = i(a.getShallow("symbol", !0)),
						    u = i(a.getShallow("symbolSize", !0)),
						    c = a.get(r),
						    h = a.get(s);switch (c) {case "source":
								c = o.node1.getVisual("color");break;case "target":
								c = o.node2.getVisual("color");}l[0] && o.setVisual("fromSymbol", l[0]), l[1] && o.setVisual("toSymbol", l[1]), u[0] && o.setVisual("fromSymbolSize", u[0]), u[1] && o.setVisual("toSymbolSize", u[1]), o.setVisual("color", c), o.setVisual("opacity", h);
					});
				});
			};
		}, function (t, e, i) {
			var n = i(6),
			    a = n.scaleAndAdd;t.exports = function (t, e, i) {
				for (var o = i.rect, r = o.width, s = o.height, l = [o.x + r / 2, o.y + s / 2], u = null == i.gravity ? .1 : i.gravity, c = 0; c < t.length; c++) {
					var h = t[c];h.p || (h.p = n.create(r * (Math.random() - .5) + l[0], s * (Math.random() - .5) + l[1])), h.pp = n.clone(h.p), h.edges = null;
				}var d = .6;return { warmUp: function warmUp() {
						d = .5;
					}, setFixed: function setFixed(e) {
						t[e].fixed = !0;
					}, setUnfixed: function setUnfixed(e) {
						t[e].fixed = !1;
					}, step: function step(i) {
						for (var o = [], r = t.length, s = 0; s < e.length; s++) {
							var c = e[s],
							    h = c.n1,
							    f = c.n2;n.sub(o, f.p, h.p);var p = n.len(o) - c.d,
							    g = f.w / (h.w + f.w);n.normalize(o, o), !h.fixed && a(h.p, h.p, o, g * p * d), !f.fixed && a(f.p, f.p, o, -(1 - g) * p * d);
						}for (var s = 0; s < r; s++) {
							var m = t[s];m.fixed || (n.sub(o, l, m.p), n.scaleAndAdd(m.p, m.p, o, u * d));
						}for (var s = 0; s < r; s++) {
							for (var h = t[s], v = s + 1; v < r; v++) {
								var f = t[v];n.sub(o, f.p, h.p);var p = n.len(o);0 === p && (n.set(o, Math.random() - .5, Math.random() - .5), p = 1);var y = (h.rep + f.rep) / p / p;!h.fixed && a(h.pp, h.pp, o, y), !f.fixed && a(f.pp, f.pp, o, -y);
							}
						}for (var x = [], s = 0; s < r; s++) {
							var m = t[s];m.fixed || (n.sub(x, m.p, m.pp), n.scaleAndAdd(m.p, m.p, x, d), n.copy(m.pp, m.p));
						}d = .992 * d, i && i(t, e, d < .01);
					} };
			};
		}, function (t, e, i) {
			var n = i(302),
			    a = i(4),
			    o = i(244),
			    r = i(242),
			    s = i(6),
			    l = i(1);t.exports = function (t) {
				t.eachSeriesByType("graph", function (t) {
					var e = t.coordinateSystem;if (!e || "view" === e.type) if ("force" === t.get("layout")) {
						var i = t.preservedPoints || {},
						    u = t.getGraph(),
						    c = u.data,
						    h = u.edgeData,
						    d = t.getModel("force"),
						    f = d.get("initLayout");t.preservedPoints ? c.each(function (t) {
							var e = c.getId(t);c.setItemLayout(t, i[e] || [NaN, NaN]);
						}) : f && "none" !== f ? "circular" === f && r(t) : o(t);var p = c.getDataExtent("value"),
						    g = h.getDataExtent("value"),
						    m = d.get("repulsion"),
						    v = d.get("edgeLength");l.isArray(m) || (m = [m, m]), l.isArray(v) || (v = [v, v]), v = [v[1], v[0]];var y = c.mapArray("value", function (t, e) {
							var i = c.getItemLayout(e),
							    n = a.linearMap(t, p, m);return isNaN(n) && (n = (m[0] + m[1]) / 2), { w: n, rep: n, p: !i || isNaN(i[0]) || isNaN(i[1]) ? null : i };
						}),
						    x = h.mapArray("value", function (t, e) {
							var i = u.getEdgeByIndex(e),
							    n = a.linearMap(t, g, v);return isNaN(n) && (n = (v[0] + v[1]) / 2), { n1: y[i.node1.dataIndex], n2: y[i.node2.dataIndex], d: n, curveness: i.getModel().get("lineStyle.normal.curveness") || 0 };
						}),
						    e = t.coordinateSystem,
						    _ = e.getBoundingRect(),
						    b = n(y, x, { rect: _, gravity: d.get("gravity") }),
						    w = b.step;b.step = function (t) {
							for (var e = 0, n = y.length; e < n; e++) {
								y[e].fixed && s.copy(y[e].p, u.getNodeByIndex(e).getLayout());
							}w(function (e, n, a) {
								for (var o = 0, r = e.length; o < r; o++) {
									e[o].fixed || u.getNodeByIndex(o).setLayout(e[o].p), i[c.getId(o)] = e[o].p;
								}for (var o = 0, r = n.length; o < r; o++) {
									var l = n[o],
									    h = u.getEdgeByIndex(o),
									    d = l.n1.p,
									    f = l.n2.p,
									    p = h.getLayout();p = p ? p.slice() : [], p[0] = p[0] || [], p[1] = p[1] || [], s.copy(p[0], d), s.copy(p[1], f), +l.curveness && (p[2] = [(d[0] + f[0]) / 2 - (d[1] - f[1]) * l.curveness, (d[1] + f[1]) / 2 - (f[0] - d[0]) * l.curveness]), h.setLayout(p);
								}t && t(a);
							});
						}, t.forceLayout = b, t.preservedPoints = i, b.step();
					} else t.forceLayout = null;
				});
			};
		}, function (t, e, i) {
			var n = i(2),
			    a = i(241),
			    o = { type: "graphRoam", event: "graphRoam", update: "none" };n.registerAction(o, function (t, e) {
				e.eachComponent({ mainType: "series", query: t }, function (e) {
					var i = e.coordinateSystem,
					    n = a.updateCenterAndZoom(i, t);e.setCenter && e.setCenter(n.center), e.setZoom && e.setZoom(n.zoom);
				});
			}), n.registerAction({ type: "focusNodeAdjacency", event: "focusNodeAdjacency", update: "series.graph:focusNodeAdjacency" }, function () {}), n.registerAction({ type: "unfocusNodeAdjacency", event: "unfocusNodeAdjacency", update: "series.graph:unfocusNodeAdjacency" }, function () {});
		}, function (t, e, i) {
			var n = i(244),
			    a = i(243);t.exports = function (t, e) {
				t.eachSeriesByType("graph", function (t) {
					var e = t.get("layout"),
					    i = t.coordinateSystem;if (i && "view" !== i.type) {
						var o = t.getData(),
						    r = i.dimensions;o.each(r, function () {
							for (var t, e = arguments, n = [], a = 0; a < r.length; a++) {
								isNaN(e[a]) || (t = !0), n.push(e[a]);
							}var s = e[e.length - 1];t ? o.setItemLayout(s, i.dataToPoint(n)) : o.setItemLayout(s, [NaN, NaN]);
						}), a(o.graph);
					} else e && "none" !== e || n(t);
				});
			};
		}, function (t, e, i) {
			i(308), i(309);
		}, function (t, e, i) {
			function n() {
				var t = o.createCanvas();this.canvas = t, this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {};
			}var a = 256,
			    o = i(1);n.prototype = { update: function update(t, e, i, n, o, r) {
					var s = this._getBrush(),
					    l = this._getGradient(t, o, "inRange"),
					    u = this._getGradient(t, o, "outOfRange"),
					    c = this.pointSize + this.blurSize,
					    h = this.canvas,
					    d = h.getContext("2d"),
					    f = t.length;h.width = e, h.height = i;for (var p = 0; p < f; ++p) {
						var g = t[p],
						    m = g[0],
						    v = g[1],
						    y = g[2],
						    x = n(y);d.globalAlpha = x, d.drawImage(s, m - c, v - c);
					}for (var _ = d.getImageData(0, 0, h.width, h.height), b = _.data, w = 0, S = b.length, M = this.minOpacity, I = this.maxOpacity, T = I - M; w < S;) {
						var x = b[w + 3] / 256,
						    A = 4 * Math.floor(x * (a - 1));if (x > 0) {
							var C = r(x) ? l : u;x > 0 && (x = x * T + M), b[w++] = C[A], b[w++] = C[A + 1], b[w++] = C[A + 2], b[w++] = C[A + 3] * x * 256;
						} else w += 4;
					}return d.putImageData(_, 0, 0), h;
				}, _getBrush: function _getBrush() {
					var t = this._brushCanvas || (this._brushCanvas = o.createCanvas()),
					    e = this.pointSize + this.blurSize,
					    i = 2 * e;t.width = i, t.height = i;var n = t.getContext("2d");return n.clearRect(0, 0, i, i), n.shadowOffsetX = i, n.shadowBlur = this.blurSize, n.shadowColor = "#000", n.beginPath(), n.arc(-e, e, this.pointSize, 0, 2 * Math.PI, !0), n.closePath(), n.fill(), t;
				}, _getGradient: function _getGradient(t, e, i) {
					for (var n = this._gradientPixels, a = n[i] || (n[i] = new Uint8ClampedArray(1024)), o = [0, 0, 0, 0], r = 0, s = 0; s < 256; s++) {
						e[i](s / 255, !0, o), a[r++] = o[0], a[r++] = o[1], a[r++] = o[2], a[r++] = o[3];
					}return a;
				} }, t.exports = n;
		}, function (t, e, i) {
			var n = i(17),
			    a = i(28);t.exports = n.extend({ type: "series.heatmap", getInitialData: function getInitialData(t, e) {
					return a(t.data, this, e);
				}, defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, geoIndex: 0, blurSize: 30, pointSize: 20, maxOpacity: 1, minOpacity: 0 } });
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = t[1] - t[0];e = l.map(e, function (e) {
					return { interval: [(e.interval[0] - t[0]) / n, (e.interval[1] - t[0]) / n] };
				});var a = e.length,
				    o = 0;return function (t) {
					for (var n = o; n < a; n++) {
						var r = e[n].interval;if (r[0] <= t && t <= r[1]) {
							o = n;break;
						}
					}if (n === a) for (var n = o - 1; n >= 0; n--) {
						var r = e[n].interval;if (r[0] <= t && t <= r[1]) {
							o = n;break;
						}
					}return n >= 0 && n < a && i[n];
				};
			}function a(t, e) {
				var i = t[1] - t[0];return e = [(e[0] - t[0]) / i, (e[1] - t[0]) / i], function (t) {
					return t >= e[0] && t <= e[1];
				};
			}function o(t) {
				var e = t.dimensions;return "lng" === e[0] && "lat" === e[1];
			}var r = i(3),
			    s = i(307),
			    l = i(1);t.exports = i(2).extendChartView({ type: "heatmap", render: function render(t, e, i) {
					var n;e.eachComponent("visualMap", function (e) {
						e.eachTargetSeries(function (i) {
							i === t && (n = e);
						});
					}), this.group.removeAll();var a = t.coordinateSystem;"cartesian2d" === a.type || "calendar" === a.type ? this._renderOnCartesianAndCalendar(a, t, i) : o(a) && this._renderOnGeo(a, t, n, i);
				}, dispose: function dispose() {}, _renderOnCartesianAndCalendar: function _renderOnCartesianAndCalendar(t, e, i) {
					if ("cartesian2d" === t.type) var n = t.getAxis("x"),
					    a = t.getAxis("y"),
					    o = n.getBandWidth(),
					    s = a.getBandWidth();var u = this.group,
					    c = e.getData(),
					    h = "itemStyle.normal",
					    d = "itemStyle.emphasis",
					    f = "label.normal",
					    p = "label.emphasis",
					    g = e.getModel(h).getItemStyle(["color"]),
					    m = e.getModel(d).getItemStyle(),
					    v = e.getModel("label.normal"),
					    y = e.getModel("label.emphasis"),
					    x = t.type,
					    _ = "cartesian2d" === x ? [e.coordDimToDataDim("x")[0], e.coordDimToDataDim("y")[0], e.coordDimToDataDim("value")[0]] : [e.coordDimToDataDim("time")[0], e.coordDimToDataDim("value")[0]];c.each(function (i) {
						var n;if ("cartesian2d" === x) {
							if (isNaN(c.get(_[2], i))) return;var a = t.dataToPoint([c.get(_[0], i), c.get(_[1], i)]);n = new r.Rect({ shape: { x: a[0] - o / 2, y: a[1] - s / 2, width: o, height: s }, style: { fill: c.getItemVisual(i, "color"), opacity: c.getItemVisual(i, "opacity") } });
						} else {
							if (isNaN(c.get(_[1], i))) return;n = new r.Rect({ z2: 1, shape: t.dataToRect([c.get(_[0], i)]).contentShape, style: { fill: c.getItemVisual(i, "color"), opacity: c.getItemVisual(i, "opacity") } });
						}var b = c.getItemModel(i);c.hasItemOption && (g = b.getModel(h).getItemStyle(["color"]), m = b.getModel(d).getItemStyle(), v = b.getModel(f), y = b.getModel(p));var w = e.getRawValue(i),
						    S = "-";w && null != w[2] && (S = w[2]), v.getShallow("show") && (r.setText(g, v), g.text = e.getFormattedLabel(i, "normal") || S), y.getShallow("show") && (r.setText(m, y), m.text = e.getFormattedLabel(i, "emphasis") || S), n.setStyle(g), r.setHoverStyle(n, c.hasItemOption ? m : l.extend({}, m)), u.add(n), c.setItemGraphicEl(i, n);
					});
				}, _renderOnGeo: function _renderOnGeo(t, e, i, o) {
					var l = i.targetVisuals.inRange,
					    u = i.targetVisuals.outOfRange,
					    c = e.getData(),
					    h = this._hmLayer || this._hmLayer || new s();h.blurSize = e.get("blurSize"), h.pointSize = e.get("pointSize"), h.minOpacity = e.get("minOpacity"), h.maxOpacity = e.get("maxOpacity");var d = t.getViewRect().clone(),
					    f = t.getRoamTransform().transform;d.applyTransform(f);var p = Math.max(d.x, 0),
					    g = Math.max(d.y, 0),
					    m = Math.min(d.width + d.x, o.getWidth()),
					    v = Math.min(d.height + d.y, o.getHeight()),
					    y = m - p,
					    x = v - g,
					    _ = c.mapArray(["lng", "lat", "value"], function (e, i, n) {
						var a = t.dataToPoint([e, i]);return a[0] -= p, a[1] -= g, a.push(n), a;
					}),
					    b = i.getExtent(),
					    w = "visualMap.continuous" === i.type ? a(b, i.option.range) : n(b, i.getPieceList(), i.option.selected);h.update(_, y, x, l.color.getNormalizer(), { inRange: l.color.getColorMapper(), outOfRange: u.color.getColorMapper() }, w);var S = new r.Image({ style: { width: y, height: x, x: p, y: g, image: h.canvas }, silent: !0 });this.group.add(S);
				} });
		}, function (t, e, i) {
			function n(t, e, i) {
				r.call(this, t, e, i), this._lastFrame = 0, this._lastFramePercent = 0;
			}var a = i(246),
			    o = i(1),
			    r = i(245),
			    s = i(6),
			    l = n.prototype;l.createLine = function (t, e, i) {
				return new a(t, e, i);
			}, l.updateAnimationPoints = function (t, e) {
				this._points = e;for (var i = [0], n = 0, a = 1; a < e.length; a++) {
					var o = e[a - 1],
					    r = e[a];n += s.dist(o, r), i.push(n);
				}if (0 !== n) {
					for (var a = 0; a < i.length; a++) {
						i[a] /= n;
					}this._offsets = i, this._length = n;
				}
			}, l.getLineLength = function (t) {
				return this._length;
			}, l.updateSymbolPosition = function (t) {
				var e = t.__t,
				    i = this._points,
				    n = this._offsets,
				    a = i.length;if (n) {
					var o,
					    r = this._lastFrame;if (e < this._lastFramePercent) {
						var l = Math.min(r + 1, a - 1);for (o = l; o >= 0 && !(n[o] <= e); o--) {}o = Math.min(o, a - 2);
					} else {
						for (var o = r; o < a && !(n[o] > e); o++) {}o = Math.min(o - 1, a - 2);
					}s.lerp(t.position, i[o], i[o + 1], (e - n[o]) / (n[o + 1] - n[o]));var u = i[o + 1][0] - i[o][0],
					    c = i[o + 1][1] - i[o][1];t.rotation = -Math.atan2(c, u) - Math.PI / 2, this._lastFrame = o, this._lastFramePercent = e, t.ignore = !1;
				}
			}, o.inherits(n, r), t.exports = n;
		}, function (t, e, i) {
			function n(t) {
				return r.isArray(t) || (t = [+t, +t]), t;
			}function a(t, e) {
				t.eachChild(function (t) {
					t.attr({ z: e.z, zlevel: e.zlevel, style: { stroke: "stroke" === e.brushType ? e.color : null, fill: "fill" === e.brushType ? e.color : null } });
				});
			}function o(t, e) {
				h.call(this);var i = new c(t, e),
				    n = new h();this.add(i), this.add(n), n.beforeUpdate = function () {
					this.attr(i.getScale());
				}, this.updateData(t, e);
			}var r = i(1),
			    s = i(24),
			    l = i(3),
			    u = i(4),
			    c = i(54),
			    h = l.Group,
			    d = 3,
			    f = o.prototype;f.stopEffectAnimation = function () {
				this.childAt(1).removeAll();
			}, f.startEffectAnimation = function (t) {
				for (var e = t.symbolType, i = t.color, n = this.childAt(1), o = 0; o < d; o++) {
					var r = s.createSymbol(e, -1, -1, 2, 2, i);r.attr({ style: { strokeNoScale: !0 }, z2: 99, silent: !0, scale: [.5, .5] });var l = -o / d * t.period + t.effectOffset;r.animate("", !0).when(t.period, { scale: [t.rippleScale / 2, t.rippleScale / 2] }).delay(l).start(), r.animateStyle(!0).when(t.period, { opacity: 0 }).delay(l).start(), n.add(r);
				}a(n, t);
			}, f.updateEffectAnimation = function (t) {
				for (var e = this._effectCfg, i = this.childAt(1), n = ["symbolType", "period", "rippleScale"], o = 0; o < n; o++) {
					var r = n[o];if (e[r] !== t[r]) return this.stopEffectAnimation(), void this.startEffectAnimation(t);
				}a(i, t);
			}, f.highlight = function () {
				this.trigger("emphasis");
			}, f.downplay = function () {
				this.trigger("normal");
			}, f.updateData = function (t, e) {
				var i = t.hostModel;this.childAt(0).updateData(t, e);var a = this.childAt(1),
				    o = t.getItemModel(e),
				    r = t.getItemVisual(e, "symbol"),
				    s = n(t.getItemVisual(e, "symbolSize")),
				    l = t.getItemVisual(e, "color");a.attr("scale", s), a.traverse(function (t) {
					t.attr({ fill: l });
				});var c = o.getShallow("symbolOffset");if (c) {
					var h = a.position;h[0] = u.parsePercent(c[0], s[0]), h[1] = u.parsePercent(c[1], s[1]);
				}a.rotation = (o.getShallow("symbolRotate") || 0) * Math.PI / 180 || 0;var d = {};if (d.showEffectOn = i.get("showEffectOn"), d.rippleScale = o.get("rippleEffect.scale"), d.brushType = o.get("rippleEffect.brushType"), d.period = 1e3 * o.get("rippleEffect.period"), d.effectOffset = e / t.count(), d.z = o.getShallow("z") || 0, d.zlevel = o.getShallow("zlevel") || 0, d.symbolType = r, d.color = l, this.off("mouseover").off("mouseout").off("emphasis").off("normal"), "render" === d.showEffectOn) this._effectCfg ? this.updateEffectAnimation(d) : this.startEffectAnimation(d), this._effectCfg = d;else {
					this._effectCfg = null, this.stopEffectAnimation();var f = this.childAt(0),
					    p = function p() {
						f.trigger("emphasis"), "render" !== d.showEffectOn && this.startEffectAnimation(d);
					},
					    g = function g() {
						f.trigger("normal"), "render" !== d.showEffectOn && this.stopEffectAnimation();
					};this.on("mouseover", p, this).on("mouseout", g, this).on("emphasis", p, this).on("normal", g, this);
				}this._effectCfg = d;
			}, f.fadeOut = function (t) {
				this.off("mouseover").off("mouseout").off("emphasis").off("normal"), t && t();
			}, r.inherits(o, h), t.exports = o;
		}, function (t, e, i) {
			function n() {
				this.group = new a.Group(), this._lineEl = new s();
			}var a = i(3),
			    o = i(98),
			    r = i(97),
			    s = a.extendShape({ shape: { polyline: !1, segs: [] }, buildPath: function buildPath(t, e) {
					for (var i = e.segs, n = e.polyline, a = 0; a < i.length; a++) {
						var o = i[a];if (n) {
							t.moveTo(o[0][0], o[0][1]);for (var r = 1; r < o.length; r++) {
								t.lineTo(o[r][0], o[r][1]);
							}
						} else t.moveTo(o[0][0], o[0][1]), o.length > 2 ? t.quadraticCurveTo(o[2][0], o[2][1], o[1][0], o[1][1]) : t.lineTo(o[1][0], o[1][1]);
					}
				}, findDataIndex: function findDataIndex(t, e) {
					for (var i = this.shape, n = i.segs, a = i.polyline, s = Math.max(this.style.lineWidth, 1), l = 0; l < n.length; l++) {
						var u = n[l];if (a) {
							for (var c = 1; c < u.length; c++) {
								if (r.containStroke(u[c - 1][0], u[c - 1][1], u[c][0], u[c][1], s, t, e)) return l;
							}
						} else if (u.length > 2) {
							if (o.containStroke(u[0][0], u[0][1], u[2][0], u[2][1], u[1][0], u[1][1], s, t, e)) return l;
						} else if (r.containStroke(u[0][0], u[0][1], u[1][0], u[1][1], s, t, e)) return l;
					}return -1;
				} }),
			    l = n.prototype;l.updateData = function (t) {
				this.group.removeAll();var e = this._lineEl,
				    i = t.hostModel;e.setShape({ segs: t.mapArray(t.getItemLayout), polyline: i.get("polyline") }), e.useStyle(i.getModel("lineStyle.normal").getLineStyle());var n = t.getVisual("color");n && e.setStyle("stroke", n), e.setStyle("fill"), e.seriesIndex = i.seriesIndex, e.on("mousemove", function (t) {
					e.dataIndex = null;var i = e.findDataIndex(t.offsetX, t.offsetY);i > 0 && (e.dataIndex = i);
				}), this.group.add(e);
			}, l.updateLayout = function (t) {
				var e = t.getData();this._lineEl.setShape({ segs: e.mapArray(e.getItemLayout) });
			}, l.remove = function () {
				this.group.removeAll();
			}, t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i, n) {
				l.Group.call(this), this.bodyIndex, this.whiskerIndex, this.styleUpdater = i, this._createContent(t, e, n), this.updateData(t, e, n), this._seriesModel;
			}function a(t, e, i) {
				return s.map(t, function (t) {
					return t = t.slice(), t[e] = i.initBaseline, t;
				});
			}function o(t) {
				var e = {};return s.each(t, function (t, i) {
					e["ends" + i] = t;
				}), e;
			}function r(t) {
				this.group = new l.Group(), this.styleUpdater = t;
			}var s = i(1),
			    l = i(3),
			    u = i(8),
			    c = u.extend({ type: "whiskerInBox", shape: {}, buildPath: function buildPath(t, e) {
					for (var i in e) {
						if (e.hasOwnProperty(i) && 0 === i.indexOf("ends")) {
							var n = e[i];t.moveTo(n[0][0], n[0][1]), t.lineTo(n[1][0], n[1][1]);
						}
					}
				} }),
			    h = n.prototype;h._createContent = function (t, e, i) {
				var n = t.getItemLayout(e),
				    r = "horizontal" === n.chartLayout ? 1 : 0,
				    u = 0;this.add(new l.Polygon({ shape: { points: i ? a(n.bodyEnds, r, n) : n.bodyEnds }, style: { strokeNoScale: !0 }, z2: 100 })), this.bodyIndex = u++;var h = s.map(n.whiskerEnds, function (t) {
					return i ? a(t, r, n) : t;
				});this.add(new c({ shape: o(h), style: { strokeNoScale: !0 }, z2: 100 })), this.whiskerIndex = u++;
			}, h.updateData = function (t, e, i) {
				var n = this._seriesModel = t.hostModel,
				    a = t.getItemLayout(e),
				    r = l[i ? "initProps" : "updateProps"];r(this.childAt(this.bodyIndex), { shape: { points: a.bodyEnds } }, n, e), r(this.childAt(this.whiskerIndex), { shape: o(a.whiskerEnds) }, n, e), this.styleUpdater.call(null, this, t, e);
			}, s.inherits(n, l.Group);var d = r.prototype;d.updateData = function (t) {
				var e = this.group,
				    i = this._data,
				    a = this.styleUpdater;t.diff(i).add(function (i) {
					if (t.hasValue(i)) {
						var o = new n(t, i, a, !0);t.setItemGraphicEl(i, o), e.add(o);
					}
				}).update(function (o, r) {
					var s = i.getItemGraphicEl(r);return t.hasValue(o) ? (s ? s.updateData(t, o) : s = new n(t, o, a), e.add(s), void t.setItemGraphicEl(o, s)) : void e.remove(s);
				}).remove(function (t) {
					var n = i.getItemGraphicEl(t);n && e.remove(n);
				}).execute(), this._data = t;
			}, d.remove = function () {
				var t = this.group,
				    e = this._data;this._data = null, e && e.eachItemGraphicEl(function (e) {
					e && t.remove(e);
				});
			}, t.exports = r;
		}, function (t, e, i) {
			i(315), i(316);var n = i(2);n.registerLayout(i(317)), n.registerVisual(i(318));
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				var e = t.data;e && e[0] && e[0][0] && e[0][0].coord && (t.data = r.map(e, function (t) {
					var e = [t[0].coord, t[1].coord],
					    i = { coords: e };return t[0].name && (i.fromName = t[0].name), t[1].name && (i.toName = t[1].name), r.mergeAll([i, t[0], t[1]]);
				}));
			}var a = i(17),
			    o = i(14),
			    r = i(1),
			    s = i(7),
			    l = (i(26), a.extend({ type: "series.lines", dependencies: ["grid", "polar"], visualColorAccessPath: "lineStyle.normal.color", init: function init(t) {
					n(t), l.superApply(this, "init", arguments);
				}, mergeOption: function mergeOption(t) {
					n(t), l.superApply(this, "mergeOption", arguments);
				}, getInitialData: function getInitialData(t, e) {
					var i = new o(["value"], this);return i.hasItemOption = !1, i.initData(t.data, [], function (t, e, n, a) {
						if (t instanceof Array) return NaN;i.hasItemOption = !0;var o = t.value;return null != o ? o instanceof Array ? o[a] : o : void 0;
					}), i;
				}, formatTooltip: function formatTooltip(t) {
					var e = this.getData(),
					    i = e.getItemModel(t),
					    n = i.get("name");if (n) return n;var a = i.get("fromName"),
					    o = i.get("toName"),
					    r = [];return null != a && r.push(a), null != o && r.push(o), s.encodeHTML(r.join(" > "));
				}, defaultOption: { coordinateSystem: "geo", zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, xAxisIndex: 0, yAxisIndex: 0, symbol: ["none", "none"], symbolSize: [10, 10], geoIndex: 0, effect: { show: !1, period: 4, constantSpeed: 0, symbol: "circle", symbolSize: 3, loop: !0, trailLength: .2 }, large: !1, largeThreshold: 2e3, polyline: !1, label: { normal: { show: !1, position: "end" } }, lineStyle: { normal: { opacity: .5 } } } }));
		}, function (t, e, i) {
			var n = i(107),
			    a = i(245),
			    o = i(106),
			    r = i(246),
			    s = i(310),
			    l = i(312);i(2).extendChartView({ type: "lines", init: function init() {}, render: function render(t, e, i) {
					var u = t.getData(),
					    c = this._lineDraw,
					    h = t.get("effect.show"),
					    d = t.get("polyline"),
					    f = t.get("large") && u.count() >= t.get("largeThreshold");h === this._hasEffet && d === this._isPolyline && f === this._isLarge || (c && c.remove(), c = this._lineDraw = f ? new l() : new n(d ? h ? s : r : h ? a : o), this._hasEffet = h, this._isPolyline = d, this._isLarge = f);var p = t.get("zlevel"),
					    g = t.get("effect.trailLength"),
					    m = i.getZr();if (m.painter.getLayer(p).clear(!0), null != this._lastZlevel && m.configLayer(this._lastZlevel, { motionBlur: !1 }), h && g) {
						m.configLayer(p, { motionBlur: !0, lastFrameAlpha: Math.max(Math.min(g / 10 + .9, 1), 0) });
					}this.group.add(c.group), c.updateData(u), this._lastZlevel = p;
				}, updateLayout: function updateLayout(t, e, i) {
					this._lineDraw.updateLayout(t);var n = i.getZr();n.painter.getLayer(this._lastZlevel).clear(!0);
				}, remove: function remove(t, e) {
					this._lineDraw && this._lineDraw.remove(e, !0);
				}, dispose: function dispose() {} });
		}, function (t, e, i) {
			t.exports = function (t) {
				t.eachSeriesByType("lines", function (t) {
					var e = t.coordinateSystem,
					    i = t.getData();i.each(function (n) {
						var a = i.getItemModel(n),
						    o = a.option instanceof Array ? a.option : a.get("coords"),
						    r = [];if (t.get("polyline")) for (var s = 0; s < o.length; s++) {
							r.push(e.dataToPoint(o[s]));
						} else {
							r[0] = e.dataToPoint(o[0]), r[1] = e.dataToPoint(o[1]);var l = a.get("lineStyle.normal.curveness");+l && (r[2] = [(r[0][0] + r[1][0]) / 2 - (r[0][1] - r[1][1]) * l, (r[0][1] + r[1][1]) / 2 - (r[1][0] - r[0][0]) * l]);
						}i.setItemLayout(n, r);
					});
				});
			};
		}, function (t, e) {
			function i(t) {
				return t instanceof Array || (t = [t, t]), t;
			}t.exports = function (t) {
				t.eachSeriesByType("lines", function (t) {
					var e = t.getData(),
					    n = i(t.get("symbol")),
					    a = i(t.get("symbolSize")),
					    o = "lineStyle.normal.opacity".split(".");e.setVisual("fromSymbol", n && n[0]), e.setVisual("toSymbol", n && n[1]), e.setVisual("fromSymbolSize", a && a[0]), e.setVisual("toSymbolSize", a && a[1]), e.setVisual("opacity", t.get(o)), e.each(function (t) {
						var n = e.getItemModel(t),
						    a = i(n.getShallow("symbol", !0)),
						    r = i(n.getShallow("symbolSize", !0)),
						    s = n.get(o);a[0] && e.setItemVisual(t, "fromSymbol", a[0]), a[1] && e.setItemVisual(t, "toSymbol", a[1]), r[0] && e.setItemVisual(t, "fromSymbolSize", r[0]), r[1] && e.setItemVisual(t, "toSymbolSize", r[1]), e.setItemVisual(t, "opacity", s);
					});
				});
			};
		}, function (t, e, i) {
			var n = i(2),
			    a = n.PRIORITY;i(320), i(321), i(240), i(186), n.registerLayout(i(324)), n.registerVisual(i(325)), n.registerProcessor(a.PROCESSOR.STATISTIC, i(323)), n.registerPreprocessor(i(322)), i(89)("map", [{ type: "mapToggleSelect", event: "mapselectchanged", method: "toggleSelected" }, { type: "mapSelect", event: "mapselected", method: "select" }, { type: "mapUnSelect", event: "mapunselected", method: "unSelect" }]);
		}, function (t, e, i) {
			var n = i(14),
			    a = i(17),
			    o = i(1),
			    r = i(25),
			    s = i(7),
			    l = s.encodeHTML,
			    u = s.addCommas,
			    c = i(78),
			    h = i(186),
			    d = a.extend({ type: "series.map", dependencies: ["geo"], layoutMode: "box", needsDrawMap: !1, seriesGroup: [], init: function init(t) {
					t = this._fillOption(t, this.getMapType()), this.option = t, d.superApply(this, "init", arguments), this.updateSelectedMap(t.data);
				}, getInitialData: function getInitialData(t) {
					var e = r(["value"], t.data || []),
					    i = new n(e, this);return i.initData(t.data), i;
				}, mergeOption: function mergeOption(t) {
					t.data && (t = this._fillOption(t, this.getMapType())), d.superCall(this, "mergeOption", t), this.updateSelectedMap(this.option.data);
				}, getHostGeoModel: function getHostGeoModel() {
					var t = this.option.geoIndex;return null != t ? this.dependentModels.geo[t] : null;
				}, getMapType: function getMapType() {
					return (this.getHostGeoModel() || this).option.map;
				}, _fillOption: function _fillOption(t, e) {
					return t = o.extend({}, t), t.data = h.getFilledRegions(t.data, e), t;
				}, getRawValue: function getRawValue(t) {
					return this.getData().get("value", t);
				}, getRegionModel: function getRegionModel(t) {
					var e = this.getData();return e.getItemModel(e.indexOfName(t));
				}, formatTooltip: function formatTooltip(t) {
					for (var e = this.getData(), i = u(this.getRawValue(t)), n = e.getName(t), a = this.seriesGroup, o = [], r = 0; r < a.length; r++) {
						var s = a[r].originalData.indexOfName(n);isNaN(a[r].originalData.get("value", s)) || o.push(l(a[r].name));
					}return o.join(", ") + "<br />" + l(n + " : " + i);
				}, getTooltipPosition: function getTooltipPosition(t) {
					if (null != t) {
						var e = this.getData().getName(t),
						    i = this.coordinateSystem,
						    n = i.getRegion(e);return n && i.dataToPoint(n.center);
					}
				}, setZoom: function setZoom(t) {
					this.option.zoom = t;
				}, setCenter: function setCenter(t) {
					this.option.center = t;
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "geo", map: "", left: "center", top: "center", aspectScale: .75, showLegendSymbol: !0, dataRangeHoverLink: !0, boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { normal: { show: !1, textStyle: { color: "#000" } }, emphasis: { show: !0, textStyle: { color: "rgb(100,0,0)" } } }, itemStyle: { normal: { borderWidth: .5, borderColor: "#444", areaColor: "#eee" }, emphasis: { areaColor: "rgba(255,215,0,0.8)" } } } });o.mixin(d, c), t.exports = d;
		}, function (t, e, i) {
			var n = i(3),
			    a = i(249);i(2).extendChartView({ type: "map", render: function render(t, e, i, n) {
					if (!n || "mapToggleSelect" !== n.type || n.from !== this.uid) {
						var o = this.group;if (o.removeAll(), !t.getHostGeoModel()) {
							if (n && "geoRoam" === n.type && "series" === n.componentType && n.seriesId === t.id) {
								var r = this._mapDraw;r && o.add(r.group);
							} else if (t.needsDrawMap) {
								var r = this._mapDraw || new a(i, !0);o.add(r.group), r.draw(t, e, i, this, n), this._mapDraw = r;
							} else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;t.get("showLegendSymbol") && e.getComponent("legend") && this._renderSymbols(t, e, i);
						}
					}
				}, remove: function remove() {
					this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
				}, dispose: function dispose() {
					this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
				}, _renderSymbols: function _renderSymbols(t, e, i) {
					var a = t.originalData,
					    o = this.group;a.each("value", function (e, i) {
						if (!isNaN(e)) {
							var r = a.getItemLayout(i);if (r && r.point) {
								var s = r.point,
								    l = r.offset,
								    u = new n.Circle({ style: { fill: t.getData().getVisual("color") }, shape: { cx: s[0] + 9 * l, cy: s[1], r: 3 }, silent: !0, z2: 10 });if (!l) {
									var c = t.mainSeries.getData(),
									    h = a.getName(i),
									    d = h,
									    f = c.indexOfName(h),
									    p = a.getItemModel(i),
									    g = p.getModel("label.normal"),
									    m = p.getModel("label.emphasis"),
									    v = g.getModel("textStyle"),
									    y = m.getModel("textStyle"),
									    x = c.getItemGraphicEl(f);u.setStyle({ textPosition: "bottom" });var _ = function _() {
										u.setStyle({ text: m.get("show") ? d : "", textFill: y.getTextColor(), textFont: y.getFont() });
									},
									    b = function b() {
										u.setStyle({ text: g.get("show") ? d : "", textFill: v.getTextColor(), textFont: v.getFont() });
									};x.on("mouseover", _).on("mouseout", b).on("emphasis", _).on("normal", b), b();
								}o.add(u);
							}
						}
					});
				} });
		}, function (t, e, i) {
			var n = i(1);t.exports = function (t) {
				var e = [];n.each(t.series, function (t) {
					"map" === t.type && e.push(t);
				}), n.each(e, function (t) {
					t.map = t.map || t.mapType, n.defaults(t, t.mapLocation);
				});
			};
		}, function (t, e, i) {
			function n(t, e) {
				var i = {},
				    n = ["value"];return a.each(t, function (t) {
					t.each(n, function (e, n) {
						var a = "ec-" + t.getName(n);i[a] = i[a] || [], isNaN(e) || i[a].push(e);
					});
				}), t[0].map(n, function (n, a) {
					for (var o = "ec-" + t[0].getName(a), r = 0, s = 1 / 0, l = -(1 / 0), u = i[o].length, c = 0; c < u; c++) {
						s = Math.min(s, i[o][c]), l = Math.max(l, i[o][c]), r += i[o][c];
					}var h;return h = "min" === e ? s : "max" === e ? l : "average" === e ? r / u : r, 0 === u ? NaN : h;
				});
			}var a = i(1);t.exports = function (t) {
				var e = {};t.eachSeriesByType("map", function (t) {
					var i = t.getHostGeoModel(),
					    n = i ? "o" + i.id : "i" + t.getMapType();(e[n] = e[n] || []).push(t);
				}), a.each(e, function (t, e) {
					for (var i = n(a.map(t, function (t) {
						return t.getData();
					}), t[0].get("mapValueCalculation")), o = 0; o < t.length; o++) {
						t[o].originalData = t[o].getData();
					}for (var o = 0; o < t.length; o++) {
						t[o].seriesGroup = t, t[o].needsDrawMap = 0 === o && !t[o].getHostGeoModel(), t[o].setData(i.cloneShallow()), t[o].mainSeries = t[0];
					}
				});
			};
		}, function (t, e, i) {
			var n = i(1);t.exports = function (t) {
				var e = {};t.eachSeriesByType("map", function (i) {
					var a = i.getMapType();if (!i.getHostGeoModel() && !e[a]) {
						var o = {};n.each(i.seriesGroup, function (e) {
							var i = e.coordinateSystem,
							    n = e.originalData;e.get("showLegendSymbol") && t.getComponent("legend") && n.each("value", function (t, e) {
								var a = n.getName(e),
								    r = i.getRegion(a);if (r && !isNaN(t)) {
									var s = o[a] || 0,
									    l = i.dataToPoint(r.center);o[a] = s + 1, n.setItemLayout(e, { point: l, offset: s });
								}
							});
						});var r = i.getData();r.each(function (t) {
							var e = r.getName(t),
							    i = r.getItemLayout(t) || {};i.showLabel = !o[e], r.setItemLayout(t, i);
						}), e[a] = !0;
					}
				});
			};
		}, function (t, e) {
			t.exports = function (t) {
				t.eachSeriesByType("map", function (t) {
					var e = t.get("color"),
					    i = t.getModel("itemStyle.normal"),
					    n = i.get("areaColor"),
					    a = i.get("color") || e[t.seriesIndex % e.length];t.getData().setVisual({ areaColor: n, color: a });
				});
			};
		}, function (t, e, i) {
			var n = i(2);i(251), i(327), i(328), n.registerVisual(i(329));
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = t.get("data"),
				    o = a(e);n && n.length && s.each(i, function (t) {
					if (t) {
						var e = s.indexOf(n, t[o]);t[o] = e >= 0 ? e : NaN;
					}
				});
			}function a(t) {
				return +t.replace("dim", "");
			}function o(t, e) {
				var i = 0;s.each(t, function (t) {
					var e = a(t);e > i && (i = e);
				});var n = e[0];n && n.length - 1 > i && (i = n.length - 1);for (var o = [], r = 0; r <= i; r++) {
					o.push("dim" + r);
				}return o;
			}var r = i(14),
			    s = i(1),
			    l = i(17),
			    u = i(25);t.exports = l.extend({ type: "series.parallel", dependencies: ["parallel"], visualColorAccessPath: "lineStyle.normal.color", getInitialData: function getInitialData(t, e) {
					var i = e.getComponent("parallel", this.get("parallelIndex")),
					    a = i.parallelAxisIndex,
					    l = t.data,
					    c = i.dimensions,
					    h = o(c, l),
					    d = s.map(h, function (t, i) {
						var o = s.indexOf(c, t),
						    r = o >= 0 && e.getComponent("parallelAxis", a[o]);return r && "category" === r.get("type") ? (n(r, t, l), { name: t, type: "ordinal" }) : o < 0 && u.guessOrdinal(l, i) ? { name: t, type: "ordinal" } : t;
					}),
					    f = new r(d, this);return f.initData(l), this.option.progressive && (this.option.animation = !1), f;
				}, getRawIndicesByActiveState: function getRawIndicesByActiveState(t) {
					var e = this.coordinateSystem,
					    i = this.getData(),
					    n = [];return e.eachActiveState(i, function (e, a) {
						t === e && n.push(i.getRawIndex(a));
					}), n;
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "parallel", parallelIndex: 0, label: { normal: { show: !1 }, emphasis: { show: !1 } }, inactiveOpacity: .05, activeOpacity: 1, lineStyle: { normal: { width: 1, opacity: .45, type: "solid" } }, progressive: !1, smooth: !1, animationEasing: "linear" } });
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = t.model,
				    a = t.getRect(),
				    o = new l.Rect({ shape: { x: a.x, y: a.y, width: a.width, height: a.height } }),
				    r = "horizontal" === n.get("layout") ? "width" : "height";return o.setShape(r, 0), l.initProps(o, { shape: { width: a.width, height: a.height } }, e, i), o;
			}function a(t, e, i, n) {
				for (var a = [], o = 0; o < i.length; o++) {
					var r = i[o],
					    l = t.get(r, e);s(l, n.getAxis(r).type) || a.push(n.dataToPoint(l, r));
				}return a;
			}function o(t, e, i, n, o) {
				var r = a(t, i, n, o),
				    s = new l.Polyline({ shape: { points: r }, silent: !0, z2: 10 });e.add(s), t.setItemGraphicEl(i, s);
			}function r(t, e) {
				var i = t.hostModel.getModel("lineStyle.normal"),
				    n = i.getLineStyle();t.eachItemGraphicEl(function (a, o) {
					if (t.hasItemOption) {
						var r = t.getItemModel(o),
						    s = r.getModel("lineStyle.normal", i);n = s.getLineStyle(["color", "stroke"]);
					}a.useStyle(u.extend(n, { fill: null, stroke: t.getItemVisual(o, "color"), opacity: t.getItemVisual(o, "opacity") })), a.shape.smooth = e;
				});
			}function s(t, e) {
				return "category" === e ? null == t : null == t || isNaN(t);
			}var l = i(3),
			    u = i(1),
			    c = .3,
			    h = i(30).extend({ type: "parallel", init: function init() {
					this._dataGroup = new l.Group(), this.group.add(this._dataGroup), this._data;
				}, render: function render(t, e, i, n) {
					this._renderForNormal(t, n);
				}, dispose: function dispose() {}, _renderForNormal: function _renderForNormal(t, e) {
					function i(t) {
						o(d, h, t, g, p, null, v);
					}function s(i, n) {
						var o = f.getItemGraphicEl(n),
						    r = a(d, i, g, p);d.setItemGraphicEl(i, o);var s = e && e.animation === !1 ? null : t;l.updateProps(o, { shape: { points: r } }, s, i);
					}function u(t) {
						var e = f.getItemGraphicEl(t);h.remove(e);
					}var h = this._dataGroup,
					    d = t.getData(),
					    f = this._data,
					    p = t.coordinateSystem,
					    g = p.dimensions,
					    m = t.option,
					    v = m.smooth ? c : null;if (d.diff(f).add(i).update(s).remove(u).execute(), r(d, v), !this._data) {
						var y = n(p, t, function () {
							setTimeout(function () {
								h.removeClipPath();
							});
						});h.setClipPath(y);
					}this._data = d;
				}, remove: function remove() {
					this._dataGroup && this._dataGroup.removeAll(), this._data = null;
				} });t.exports = h;
		}, function (t, e) {
			var i = ["lineStyle", "normal", "opacity"];t.exports = function (t) {
				t.eachSeriesByType("parallel", function (e) {
					var n = e.getModel("itemStyle.normal"),
					    a = e.getModel("lineStyle.normal"),
					    o = t.get("color"),
					    r = a.get("color") || n.get("color") || o[e.seriesIndex % o.length],
					    s = e.get("inactiveOpacity"),
					    l = e.get("activeOpacity"),
					    u = e.getModel("lineStyle.normal").getLineStyle(),
					    c = e.coordinateSystem,
					    h = e.getData(),
					    d = { normal: u.opacity, active: l, inactive: s };c.eachActiveState(h, function (t, e) {
						var n = h.getItemModel(e),
						    a = d[t];if ("normal" === t) {
							var o = n.get(i, !0);null != o && (a = o);
						}h.setItemVisual(e, "opacity", a);
					}), h.setVisual("color", r);
				});
			};
		}, function (t, e, i) {
			var n = i(1);i(57), i(268), i(269);var a = i(82),
			    o = i(2);o.registerLayout(n.curry(a, "pictorialBar")), o.registerVisual(n.curry(i(50), "pictorialBar", "roundRect", null)), i(32);
		}, function (t, e, i) {
			var n = i(1),
			    a = i(2);i(374), i(332), i(333), a.registerVisual(n.curry(i(84), "radar")), a.registerVisual(n.curry(i(50), "radar", "circle", null)), a.registerLayout(i(335)), a.registerProcessor(n.curry(i(63), "radar")), a.registerPreprocessor(i(334));
		}, function (t, e, i) {
			"use strict";
			var n = i(17),
			    a = i(14),
			    o = i(25),
			    r = i(1),
			    s = i(7).encodeHTML,
			    l = n.extend({ type: "series.radar", dependencies: ["radar"], init: function init(t) {
					l.superApply(this, "init", arguments), this.legendDataProvider = function () {
						return this.getRawData();
					};
				}, getInitialData: function getInitialData(t, e) {
					var i = t.data || [],
					    n = o([], i, { extraPrefix: "indicator_", extraFromZero: !0 }),
					    r = new a(n, this);return r.initData(i), r;
				}, formatTooltip: function formatTooltip(t) {
					var e = this.getRawValue(t),
					    i = this.coordinateSystem,
					    n = i.getIndicatorAxes(),
					    a = this.getData().getName(t);return s("" === a ? this.name : a) + "<br/>" + r.map(n, function (t, i) {
						return s(t.name + " : " + e[i]);
					}).join("<br />");
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "radar", legendHoverLink: !0, radarIndex: 0, lineStyle: { normal: { width: 2, type: "solid" } }, label: { normal: { position: "top" } }, symbol: "emptyCircle", symbolSize: 4 } });t.exports = l;
		}, function (t, e, i) {
			function n(t) {
				return o.isArray(t) || (t = [+t, +t]), t;
			}var a = i(3),
			    o = i(1),
			    r = i(24);t.exports = i(2).extendChartView({ type: "radar", render: function render(t, e, i) {
					function s(t, e) {
						var i = t.getItemVisual(e, "symbol") || "circle",
						    a = t.getItemVisual(e, "color");if ("none" !== i) {
							var o = r.createSymbol(i, -.5, -.5, 1, 1, a);return o.attr({ style: { strokeNoScale: !0 }, z2: 100, scale: n(t.getItemVisual(e, "symbolSize")) }), o;
						}
					}function l(e, i, n, o, r, l) {
						n.removeAll();for (var u = 0; u < i.length - 1; u++) {
							var c = s(o, r);c && (c.__dimIdx = u, e[u] ? (c.attr("position", e[u]), a[l ? "initProps" : "updateProps"](c, { position: i[u] }, t, r)) : c.attr("position", i[u]), n.add(c));
						}
					}function u(t) {
						return o.map(t, function (t) {
							return [c.cx, c.cy];
						});
					}var c = t.coordinateSystem,
					    h = this.group,
					    d = t.getData(),
					    f = this._data;d.diff(f).add(function (e) {
						var i = d.getItemLayout(e);if (i) {
							var n = new a.Polygon(),
							    o = new a.Polyline(),
							    r = { shape: { points: i } };n.shape.points = u(i), o.shape.points = u(i), a.initProps(n, r, t, e), a.initProps(o, r, t, e);var s = new a.Group(),
							    c = new a.Group();s.add(o), s.add(n), s.add(c), l(o.shape.points, i, c, d, e, !0), d.setItemGraphicEl(e, s);
						}
					}).update(function (e, i) {
						var n = f.getItemGraphicEl(i),
						    o = n.childAt(0),
						    r = n.childAt(1),
						    s = n.childAt(2),
						    u = { shape: { points: d.getItemLayout(e) } };u.shape.points && (l(o.shape.points, u.shape.points, s, d, e, !1), a.updateProps(o, u, t), a.updateProps(r, u, t), d.setItemGraphicEl(e, n));
					}).remove(function (t) {
						h.remove(f.getItemGraphicEl(t));
					}).execute(), d.eachItemGraphicEl(function (e, i) {
						function n() {
							u.attr("ignore", v);
						}function r() {
							u.attr("ignore", m);
						}var s = d.getItemModel(i),
						    l = e.childAt(0),
						    u = e.childAt(1),
						    c = e.childAt(2),
						    f = d.getItemVisual(i, "color");h.add(e), l.useStyle(o.defaults(s.getModel("lineStyle.normal").getLineStyle(), { fill: "none", stroke: f })), l.hoverStyle = s.getModel("lineStyle.emphasis").getLineStyle();var p = s.getModel("areaStyle.normal"),
						    g = s.getModel("areaStyle.emphasis"),
						    m = p.isEmpty() && p.parentModel.isEmpty(),
						    v = g.isEmpty() && g.parentModel.isEmpty();v = v && m, u.ignore = m, u.useStyle(o.defaults(p.getAreaStyle(), { fill: f, opacity: .7 })), u.hoverStyle = g.getAreaStyle();var y = s.getModel("itemStyle.normal").getItemStyle(["color"]),
						    x = s.getModel("itemStyle.emphasis").getItemStyle(),
						    _ = s.getModel("label.normal"),
						    b = s.getModel("label.emphasis");c.eachChild(function (e) {
							e.setStyle(y), e.hoverStyle = o.clone(x);var n = d.get(d.dimensions[e.__dimIdx], i);a.setText(e.style, _, f), e.setStyle({ text: _.get("show") ? o.retrieve(t.getFormattedLabel(i, "normal", null, e.__dimIdx), n) : "" }), a.setText(e.hoverStyle, b, f), e.hoverStyle.text = b.get("show") ? o.retrieve(t.getFormattedLabel(i, "emphasis", null, e.__dimIdx), n) : "";
						}), e.off("mouseover").off("mouseout").off("normal").off("emphasis"), e.on("emphasis", n).on("mouseover", n).on("normal", r).on("mouseout", r), a.setHoverStyle(e);
					}), this._data = d;
				}, remove: function remove() {
					this.group.removeAll(), this._data = null;
				}, dispose: function dispose() {} });
		}, function (t, e, i) {
			var n = i(1);t.exports = function (t) {
				var e = t.polar;if (e) {
					n.isArray(e) || (e = [e]);var i = [];n.each(e, function (e, a) {
						e.indicator ? (e.type && !e.shape && (e.shape = e.type), t.radar = t.radar || [], n.isArray(t.radar) || (t.radar = [t.radar]), t.radar.push(e)) : i.push(e);
					}), t.polar = i;
				}n.each(t.series, function (t) {
					"radar" === t.type && t.polarIndex && (t.radarIndex = t.polarIndex);
				});
			};
		}, function (t, e) {
			t.exports = function (t) {
				t.eachSeriesByType("radar", function (t) {
					function e(t, e) {
						n[e] = n[e] || [], n[e][o] = a.dataToPoint(t, o);
					}var i = t.getData(),
					    n = [],
					    a = t.coordinateSystem;if (a) {
						for (var o = 0; o < a.getIndicatorAxes().length; o++) {
							var r = i.dimensions[o];i.each(r, e);
						}i.each(function (t) {
							n[t][0] && n[t].push(n[t][0].slice()), i.setItemLayout(t, n[t]);
						});
					}
				});
			};
		}, function (t, e, i) {
			var n = i(2);i(337), i(338), n.registerLayout(i(339)), n.registerVisual(i(340));
		}, function (t, e, i) {
			var n = i(17),
			    a = i(247),
			    o = i(7).encodeHTML,
			    r = n.extend({ type: "series.sankey", layoutInfo: null, getInitialData: function getInitialData(t) {
					var e = t.edges || t.links,
					    i = t.data || t.nodes;if (i && e) {
						var n = a(i, e, this, !0);return n.data;
					}
				}, getGraph: function getGraph() {
					return this.getData().graph;
				}, getEdgeData: function getEdgeData() {
					return this.getGraph().edgeData;
				}, formatTooltip: function formatTooltip(t, e, i) {
					if ("edge" === i) {
						var n = this.getDataParams(t, i),
						    a = n.data,
						    s = a.source + " -- " + a.target;return n.value && (s += " : " + n.value), o(s);
					}return r.superCall(this, "formatTooltip", t, e);
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "view", layout: null, left: "5%", top: "5%", right: "20%", bottom: "5%", nodeWidth: 20, nodeGap: 8, layoutIterations: 32, label: { normal: { show: !0, position: "right", textStyle: { color: "#000", fontSize: 12 } }, emphasis: { show: !0 } }, itemStyle: { normal: { borderWidth: 1, borderColor: "#333" } }, lineStyle: { normal: { color: "#314656", opacity: .2, curveness: .5 }, emphasis: { opacity: .6 } }, animationEasing: "linear", animationDuration: 1e3 } });t.exports = r;
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = new a.Rect({ shape: { x: t.x - 10, y: t.y - 10, width: 0, height: t.height + 20 } });return a.initProps(n, { shape: { width: t.width + 20, height: t.height + 20 } }, e, i), n;
			}var a = i(3),
			    o = i(1),
			    r = a.extendShape({ shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, cpx2: 0, cpy2: 0, extent: 0 }, buildPath: function buildPath(t, e) {
					var i = e.extent / 2;t.moveTo(e.x1, e.y1 - i), t.bezierCurveTo(e.cpx1, e.cpy1 - i, e.cpx2, e.cpy2 - i, e.x2, e.y2 - i), t.lineTo(e.x2, e.y2 + i), t.bezierCurveTo(e.cpx2, e.cpy2 + i, e.cpx1, e.cpy1 + i, e.x1, e.y1 + i), t.closePath();
				} });t.exports = i(2).extendChartView({ type: "sankey", _model: null, render: function render(t, e, i) {
					var s = t.getGraph(),
					    l = this.group,
					    u = t.layoutInfo,
					    c = t.getData(),
					    h = t.getData("edge");this._model = t, l.removeAll(), l.position = [u.x, u.y], s.eachEdge(function (e) {
						var i = new r();i.dataIndex = e.dataIndex, i.seriesIndex = t.seriesIndex, i.dataType = "edge";var n = e.getModel("lineStyle.normal"),
						    o = n.get("curveness"),
						    s = e.node1.getLayout(),
						    u = e.node2.getLayout(),
						    c = e.getLayout();i.shape.extent = Math.max(1, c.dy);var d = s.x + s.dx,
						    f = s.y + c.sy + c.dy / 2,
						    p = u.x,
						    g = u.y + c.ty + c.dy / 2,
						    m = d * (1 - o) + p * o,
						    v = f,
						    y = d * o + p * (1 - o),
						    x = g;switch (i.setShape({ x1: d, y1: f, x2: p, y2: g, cpx1: m, cpy1: v, cpx2: y, cpy2: x }), i.setStyle(n.getItemStyle()), i.style.fill) {case "source":
								i.style.fill = e.node1.getVisual("color");break;case "target":
								i.style.fill = e.node2.getVisual("color");}a.setHoverStyle(i, e.getModel("lineStyle.emphasis").getItemStyle()), l.add(i), h.setItemGraphicEl(e.dataIndex, i);
					}), s.eachNode(function (e) {
						var i = e.getLayout(),
						    n = e.getModel(),
						    r = n.getModel("label.normal"),
						    s = r.getModel("textStyle"),
						    u = n.getModel("label.emphasis"),
						    h = u.getModel("textStyle"),
						    d = new a.Rect({ shape: { x: i.x, y: i.y, width: e.getLayout().dx, height: e.getLayout().dy }, style: { text: r.get("show") ? t.getFormattedLabel(e.dataIndex, "normal") || e.id : "", textFont: s.getFont(), textFill: s.getTextColor(), textPosition: r.get("position") } });d.setStyle(o.defaults({ fill: e.getVisual("color") }, n.getModel("itemStyle.normal").getItemStyle())), a.setHoverStyle(d, o.extend(e.getModel("itemStyle.emphasis"), { text: u.get("show") ? t.getFormattedLabel(e.dataIndex, "emphasis") || e.id : "", textFont: h.getFont(), textFill: h.getTextColor(), textPosition: u.get("position") })), l.add(d), c.setItemGraphicEl(e.dataIndex, d), d.dataType = "node";
					}), !this._data && t.get("animation") && l.setClipPath(n(l.getBoundingRect(), t, function () {
						l.removeClipPath();
					})), this._data = t.getData();
				}, dispose: function dispose() {} });
		}, function (t, e, i) {
			function n(t, e) {
				return M.getLayoutRect(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() });
			}function a(t, e, i, n, a, o, s) {
				r(t, i, a), u(t, e, o, n, s), m(t);
			}function o(t) {
				T.each(t, function (t) {
					var e = x(t.outEdges, S),
					    i = x(t.inEdges, S),
					    n = Math.max(e, i);t.setLayout({ value: n }, !0);
				});
			}function r(t, e, i) {
				for (var n = t, a = null, o = 0, r = 0; n.length;) {
					a = [];for (var u = 0, c = n.length; u < c; u++) {
						var h = n[u];h.setLayout({ x: o }, !0), h.setLayout({ dx: e }, !0);for (var d = 0, f = h.outEdges.length; d < f; d++) {
							a.push(h.outEdges[d].node2);
						}
					}n = a, ++o;
				}s(t, o), r = (i - e) / (o - 1), l(t, r);
			}function s(t, e) {
				T.each(t, function (t) {
					t.outEdges.length || t.setLayout({ x: e - 1 }, !0);
				});
			}function l(t, e) {
				T.each(t, function (t) {
					var i = t.getLayout().x * e;t.setLayout({ x: i }, !0);
				});
			}function u(t, e, i, n, a) {
				var o = I().key(function (t) {
					return t.getLayout().x;
				}).sortKeys(w).entries(t).map(function (t) {
					return t.values;
				});c(t, o, e, i, n), h(o, n, i);for (var r = 1; a > 0; a--) {
					r *= .99, d(o, r), h(o, n, i), p(o, r), h(o, n, i);
				}
			}function c(t, e, i, n, a) {
				var o = [];T.each(e, function (t) {
					var e = t.length,
					    i = 0;T.each(t, function (t) {
						i += t.getLayout().value;
					});var r = (n - (e - 1) * a) / i;o.push(r);
				}), o.sort(function (t, e) {
					return t - e;
				});var r = o[0];T.each(e, function (t) {
					T.each(t, function (t, e) {
						t.setLayout({ y: e }, !0);var i = t.getLayout().value * r;t.setLayout({ dy: i }, !0);
					});
				}), T.each(i, function (t) {
					var e = +t.getValue() * r;t.setLayout({ dy: e }, !0);
				});
			}function h(t, e, i) {
				T.each(t, function (t) {
					var n,
					    a,
					    o,
					    r = 0,
					    s = t.length;for (t.sort(b), o = 0; o < s; o++) {
						if (n = t[o], a = r - n.getLayout().y, a > 0) {
							var l = n.getLayout().y + a;n.setLayout({ y: l }, !0);
						}r = n.getLayout().y + n.getLayout().dy + e;
					}if (a = r - e - i, a > 0) {
						var l = n.getLayout().y - a;for (n.setLayout({ y: l }, !0), r = n.getLayout().y, o = s - 2; o >= 0; --o) {
							n = t[o], a = n.getLayout().y + n.getLayout().dy + e - r, a > 0 && (l = n.getLayout().y - a, n.setLayout({ y: l }, !0)), r = n.getLayout().y;
						}
					}
				});
			}function d(t, e) {
				T.each(t.slice().reverse(), function (t) {
					T.each(t, function (t) {
						if (t.outEdges.length) {
							var i = x(t.outEdges, f) / x(t.outEdges, S),
							    n = t.getLayout().y + (i - _(t)) * e;t.setLayout({ y: n }, !0);
						}
					});
				});
			}function f(t) {
				return _(t.node2) * t.getValue();
			}function p(t, e) {
				T.each(t, function (t) {
					T.each(t, function (t) {
						if (t.inEdges.length) {
							var i = x(t.inEdges, g) / x(t.inEdges, S),
							    n = t.getLayout().y + (i - _(t)) * e;t.setLayout({ y: n }, !0);
						}
					});
				});
			}function g(t) {
				return _(t.node1) * t.getValue();
			}function m(t) {
				T.each(t, function (t) {
					t.outEdges.sort(v), t.inEdges.sort(y);
				}), T.each(t, function (t) {
					var e = 0,
					    i = 0;T.each(t.outEdges, function (t) {
						t.setLayout({ sy: e }, !0), e += t.getLayout().dy;
					}), T.each(t.inEdges, function (t) {
						t.setLayout({ ty: i }, !0), i += t.getLayout().dy;
					});
				});
			}function v(t, e) {
				return t.node2.getLayout().y - e.node2.getLayout().y;
			}function y(t, e) {
				return t.node1.getLayout().y - e.node1.getLayout().y;
			}function x(t, e) {
				for (var i = 0, n = t.length, a = -1; ++a < n;) {
					var o = +e.call(t, t[a], a);isNaN(o) || (i += o);
				}return i;
			}function _(t) {
				return t.getLayout().y + t.getLayout().dy / 2;
			}function b(t, e) {
				return t.getLayout().y - e.getLayout().y;
			}function w(t, e) {
				return t < e ? -1 : t > e ? 1 : t === e ? 0 : NaN;
			}function S(t) {
				return t.getValue();
			}var M = i(12),
			    I = i(265),
			    T = i(1);t.exports = function (t, e, i) {
				t.eachSeriesByType("sankey", function (t) {
					var i = t.get("nodeWidth"),
					    r = t.get("nodeGap"),
					    s = n(t, e);t.layoutInfo = s;var l = s.width,
					    u = s.height,
					    c = t.getGraph(),
					    h = c.nodes,
					    d = c.edges;o(h);var f = T.filter(h, function (t) {
						return 0 === t.getLayout().value;
					}),
					    p = 0 !== f.length ? 0 : t.get("layoutIterations");a(h, d, i, r, l, u, p);
				});
			};
		}, function (t, e, i) {
			var n = i(83),
			    a = i(1);t.exports = function (t, e) {
				t.eachSeriesByType("sankey", function (t) {
					var e = t.getGraph(),
					    i = e.nodes;i.sort(function (t, e) {
						return t.getLayout().value - e.getLayout().value;
					});var o = i[0].getLayout().value,
					    r = i[i.length - 1].getLayout().value;a.each(i, function (e) {
						var i = new n({ type: "color", mappingMethod: "linear", dataExtent: [o, r], visual: t.get("color") }),
						    a = i.mapValueToVisual(e.getLayout().value);e.setVisual("color", a);var s = e.getModel(),
						    l = s.get("itemStyle.normal.color");null != l && e.setVisual("color", l);
					});
				});
			};
		}, function (t, e, i) {
			var n = i(2),
			    a = i(1);i(252), i(342), i(343), n.registerLayout(i(344)), n.registerVisual(i(345)), n.registerProcessor(a.curry(i(63), "themeRiver"));
		}, function (t, e, i) {
			"use strict";
			var n = i(25),
			    a = i(17),
			    o = i(14),
			    r = i(1),
			    s = i(7),
			    l = s.encodeHTML,
			    u = i(265),
			    c = 2,
			    h = a.extend({ type: "series.themeRiver", dependencies: ["singleAxis"], nameMap: null, init: function init(t) {
					h.superApply(this, "init", arguments), this.legendDataProvider = function () {
						return this.getRawData();
					};
				}, fixData: function fixData(t) {
					for (var e = t.length, i = u().key(function (t) {
						return t[2];
					}).entries(t), n = r.map(i, function (t) {
						return { name: t.key, dataList: t.values };
					}), a = n.length, o = -1, s = -1, l = 0; l < a; ++l) {
						var c = n[l].dataList.length;c > o && (o = c, s = l);
					}for (var h = 0; h < a; ++h) {
						if (h !== s) for (var d = n[h].name, f = 0; f < o; ++f) {
							for (var p = n[s].dataList[f][0], g = n[h].dataList.length, m = -1, v = 0; v < g; ++v) {
								var y = n[h].dataList[v][0];if (y === p) {
									m = v;break;
								}
							}m === -1 && (t[e] = [], t[e][0] = p, t[e][1] = 0, t[e][2] = d, e++);
						}
					}return t;
				}, getInitialData: function getInitialData(t, e) {
					var i = [],
					    a = e.queryComponents({ mainType: "singleAxis", index: this.get("singleAxisIndex"), id: this.get("singleAxisId") })[0],
					    s = a.get("type");i = [{ name: "time", type: "category" === s ? "ordinal" : "time" === s ? "time" : "float" }, { name: "value", type: "float" }, { name: "name", type: "ordinal" }];for (var l = r.filter(t.data, function (t) {
						return void 0 !== t[2];
					}), u = this.fixData(l || []), h = [], d = this.nameMap = r.createHashMap(), f = 0, p = 0; p < u.length; ++p) {
						h.push(u[p][c]), d.get(u[p][c]) || (d.set(u[p][c], f), f++);
					}i = n(i, u);var g = new o(i, this);return g.initData(u, h), g;
				}, coordDimToDataDim: function coordDimToDataDim(t) {
					return ["time"];
				}, getLayerSeries: function getLayerSeries() {
					function t(t, i) {
						return e.get("time", t) - e.get("time", i);
					}for (var e = this.getData(), i = e.count(), n = [], a = 0; a < i; ++a) {
						n[a] = a;
					}for (var o = u().key(function (t) {
						return e.get("name", t);
					}).entries(n), s = r.map(o, function (t) {
						return { name: t.key, indices: t.values };
					}), l = 0; l < s.length; ++l) {
						s[l].indices.sort(t);
					}return s;
				}, getAxisTooltipData: function getAxisTooltipData(t, e, i) {
					r.isArray(t) || (t = t ? [t] : []);for (var n, a = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, u = 0; u < l; ++u) {
						for (var c = Number.MAX_VALUE, h = -1, d = o[u].indices.length, f = 0; f < d; ++f) {
							var p = a.get(t[0], o[u].indices[f]),
							    g = Math.abs(p - e);g <= c && (n = p, c = g, h = o[u].indices[f]);
						}s.push(h);
					}return { dataIndices: s, nestestValue: n };
				}, formatTooltip: function formatTooltip(t) {
					var e = this.getData(),
					    i = e.get("name", t),
					    n = e.get("value", t);return (isNaN(n) || null == n) && (n = "-"), l(i + " : " + n);
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "singleAxis", boundaryGap: ["10%", "10%"], singleAxisIndex: 0, animationEasing: "linear", label: { normal: { margin: 4, textAlign: "right", show: !0, position: "left", textStyle: { color: "#000", fontSize: 11 } }, emphasis: { show: !0 } } } });t.exports = h;
		}, function (t, e, i) {
			(function (e) {
				function n(t, e, i) {
					var n = new o.Rect({ shape: { x: t.x - 10, y: t.y - 10, width: 0, height: t.height + 20 } });return o.initProps(n, { shape: { width: t.width + 20, height: t.height + 20 } }, e, i), n;
				}var a = i(93),
				    o = i(3),
				    r = i(1),
				    s = i(48);t.exports = i(2).extendChartView({ type: "themeRiver", init: function init() {
						this._layers = [];
					}, render: function render(t, e, i) {
						function l(t) {
							return t.name;
						}function u(e, i, s) {
							var l = this._layers;if ("remove" === e) return void d.remove(l[i]);for (var u, p = [], g = [], m = f[i].indices, v = 0; v < m.length; v++) {
								var x = c.getItemLayout(m[v]),
								    _ = x.x,
								    b = x.y0,
								    w = x.y;p.push([_, b]), g.push([_, b + w]), u = h.getItemVisual(m[v], "color");
							}var S,
							    M,
							    I = c.getItemLayout(m[0]),
							    T = c.getItemModel(m[v - 1]),
							    A = T.getModel("label.normal"),
							    C = A.get("margin");if ("add" === e) {
								var L = y[i] = new o.Group();S = new a.Polygon({ shape: { points: p, stackedOnPoints: g, smooth: .4, stackedOnSmooth: .4, smoothConstraint: !1 }, z2: 0 }), M = new o.Text({ style: { x: I.x - C, y: I.y0 + I.y / 2 } }), L.add(S), L.add(M), d.add(L), S.setClipPath(n(S.getBoundingRect(), t, function () {
									S.removeClipPath();
								}));
							} else {
								var L = l[s];S = L.childAt(0), M = L.childAt(1), d.add(L), y[i] = L, o.updateProps(S, { shape: { points: p, stackedOnPoints: g } }, t), o.updateProps(M, { style: { x: I.x - C, y: I.y0 + I.y / 2 } }, t);
							}var D = T.getModel("itemStyle.emphasis"),
							    P = T.getModel("itemStyle.normal"),
							    k = A.getModel("textStyle");M.setStyle({ text: A.get("show") ? t.getFormattedLabel(m[v - 1], "normal") || c.getName(m[v - 1]) : "", textFont: k.getFont(), textAlign: A.get("textAlign"), textVerticalAlign: "middle" }), S.setStyle(r.extend({ fill: u }, P.getItemStyle(["color"]))), o.setHoverStyle(S, D.getItemStyle());
						}var c = t.getData(),
						    h = t.getRawData();if (c.count()) {
							var d = this.group,
							    f = t.getLayerSeries(),
							    p = c.getLayout("layoutInfo"),
							    g = p.rect,
							    m = p.boundaryGap;d.attr("position", [0, g.y + m[0]]);var v = new s(this._layersSeries || [], f, l, l),
							    y = {};v.add(r.bind(r.curry(u, "add"), this)).update(r.bind(r.curry(u, "update"), this)).remove(r.bind(r.curry(u, "remove"), this)).execute(), this._layersSeries = f, this._layers = y;
						}
					}, dispose: function dispose() {} });
			}).call(e, i(188));
		}, function (t, e, i) {
			function n(t, e, i) {
				if (t.count()) for (var n, r = e.coordinateSystem, s = e.getLayerSeries(), l = o.map(s, function (e) {
					return o.map(e.indices, function (e) {
						var i = r.dataToPoint(t.get("time", e));return i[1] = t.get("value", e), i;
					});
				}), u = a(l), c = u.y0, h = i / u.max, d = s.length, f = s[0].indices.length, p = 0; p < f; ++p) {
					n = c[p] * h, t.setItemLayout(s[0].indices[p], { layerIndex: 0, x: l[0][p][0], y0: n, y: l[0][p][1] * h });for (var g = 1; g < d; ++g) {
						n += l[g - 1][p][1] * h, t.setItemLayout(s[g].indices[p], { layerIndex: g, x: l[g][p][0], y0: n, y: l[g][p][1] * h });
					}
				}
			}function a(t) {
				for (var e, i = t.length, n = t[0].length, a = [], o = [], r = 0, s = {}, l = 0; l < n; ++l) {
					for (var u = 0, e = 0; u < i; ++u) {
						e += t[u][l][1];
					}e > r && (r = e), a.push(e);
				}for (var c = 0; c < n; ++c) {
					o[c] = (r - a[c]) / 2;
				}r = 0;for (var h = 0; h < n; ++h) {
					var d = a[h] + o[h];d > r && (r = d);
				}return s.y0 = o, s.max = r, s;
			}var o = i(1),
			    r = i(4);t.exports = function (t, e) {
				t.eachSeriesByType("themeRiver", function (t) {
					var e = t.getData(),
					    i = t.coordinateSystem,
					    a = {},
					    o = i.getRect();a.rect = o;var s = t.get("boundaryGap"),
					    l = i.getAxis();if (a.boundaryGap = s, "horizontal" === l.orient) {
						s[0] = r.parsePercent(s[0], o.height), s[1] = r.parsePercent(s[1], o.height);var u = o.height - s[0] - s[1];n(e, t, u);
					} else {
						s[0] = r.parsePercent(s[0], o.width), s[1] = r.parsePercent(s[1], o.width);var c = o.width - s[0] - s[1];n(e, t, c);
					}e.setLayout("layoutInfo", a);
				});
			};
		}, function (t, e) {
			t.exports = function (t) {
				t.eachSeriesByType("themeRiver", function (t) {
					var e = t.getData(),
					    i = t.getRawData(),
					    n = t.get("color");e.each(function (a) {
						var o = e.getName(a),
						    r = n[(t.nameMap.get(o) - 1) % n.length];i.setItemVisual(a, "color", r);
					});
				});
			};
		}, function (t, e, i) {
			var n = i(2);i(348), i(349), i(350), n.registerVisual(i(352)), n.registerLayout(i(351));
		}, function (t, e, i) {
			function n(t) {
				this.group = new r.Group(), t.add(this.group);
			}function a(t, e, i, n, a, o) {
				var r = [[a ? t : t - d, e], [t + i, e], [t + i, e + n], [a ? t : t - d, e + n]];return !o && r.splice(2, 0, [t + i + d, e + n / 2]), !a && r.push([t, e + n / 2]), r;
			}function o(t, e, i) {
				t.eventData = { componentType: "series", componentSubType: "treemap", seriesIndex: e.componentIndex, seriesName: e.name, seriesType: "treemap", selfType: "breadcrumb", nodeData: { dataIndex: i && i.dataIndex, name: i && i.name }, treePathInfo: i && u.wrapTreePathInfo(i, e) };
			}var r = i(3),
			    s = i(12),
			    l = i(1),
			    u = i(94),
			    c = 8,
			    h = 8,
			    d = 5;n.prototype = { constructor: n, render: function render(t, e, i, n) {
					var a = t.getModel("breadcrumb"),
					    o = this.group;if (o.removeAll(), a.get("show") && i) {
						var r = a.getModel("itemStyle.normal"),
						    l = r.getModel("textStyle"),
						    u = { pos: { left: a.get("left"), right: a.get("right"), top: a.get("top"), bottom: a.get("bottom") }, box: { width: e.getWidth(), height: e.getHeight() }, emptyItemWidth: a.get("emptyItemWidth"), totalWidth: 0, renderList: [] };this._prepare(i, u, l), this._renderContent(t, u, r, l, n), s.positionElement(o, u.pos, u.box);
					}
				}, _prepare: function _prepare(t, e, i) {
					for (var n = t; n; n = n.parentNode) {
						var a = n.getModel().get("name"),
						    o = i.getTextRect(a),
						    r = Math.max(o.width + 2 * c, e.emptyItemWidth);e.totalWidth += r + h, e.renderList.push({ node: n, text: a, width: r });
					}
				}, _renderContent: function _renderContent(t, e, i, n, u) {
					for (var c = 0, d = e.emptyItemWidth, f = t.get("breadcrumb.height"), p = s.getAvailableSize(e.pos, e.box), g = e.totalWidth, m = e.renderList, v = m.length - 1; v >= 0; v--) {
						var y = m[v],
						    x = y.node,
						    _ = y.width,
						    b = y.text;g > p.width && (g -= _ - d, _ = d, b = "");var w = new r.Polygon({ shape: { points: a(c, 0, _, f, v === m.length - 1, 0 === v) }, style: l.defaults(i.getItemStyle(), { lineJoin: "bevel", text: b, textFill: n.getTextColor(), textFont: n.getFont() }), z: 10, onclick: l.curry(u, x) });this.group.add(w), o(w, t, x), c += _ + h;
					}
				}, remove: function remove() {
					this.group.removeAll();
				} }, t.exports = n;
		}, function (t, e, i) {
			function n(t) {
				var e = 0;s.each(t.children, function (t) {
					n(t);var i = t.value;s.isArray(i) && (i = i[0]), e += i;
				});var i = t.value;s.isArray(i) && (i = i[0]), (null == i || isNaN(i)) && (i = e), i < 0 && (i = 0), s.isArray(t.value) ? t.value[0] = i : t.value = i;
			}function a(t, e) {
				var i = e.get("color");if (i) {
					t = t || [];var n;if (s.each(t, function (t) {
						var e = new l(t),
						    i = e.get("color");(e.get("itemStyle.normal.color") || i && "none" !== i) && (n = !0);
					}), !n) {
						var a = t[0] || (t[0] = {});a.color = i.slice();
					}return t;
				}
			}var o = i(17),
			    r = i(424),
			    s = i(1),
			    l = i(10),
			    u = i(7),
			    c = i(94),
			    h = u.encodeHTML,
			    d = u.addCommas;t.exports = o.extend({ type: "series.treemap", layoutMode: "box", dependencies: ["grid", "polar"], _viewRoot: null, defaultOption: { progressive: 0, hoverLayerThreshold: 1 / 0, left: "center", top: "middle", right: null, bottom: null, width: "80%", height: "80%", sort: !0, clipWindow: "origin", squareRatio: .5 * (1 + Math.sqrt(5)), leafDepth: null, drillDownIcon: "", zoomToNodeRatio: .1024, roam: !0, nodeClick: "zoomToNode", animation: !0, animationDurationUpdate: 900, animationEasing: "quinticInOut", breadcrumb: { show: !0, height: 22, left: "center", top: "bottom", emptyItemWidth: 25, itemStyle: { normal: { color: "rgba(0,0,0,0.7)", borderColor: "rgba(255,255,255,0.7)", borderWidth: 1, shadowColor: "rgba(150,150,150,1)", shadowBlur: 3, shadowOffsetX: 0, shadowOffsetY: 0, textStyle: { color: "#fff" } }, emphasis: { textStyle: {} } } }, label: { normal: { show: !0, position: "inside", textStyle: { color: "#fff", ellipsis: !0 } } }, itemStyle: { normal: { color: null, colorAlpha: null, colorSaturation: null, borderWidth: 0, gapWidth: 0, borderColor: "#fff", borderColorSaturation: null }, emphasis: {} }, visualDimension: 0, visualMin: null, visualMax: null, color: [], colorAlpha: null, colorSaturation: null, colorMappingBy: "index", visibleMin: 10, childrenVisibleMin: null, levels: [] }, getInitialData: function getInitialData(t, e) {
					var i = t.name;null == i && (i = t.name);var o = { name: i, children: t.data };n(o);var s = t.levels || [];return s = t.levels = a(s, e), r.createTree(o, this, s).data;
				}, optionUpdated: function optionUpdated() {
					this.resetViewRoot();
				}, formatTooltip: function formatTooltip(t) {
					var e = this.getData(),
					    i = this.getRawValue(t),
					    n = d(s.isArray(i) ? i[0] : i),
					    a = e.getName(t);return h(a + ": " + n);
				}, getDataParams: function getDataParams(t) {
					var e = o.prototype.getDataParams.apply(this, arguments),
					    i = this.getData().tree.getNodeByDataIndex(t);return e.treePathInfo = c.wrapTreePathInfo(i, this), e;
				}, setLayoutInfo: function setLayoutInfo(t) {
					this.layoutInfo = this.layoutInfo || {}, s.extend(this.layoutInfo, t);
				}, mapIdToIndex: function mapIdToIndex(t) {
					var e = this._idIndexMap;e || (e = this._idIndexMap = s.createHashMap(), this._idIndexMapCount = 0);var i = e.get(t);return null == i && e.set(t, i = this._idIndexMapCount++), i;
				}, getViewRoot: function getViewRoot() {
					return this._viewRoot;
				}, resetViewRoot: function resetViewRoot(t) {
					t ? this._viewRoot = t : t = this._viewRoot;var e = this.getData().tree.root;t && (t === e || e.contains(t)) || (this._viewRoot = e);
				} });
		}, function (t, e, i) {
			function n() {
				return { nodeGroup: [], background: [], content: [] };
			}function a(t, e, i, n, a, l, u, c, h, d) {
				function f(e) {
					E.dataIndex = u.dataIndex, E.seriesIndex = t.seriesIndex;var i = T.borderWidth,
					    n = Math.max(A - 2 * i, 0),
					    a = Math.max(C - 2 * i, 0);E.culling = !0, E.setShape({ x: i, y: i, width: n, height: a });var o = u.getVisual("color", !0);p(E, function () {
						var t = { fill: o },
						    e = u.getModel("itemStyle.emphasis").getItemStyle();g(t, e, o, n, a), E.setStyle(t), s.setHoverStyle(E, e);
					}), e.add(E);
				}function p(t, e) {
					L ? !t.invisible && l.push(t) : (e(), t.__tmWillVisible || (t.invisible = !1));
				}function g(e, i, n, a, o) {
					var r = u.getModel(),
					    s = r.get("name");if (T.isLeafRoot) {
						var l = t.get("drillDownIcon", !0);s = l ? l + " " + s : s;
					}y(s, e, r, _, n, a, o), y(s, i, r, b, n, a, o);
				}function y(t, e, i, n, a, o, r) {
					var l = i.getModel(n),
					    u = l.getModel("textStyle");s.setText(e, l, a), e.textAlign = u.get("align"), e.textVerticalAlign = u.get("baseline");var c = u.getTextRect(t);!l.getShallow("show") || c.height > r ? e.text = "" : c.width > o ? e.text = u.get("ellipsis") ? u.truncateText(t, o, null, { minChar: 2 }) : "" : e.text = t;
				}function x(t, n, r, s) {
					var l = null != P && i[t][P],
					    u = a[t];return l ? (i[t][P] = null, w(u, l, t)) : L || (l = new n({ z: o(r, s) }), l.__tmDepth = r, l.__tmStorageName = t, I(u, l, t)), e[t][D] = l;
				}function w(t, e, i) {
					var n = t[D] = {};n.old = "nodeGroup" === i ? e.position.slice() : r.extend({}, e.shape);
				}function I(t, e, i) {
					var o = t[D] = {},
					    r = u.parentNode;if (r && (!n || "drillDown" === n.direction)) {
						var s = 0,
						    l = 0,
						    c = a.background[r.getRawIndex()];!n && c && c.old && (s = c.old.width, l = c.old.height), o.old = "nodeGroup" === i ? [0, l] : { x: s, y: l, width: 0, height: 0 };
					}o.fadein = "nodeGroup" !== i;
				}if (u) {
					var T = u.getLayout();if (T && T.isInView) {
						var A = T.width,
						    C = T.height,
						    L = T.invisible,
						    D = u.getRawIndex(),
						    P = c && c.getRawIndex(),
						    k = x("nodeGroup", m);if (k) {
							if (h.add(k), k.attr("position", [T.x || 0, T.y || 0]), k.__tmNodeWidth = A, k.__tmNodeHeight = C, T.isAboveViewRoot) return k;var O = x("background", v, d, S);O && (O.setShape({ x: 0, y: 0, width: A, height: C }), p(O, function () {
								O.setStyle("fill", u.getVisual("borderColor", !0));
							}), k.add(O));var z = u.viewChildren;if (!z || !z.length) {
								var E = x("content", v, d, M);E && f(k);
							}return k;
						}
					}
				}
			}function o(t, e) {
				var i = t * w + e;return (i - 1) / i;
			}var r = i(1),
			    s = i(3),
			    l = i(48),
			    u = i(94),
			    c = i(347),
			    h = i(95),
			    d = i(11),
			    f = i(19),
			    p = i(426),
			    g = r.bind,
			    m = s.Group,
			    v = s.Rect,
			    y = r.each,
			    x = 3,
			    _ = ["label", "normal"],
			    b = ["label", "emphasis"],
			    w = 10,
			    S = 1,
			    M = 2;t.exports = i(2).extendChartView({ type: "treemap", init: function init(t, e) {
					this._containerGroup, this._storage = n(), this._oldTree, this._breadcrumb, this._controller, this._state = "ready", this._mayClick;
				}, render: function render(t, e, i, n) {
					var a = e.findComponents({ mainType: "series", subType: "treemap", query: n });if (!(r.indexOf(a, t) < 0)) {
						this.seriesModel = t, this.api = i, this.ecModel = e;var o = u.retrieveTargetInfo(n, t),
						    s = n && n.type,
						    l = t.layoutInfo,
						    c = !this._oldTree,
						    h = this._storage,
						    d = "treemapRootToNode" === s && o && h ? { rootNodeGroup: h.nodeGroup[o.node.getRawIndex()], direction: n.direction } : null,
						    f = this._giveContainerGroup(l),
						    p = this._doRender(f, t, d);c || s && "treemapZoomToNode" !== s && "treemapRootToNode" !== s ? p.renderFinally() : this._doAnimation(f, p, t, d), this._resetController(i), this._renderBreadcrumb(t, i, o);
					}
				}, _giveContainerGroup: function _giveContainerGroup(t) {
					var e = this._containerGroup;return e || (e = this._containerGroup = new m(), this._initEvents(e), this.group.add(e)), e.attr("position", [t.x, t.y]), e;
				}, _doRender: function _doRender(t, e, i) {
					function o(t, e, i, n, a) {
						function s(t) {
							return t.getId();
						}function u(r, s) {
							var l = null != r ? t[r] : null,
							    u = null != s ? e[s] : null,
							    c = m(l, u, i, a);c && o(l && l.viewChildren || [], u && u.viewChildren || [], c, n, a + 1);
						}n ? (e = t, y(t, function (t, e) {
							!t.isRemoved() && u(e, e);
						})) : new l(e, t, s, s).add(u).update(u).remove(r.curry(u, null)).execute();
					}function s(t) {
						var e = n();return t && y(t, function (t, i) {
							var n = e[i];y(t, function (t) {
								t && (n.push(t), t.__tmWillDelete = 1);
							});
						}), e;
					}function u() {
						y(v, function (t) {
							y(t, function (t) {
								t.parent && t.parent.remove(t);
							});
						}), y(g, function (t) {
							t.invisible = !0, t.dirty();
						});
					}var c = e.getData().tree,
					    h = this._oldTree,
					    d = n(),
					    f = n(),
					    p = this._storage,
					    g = [],
					    m = r.curry(a, e, f, p, i, d, g);o(c.root ? [c.root] : [], h && h.root ? [h.root] : [], t, c === h || !h, 0);var v = s(p);return this._oldTree = c, this._storage = f, { lastsForAnimation: d, willDeleteEls: v, renderFinally: u };
				}, _doAnimation: function _doAnimation(t, e, i, n) {
					if (i.get("animation")) {
						var a = i.get("animationDurationUpdate"),
						    o = i.get("animationEasing"),
						    s = p.createWrap();y(e.willDeleteEls, function (t, e) {
							y(t, function (t, i) {
								if (!t.invisible) {
									var r,
									    l = t.parent;if (n && "drillDown" === n.direction) r = l === n.rootNodeGroup ? { shape: { x: 0, y: 0, width: l.__tmNodeWidth, height: l.__tmNodeHeight }, style: { opacity: 0 } } : { style: { opacity: 0 } };else {
										var u = 0,
										    c = 0;l.__tmWillDelete || (u = l.__tmNodeWidth / 2, c = l.__tmNodeHeight / 2), r = "nodeGroup" === e ? { position: [u, c], style: { opacity: 0 } } : { shape: { x: u, y: c, width: 0, height: 0 }, style: { opacity: 0 } };
									}r && s.add(t, r, a, o);
								}
							});
						}), y(this._storage, function (t, i) {
							y(t, function (t, n) {
								var l = e.lastsForAnimation[i][n],
								    u = {};l && ("nodeGroup" === i ? l.old && (u.position = t.position.slice(), t.attr("position", l.old)) : (l.old && (u.shape = r.extend({}, t.shape), t.setShape(l.old)), l.fadein ? (t.setStyle("opacity", 0), u.style = { opacity: 1 }) : 1 !== t.style.opacity && (u.style = { opacity: 1 })), s.add(t, u, a, o));
							});
						}, this), this._state = "animating", s.done(g(function () {
							this._state = "ready", e.renderFinally();
						}, this)).start();
					}
				}, _resetController: function _resetController(t) {
					var e = this._controller;e || (e = this._controller = new h(t.getZr()), e.enable(this.seriesModel.get("roam")), e.on("pan", g(this._onPan, this)), e.on("zoom", g(this._onZoom, this)));var i = new d(0, 0, t.getWidth(), t.getHeight());e.setPointerChecker(function (t, e, n) {
						return i.contain(e, n);
					});
				}, _clearController: function _clearController() {
					var t = this._controller;t && (t.dispose(), t = null);
				}, _onPan: function _onPan(t, e) {
					if (this._mayClick = !1, "animating" !== this._state && (Math.abs(t) > x || Math.abs(e) > x)) {
						var i = this.seriesModel.getData().tree.root;if (!i) return;var n = i.getLayout();if (!n) return;this.api.dispatchAction({ type: "treemapMove", from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: n.x + t, y: n.y + e, width: n.width, height: n.height } });
					}
				}, _onZoom: function _onZoom(t, e, i) {
					if (this._mayClick = !1, "animating" !== this._state) {
						var n = this.seriesModel.getData().tree.root;if (!n) return;var a = n.getLayout();if (!a) return;var o = new d(a.x, a.y, a.width, a.height),
						    r = this.seriesModel.layoutInfo;e -= r.x, i -= r.y;var s = f.create();f.translate(s, s, [-e, -i]), f.scale(s, s, [t, t]), f.translate(s, s, [e, i]), o.applyTransform(s), this.api.dispatchAction({ type: "treemapRender", from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: o.x, y: o.y, width: o.width, height: o.height } });
					}
				}, _initEvents: function _initEvents(t) {
					function e(t) {
						var e = this.seriesModel.get("nodeClick", !0);if (e) {
							var i = this.findTarget(t.offsetX, t.offsetY);if (i) {
								var n = i.node;if (n.getLayout().isLeafRoot) this._rootToNode(i);else if ("zoomToNode" === e) this._zoomToNode(i);else if ("link" === e) {
									var a = n.hostTree.data.getItemModel(n.dataIndex),
									    o = a.get("link", !0),
									    r = a.get("target", !0) || "blank";o && window.open(o, r);
								}
							}
						}
					}t.on("mousedown", function (t) {
						"ready" === this._state && (this._mayClick = !0);
					}, this), t.on("mouseup", function (t) {
						this._mayClick && (this._mayClick = !1, "ready" === this._state && e.call(this, t));
					}, this);
				}, _renderBreadcrumb: function _renderBreadcrumb(t, e, i) {
					function n(e) {
						"animating" !== this._state && (u.aboveViewRoot(t.getViewRoot(), e) ? this._rootToNode({ node: e }) : this._zoomToNode({ node: e }));
					}i || (i = null != t.get("leafDepth", !0) ? { node: t.getViewRoot() } : this.findTarget(e.getWidth() / 2, e.getHeight() / 2), i || (i = { node: t.getData().tree.root })), (this._breadcrumb || (this._breadcrumb = new c(this.group))).render(t, e, i.node, g(n, this));
				}, remove: function remove() {
					this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = n(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
				}, dispose: function dispose() {
					this._clearController();
				}, _zoomToNode: function _zoomToNode(t) {
					this.api.dispatchAction({ type: "treemapZoomToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: t.node });
				}, _rootToNode: function _rootToNode(t) {
					this.api.dispatchAction({ type: "treemapRootToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: t.node });
				}, findTarget: function findTarget(t, e) {
					var i,
					    n = this.seriesModel.getViewRoot();return n.eachNode({ attr: "viewChildren", order: "preorder" }, function (n) {
						var a = this._storage.background[n.getRawIndex()];if (a) {
							var o = a.transformCoordToLocal(t, e),
							    r = a.shape;if (!(r.x <= o[0] && o[0] <= r.x + r.width && r.y <= o[1] && o[1] <= r.y + r.height)) return !1;i = { node: n, offsetX: o[0], offsetY: o[1] };
						}
					}, this), i;
				} });
		}, function (t, e, i) {
			for (var n = i(2), a = i(94), o = function o() {}, r = ["treemapZoomToNode", "treemapRender", "treemapMove"], s = 0; s < r.length; s++) {
				n.registerAction({ type: r[s], update: "updateView" }, o);
			}n.registerAction({ type: "treemapRootToNode", update: "updateView" }, function (t, e) {
				function i(e, i) {
					var n = a.retrieveTargetInfo(t, e);if (n) {
						var o = e.getViewRoot();o && (t.direction = a.aboveViewRoot(o, n.node) ? "rollUp" : "drillDown"), e.resetViewRoot(n.node);
					}
				}e.eachComponent({ mainType: "series", subType: "treemap", query: t }, i);
			});
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = { mainType: "series", subType: "treemap", query: i };t.eachComponent(n, function (t) {
					var n = e.getWidth(),
					    o = e.getHeight(),
					    r = t.option,
					    s = m.getLayoutRect(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }),
					    l = r.size || [],
					    u = b(w(s.width, l[0]), n),
					    c = b(w(s.height, l[1]), o),
					    g = i && i.type,
					    x = v.retrieveTargetInfo(i, t),
					    _ = "treemapRender" === g || "treemapMove" === g ? i.rootRect : null,
					    M = t.getViewRoot(),
					    I = v.getPathToRoot(M);if ("treemapMove" !== g) {
						var T = "treemapZoomToNode" === g ? h(t, x, M, u, c) : _ ? [_.width, _.height] : [u, c],
						    A = r.sort;A && "asc" !== A && "desc" !== A && (A = "desc");var C = { squareRatio: r.squareRatio, sort: A, leafDepth: r.leafDepth };M.hostTree.clearLayouts();var L = { x: 0, y: 0, width: T[0], height: T[1], area: T[0] * T[1] };M.setLayout(L), a(M, C, !1, 0);var L = M.getLayout();S(I, function (t, e) {
							var i = (I[e + 1] || M).getValue();t.setLayout(p.extend({ dataExtent: [i, i], borderWidth: 0 }, L));
						});
					}var D = t.getData().tree.root;D.setLayout(d(s, _, x), !0), t.setLayoutInfo(s), f(D, new y(-s.x, -s.y, n, o), I, M, 0);
				});
			}function a(t, e, i, n) {
				var r, s;if (!t.isRemoved()) {
					var l = t.getLayout();r = l.width, s = l.height;var h = t.getModel("itemStyle.normal"),
					    d = h.get("borderWidth"),
					    f = h.get("gapWidth") / 2,
					    p = d - f,
					    g = t.getModel();t.setLayout({ borderWidth: d }, !0), r = x(r - 2 * p, 0), s = x(s - 2 * p, 0);var m = r * s,
					    v = o(t, g, m, e, i, n);if (v.length) {
						var y = { x: p, y: p, width: r, height: s },
						    b = _(r, s),
						    w = 1 / 0,
						    S = [];S.area = 0;for (var M = 0, I = v.length; M < I;) {
							var T = v[M];S.push(T), S.area += T.getLayout().area;var A = u(S, b, e.squareRatio);A <= w ? (M++, w = A) : (S.area -= S.pop().getLayout().area, c(S, b, y, f, !1), b = _(y.width, y.height), S.length = S.area = 0, w = 1 / 0);
						}if (S.length && c(S, b, y, f, !0), !i) {
							var C = g.get("childrenVisibleMin");null != C && m < C && (i = !0);
						}for (var M = 0, I = v.length; M < I; M++) {
							a(v[M], e, i, n + 1);
						}
					}
				}
			}function o(t, e, i, n, a, o) {
				var u = t.children || [],
				    c = n.sort;"asc" !== c && "desc" !== c && (c = null);var h = null != n.leafDepth && n.leafDepth <= o;if (a && !h) return t.viewChildren = [];u = p.filter(u, function (t) {
					return !t.isRemoved();
				}), s(u, c);var d = l(e, u, c);if (0 === d.sum) return t.viewChildren = [];if (d.sum = r(e, i, d.sum, c, u), 0 === d.sum) return t.viewChildren = [];for (var f = 0, g = u.length; f < g; f++) {
					var m = u[f].getValue() / d.sum * i;u[f].setLayout({ area: m });
				}return h && (u.length && t.setLayout({ isLeafRoot: !0 }, !0), u.length = 0), t.viewChildren = u, t.setLayout({ dataExtent: d.dataExtent }, !0), u;
			}function r(t, e, i, n, a) {
				if (!n) return i;for (var o = t.get("visibleMin"), r = a.length, s = r, l = r - 1; l >= 0; l--) {
					var u = a["asc" === n ? r - l - 1 : l].getValue();u / i * e < o && (s = l, i -= u);
				}return "asc" === n ? a.splice(0, r - s) : a.splice(s, r - s), i;
			}function s(t, e) {
				return e && t.sort(function (t, i) {
					var n = "asc" === e ? t.getValue() - i.getValue() : i.getValue() - t.getValue();return 0 === n ? "asc" === e ? t.dataIndex - i.dataIndex : i.dataIndex - t.dataIndex : n;
				}), t;
			}function l(t, e, i) {
				for (var n = 0, a = 0, o = e.length; a < o; a++) {
					n += e[a].getValue();
				}var r,
				    s = t.get("visualDimension");if (e && e.length) {
					if ("value" === s && i) r = [e[e.length - 1].getValue(), e[0].getValue()], "asc" === i && r.reverse();else {
						var r = [1 / 0, -(1 / 0)];S(e, function (t) {
							var e = t.getValue(s);e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);
						});
					}
				} else r = [NaN, NaN];return { sum: n, dataExtent: r };
			}function u(t, e, i) {
				for (var n, a = 0, o = 1 / 0, r = 0, s = t.length; r < s; r++) {
					n = t[r].getLayout().area, n && (n < o && (o = n), n > a && (a = n));
				}var l = t.area * t.area,
				    u = e * e * i;return l ? x(u * a / l, l / (u * o)) : 1 / 0;
			}function c(t, e, i, n, a) {
				var o = e === i.width ? 0 : 1,
				    r = 1 - o,
				    s = ["x", "y"],
				    l = ["width", "height"],
				    u = i[s[o]],
				    c = e ? t.area / e : 0;(a || c > i[l[r]]) && (c = i[l[r]]);for (var h = 0, d = t.length; h < d; h++) {
					var f = t[h],
					    p = {},
					    g = c ? f.getLayout().area / c : 0,
					    m = p[l[r]] = x(c - 2 * n, 0),
					    v = i[s[o]] + i[l[o]] - u,
					    y = h === d - 1 || v < g ? v : g,
					    b = p[l[o]] = x(y - 2 * n, 0);p[s[r]] = i[s[r]] + _(n, m / 2), p[s[o]] = u + _(n, b / 2), u += y, f.setLayout(p, !0);
				}i[s[r]] += c, i[l[r]] -= c;
			}function h(t, e, i, n, a) {
				var o = (e || {}).node,
				    r = [n, a];if (!o || o === i) return r;for (var s, l = n * a, u = l * t.option.zoomToNodeRatio; s = o.parentNode;) {
					for (var c = 0, h = s.children, d = 0, f = h.length; d < f; d++) {
						c += h[d].getValue();
					}var p = o.getValue();if (0 === p) return r;u *= c / p;var m = s.getModel("itemStyle.normal").get("borderWidth");isFinite(m) && (u += 4 * m * m + 4 * m * Math.pow(u, .5)), u > g.MAX_SAFE_INTEGER && (u = g.MAX_SAFE_INTEGER), o = s;
				}u < l && (u = l);var v = Math.pow(u / l, .5);return [n * v, a * v];
			}function d(t, e, i) {
				if (e) return { x: e.x, y: e.y };var n = { x: 0, y: 0 };if (!i) return n;var a = i.node,
				    o = a.getLayout();if (!o) return n;for (var r = [o.width / 2, o.height / 2], s = a; s;) {
					var l = s.getLayout();r[0] += l.x, r[1] += l.y, s = s.parentNode;
				}return { x: t.width / 2 - r[0], y: t.height / 2 - r[1] };
			}function f(t, e, i, n, a) {
				var o = t.getLayout(),
				    r = i[a],
				    s = r && r === t;if (!(r && !s || a === i.length && t !== n)) {
					t.setLayout({ isInView: !0, invisible: !s && !e.intersect(o), isAboveViewRoot: s }, !0);var l = new y(e.x - o.x, e.y - o.y, e.width, e.height);S(t.viewChildren || [], function (t) {
						f(t, l, i, n, a + 1);
					});
				}
			}var p = i(1),
			    g = i(4),
			    m = i(12),
			    v = i(94),
			    y = i(11),
			    v = i(94),
			    x = Math.max,
			    _ = Math.min,
			    b = g.parsePercent,
			    w = p.retrieve,
			    S = p.each;t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i, s, u, h) {
				var d = t.getModel(),
				    p = t.getLayout();if (p && !p.invisible && p.isInView) {
					var m,
					    v = t.getModel(g),
					    y = i[t.depth],
					    x = a(v, e, y, s),
					    _ = v.get("borderColor"),
					    b = v.get("borderColorSaturation");null != b && (m = o(x, t), _ = r(b, m)), t.setVisual("borderColor", _);var w = t.viewChildren;if (w && w.length) {
						var S = l(t, d, p, v, x, w);f.each(w, function (t, e) {
							if (t.depth >= u.length || t === u[t.depth]) {
								var a = c(d, x, t, e, S, h);n(t, a, i, s, u, h);
							}
						});
					} else m = o(x, t), t.setVisual("color", m);
				}
			}function a(t, e, i, n) {
				var a = f.extend({}, e);return f.each(["color", "colorAlpha", "colorSaturation"], function (o) {
					var r = t.get(o, !0);null == r && i && (r = i[o]), null == r && (r = e[o]), null == r && (r = n.get(o)), null != r && (a[o] = r);
				}), a;
			}function o(t) {
				var e = s(t, "color");if (e) {
					var i = s(t, "colorAlpha"),
					    n = s(t, "colorSaturation");return n && (e = d.modifyHSL(e, null, null, n)), i && (e = d.modifyAlpha(e, i)), e;
				}
			}function r(t, e) {
				return null != e ? d.modifyHSL(e, null, null, t) : null;
			}function s(t, e) {
				var i = t[e];if (null != i && "none" !== i) return i;
			}function l(t, e, i, n, a, o) {
				if (o && o.length) {
					var r = u(e, "color") || null != a.color && "none" !== a.color && (u(e, "colorAlpha") || u(e, "colorSaturation"));if (r) {
						var s = e.get("visualMin"),
						    l = e.get("visualMax"),
						    c = i.dataExtent.slice();null != s && s < c[0] && (c[0] = s), null != l && l > c[1] && (c[1] = l);var d = e.get("colorMappingBy"),
						    f = { type: r.name, dataExtent: c, visual: r.range };"color" !== f.type || "index" !== d && "id" !== d ? f.mappingMethod = "linear" : (f.mappingMethod = "category", f.loop = !0);var p = new h(f);return p.__drColorMappingBy = d, p;
					}
				}
			}function u(t, e) {
				var i = t.get(e);return p(i) && i.length ? { name: e, range: i } : null;
			}function c(t, e, i, n, a, o) {
				var r = f.extend({}, e);if (a) {
					var s = a.type,
					    l = "color" === s && a.__drColorMappingBy,
					    u = "index" === l ? n : "id" === l ? o.mapIdToIndex(i.getId()) : i.getValue(t.get("visualDimension"));r[s] = a.mapValueToVisual(u);
				}return r;
			}var h = i(83),
			    d = i(22),
			    f = i(1),
			    p = f.isArray,
			    g = "itemStyle.normal";t.exports = function (t, e, i) {
				var a = { mainType: "series", subType: "treemap", query: i };t.eachComponent(a, function (t) {
					var e = t.getData().tree,
					    i = e.root,
					    a = t.getModel(g);if (!i.isRemoved()) {
						var o = f.map(e.levelModels, function (t) {
							return t ? t.get(g) : null;
						});n(i, {}, o, a, t.getViewRoot().getAncestors(), t);
					}
				});
			};
		}, function (t, e, i) {
			"use strict";
			i(236), i(354);
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i, n) {
				var a = t.coordToPoint([e, n]),
				    o = t.coordToPoint([i, n]);return { x1: a[0], y1: a[1], x2: o[0], y2: o[1] };
			}var a = i(1),
			    o = i(3),
			    r = i(10),
			    s = ["axisLine", "axisLabel", "axisTick", "splitLine", "splitArea"];i(41).extend({ type: "angleAxis", axisPointerClass: "PolarAxisPointer", render: function render(t, e) {
					if (this.group.removeAll(), t.get("show")) {
						var i = t.axis,
						    n = i.polar,
						    o = n.getRadiusAxis().getExtent(),
						    r = i.getTicksCoords();"category" !== i.type && r.pop(), a.each(s, function (e) {
							!t.get(e + ".show") || i.scale.isBlank() && "axisLine" !== e || this["_" + e](t, n, r, o);
						}, this);
					}
				}, _axisLine: function _axisLine(t, e, i, n) {
					var a = t.getModel("axisLine.lineStyle"),
					    r = new o.Circle({ shape: { cx: e.cx, cy: e.cy, r: n[1] }, style: a.getLineStyle(), z2: 1, silent: !0 });r.style.fill = null, this.group.add(r);
				}, _axisTick: function _axisTick(t, e, i, r) {
					var s = t.getModel("axisTick"),
					    l = (s.get("inside") ? -1 : 1) * s.get("length"),
					    u = a.map(i, function (t) {
						return new o.Line({ shape: n(e, r[1], r[1] + l, t) });
					});this.group.add(o.mergePath(u, { style: a.defaults(s.getModel("lineStyle").getLineStyle(), { stroke: t.get("axisLine.lineStyle.color") }) }));
				}, _axisLabel: function _axisLabel(t, e, i, n) {
					for (var a = t.axis, s = t.get("data"), l = t.getModel("axisLabel"), u = l.getModel("textStyle"), c = t.getFormattedLabels(), h = l.get("margin"), d = a.getLabelsCoords(), f = 0; f < i.length; f++) {
						var p = n[1],
						    g = e.coordToPoint([p + h, d[f]]),
						    m = e.cx,
						    v = e.cy,
						    y = Math.abs(g[0] - m) / p < .3 ? "center" : g[0] > m ? "left" : "right",
						    x = Math.abs(g[1] - v) / p < .3 ? "middle" : g[1] > v ? "top" : "bottom",
						    _ = u;s && s[f] && s[f].textStyle && (_ = new r(s[f].textStyle, u)), this.group.add(new o.Text({ style: { x: g[0], y: g[1], fill: _.getTextColor() || t.get("axisLine.lineStyle.color"), text: c[f], textAlign: y, textVerticalAlign: x, textFont: _.getFont() }, silent: !0 }));
					}
				}, _splitLine: function _splitLine(t, e, i, r) {
					var s = t.getModel("splitLine"),
					    l = s.getModel("lineStyle"),
					    u = l.get("color"),
					    c = 0;u = u instanceof Array ? u : [u];for (var h = [], d = 0; d < i.length; d++) {
						var f = c++ % u.length;h[f] = h[f] || [], h[f].push(new o.Line({ shape: n(e, r[0], r[1], i[d]) }));
					}for (var d = 0; d < h.length; d++) {
						this.group.add(o.mergePath(h[d], { style: a.defaults({ stroke: u[d % u.length] }, l.getLineStyle()), silent: !0, z: t.get("z") }));
					}
				}, _splitArea: function _splitArea(t, e, i, n) {
					var r = t.getModel("splitArea"),
					    s = r.getModel("areaStyle"),
					    l = s.get("color"),
					    u = 0;l = l instanceof Array ? l : [l];for (var c = [], h = Math.PI / 180, d = -i[0] * h, f = Math.min(n[0], n[1]), p = Math.max(n[0], n[1]), g = t.get("clockwise"), m = 1; m < i.length; m++) {
						var v = u++ % l.length;c[v] = c[v] || [], c[v].push(new o.Sector({ shape: { cx: e.cx, cy: e.cy, r0: f, r: p, startAngle: d, endAngle: -i[m] * h, clockwise: g }, silent: !0 })), d = -i[m] * h;
					}for (var m = 0; m < c.length; m++) {
						this.group.add(o.mergePath(c[m], { style: a.defaults({ fill: l[m % l.length] }, s.getAreaStyle()), silent: !0 }));
					}
				} });
		}, function (t, e, i) {
			function n(t, e, i) {
				return i && "axisAreaSelect" === i.type && e.findComponents({ mainType: "parallelAxis", query: i })[0] === t;
			}function a(t) {
				var e = t.axis;return r.map(t.activeIntervals, function (t) {
					return { brushType: "lineX", panelId: "pl", range: [e.dataToCoord(t[0], !0), e.dataToCoord(t[1], !0)] };
				});
			}function o(t, e) {
				return e.getComponent("parallel", t.get("parallelIndex"));
			}var r = i(1),
			    s = i(40),
			    l = i(127),
			    u = i(185),
			    c = i(3),
			    h = ["axisLine", "axisLabel", "axisTick", "axisName"],
			    d = i(2).extendComponentView({ type: "parallelAxis", init: function init(t, e) {
					d.superApply(this, "init", arguments), (this._brushController = new l(e.getZr())).on("brush", r.bind(this._onBrush, this));
				}, render: function render(t, e, i, a) {
					if (!n(t, e, a)) {
						this.axisModel = t, this.api = i, this.group.removeAll();var l = this._axisGroup;if (this._axisGroup = new c.Group(), this.group.add(this._axisGroup), t.get("show")) {
							var u = o(t, e),
							    d = u.coordinateSystem,
							    f = t.getAreaSelectStyle(),
							    p = f.width,
							    g = t.axis.dim,
							    m = d.getAxisLayout(g),
							    v = r.extend({ strokeContainThreshold: p }, m),
							    y = new s(t, v);r.each(h, y.add, y), this._axisGroup.add(y.getGroup()), this._refreshBrushController(v, f, t, u, p, i);var x = a && a.animation === !1 ? null : t;c.groupTransition(l, this._axisGroup, x);
						}
					}
				}, updateVisual: function updateVisual(t, e, i, n) {
					this._brushController && this._brushController.updateCovers(a(t));
				}, _refreshBrushController: function _refreshBrushController(t, e, i, n, o, r) {
					var s = i.axis.getExtent(),
					    l = s[1] - s[0],
					    h = Math.min(30, .1 * Math.abs(l)),
					    d = c.BoundingRect.create({ x: s[0], y: -o / 2, width: l, height: o });d.x -= h, d.width += 2 * h, this._brushController.mount({ enableGlobalPan: !0, rotation: t.rotation, position: t.position }).setPanels([{ panelId: "pl", clipPath: u.makeRectPanelClipPath(d), isTargetByCursor: u.makeRectIsTargetByCursor(d, r, n), getLinearBrushOtherExtent: u.makeLinearBrushOtherExtent(d, 0) }]).enableBrush({ brushType: "lineX", brushStyle: e, removeOnClick: !0 }).updateCovers(a(i));
				}, _onBrush: function _onBrush(t, e) {
					var i = this.axisModel,
					    n = i.axis,
					    a = r.map(t, function (t) {
						return [n.coordToData(t.range[0], !0), n.coordToData(t.range[1], !0)];
					});(!i.option.realtime === e.isEnd || e.removeOnClick) && this.api.dispatchAction({ type: "axisAreaSelect", parallelAxisId: i.id, intervals: a });
				}, dispose: function dispose() {
					this._brushController.dispose();
				} });t.exports = d;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				return { position: [t.cx, t.cy], rotation: i / 180 * Math.PI, labelDirection: -1, tickDirection: -1, nameDirection: 1, labelRotate: e.getModel("axisLabel").get("rotate"), z2: 1 };
			}var a = i(1),
			    o = i(3),
			    r = i(40),
			    s = ["axisLine", "axisLabel", "axisTick", "axisName"],
			    l = ["splitLine", "splitArea"];i(41).extend({ type: "radiusAxis", axisPointerClass: "PolarAxisPointer", render: function render(t, e) {
					if (this.group.removeAll(), t.get("show")) {
						var i = t.axis,
						    o = i.polar,
						    u = o.getAngleAxis(),
						    c = i.getTicksCoords(),
						    h = u.getExtent()[0],
						    d = i.getExtent(),
						    f = n(o, t, h),
						    p = new r(t, f);a.each(s, p.add, p), this.group.add(p.getGroup()), a.each(l, function (e) {
							t.get(e + ".show") && !i.scale.isBlank() && this["_" + e](t, o, h, d, c);
						}, this);
					}
				}, _splitLine: function _splitLine(t, e, i, n, r) {
					var s = t.getModel("splitLine"),
					    l = s.getModel("lineStyle"),
					    u = l.get("color"),
					    c = 0;u = u instanceof Array ? u : [u];for (var h = [], d = 0; d < r.length; d++) {
						var f = c++ % u.length;h[f] = h[f] || [], h[f].push(new o.Circle({ shape: { cx: e.cx, cy: e.cy, r: r[d] }, silent: !0 }));
					}for (var d = 0; d < h.length; d++) {
						this.group.add(o.mergePath(h[d], { style: a.defaults({ stroke: u[d % u.length], fill: null }, l.getLineStyle()), silent: !0 }));
					}
				}, _splitArea: function _splitArea(t, e, i, n, r) {
					var s = t.getModel("splitArea"),
					    l = s.getModel("areaStyle"),
					    u = l.get("color"),
					    c = 0;u = u instanceof Array ? u : [u];for (var h = [], d = r[0], f = 1; f < r.length; f++) {
						var p = c++ % u.length;h[p] = h[p] || [], h[p].push(new o.Sector({ shape: { cx: e.cx, cy: e.cy, r0: d, r: r[f], startAngle: 0, endAngle: 2 * Math.PI }, silent: !0 })), d = r[f];
					}for (var f = 0; f < h.length; f++) {
						this.group.add(o.mergePath(h[f], { style: a.defaults({ fill: u[f % u.length] }, l.getAreaStyle()), silent: !0 }));
					}
				} });
		}, function (t, e, i) {
			var n = i(40),
			    a = i(1),
			    o = i(3),
			    r = i(248),
			    s = n.getInterval,
			    l = n.ifIgnoreOnTick,
			    u = ["axisLine", "axisLabel", "axisTick", "axisName"],
			    c = "splitLine",
			    h = i(41).extend({ type: "singleAxis", axisPointerClass: "SingleAxisPointer", render: function render(t, e, i, o) {
					var s = this.group;s.removeAll();var l = r.layout(t),
					    d = new n(t, l);a.each(u, d.add, d), s.add(d.getGroup()), t.get(c + ".show") && this["_" + c](t, l.labelInterval), h.superCall(this, "render", t, e, i, o);
				}, _splitLine: function _splitLine(t, e) {
					var i = t.axis;if (!i.scale.isBlank()) {
						var n = t.getModel("splitLine"),
						    a = n.getModel("lineStyle"),
						    r = a.get("width"),
						    u = a.get("color"),
						    c = s(n, e);u = u instanceof Array ? u : [u];for (var h = t.coordinateSystem.getRect(), d = i.isHorizontal(), f = [], p = 0, g = i.getTicksCoords(), m = [], v = [], y = 0; y < g.length; ++y) {
							if (!l(i, y, c)) {
								var x = i.toGlobalCoord(g[y]);d ? (m[0] = x, m[1] = h.y, v[0] = x, v[1] = h.y + h.height) : (m[0] = h.x, m[1] = x, v[0] = h.x + h.width, v[1] = x);var _ = p++ % u.length;f[_] = f[_] || [], f[_].push(new o.Line(o.subPixelOptimizeLine({ shape: { x1: m[0], y1: m[1], x2: v[0], y2: v[1] }, style: { lineWidth: r }, silent: !0 })));
							}
						}for (var y = 0; y < f.length; ++y) {
							this.group.add(o.mergePath(f[y], { style: { stroke: u[y % u.length], lineDash: a.getLineDash(r), lineWidth: r }, silent: !0 }));
						}
					}
				} });t.exports = h;
		}, function (t, e, i) {
			var n = i(2),
			    a = { type: "axisAreaSelect", event: "axisAreaSelected", update: "updateVisual" };n.registerAction(a, function (t, e) {
				e.eachComponent({ mainType: "parallelAxis", query: t }, function (e) {
					e.axis.model.setActiveIntervals(t.intervals);
				});
			}), n.registerAction("parallelAxisExpand", function (t, e) {
				e.eachComponent({ mainType: "parallel", query: t }, function (e) {
					e.setAxisExpand(t);
				});
			});
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i, n, a) {
				var o = e.axis,
				    s = o.dataToCoord(t),
				    c = n.getAngleAxis().getExtent()[0];c = c / 180 * Math.PI;var h,
				    d,
				    f,
				    p = n.getRadiusAxis().getExtent();if ("radius" === o.dim) {
					var g = l.create();l.rotate(g, g, c), l.translate(g, g, [n.cx, n.cy]), h = r.applyTransform([s, -a], g);var m = e.getModel("axisLabel").get("rotate") || 0,
					    v = u.innerTextLayout(c, m * Math.PI / 180, -1);d = v.textAlign, f = v.textVerticalAlign;
				} else {
					var y = p[1];h = n.coordToPoint([y + a, s]);var x = n.cx,
					    _ = n.cy;d = Math.abs(h[0] - x) / y < .3 ? "center" : h[0] > x ? "left" : "right", f = Math.abs(h[1] - _) / y < .3 ? "middle" : h[1] > _ ? "top" : "bottom";
				}return { position: h, align: d, verticalAlign: f };
			}var a = i(7),
			    o = i(119),
			    r = i(3),
			    s = i(76),
			    l = i(19),
			    u = i(40),
			    c = i(41),
			    h = o.extend({ makeElOption: function makeElOption(t, e, i, o, r) {
					var l = i.axis;"angle" === l.dim && (this.animationThreshold = Math.PI / 18);var u,
					    c = l.polar,
					    h = c.getOtherAxis(l),
					    f = h.getExtent();u = l["dataTo" + a.capitalFirst(l.dim)](e);var p = o.get("type");if (p && "none" !== p) {
						var g = s.buildElStyle(o),
						    m = d[p](l, c, u, f, g);m.style = g, t.graphicKey = m.type, t.pointer = m;
					}var v = o.get("label.margin"),
					    y = n(e, i, o, c, v);s.buildLabelElOption(t, i, o, r, y);
				} }),
			    d = { line: function line(t, e, i, n, a) {
					return "angle" === t.dim ? { type: "Line", shape: s.makeLineShape(e.coordToPoint([n[0], i]), e.coordToPoint([n[1], i])) } : { type: "Circle", shape: { cx: e.cx, cy: e.cy, r: i } };
				}, shadow: function shadow(t, e, i, n, a) {
					var o = t.getBandWidth(),
					    r = Math.PI / 180;return "angle" === t.dim ? { type: "Sector", shape: s.makeSectorShape(e.cx, e.cy, n[0], n[1], (-i - o / 2) * r, (-i + o / 2) * r) } : { type: "Sector", shape: s.makeSectorShape(e.cx, e.cy, i - o / 2, i + o / 2, 0, 2 * Math.PI) };
				} };c.registerAxisPointerClass("PolarAxisPointer", h), t.exports = h;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return t.isHorizontal() ? 0 : 1;
			}function a(t, e) {
				var i = t.getRect();return [i[c[e]], i[c[e]] + i[h[e]]];
			}var o = i(3),
			    r = i(119),
			    s = i(76),
			    l = i(248),
			    u = i(41),
			    c = ["x", "y"],
			    h = ["width", "height"],
			    d = r.extend({ makeElOption: function makeElOption(t, e, i, o, r) {
					var u = i.axis,
					    c = u.coordinateSystem,
					    h = a(c, 1 - n(u)),
					    d = c.dataToPoint(e)[0],
					    p = o.get("type");if (p && "none" !== p) {
						var g = s.buildElStyle(o),
						    m = f[p](u, d, h, g);m.style = g, t.graphicKey = m.type, t.pointer = m;
					}var v = l.layout(i);s.buildCartesianSingleLabelElOption(e, t, v, i, o, r);
				}, getHandleTransform: function getHandleTransform(t, e, i) {
					var n = l.layout(e, { labelInside: !1 });return n.labelMargin = i.get("handle.margin"), { position: s.getTransformedPosition(e.axis, t, n), rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0) };
				}, updateHandleTransform: function updateHandleTransform(t, e, i, o) {
					var r = i.axis,
					    s = r.coordinateSystem,
					    l = n(r),
					    u = a(s, l),
					    c = t.position;c[l] += e[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);var h = a(s, 1 - l),
					    d = (h[1] + h[0]) / 2,
					    f = [d, d];return f[l] = c[l], { position: c, rotation: t.rotation, cursorPoint: f, tooltipOption: { verticalAlign: "middle" } };
				} }),
			    f = { line: function line(t, e, i, a) {
					var r = s.makeLineShape([e, i[0]], [e, i[1]], n(t));return o.subPixelOptimizeLine({ shape: r, style: a }), { type: "Line", shape: r };
				}, shadow: function shadow(t, e, i, a) {
					var o = t.getBandWidth(),
					    r = i[1] - i[0];return { type: "Rect", shape: s.makeRectShape([e - o / 2, i[0]], [o, r], n(t)) };
				} };u.registerAxisPointerClass("SingleAxisPointer", d), t.exports = d;
		}, function (t, e, i) {
			i(2).registerPreprocessor(i(365)), i(367), i(362), i(363), i(364), i(386);
		}, function (t, e, i) {
			function n(t, e) {
				return o.merge({ brushType: t.brushType, brushMode: t.brushMode, transformable: t.transformable, brushStyle: new s(t.brushStyle).getItemStyle(), removeOnClick: t.removeOnClick, z: t.z }, e, !0);
			}var a = i(2),
			    o = i(1),
			    r = i(187),
			    s = i(10),
			    l = ["#ddd"],
			    u = a.extendComponentModel({ type: "brush", dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], defaultOption: { toolbox: null, brushLink: null, seriesIndex: "all", geoIndex: null, xAxisIndex: null, yAxisIndex: null, brushType: "rect", brushMode: "single", transformable: !0, brushStyle: { borderWidth: 1, color: "rgba(120,140,180,0.3)", borderColor: "rgba(120,140,180,0.8)" }, throttleType: "fixRate", throttleDelay: 0, removeOnClick: !0, z: 1e4 }, areas: [], brushType: null, brushOption: {}, coordInfoList: [], optionUpdated: function optionUpdated(t, e) {
					var i = this.option;!e && r.replaceVisualOption(i, t, ["inBrush", "outOfBrush"]), i.inBrush = i.inBrush || {}, i.outOfBrush = i.outOfBrush || { color: l };
				}, setAreas: function setAreas(t) {
					t && (this.areas = o.map(t, function (t) {
						return n(this.option, t);
					}, this));
				}, setBrushOption: function setBrushOption(t) {
					this.brushOption = n(this.option, t), this.brushType = this.brushOption.brushType;
				} });t.exports = u;
		}, function (t, e, i) {
			function n(t, e, i, n) {
				(!n || n.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption).updateCovers(t.areas.slice());
			}var a = i(1),
			    o = i(127),
			    r = i(2);t.exports = r.extendComponentView({ type: "brush", init: function init(t, e) {
					this.ecModel = t, this.api = e, this.model, (this._brushController = new o(e.getZr())).on("brush", a.bind(this._onBrush, this)).mount();
				}, render: function render(t) {
					return this.model = t, n.apply(this, arguments);
				}, updateView: n, updateLayout: n, updateVisual: n, dispose: function dispose() {
					this._brushController.dispose();
				}, _onBrush: function _onBrush(t, e) {
					var i = this.model.id;this.model.brushTargetManager.setOutputRanges(t, this.ecModel), (!e.isEnd || e.removeOnClick) && this.api.dispatchAction({ type: "brush", brushId: i, areas: a.clone(t), $from: i });
				} });
		}, function (t, e, i) {
			var n = i(2);n.registerAction({ type: "brush", event: "brush", update: "updateView" }, function (t, e) {
				e.eachComponent({ mainType: "brush", query: t }, function (e) {
					e.setAreas(t.areas);
				});
			}), n.registerAction({ type: "brushSelect", event: "brushSelected", update: "none" }, function () {});
		}, function (t, e, i) {
			function n(t) {
				var e = {};a.each(t, function (t) {
					e[t] = 1;
				}), t.length = 0, a.each(e, function (e, i) {
					t.push(i);
				});
			}var a = i(1),
			    o = ["rect", "polygon", "keep", "clear"];t.exports = function (t, e) {
				var i = t && t.brush;if (a.isArray(i) || (i = i ? [i] : []), i.length) {
					var r = [];a.each(i, function (t) {
						var e = t.hasOwnProperty("toolbox") ? t.toolbox : [];e instanceof Array && (r = r.concat(e));
					});var s = t && t.toolbox;a.isArray(s) && (s = s[0]), s || (s = { feature: {} }, t.toolbox = [s]);var l = s.feature || (s.feature = {}),
					    u = l.brush || (l.brush = {}),
					    c = u.type || (u.type = []);c.push.apply(c, r), n(c), e && !c.length && c.push.apply(c, o);
				}
			};
		}, function (t, e, i) {
			function n(t) {
				var e = ["x", "y"],
				    i = ["width", "height"];return { point: function point(e, i, n) {
						var o = n.range,
						    r = e[t];return a(r, o);
					}, rect: function rect(n, o, r) {
						var s = r.range,
						    l = [n[e[t]], n[e[t]] + n[i[t]]];return l[1] < l[0] && l.reverse(), a(l[0], s) || a(l[1], s) || a(s[0], l) || a(s[1], l);
					} };
			}function a(t, e) {
				return e[0] <= t && t <= e[1];
			}function o(t, e, i, n, a) {
				for (var o = 0, s = a[a.length - 1]; o < a.length; o++) {
					var l = a[o];if (r(t, e, i, n, l[0], l[1], s[0], s[1])) return !0;s = l;
				}
			}function r(t, e, i, n, a, o, r, u) {
				var c = l(i - t, a - r, n - e, o - u);if (s(c)) return !1;var h = l(a - t, a - r, o - e, o - u) / c;if (h < 0 || h > 1) return !1;var d = l(i - t, a - t, n - e, o - e) / c;return !(d < 0 || d > 1);
			}function s(t) {
				return t <= 1e-6 && t >= -1e-6;
			}function l(t, e, i, n) {
				return t * n - e * i;
			}var u = i(267).contain,
			    c = i(11),
			    h = { lineX: n(0), lineY: n(1), rect: { point: function point(t, e, i) {
						return i.boundingRect.contain(t[0], t[1]);
					}, rect: function rect(t, e, i) {
						return i.boundingRect.intersect(t);
					} }, polygon: { point: function point(t, e, i) {
						return i.boundingRect.contain(t[0], t[1]) && u(i.range, t[0], t[1]);
					}, rect: function rect(t, e, i) {
						var n = i.range;if (n.length <= 1) return !1;var a = t.x,
						    r = t.y,
						    s = t.width,
						    l = t.height,
						    h = n[0];return !!(u(n, a, r) || u(n, a + s, r) || u(n, a, r + l) || u(n, a + s, r + l) || c.create(t).contain(h[0], h[1]) || o(a, r, a + s, r, n) || o(a, r, a, r + l, n) || o(a + s, r, a + s, r + l, n) || o(a, r + l, a + s, r + l, n)) || void 0;
					} } };t.exports = h;
		}, function (t, e, i) {
			function n(t, e, i, n, o) {
				if (o) {
					var r = t.getZr();if (!r[x]) {
						r[y] || (r[y] = a);var s = g.createOrUpdate(r, y, i, e);s(t, n);
					}
				}
			}function a(t, e) {
				if (!t.isDisposed()) {
					var i = t.getZr();i[x] = !0, t.dispatchAction({ type: "brushSelect", batch: e }), i[x] = !1;
				}
			}function o(t, e, i, n) {
				for (var a = 0, o = e.length; a < o; a++) {
					var r = e[a];if (t[r.brushType](n, i, r.selectors, r)) return !0;
				}
			}function r(t) {
				var e = t.brushSelector;if (d.isString(e)) {
					var i = [];return d.each(p, function (t, n) {
						i[n] = function (i, n, a, o) {
							var r = n.getItemLayout(i);return t[e](r, a, o);
						};
					}), i;
				}if (d.isFunction(e)) {
					var n = {};return d.each(p, function (t, i) {
						n[i] = e;
					}), n;
				}return e;
			}function s(t, e) {
				var i = t.option.seriesIndex;return null != i && "all" !== i && (d.isArray(i) ? d.indexOf(i, e) < 0 : e !== i);
			}function l(t) {
				var e = t.selectors = {};return d.each(p[t.brushType], function (i, n) {
					e[n] = function (n) {
						return i(n, e, t);
					};
				}), t;
			}function u(t) {
				return new f(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0]);
			}var c = i(2),
			    h = i(187),
			    d = i(1),
			    f = i(11),
			    p = i(366),
			    g = i(37),
			    m = i(184),
			    v = ["inBrush", "outOfBrush"],
			    y = "__ecBrushSelect",
			    x = "__ecInBrushSelectEvent",
			    _ = c.PRIORITY.VISUAL.BRUSH;c.registerLayout(_, function (t, e, i) {
				t.eachComponent({ mainType: "brush" }, function (e) {
					i && "takeGlobalCursor" === i.type && e.setBrushOption("brush" === i.key ? i.brushOption : { brushType: !1 });var n = e.brushTargetManager = new m(e.option, t);n.setInputRanges(e.areas, t);
				});
			}), c.registerVisual(_, function (t, e, i) {
				var a,
				    u,
				    c = [];t.eachComponent({ mainType: "brush" }, function (e, i) {
					function n(t) {
						return "all" === x || _[t];
					}function f(t) {
						return !!t.length;
					}function p(t, e) {
						var i = t.coordinateSystem;M |= i.hasAxisBrushed(), n(e) && i.eachActiveState(t.getData(), function (t, e) {
							"active" === t && (w[e] = 1);
						});
					}function g(i, a, l) {
						var u = r(i);if (u && !s(e, a) && (d.each(I, function (n) {
							u[n.brushType] && e.brushTargetManager.controlSeries(n, i, t) && l.push(n), M |= f(l);
						}), n(a) && f(l))) {
							var c = i.getData();c.each(function (t) {
								o(u, l, c, t) && (w[t] = 1);
							});
						}
					}var m = { brushId: e.id, brushIndex: i, brushName: e.name, areas: d.clone(e.areas), selected: [] };c.push(m);var y = e.option,
					    x = y.brushLink,
					    _ = [],
					    w = [],
					    S = [],
					    M = 0;i || (a = y.throttleType, u = y.throttleDelay);var I = d.map(e.areas, function (t) {
						return l(d.defaults({ boundingRect: b[t.brushType](t) }, t));
					}),
					    T = h.createVisualMappings(e.option, v, function (t) {
						t.mappingMethod = "fixed";
					});d.isArray(x) && d.each(x, function (t) {
						_[t] = 1;
					}), t.eachSeries(function (t, e) {
						var i = S[e] = [];"parallel" === t.subType ? p(t, e, i) : g(t, e, i);
					}), t.eachSeries(function (t, e) {
						var i = { seriesId: t.id, seriesIndex: e, seriesName: t.name, dataIndex: [] };m.selected.push(i);var a = r(t),
						    s = S[e],
						    l = t.getData(),
						    u = n(e) ? function (t) {
							return w[t] ? (i.dataIndex.push(l.getRawIndex(t)), "inBrush") : "outOfBrush";
						} : function (t) {
							return o(a, s, l, t) ? (i.dataIndex.push(l.getRawIndex(t)), "inBrush") : "outOfBrush";
						};(n(e) ? M : f(s)) && h.applyVisual(v, T, l, u);
					});
				}), n(e, a, u, c, i);
			});var b = { lineX: d.noop, lineY: d.noop, rect: function rect(t) {
					return u(t.range);
				}, polygon: function polygon(t) {
					for (var e, i = t.range, n = 0, a = i.length; n < a; n++) {
						e = e || [[1 / 0, -(1 / 0)], [1 / 0, -(1 / 0)]];var o = i[n];o[0] < e[0][0] && (e[0][0] = o[0]), o[0] > e[0][1] && (e[0][1] = o[0]), o[1] < e[1][0] && (e[1][0] = o[1]), o[1] > e[1][1] && (e[1][1] = o[1]);
					}return e && u(e);
				} };
		}, function (t, e, i) {
			"use strict";
			i(394), i(395), i(369);
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(3),
			    o = i(7),
			    r = i(4),
			    s = { EN: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], CN: ["", "", "", "", "", "", "", "", "", "", "", ""] },
			    l = { EN: ["S", "M", "T", "W", "T", "F", "S"], CN: ["", "", "", "", "", "", ""] };t.exports = i(2).extendComponentView({ type: "calendar", _tlpoints: null, _blpoints: null, _firstDayOfMonth: null, _firstDayPoints: null, render: function render(t, e, i) {
					var n = this.group;n.removeAll();var a = t.coordinateSystem,
					    o = a.getRangeInfo(),
					    r = a.getOrient();this._renderDayRect(t, o, n), this._renderLines(t, o, r, n), this._renderYearText(t, o, r, n), this._renderMonthText(t, r, n), this._renderWeekText(t, o, r, n);
				}, _renderDayRect: function _renderDayRect(t, e, i) {
					for (var n = t.coordinateSystem, o = t.getModel("itemStyle.normal").getItemStyle(), r = n.getCellWidth(), s = n.getCellHeight(), l = e.start.time; l <= e.end.time; l = n.getNextNDay(l, 1).time) {
						var u = n.dataToRect([l], !1).tl,
						    c = new a.Rect({ shape: { x: u[0], y: u[1], width: r, height: s }, style: o });i.add(c);
					}
				}, _renderLines: function _renderLines(t, e, i, n) {
					function a(e) {
						o._firstDayOfMonth.push(r.getDateInfo(e)), o._firstDayPoints.push(r.dataToRect([e], !1).tl);var a = o._getLinePointsOfOneWeek(t, e, i);o._tlpoints.push(a[0]), o._blpoints.push(a[a.length - 1]), l && o._drawSplitline(a, s, n);
					}var o = this,
					    r = t.coordinateSystem,
					    s = t.getModel("splitLine.lineStyle").getLineStyle(),
					    l = t.get("splitLine.show"),
					    u = s.lineWidth;this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];for (var c = e.start, h = 0; c.time <= e.end.time; h++) {
						a(c.formatedDate), 0 === h && (c = r.getDateInfo(e.start.y + "-" + e.start.m));var d = c.date;d.setMonth(d.getMonth() + 1), c = r.getDateInfo(d);
					}a(r.getNextNDay(e.end.time, 1).formatedDate), l && this._drawSplitline(o._getEdgesPoints(o._tlpoints, u, i), s, n), l && this._drawSplitline(o._getEdgesPoints(o._blpoints, u, i), s, n);
				}, _getEdgesPoints: function _getEdgesPoints(t, e, i) {
					var n = [t[0].slice(), t[t.length - 1].slice()],
					    a = "horizontal" === i ? 0 : 1;return n[0][a] = n[0][a] - e / 2, n[1][a] = n[1][a] + e / 2, n;
				}, _drawSplitline: function _drawSplitline(t, e, i) {
					var n = new a.Polyline({ z2: 20, shape: { points: t }, style: e });i.add(n);
				}, _getLinePointsOfOneWeek: function _getLinePointsOfOneWeek(t, e, i) {
					var n = t.coordinateSystem;e = n.getDateInfo(e);for (var a = [], o = 0; o < 7; o++) {
						var r = n.getNextNDay(e.time, o),
						    s = n.dataToRect([r.time], !1);a[2 * r.day] = s.tl, a[2 * r.day + 1] = s["horizontal" === i ? "bl" : "tr"];
					}return a;
				}, _formatterLabel: function _formatterLabel(t, e) {
					return "string" == typeof t && t ? o.formatTplSimple(t, e) : "function" == typeof t ? t(e) : e.nameMap;
				}, _yearTextPositionControl: function _yearTextPositionControl(t, e, i, n) {
					t = t.slice();var a = ["center", "bottom"];"top" === i && (t[1] -= n), "bottom" === i && (t[1] += n, a = ["center", "top"]), "left" === i && (t[0] -= n), "right" === i && (t[0] += n, a = ["center", "top"]);var o = 0;return "left" !== i && "right" !== i || (o = Math.PI / 2), { rotation: o, origin: t, style: { x: t[0], y: t[1], textAlign: a[0], textVerticalAlign: a[1] } };
				}, _renderYearText: function _renderYearText(t, e, i, o) {
					var r = t.getModel("yearLabel");if (r.get("show")) {
						var s = t.getModel("yearLabel.textStyle"),
						    l = r.get("margin"),
						    u = r.get("position");u || (u = "horizontal" !== i ? "top" : "left");var c = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]],
						    h = (c[0][0] + c[1][0]) / 2,
						    d = (c[0][1] + c[1][1]) / 2,
						    f = "horizontal" === i ? 0 : 1,
						    p = { top: [h, c[f][1]], bottom: [h, c[1 - f][1]], left: [c[1 - f][0], d], right: [c[f][0], d] },
						    g = e.start.y;+e.end.y > +e.start.y && (g = g + "-" + e.end.y);var m = r.get("formatter"),
						    v = { start: e.start.y, end: e.end.y, nameMap: g },
						    y = this._formatterLabel(m, v),
						    x = new a.Text(n.merge({ z2: 30, style: { text: y, font: s.getFont(), fill: s.getTextColor() } }, this._yearTextPositionControl(p[u], i, u, l)));o.add(x);
					}
				}, _monthTextPositionControl: function _monthTextPositionControl(t, e, i, n, a) {
					var o = "left",
					    r = "top",
					    s = t[0],
					    l = t[1];return "horizontal" === i ? (l += a, e && (o = "center"), "start" === n && (r = "bottom")) : (s += a, e && (r = "middle"), "start" === n && (o = "right")), { x: s, y: l, textAlign: o, textVerticalAlign: r };
				}, _renderMonthText: function _renderMonthText(t, e, i) {
					var o = t.getModel("monthLabel");if (o.get("show")) {
						var r = t.getModel("monthLabel.textStyle"),
						    l = o.get("nameMap"),
						    u = o.get("margin"),
						    c = o.get("position"),
						    h = o.get("align"),
						    d = [this._tlpoints, this._blpoints];n.isString(l) && (l = s[l.toUpperCase()] || []);var f = "start" === c ? 0 : 1,
						    p = "horizontal" === e ? 0 : 1;u = "start" === c ? -u : u;for (var g = "center" === h, m = 0; m < d[f].length - 1; m++) {
							var v = d[f][m].slice(),
							    y = this._firstDayOfMonth[m];if (g) {
								var x = this._firstDayPoints[m];v[p] = (x[p] + d[0][m + 1][p]) / 2;
							}var _ = o.get("formatter"),
							    b = l[+y.m - 1],
							    w = { yyyy: y.y, yy: (y.y + "").slice(2), MM: y.m, M: +y.m, nameMap: b },
							    S = this._formatterLabel(_, w),
							    M = new a.Text({ z2: 30, style: n.extend({ text: S, font: r.getFont(), fill: r.getTextColor() }, this._monthTextPositionControl(v, g, e, c, u)) });i.add(M);
						}
					}
				}, _weekTextPositionControl: function _weekTextPositionControl(t, e, i, n, a) {
					var o = "center",
					    r = "middle",
					    s = t[0],
					    l = t[1],
					    u = "start" === i;return "horizontal" === e ? (s = s + n + (u ? 1 : -1) * a[0] / 2, o = u ? "right" : "left") : (l = l + n + (u ? 1 : -1) * a[1] / 2, r = u ? "bottom" : "top"), { x: s, y: l, textAlign: o, textVerticalAlign: r };
				}, _renderWeekText: function _renderWeekText(t, e, i, o) {
					var s = t.getModel("dayLabel");if (s.get("show")) {
						var u = t.coordinateSystem,
						    c = t.getModel("dayLabel.textStyle"),
						    h = s.get("position"),
						    d = s.get("nameMap"),
						    f = s.get("margin"),
						    p = u.getFirstDayOfWeek();n.isString(d) && (d = l[d.toUpperCase()] || []);var g = u.getNextNDay(e.end.time, 7 - e.lweek).time,
						    m = [u.getCellWidth(), u.getCellHeight()];f = r.parsePercent(f, m["horizontal" === i ? 0 : 1]), "start" === h && (g = u.getNextNDay(e.start.time, -(7 + e.fweek)).time, f = -f);for (var v = 0; v < 7; v++) {
							var y = u.getNextNDay(g, v),
							    x = u.dataToRect([y.time], !1).center,
							    _ = v;_ = Math.abs((v + p) % 7);var b = new a.Text({ z2: 30, style: n.extend({ text: d[_], font: c.getFont(),
									fill: c.getTextColor() }, this._weekTextPositionControl(x, i, h, f, m)) });o.add(b);
						}
					}
				} });
		}, function (t, e, i) {
			function n(t, e) {
				e.update = "updateView", a.registerAction(e, function (e, i) {
					var n = {};return i.eachComponent({ mainType: "geo", query: e }, function (i) {
						i[t](e.name);var a = i.coordinateSystem;o.each(a.regions, function (t) {
							n[t.name] = i.isSelected(t.name) || !1;
						});
					}), { selected: n, name: e.name };
				});
			}i(399), i(186), i(371), i(240);var a = i(2),
			    o = i(1);n("toggleSelected", { type: "geoToggleSelect", event: "geoselectchanged" }), n("select", { type: "geoSelect", event: "geoselected" }), n("unSelect", { type: "geoUnSelect", event: "geounselected" });
		}, function (t, e, i) {
			"use strict";
			var n = i(249);t.exports = i(2).extendComponentView({ type: "geo", init: function init(t, e) {
					var i = new n(e, !0);this._mapDraw = i, this.group.add(i.group);
				}, render: function render(t, e, i, n) {
					if (!n || "geoToggleSelect" !== n.type || n.from !== this.uid) {
						var a = this._mapDraw;t.get("show") ? a.draw(t, e, i, this, n) : this._mapDraw.group.removeAll(), this.group.silent = t.get("silent");
					}
				}, dispose: function dispose() {
					this._mapDraw && this._mapDraw.remove();
				} });
		}, function (t, e, i) {
			i(263), i(358), i(355);
		}, function (t, e, i) {
			"use strict";
			var n = i(1);i(236), i(353), i(376), i(55), i(359), i(2).registerLayout(n.curry(i(425), "bar")), i(2).extendComponentView({ type: "polar" });
		}, function (t, e, i) {
			i(416), i(417), i(375);
		}, function (t, e, i) {
			var n = i(40),
			    a = i(1),
			    o = i(3),
			    r = ["axisLine", "axisLabel", "axisTick", "axisName"];t.exports = i(2).extendComponentView({ type: "radar", render: function render(t, e, i) {
					var n = this.group;n.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t);
				}, _buildAxes: function _buildAxes(t) {
					var e = t.coordinateSystem,
					    i = e.getIndicatorAxes(),
					    o = a.map(i, function (t) {
						var i = new n(t.model, { position: [e.cx, e.cy], rotation: t.angle, labelDirection: -1, tickDirection: -1, nameDirection: 1 });return i;
					});a.each(o, function (t) {
						a.each(r, t.add, t), this.group.add(t.getGroup());
					}, this);
				}, _buildSplitLineAndArea: function _buildSplitLineAndArea(t) {
					function e(t, e, i) {
						var n = i % e.length;return t[n] = t[n] || [], n;
					}var i = t.coordinateSystem,
					    n = i.getIndicatorAxes();if (n.length) {
						var r = t.get("shape"),
						    s = t.getModel("splitLine"),
						    l = t.getModel("splitArea"),
						    u = s.getModel("lineStyle"),
						    c = l.getModel("areaStyle"),
						    h = s.get("show"),
						    d = l.get("show"),
						    f = u.get("color"),
						    p = c.get("color");f = a.isArray(f) ? f : [f], p = a.isArray(p) ? p : [p];var g = [],
						    m = [];if ("circle" === r) for (var v = n[0].getTicksCoords(), y = i.cx, x = i.cy, _ = 0; _ < v.length; _++) {
							if (h) {
								var b = e(g, f, _);g[b].push(new o.Circle({ shape: { cx: y, cy: x, r: v[_] } }));
							}if (d && _ < v.length - 1) {
								var b = e(m, p, _);m[b].push(new o.Ring({ shape: { cx: y, cy: x, r0: v[_], r: v[_ + 1] } }));
							}
						} else for (var w = -1, S = a.map(n, function (t, e) {
							var n = t.getTicksCoords();return w = Math.max(n.length - 1, w), a.map(n, function (t) {
								return i.coordToPoint(t, e);
							});
						}), M = [], _ = 0; _ <= w; _++) {
							for (var I = [], T = 0; T < n.length; T++) {
								I.push(S[T][_]);
							}if (I[0] && I.push(I[0].slice()), h) {
								var b = e(g, f, _);g[b].push(new o.Polyline({ shape: { points: I } }));
							}if (d && M) {
								var b = e(m, p, _ - 1);m[b].push(new o.Polygon({ shape: { points: I.concat(M) } }));
							}M = I.slice().reverse();
						}var A = u.getLineStyle(),
						    C = c.getAreaStyle();a.each(m, function (t, e) {
							this.group.add(o.mergePath(t, { style: a.defaults({ stroke: "none", fill: p[e % p.length] }, C), silent: !0 }));
						}, this), a.each(g, function (t, e) {
							this.group.add(o.mergePath(t, { style: a.defaults({ fill: "none", stroke: f[e % f.length] }, A), silent: !0 }));
						}, this);
					}
				} });
		}, function (t, e, i) {
			i(236), i(356);
		}, function (t, e, i) {
			var n = i(2);n.registerPreprocessor(i(383)), i(385), i(384), i(378), i(379);
		}, function (t, e, i) {
			var n = i(381),
			    a = i(1),
			    o = i(5),
			    r = n.extend({ type: "timeline.slider", defaultOption: { backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, orient: "horizontal", inverse: !1, tooltip: { trigger: "item" }, symbol: "emptyCircle", symbolSize: 10, lineStyle: { show: !0, width: 2, color: "#304654" }, label: { position: "auto", normal: { show: !0, interval: "auto", rotate: 0, textStyle: { color: "#304654" } }, emphasis: { show: !0, textStyle: { color: "#c23531" } } }, itemStyle: { normal: { color: "#304654", borderWidth: 1 }, emphasis: { color: "#c23531" } }, checkpointStyle: { symbol: "circle", symbolSize: 13, color: "#c23531", borderWidth: 5, borderColor: "rgba(194,53,49, 0.5)", animation: !0, animationDuration: 300, animationEasing: "quinticInOut" }, controlStyle: { show: !0, showPlayBtn: !0, showPrevBtn: !0, showNextBtn: !0, itemSize: 22, itemGap: 12, position: "left", playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z", stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z", nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z", prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z", normal: { color: "#304654", borderColor: "#304654", borderWidth: 1 }, emphasis: { color: "#c23531", borderColor: "#c23531", borderWidth: 2 } }, data: [] } });a.mixin(r, o.dataFormatMixin), t.exports = r;
		}, function (t, e, i) {
			function n(t, e) {
				return u.getLayoutRect(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }, t.get("padding"));
			}function a(t, e, i, n) {
				var a = l.makePath(t.get(e).replace(/^path:\/\//, ""), s.clone(n || {}), new p(i[0], i[1], i[2], i[3]), "center");return a;
			}function o(t, e, i, n, a, o) {
				var r = e.get("color");if (a) a.setColor(r), i.add(a), o && o.onUpdate(a);else {
					var l = t.get("symbol");a = d.createSymbol(l, -1, -1, 2, 2, r), a.setStyle("strokeNoScale", !0), i.add(a), o && o.onCreate(a);
				}var u = e.getItemStyle(["color", "symbol", "symbolSize"]);a.setStyle(u), n = s.merge({ rectHover: !0, z2: 100 }, n, !0);var c = t.get("symbolSize");c = c instanceof Array ? c.slice() : [+c, +c], c[0] /= 2, c[1] /= 2, n.scale = c;var h = t.get("symbolOffset");if (h) {
					var f = n.position = n.position || [0, 0];f[0] += m.parsePercent(h[0], c[0]), f[1] += m.parsePercent(h[1], c[1]);
				}var p = t.get("symbolRotate");return n.rotation = (p || 0) * Math.PI / 180 || 0, a.attr(n), a.updateTransform(), a;
			}function r(t, e, i, n, a) {
				if (!t.dragging) {
					var o = n.getModel("checkpointStyle"),
					    r = i.dataToCoord(n.getData().get(["value"], e));a || !o.get("animation", !0) ? t.attr({ position: [r, 0] }) : (t.stopAnimation(!0), t.animateTo({ position: [r, 0] }, o.get("animationDuration", !0), o.get("animationEasing", !0)));
				}
			}var s = i(1),
			    l = i(3),
			    u = i(12),
			    c = i(382),
			    h = i(380),
			    d = i(24),
			    f = i(18),
			    p = i(11),
			    g = i(19),
			    m = i(4),
			    v = i(7),
			    y = v.encodeHTML,
			    x = s.bind,
			    _ = s.each,
			    b = Math.PI;t.exports = c.extend({ type: "timeline.slider", init: function init(t, e) {
					this.api = e, this._axis, this._viewRect, this._timer, this._currentPointer, this._mainGroup, this._labelGroup;
				}, render: function render(t, e, i, n) {
					if (this.model = t, this.api = i, this.ecModel = e, this.group.removeAll(), t.get("show", !0)) {
						var a = this._layout(t, i),
						    o = this._createGroup("mainGroup"),
						    r = this._createGroup("labelGroup"),
						    s = this._axis = this._createAxis(a, t);t.formatTooltip = function (t) {
							return y(s.scale.getLabel(t));
						}, _(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function (e) {
							this["_render" + e](a, o, s, t);
						}, this), this._renderAxisLabel(a, r, s, t), this._position(a, t);
					}this._doPlayStop();
				}, remove: function remove() {
					this._clearTimer(), this.group.removeAll();
				}, dispose: function dispose() {
					this._clearTimer();
				}, _layout: function _layout(t, e) {
					var i = t.get("label.normal.position"),
					    a = t.get("orient"),
					    o = n(t, e);null == i || "auto" === i ? i = "horizontal" === a ? o.y + o.height / 2 < e.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < e.getWidth() / 2 ? "+" : "-" : isNaN(i) && (i = { horizontal: { top: "-", bottom: "+" }, vertical: { left: "-", right: "+" } }[a][i]);var r = { horizontal: "center", vertical: i >= 0 || "+" === i ? "left" : "right" },
					    s = { horizontal: i >= 0 || "+" === i ? "top" : "bottom", vertical: "middle" },
					    l = { horizontal: 0, vertical: b / 2 },
					    u = "vertical" === a ? o.height : o.width,
					    c = t.getModel("controlStyle"),
					    h = c.get("show"),
					    d = h ? c.get("itemSize") : 0,
					    f = h ? c.get("itemGap") : 0,
					    p = d + f,
					    g = t.get("label.normal.rotate") || 0;g = g * b / 180;var m,
					    v,
					    y,
					    x,
					    _ = c.get("position", !0),
					    h = c.get("show", !0),
					    w = h && c.get("showPlayBtn", !0),
					    S = h && c.get("showPrevBtn", !0),
					    M = h && c.get("showNextBtn", !0),
					    I = 0,
					    T = u;return "left" === _ || "bottom" === _ ? (w && (m = [0, 0], I += p), S && (v = [I, 0], I += p), M && (y = [T - d, 0], T -= p)) : (w && (m = [T - d, 0], T -= p), S && (v = [0, 0], I += p), M && (y = [T - d, 0], T -= p)), x = [I, T], t.get("inverse") && x.reverse(), { viewRect: o, mainLength: u, orient: a, rotation: l[a], labelRotation: g, labelPosOpt: i, labelAlign: r[a], labelBaseline: s[a], playPosition: m, prevBtnPosition: v, nextBtnPosition: y, axisExtent: x, controlSize: d, controlGap: f };
				}, _position: function _position(t, e) {
					function i(t) {
						var e = t.position;t.origin = [h[0][0] - e[0], h[1][0] - e[1]];
					}function n(t) {
						return [[t.x, t.x + t.width], [t.y, t.y + t.height]];
					}function a(t, e, i, n, a) {
						t[n] += i[n][a] - e[n][a];
					}var o = this._mainGroup,
					    r = this._labelGroup,
					    s = t.viewRect;if ("vertical" === t.orient) {
						var l = g.create(),
						    u = s.x,
						    c = s.y + s.height;g.translate(l, l, [-u, -c]), g.rotate(l, l, -b / 2), g.translate(l, l, [u, c]), s = s.clone(), s.applyTransform(l);
					}var h = n(s),
					    d = n(o.getBoundingRect()),
					    f = n(r.getBoundingRect()),
					    p = o.position,
					    m = r.position;m[0] = p[0] = h[0][0];var v = t.labelPosOpt;if (isNaN(v)) {
						var y = "+" === v ? 0 : 1;a(p, d, h, 1, y), a(m, f, h, 1, 1 - y);
					} else {
						var y = v >= 0 ? 0 : 1;a(p, d, h, 1, y), m[1] = p[1] + v;
					}o.attr("position", p), r.attr("position", m), o.rotation = r.rotation = t.rotation, i(o), i(r);
				}, _createAxis: function _createAxis(t, e) {
					var i = e.getData(),
					    n = e.get("axisType"),
					    a = f.createScaleByModel(e, n),
					    o = i.getDataExtent("value");a.setExtent(o[0], o[1]), this._customizeScale(a, i), a.niceTicks();var r = new h("value", a, t.axisExtent, n);return r.model = e, r;
				}, _customizeScale: function _customizeScale(t, e) {
					t.getTicks = function () {
						return e.mapArray(["value"], function (t) {
							return t;
						});
					}, t.getTicksLabels = function () {
						return s.map(this.getTicks(), t.getLabel, t);
					};
				}, _createGroup: function _createGroup(t) {
					var e = this["_" + t] = new l.Group();return this.group.add(e), e;
				}, _renderAxisLine: function _renderAxisLine(t, e, i, n) {
					var a = i.getExtent();n.get("lineStyle.show") && e.add(new l.Line({ shape: { x1: a[0], y1: 0, x2: a[1], y2: 0 }, style: s.extend({ lineCap: "round" }, n.getModel("lineStyle").getLineStyle()), silent: !0, z2: 1 }));
				}, _renderAxisTick: function _renderAxisTick(t, e, i, n) {
					var a = n.getData(),
					    r = i.scale.getTicks();_(r, function (t, r) {
						var s = i.dataToCoord(t),
						    u = a.getItemModel(r),
						    c = u.getModel("itemStyle.normal"),
						    h = u.getModel("itemStyle.emphasis"),
						    d = { position: [s, 0], onclick: x(this._changeTimeline, this, r) },
						    f = o(u, c, e, d);l.setHoverStyle(f, h.getItemStyle()), u.get("tooltip") ? (f.dataIndex = r, f.dataModel = n) : f.dataIndex = f.dataModel = null;
					}, this);
				}, _renderAxisLabel: function _renderAxisLabel(t, e, i, n) {
					var a = n.getModel("label.normal");if (a.get("show")) {
						var o = n.getData(),
						    r = i.scale.getTicks(),
						    s = f.getFormattedLabels(i, a.get("formatter")),
						    u = i.getLabelInterval();_(r, function (n, a) {
							if (!i.isLabelIgnored(a, u)) {
								var r = o.getItemModel(a),
								    c = r.getModel("label.normal.textStyle"),
								    h = r.getModel("label.emphasis.textStyle"),
								    d = i.dataToCoord(n),
								    f = new l.Text({ style: { text: s[a], textAlign: t.labelAlign, textVerticalAlign: t.labelBaseline, textFont: c.getFont(), fill: c.getTextColor() }, position: [d, 0], rotation: t.labelRotation - t.rotation, onclick: x(this._changeTimeline, this, a), silent: !1 });e.add(f), l.setHoverStyle(f, h.getItemStyle());
							}
						}, this);
					}
				}, _renderControl: function _renderControl(t, e, i, n) {
					function o(t, i, o, d) {
						if (t) {
							var f = { position: t, origin: [r / 2, 0], rotation: d ? -s : 0, rectHover: !0, style: u, onclick: o },
							    p = a(n, i, h, f);e.add(p), l.setHoverStyle(p, c);
						}
					}var r = t.controlSize,
					    s = t.rotation,
					    u = n.getModel("controlStyle.normal").getItemStyle(),
					    c = n.getModel("controlStyle.emphasis").getItemStyle(),
					    h = [0, -r / 2, r, r],
					    d = n.getPlayState(),
					    f = n.get("inverse", !0);o(t.nextBtnPosition, "controlStyle.nextIcon", x(this._changeTimeline, this, f ? "-" : "+")), o(t.prevBtnPosition, "controlStyle.prevIcon", x(this._changeTimeline, this, f ? "+" : "-")), o(t.playPosition, "controlStyle." + (d ? "stopIcon" : "playIcon"), x(this._handlePlayClick, this, !d), !0);
				}, _renderCurrentPointer: function _renderCurrentPointer(t, e, i, n) {
					var a = n.getData(),
					    s = n.getCurrentIndex(),
					    l = a.getItemModel(s).getModel("checkpointStyle"),
					    u = this,
					    c = { onCreate: function onCreate(t) {
							t.draggable = !0, t.drift = x(u._handlePointerDrag, u), t.ondragend = x(u._handlePointerDragend, u), r(t, s, i, n, !0);
						}, onUpdate: function onUpdate(t) {
							r(t, s, i, n);
						} };this._currentPointer = o(l, l, this._mainGroup, {}, this._currentPointer, c);
				}, _handlePlayClick: function _handlePlayClick(t) {
					this._clearTimer(), this.api.dispatchAction({ type: "timelinePlayChange", playState: t, from: this.uid });
				}, _handlePointerDrag: function _handlePointerDrag(t, e, i) {
					this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY]);
				}, _handlePointerDragend: function _handlePointerDragend(t) {
					this._pointerChangeTimeline([t.offsetX, t.offsetY], !0);
				}, _pointerChangeTimeline: function _pointerChangeTimeline(t, e) {
					var i = this._toAxisCoord(t)[0],
					    n = this._axis,
					    a = m.asc(n.getExtent().slice());i > a[1] && (i = a[1]), i < a[0] && (i = a[0]), this._currentPointer.position[0] = i, this._currentPointer.dirty();var o = this._findNearestTick(i),
					    r = this.model;(e || o !== r.getCurrentIndex() && r.get("realtime")) && this._changeTimeline(o);
				}, _doPlayStop: function _doPlayStop() {
					function t() {
						var t = this.model;this._changeTimeline(t.getCurrentIndex() + (t.get("rewind", !0) ? -1 : 1));
					}this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(x(t, this), this.model.get("playInterval")));
				}, _toAxisCoord: function _toAxisCoord(t) {
					var e = this._mainGroup.getLocalTransform();return l.applyTransform(t, e, !0);
				}, _findNearestTick: function _findNearestTick(t) {
					var e,
					    i = this.model.getData(),
					    n = 1 / 0,
					    a = this._axis;return i.each(["value"], function (i, o) {
						var r = a.dataToCoord(i),
						    s = Math.abs(r - t);s < n && (n = s, e = o);
					}), e;
				}, _clearTimer: function _clearTimer() {
					this._timer && (clearTimeout(this._timer), this._timer = null);
				}, _changeTimeline: function _changeTimeline(t) {
					var e = this.model.getCurrentIndex();"+" === t ? t = e + 1 : "-" === t && (t = e - 1), this.api.dispatchAction({ type: "timelineChange", currentIndex: t, from: this.uid });
				} });
		}, function (t, e, i) {
			var n = i(1),
			    a = i(33),
			    o = i(18),
			    r = function r(t, e, i, n) {
				a.call(this, t, e, i), this.type = n || "value", this._autoLabelInterval, this.model = null;
			};r.prototype = { constructor: r, getLabelInterval: function getLabelInterval() {
					var t = this.model,
					    e = t.getModel("label.normal"),
					    i = e.get("interval");if (null != i && "auto" != i) return i;var i = this._autoLabelInterval;return i || (i = this._autoLabelInterval = o.getAxisLabelInterval(n.map(this.scale.getTicks(), this.dataToCoord, this), o.getFormattedLabels(this, e.get("formatter")), e.getModel("textStyle").getFont(), "horizontal" === t.get("orient"))), i;
				}, isLabelIgnored: function isLabelIgnored(t) {
					if ("category" === this.type) {
						var e = this.getLabelInterval();return "function" == typeof e && !e(t, this.scale.getLabel(t)) || t % (e + 1);
					}
				} }, n.inherits(r, a), t.exports = r;
		}, function (t, e, i) {
			var n = i(13),
			    a = i(14),
			    o = i(1),
			    r = i(5),
			    s = n.extend({ type: "timeline", layoutMode: "box", defaultOption: { zlevel: 0, z: 4, show: !0, axisType: "time", realtime: !0, left: "20%", top: null, right: "20%", bottom: 0, width: null, height: 40, padding: 5, controlPosition: "left", autoPlay: !1, rewind: !1, loop: !0, playInterval: 2e3, currentIndex: 0, itemStyle: { normal: {}, emphasis: {} }, label: { normal: { textStyle: { color: "#000" } }, emphasis: {} }, data: [] }, init: function init(t, e, i) {
					this._data, this._names, this.mergeDefaultAndTheme(t, i), this._initData();
				}, mergeOption: function mergeOption(t) {
					s.superApply(this, "mergeOption", arguments), this._initData();
				}, setCurrentIndex: function setCurrentIndex(t) {
					null == t && (t = this.option.currentIndex);var e = this._data.count();this.option.loop ? t = (t % e + e) % e : (t >= e && (t = e - 1), t < 0 && (t = 0)), this.option.currentIndex = t;
				}, getCurrentIndex: function getCurrentIndex() {
					return this.option.currentIndex;
				}, isIndexMax: function isIndexMax() {
					return this.getCurrentIndex() >= this._data.count() - 1;
				}, setPlayState: function setPlayState(t) {
					this.option.autoPlay = !!t;
				}, getPlayState: function getPlayState() {
					return !!this.option.autoPlay;
				}, _initData: function _initData() {
					var t = this.option,
					    e = t.data || [],
					    i = t.axisType,
					    n = this._names = [];if ("category" === i) {
						var s = [];o.each(e, function (t, e) {
							var i,
							    a = r.getDataItemValue(t);o.isObject(t) ? (i = o.clone(t), i.value = e) : i = e, s.push(i), o.isString(a) || null != a && !isNaN(a) || (a = ""), n.push(a + "");
						}), e = s;
					}var l = { category: "ordinal", time: "time" }[i] || "number",
					    u = this._data = new a([{ name: "value", type: l }], this);u.initData(e, n);
				}, getData: function getData() {
					return this._data;
				}, getCategories: function getCategories() {
					if ("category" === this.get("axisType")) return this._names.slice();
				} });t.exports = s;
		}, function (t, e, i) {
			var n = i(65);t.exports = n.extend({ type: "timeline" });
		}, function (t, e, i) {
			function n(t) {
				var e = t.type,
				    i = { number: "value", time: "time" };if (i[e] && (t.axisType = i[e], delete t.type), a(t), o(t, "controlPosition")) {
					var n = t.controlStyle || (t.controlStyle = {});o(n, "position") || (n.position = t.controlPosition), "none" !== n.position || o(n, "show") || (n.show = !1, delete n.position), delete t.controlPosition;
				}r.each(t.data || [], function (t) {
					r.isObject(t) && !r.isArray(t) && (!o(t, "value") && o(t, "name") && (t.value = t.name), a(t));
				});
			}function a(t) {
				var e = t.itemStyle || (t.itemStyle = {}),
				    i = e.emphasis || (e.emphasis = {}),
				    n = t.label || t.label || {},
				    a = n.normal || (n.normal = {}),
				    s = { normal: 1, emphasis: 1 };r.each(n, function (t, e) {
					s[e] || o(a, e) || (a[e] = t);
				}), i.label && !o(n, "emphasis") && (n.emphasis = i.label, delete i.label);
			}function o(t, e) {
				return t.hasOwnProperty(e);
			}var r = i(1);t.exports = function (t) {
				var e = t && t.timeline;r.isArray(e) || (e = e ? [e] : []), r.each(e, function (t) {
					t && n(t);
				});
			};
		}, function (t, e, i) {
			var n = i(2),
			    a = i(1);n.registerAction({ type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate" }, function (t, e) {
				var i = e.getComponent("timeline");return i && null != t.currentIndex && (i.setCurrentIndex(t.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.setPlayState(!1)), e.resetOption("timeline"), a.defaults({ currentIndex: i.option.currentIndex }, t);
			}), n.registerAction({ type: "timelinePlayChange", event: "timelinePlayChanged", update: "update" }, function (t, e) {
				var i = e.getComponent("timeline");i && null != t.playState && i.setPlayState(t.playState);
			});
		}, function (t, e, i) {
			i(13).registerSubTypeDefaulter("timeline", function () {
				return "slider";
			});
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				this.model = t, this.ecModel = e, this.api = i, this._brushType, this._brushMode;
			}var a = i(29),
			    o = i(1);n.defaultOption = { show: !0, type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"], icon: { rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13", polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2", lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4", lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4", keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z", clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2" }, title: { rect: "", polygon: "", lineX: "", lineY: "", keep: "", clear: "" } };var r = n.prototype;r.render = r.updateView = r.updateLayout = function (t, e, i) {
				var n, a, r;e.eachComponent({ mainType: "brush" }, function (t) {
					n = t.brushType, a = t.brushOption.brushMode || "single", r |= t.areas.length;
				}), this._brushType = n, this._brushMode = a, o.each(t.get("type", !0), function (e) {
					t.setIconStatus(e, ("keep" === e ? "multiple" === a : "clear" === e ? r : e === n) ? "emphasis" : "normal");
				});
			}, r.getIcons = function () {
				var t = this.model,
				    e = t.get("icon", !0),
				    i = {};return o.each(t.get("type", !0), function (t) {
					e[t] && (i[t] = e[t]);
				}), i;
			}, r.onclick = function (t, e, i) {
				var e = this.api,
				    n = this._brushType,
				    a = this._brushMode;"clear" === i ? (e.dispatchAction({ type: "axisAreaSelect", intervals: [] }), e.dispatchAction({ type: "brush", command: "clear", areas: [] })) : e.dispatchAction({ type: "takeGlobalCursor", key: "brush", brushOption: { brushType: "keep" === i ? n : n !== i && i, brushMode: "keep" === i ? "multiple" === a ? "single" : "multiple" : a } });
			}, a.register("brush", n), t.exports = n;
		}, function (t, e, i) {
			i(392), i(393);
		}, function (t, e, i) {
			function n(t, e, i) {
				if (i[0] === i[1]) return i.slice();for (var n = 200, a = (i[1] - i[0]) / n, o = i[0], r = [], s = 0; s <= n && o < i[1]; s++) {
					r.push(o), o += a;
				}return r.push(i[1]), r;
			}var a = i(253),
			    o = i(1),
			    r = i(4),
			    s = [20, 140],
			    l = a.extend({ type: "visualMap.continuous", defaultOption: { align: "auto", calculable: !1, range: null, realtime: !0, itemHeight: null, itemWidth: null, hoverLink: !0, hoverLinkDataSize: null, hoverLinkOnHandle: !0 }, optionUpdated: function optionUpdated(t, e) {
					l.superApply(this, "optionUpdated", arguments), this.resetTargetSeries(), this.resetExtent(), this.resetVisual(function (t) {
						t.mappingMethod = "linear", t.dataExtent = this.getExtent();
					}), this._resetRange();
				}, resetItemSize: function resetItemSize() {
					l.superApply(this, "resetItemSize", arguments);var t = this.itemSize;"horizontal" === this._orient && t.reverse(), (null == t[0] || isNaN(t[0])) && (t[0] = s[0]), (null == t[1] || isNaN(t[1])) && (t[1] = s[1]);
				}, _resetRange: function _resetRange() {
					var t = this.getExtent(),
					    e = this.option.range;!e || e.auto ? (t.auto = 1, this.option.range = t) : o.isArray(e) && (e[0] > e[1] && e.reverse(), e[0] = Math.max(e[0], t[0]), e[1] = Math.min(e[1], t[1]));
				}, completeVisualOption: function completeVisualOption() {
					a.prototype.completeVisualOption.apply(this, arguments), o.each(this.stateList, function (t) {
						var e = this.option.controller[t].symbolSize;e && e[0] !== e[1] && (e[0] = 0);
					}, this);
				}, setSelected: function setSelected(t) {
					this.option.range = t.slice(), this._resetRange();
				}, getSelected: function getSelected() {
					var t = this.getExtent(),
					    e = r.asc((this.get("range") || []).slice());return e[0] > t[1] && (e[0] = t[1]), e[1] > t[1] && (e[1] = t[1]), e[0] < t[0] && (e[0] = t[0]), e[1] < t[0] && (e[1] = t[0]), e;
				}, getValueState: function getValueState(t) {
					var e = this.option.range,
					    i = this.getExtent();return (e[0] <= i[0] || e[0] <= t) && (e[1] >= i[1] || t <= e[1]) ? "inRange" : "outOfRange";
				}, findTargetDataIndices: function findTargetDataIndices(t) {
					var e = [];return this.eachTargetSeries(function (i) {
						var n = [],
						    a = i.getData();a.each(this.getDataDimension(a), function (e, i) {
							t[0] <= e && e <= t[1] && n.push(i);
						}, !0, this), e.push({ seriesId: i.id, dataIndex: n });
					}, this), e;
				}, getVisualMeta: function getVisualMeta(t) {
					function e(e, i) {
						o.push({ value: e, color: t(e, i) });
					}for (var i = n(this, "outOfRange", this.getExtent()), a = n(this, "inRange", this.option.range.slice()), o = [], r = 0, s = 0, l = a.length, u = i.length; s < u && (!a.length || i[s] <= a[0]); s++) {
						i[s] < a[r] && e(i[s], "outOfRange");
					}for (var c = 1; r < l; r++, c = 0) {
						c && o.length && e(a[r], "outOfRange"), e(a[r], "inRange");
					}for (var c = 1; s < u; s++) {
						(!a.length || a[a.length - 1] < i[s]) && (c && (o.length && e(o[o.length - 1].value, "outOfRange"), c = 0), e(i[s], "outOfRange"));
					}var h = o.length;return { stops: o, outerColors: [h ? o[0].color : "transparent", h ? o[h - 1].color : "transparent"] };
				} });t.exports = l;
		}, function (t, e, i) {
			function n(t, e, i, n) {
				return new u.Polygon({ shape: { points: t }, draggable: !!i, cursor: e, drift: i, onmousemove: function onmousemove(t) {
						m.stop(t.event);
					}, ondragend: n });
			}function a(t, e) {
				return 0 === t ? [[0, 0], [e, 0], [e, -e]] : [[0, 0], [e, 0], [e, e]];
			}function o(t, e, i, n) {
				return t ? [[0, -x(e, _(i, 0))], [w, 0], [0, x(e, _(n - i, 0))]] : [[0, 0], [5, -5], [5, 5]];
			}function r(t, e, i) {
				var n = b / 2,
				    a = t.get("hoverLinkDataSize");return a && (n = v(a, e, i, !0) / 2), n;
			}function s(t) {
				return !t.get("realtime") && t.get("hoverLinkOnHandle");
			}var l = i(254),
			    u = i(3),
			    c = i(1),
			    h = i(4),
			    d = i(56),
			    f = i(100),
			    p = i(255),
			    g = i(5),
			    m = i(21),
			    v = h.linearMap,
			    y = c.each,
			    x = Math.min,
			    _ = Math.max,
			    b = 12,
			    w = 6,
			    S = l.extend({ type: "visualMap.continuous", init: function init() {
					S.superApply(this, "init", arguments), this._shapes = {}, this._dataInterval = [], this._handleEnds = [], this._orient, this._useHandle, this._hoverLinkDataIndices = [], this._dragging, this._hovering;
				}, doRender: function doRender(t, e, i, n) {
					n && "selectDataRange" === n.type && n.from === this.uid || this._buildView();
				}, _buildView: function _buildView() {
					this.group.removeAll();var t = this.visualMapModel,
					    e = this.group;this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(e);var i = t.get("text");this._renderEndsText(e, i, 0), this._renderEndsText(e, i, 1), this._updateView(!0), this.renderBackground(e), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(e);
				}, _renderEndsText: function _renderEndsText(t, e, i) {
					if (e) {
						var n = e[1 - i];n = null != n ? n + "" : "";var a = this.visualMapModel,
						    o = a.get("textGap"),
						    r = a.itemSize,
						    s = this._shapes.barGroup,
						    l = this._applyTransform([r[0] / 2, 0 === i ? -o : r[1] + o], s),
						    c = this._applyTransform(0 === i ? "bottom" : "top", s),
						    h = this._orient,
						    d = this.visualMapModel.textStyleModel;this.group.add(new u.Text({ style: { x: l[0], y: l[1], textVerticalAlign: "horizontal" === h ? "middle" : c, textAlign: "horizontal" === h ? c : "center", text: n, textFont: d.getFont(), fill: d.getTextColor() } }));
					}
				}, _renderBar: function _renderBar(t) {
					var e = this.visualMapModel,
					    i = this._shapes,
					    a = e.itemSize,
					    o = this._orient,
					    r = this._useHandle,
					    s = p.getItemAlign(e, this.api, a),
					    l = i.barGroup = this._createBarGroup(s);l.add(i.outOfRange = n()), l.add(i.inRange = n(null, r ? "move" : null, c.bind(this._dragHandle, this, "all", !1), c.bind(this._dragHandle, this, "all", !0)));var u = e.textStyleModel.getTextRect(""),
					    h = _(u.width, u.height);r && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(l, 0, a, h, o, s), this._createHandle(l, 1, a, h, o, s)), this._createIndicator(l, a, h, o), t.add(l);
				}, _createHandle: function _createHandle(t, e, i, o, r) {
					var s = c.bind(this._dragHandle, this, e, !1),
					    l = c.bind(this._dragHandle, this, e, !0),
					    h = n(a(e, o), "move", s, l);h.position[0] = i[0], t.add(h);var d = this.visualMapModel.textStyleModel,
					    f = new u.Text({ draggable: !0, drift: s, onmousemove: function onmousemove(t) {
							m.stop(t.event);
						}, ondragend: l, style: { x: 0, y: 0, text: "", textFont: d.getFont(), fill: d.getTextColor() } });this.group.add(f);var p = ["horizontal" === r ? o / 2 : 1.5 * o, "horizontal" === r ? 0 === e ? -(1.5 * o) : 1.5 * o : 0 === e ? -o / 2 : o / 2],
					    g = this._shapes;g.handleThumbs[e] = h, g.handleLabelPoints[e] = p, g.handleLabels[e] = f;
				}, _createIndicator: function _createIndicator(t, e, i, a) {
					var o = n([[0, 0]], "move");o.position[0] = e[0], o.attr({ invisible: !0, silent: !0 }), t.add(o);var r = this.visualMapModel.textStyleModel,
					    s = new u.Text({ silent: !0, invisible: !0, style: { x: 0, y: 0, text: "", textFont: r.getFont(), fill: r.getTextColor() } });this.group.add(s);var l = ["horizontal" === a ? i / 2 : w + 3, 0],
					    c = this._shapes;c.indicator = o, c.indicatorLabel = s, c.indicatorLabelPoint = l;
				}, _dragHandle: function _dragHandle(t, e, i, n) {
					if (this._useHandle) {
						if (this._dragging = !e, !e) {
							var a = this._applyTransform([i, n], this._shapes.barGroup, !0);this._updateInterval(t, a[1]), this._updateView();
						}e === !this.visualMapModel.get("realtime") && this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: this._dataInterval.slice() }), e ? !this._hovering && this._clearHoverLinkToSeries() : s(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1);
					}
				}, _resetInterval: function _resetInterval() {
					var t = this.visualMapModel,
					    e = this._dataInterval = t.getSelected(),
					    i = t.getExtent(),
					    n = [0, t.itemSize[1]];this._handleEnds = [v(e[0], i, n, !0), v(e[1], i, n, !0)];
				}, _updateInterval: function _updateInterval(t, e) {
					e = e || 0;var i = this.visualMapModel,
					    n = this._handleEnds,
					    a = [0, i.itemSize[1]];d(e, n, a, t, 0);var o = i.getExtent();this._dataInterval = [v(n[0], a, o, !0), v(n[1], a, o, !0)];
				}, _updateView: function _updateView(t) {
					var e = this.visualMapModel,
					    i = e.getExtent(),
					    n = this._shapes,
					    a = [0, e.itemSize[1]],
					    o = t ? a : this._handleEnds,
					    r = this._createBarVisual(this._dataInterval, i, o, "inRange"),
					    s = this._createBarVisual(i, i, a, "outOfRange");n.inRange.setStyle({ fill: r.barColor, opacity: r.opacity }).setShape("points", r.barPoints), n.outOfRange.setStyle({ fill: s.barColor, opacity: s.opacity }).setShape("points", s.barPoints), this._updateHandle(o, r);
				}, _createBarVisual: function _createBarVisual(t, e, i, n) {
					var a = { forceState: n, convertOpacityToAlpha: !0 },
					    o = this._makeColorGradient(t, a),
					    r = [this.getControllerVisual(t[0], "symbolSize", a), this.getControllerVisual(t[1], "symbolSize", a)],
					    s = this._createBarPoints(i, r);return { barColor: new f(0, 0, 0, 1, o), barPoints: s, handlesColor: [o[0].color, o[o.length - 1].color] };
				}, _makeColorGradient: function _makeColorGradient(t, e) {
					var i = 100,
					    n = [],
					    a = (t[1] - t[0]) / i;n.push({ color: this.getControllerVisual(t[0], "color", e), offset: 0 });for (var o = 1; o < i; o++) {
						var r = t[0] + a * o;if (r > t[1]) break;n.push({ color: this.getControllerVisual(r, "color", e), offset: o / i });
					}return n.push({ color: this.getControllerVisual(t[1], "color", e), offset: 1 }), n;
				}, _createBarPoints: function _createBarPoints(t, e) {
					var i = this.visualMapModel.itemSize;return [[i[0] - e[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - e[1], t[1]]];
				}, _createBarGroup: function _createBarGroup(t) {
					var e = this._orient,
					    i = this.visualMapModel.get("inverse");return new u.Group("horizontal" !== e || i ? "horizontal" === e && i ? { scale: "bottom" === t ? [-1, 1] : [1, 1], rotation: -Math.PI / 2 } : "vertical" !== e || i ? { scale: "left" === t ? [1, 1] : [-1, 1] } : { scale: "left" === t ? [1, -1] : [-1, -1] } : { scale: "bottom" === t ? [1, 1] : [-1, 1], rotation: Math.PI / 2 });
				}, _updateHandle: function _updateHandle(t, e) {
					if (this._useHandle) {
						var i = this._shapes,
						    n = this.visualMapModel,
						    a = i.handleThumbs,
						    o = i.handleLabels;y([0, 1], function (r) {
							var s = a[r];s.setStyle("fill", e.handlesColor[r]), s.position[1] = t[r];var l = u.applyTransform(i.handleLabelPoints[r], u.getTransform(s, this.group));o[r].setStyle({ x: l[0], y: l[1], text: n.formatValueText(this._dataInterval[r]), textVerticalAlign: "middle", textAlign: this._applyTransform("horizontal" === this._orient ? 0 === r ? "bottom" : "top" : "left", i.barGroup) });
						}, this);
					}
				}, _showIndicator: function _showIndicator(t, e, i, n) {
					var a = this.visualMapModel,
					    r = a.getExtent(),
					    s = a.itemSize,
					    l = [0, s[1]],
					    c = v(t, r, l, !0),
					    h = this._shapes,
					    d = h.indicator;if (d) {
						d.position[1] = c, d.attr("invisible", !1), d.setShape("points", o(!!i, n, c, s[1]));var f = { convertOpacityToAlpha: !0 },
						    p = this.getControllerVisual(t, "color", f);d.setStyle("fill", p);var g = u.applyTransform(h.indicatorLabelPoint, u.getTransform(d, this.group)),
						    m = h.indicatorLabel;m.attr("invisible", !1);var y = this._applyTransform("left", h.barGroup),
						    x = this._orient;m.setStyle({ text: (i ? i : "") + a.formatValueText(e), textVerticalAlign: "horizontal" === x ? y : "middle", textAlign: "horizontal" === x ? "center" : y, x: g[0], y: g[1] });
					}
				}, _enableHoverLinkToSeries: function _enableHoverLinkToSeries() {
					var t = this;this._shapes.barGroup.on("mousemove", function (e) {
						if (t._hovering = !0, !t._dragging) {
							var i = t.visualMapModel.itemSize,
							    n = t._applyTransform([e.offsetX, e.offsetY], t._shapes.barGroup, !0, !0);n[1] = x(_(0, n[1]), i[1]), t._doHoverLinkToSeries(n[1], 0 <= n[0] && n[0] <= i[0]);
						}
					}).on("mouseout", function () {
						t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries();
					});
				}, _enableHoverLinkFromSeries: function _enableHoverLinkFromSeries() {
					var t = this.api.getZr();this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
				}, _doHoverLinkToSeries: function _doHoverLinkToSeries(t, e) {
					var i = this.visualMapModel,
					    n = i.itemSize;if (i.option.hoverLink) {
						var a = [0, n[1]],
						    o = i.getExtent();t = x(_(a[0], t), a[1]);var l = r(i, o, a),
						    u = [t - l, t + l],
						    c = v(t, a, o, !0),
						    h = [v(u[0], a, o, !0), v(u[1], a, o, !0)];u[0] < a[0] && (h[0] = -(1 / 0)), u[1] > a[1] && (h[1] = 1 / 0), e && (h[0] === -(1 / 0) ? this._showIndicator(c, h[1], "< ", l) : h[1] === 1 / 0 ? this._showIndicator(c, h[0], "> ", l) : this._showIndicator(c, c, " ", l));var d = this._hoverLinkDataIndices,
						    f = [];(e || s(i)) && (f = this._hoverLinkDataIndices = i.findTargetDataIndices(h));var m = g.compressBatches(d, f);this._dispatchHighDown("downplay", p.convertDataIndex(m[0])), this._dispatchHighDown("highlight", p.convertDataIndex(m[1]));
					}
				}, _hoverLinkFromSeriesMouseOver: function _hoverLinkFromSeriesMouseOver(t) {
					var e = t.target,
					    i = this.visualMapModel;if (e && null != e.dataIndex) {
						var n = this.ecModel.getSeriesByIndex(e.seriesIndex);if (i.isTargetSeries(n)) {
							var a = n.getData(e.dataType),
							    o = a.getDimension(i.getDataDimension(a)),
							    r = a.get(o, e.dataIndex, !0);isNaN(r) || this._showIndicator(r, r);
						}
					}
				}, _hideIndicator: function _hideIndicator() {
					var t = this._shapes;t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0);
				}, _clearHoverLinkToSeries: function _clearHoverLinkToSeries() {
					this._hideIndicator();var t = this._hoverLinkDataIndices;this._dispatchHighDown("downplay", p.convertDataIndex(t)), t.length = 0;
				}, _clearHoverLinkFromSeries: function _clearHoverLinkFromSeries() {
					this._hideIndicator();var t = this.api.getZr();t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator);
				}, _applyTransform: function _applyTransform(t, e, i, n) {
					var a = u.getTransform(e, n ? null : this.group);return u[c.isArray(t) ? "applyTransform" : "transformDirection"](t, a, i);
				}, _dispatchHighDown: function _dispatchHighDown(t, e) {
					e && e.length && this.api.dispatchAction({ type: t, batch: e });
				}, dispose: function dispose() {
					this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
				}, remove: function remove() {
					this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
				} });t.exports = S;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t.inverse;("vertical" === t.orient ? !i : i) && e.reverse();
			}var a = i(253),
			    o = i(1),
			    r = i(83),
			    s = i(266),
			    l = i(4).reformIntervals,
			    u = a.extend({ type: "visualMap.piecewise", defaultOption: { selected: null, minOpen: !1, maxOpen: !1, align: "auto", itemWidth: 20, itemHeight: 14, itemSymbol: "roundRect", pieceList: null, categories: null, splitNumber: 5, selectedMode: "multiple", itemGap: 10, hoverLink: !0, showLabel: null }, optionUpdated: function optionUpdated(t, e) {
					u.superApply(this, "optionUpdated", arguments), this._pieceList = [], this.resetTargetSeries(), this.resetExtent();var i = this._mode = this._determineMode();c[this._mode].call(this), this._resetSelected(t, e);var n = this.option.categories;this.resetVisual(function (t, e) {
						"categories" === i ? (t.mappingMethod = "category", t.categories = o.clone(n)) : (t.dataExtent = this.getExtent(), t.mappingMethod = "piecewise", t.pieceList = o.map(this._pieceList, function (t) {
							var t = o.clone(t);return "inRange" !== e && (t.visual = null), t;
						}));
					});
				}, completeVisualOption: function completeVisualOption() {
					function t(t, e, i) {
						return t && t[e] && (o.isObject(t[e]) ? t[e].hasOwnProperty(i) : t[e] === i);
					}var e = this.option,
					    i = {},
					    n = r.listVisualTypes(),
					    l = this.isCategory();o.each(e.pieces, function (t) {
						o.each(n, function (e) {
							t.hasOwnProperty(e) && (i[e] = 1);
						});
					}), o.each(i, function (i, n) {
						var a = 0;o.each(this.stateList, function (i) {
							a |= t(e, i, n) || t(e.target, i, n);
						}, this), !a && o.each(this.stateList, function (t) {
							(e[t] || (e[t] = {}))[n] = s.get(n, "inRange" === t ? "active" : "inactive", l);
						});
					}, this), a.prototype.completeVisualOption.apply(this, arguments);
				}, _resetSelected: function _resetSelected(t, e) {
					var i = this.option,
					    n = this._pieceList,
					    a = (e ? i : t).selected || {};if (i.selected = a, o.each(n, function (t, e) {
						var i = this.getSelectedMapKey(t);a.hasOwnProperty(i) || (a[i] = !0);
					}, this), "single" === i.selectedMode) {
						var r = !1;o.each(n, function (t, e) {
							var i = this.getSelectedMapKey(t);a[i] && (r ? a[i] = !1 : r = !0);
						}, this);
					}
				}, getSelectedMapKey: function getSelectedMapKey(t) {
					return "categories" === this._mode ? t.value + "" : t.index + "";
				}, getPieceList: function getPieceList() {
					return this._pieceList;
				}, _determineMode: function _determineMode() {
					var t = this.option;return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
				}, setSelected: function setSelected(t) {
					this.option.selected = o.clone(t);
				}, getValueState: function getValueState(t) {
					var e = r.findPieceIndex(t, this._pieceList);return null != e && this.option.selected[this.getSelectedMapKey(this._pieceList[e])] ? "inRange" : "outOfRange";
				}, findTargetDataIndices: function findTargetDataIndices(t) {
					var e = [];return this.eachTargetSeries(function (i) {
						var n = [],
						    a = i.getData();a.each(this.getDataDimension(a), function (e, i) {
							var a = r.findPieceIndex(e, this._pieceList);a === t && n.push(i);
						}, !0, this), e.push({ seriesId: i.id, dataIndex: n });
					}, this), e;
				}, getRepresentValue: function getRepresentValue(t) {
					var e;if (this.isCategory()) e = t.value;else if (null != t.value) e = t.value;else {
						var i = t.interval || [];e = i[0] === -(1 / 0) && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
					}return e;
				}, getVisualMeta: function getVisualMeta(t) {
					function e(e, o) {
						var r = a.getRepresentValue({ interval: e });o || (o = a.getValueState(r));var s = t(r, o);e[0] === -(1 / 0) ? n[0] = s : e[1] === 1 / 0 ? n[1] = s : i.push({ value: e[0], color: s }, { value: e[1], color: s });
					}if (!this.isCategory()) {
						var i = [],
						    n = [],
						    a = this,
						    r = this._pieceList.slice();if (r.length) {
							var s = r[0].interval[0];s !== -(1 / 0) && r.unshift({ interval: [-(1 / 0), s] }), s = r[r.length - 1].interval[1], s !== 1 / 0 && r.push({ interval: [s, 1 / 0] });
						} else r.push({ interval: [-(1 / 0), 1 / 0] });var l = -(1 / 0);return o.each(r, function (t) {
							var i = t.interval;i && (i[0] > l && e([l, i[0]], "outOfRange"), e(i.slice()), l = i[1]);
						}, this), { stops: i, outerColors: n };
					}
				} }),
			    c = { splitNumber: function splitNumber() {
					var t = this.option,
					    e = this._pieceList,
					    i = t.precision,
					    n = this.getExtent(),
					    a = t.splitNumber;a = Math.max(parseInt(a, 10), 1), t.splitNumber = a;for (var r = (n[1] - n[0]) / a; +r.toFixed(i) !== r && i < 5;) {
						i++;
					}t.precision = i, r = +r.toFixed(i);var s = 0;t.minOpen && e.push({ index: s++, interval: [-(1 / 0), n[0]], close: [0, 0] });for (var u = n[0], c = s + a; s < c; u += r) {
						var h = s === a - 1 ? n[1] : u + r;e.push({ index: s++, interval: [u, h], close: [1, 1] });
					}t.maxOpen && e.push({ index: s++, interval: [n[1], 1 / 0], close: [0, 0] }), l(e), o.each(e, function (t) {
						t.text = this.formatValueText(t.interval);
					}, this);
				}, categories: function categories() {
					var t = this.option;o.each(t.categories, function (t) {
						this._pieceList.push({ text: this.formatValueText(t, !0), value: t });
					}, this), n(t, this._pieceList);
				}, pieces: function pieces() {
					var t = this.option,
					    e = this._pieceList;o.each(t.pieces, function (t, i) {
						o.isObject(t) || (t = { value: t });var n = { text: "", index: i };if (null != t.label && (n.text = t.label), t.hasOwnProperty("value")) {
							var a = n.value = t.value;n.interval = [a, a], n.close = [1, 1];
						} else {
							for (var s = n.interval = [], l = n.close = [0, 0], u = [1, 0, 1], c = [-(1 / 0), 1 / 0], h = [], d = 0; d < 2; d++) {
								for (var f = [["gte", "gt", "min"], ["lte", "lt", "max"]][d], p = 0; p < 3 && null == s[d]; p++) {
									s[d] = t[f[p]], l[d] = u[p], h[d] = 2 === p;
								}null == s[d] && (s[d] = c[d]);
							}h[0] && s[1] === 1 / 0 && (l[0] = 0), h[1] && s[0] === -(1 / 0) && (l[1] = 0), s[0] === s[1] && l[0] && l[1] && (n.value = s[0]);
						}n.visual = r.retrieveVisuals(t), e.push(n);
					}, this), n(t, e), l(e), o.each(e, function (t) {
						var e = t.close,
						    i = [["<", ""][e[1]], [">", ""][e[0]]];t.text = t.text || this.formatValueText(null != t.value ? t.value : t.interval, !1, i);
					}, this);
				} };t.exports = u;
		}, function (t, e, i) {
			var n = i(254),
			    a = i(1),
			    o = i(3),
			    r = i(24),
			    s = i(12),
			    l = i(255),
			    u = n.extend({ type: "visualMap.piecewise", doRender: function doRender() {
					function t(t) {
						var r = t.piece,
						    s = new o.Group();s.onclick = a.bind(this._onItemClick, this, r), this._enableHoverLink(s, t.indexInModelPieceList);var d = i.getRepresentValue(r);if (this._createItemSymbol(s, d, [0, 0, h[0], h[1]]), p) {
							var f = this.visualMapModel.getValueState(d);s.add(new o.Text({ style: { x: "right" === c ? -n : h[0] + n, y: h[1] / 2, text: r.text, textVerticalAlign: "middle", textAlign: c, textFont: l, fill: u, opacity: "outOfRange" === f ? .5 : 1 } }));
						}e.add(s);
					}var e = this.group;e.removeAll();var i = this.visualMapModel,
					    n = i.get("textGap"),
					    r = i.textStyleModel,
					    l = r.getFont(),
					    u = r.getTextColor(),
					    c = this._getItemAlign(),
					    h = i.itemSize,
					    d = this._getViewData(),
					    f = d.endsText,
					    p = a.retrieve(i.get("showLabel", !0), !f);f && this._renderEndsText(e, f[0], h, p, c), a.each(d.viewPieceList, t, this), f && this._renderEndsText(e, f[1], h, p, c), s.box(i.get("orient"), e, i.get("itemGap")), this.renderBackground(e), this.positionGroup(e);
				}, _enableHoverLink: function _enableHoverLink(t, e) {
					function i(t) {
						var i = this.visualMapModel;i.option.hoverLink && this.api.dispatchAction({ type: t, batch: l.convertDataIndex(i.findTargetDataIndices(e)) });
					}t.on("mouseover", a.bind(i, this, "highlight")).on("mouseout", a.bind(i, this, "downplay"));
				}, _getItemAlign: function _getItemAlign() {
					var t = this.visualMapModel,
					    e = t.option;if ("vertical" === e.orient) return l.getItemAlign(t, this.api, t.itemSize);var i = e.align;return i && "auto" !== i || (i = "left"), i;
				}, _renderEndsText: function _renderEndsText(t, e, i, n, a) {
					if (e) {
						var r = new o.Group(),
						    s = this.visualMapModel.textStyleModel;r.add(new o.Text({ style: { x: n ? "right" === a ? i[0] : 0 : i[0] / 2, y: i[1] / 2, textVerticalAlign: "middle", textAlign: n ? a : "center", text: e, textFont: s.getFont(), fill: s.getTextColor() } })), t.add(r);
					}
				}, _getViewData: function _getViewData() {
					var t = this.visualMapModel,
					    e = a.map(t.getPieceList(), function (t, e) {
						return { piece: t, indexInModelPieceList: e };
					}),
					    i = t.get("text"),
					    n = t.get("orient"),
					    o = t.get("inverse");return ("horizontal" === n ? o : !o) ? e.reverse() : i && (i = i.slice().reverse()), { viewPieceList: e, endsText: i };
				}, _createItemSymbol: function _createItemSymbol(t, e, i) {
					t.add(r.createSymbol(this.getControllerVisual(e, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(e, "color")));
				}, _onItemClick: function _onItemClick(t) {
					var e = this.visualMapModel,
					    i = e.option,
					    n = a.clone(i.selected),
					    o = e.getSelectedMapKey(t);"single" === i.selectedMode ? (n[o] = !0, a.each(n, function (t, e) {
						n[e] = e === o;
					})) : n[o] = !n[o], this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: n });
				} });t.exports = u;
		}, function (t, e, i) {
			i(2).registerPreprocessor(i(256)), i(257), i(258), i(388), i(389), i(259);
		}, function (t, e, i) {
			i(2).registerPreprocessor(i(256)), i(257), i(258), i(390), i(391), i(259);
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				this._model = t;
			}function a(t, e, i, n) {
				var a = i.calendarModel,
				    o = i.seriesModel,
				    r = a ? a.coordinateSystem : o ? o.coordinateSystem : null;return r === this ? r[t](n) : null;
			}var o = i(12),
			    r = i(4),
			    s = i(1),
			    l = 864e5;n.prototype = { constructor: n, type: "calendar", dimensions: ["time", "value"], getDimensionsInfo: function getDimensionsInfo() {
					return [{ name: "time", type: "time" }];
				}, getRangeInfo: function getRangeInfo() {
					return this._rangeInfo;
				}, getModel: function getModel() {
					return this._model;
				}, getRect: function getRect() {
					return this._rect;
				}, getCellWidth: function getCellWidth() {
					return this._sw;
				}, getCellHeight: function getCellHeight() {
					return this._sh;
				}, getOrient: function getOrient() {
					return this._orient;
				}, getFirstDayOfWeek: function getFirstDayOfWeek() {
					return this._firstDayOfWeek;
				}, getDateInfo: function getDateInfo(t) {
					t = r.parseDate(t);var e = t.getFullYear(),
					    i = t.getMonth() + 1;i = i < 10 ? "0" + i : i;var n = t.getDate();n = n < 10 ? "0" + n : n;var a = t.getDay();return a = Math.abs((a + 7 - this.getFirstDayOfWeek()) % 7), { y: e, m: i, d: n, day: a, time: t.getTime(), formatedDate: e + "-" + i + "-" + n, date: t };
				}, getNextNDay: function getNextNDay(t, e) {
					if (e = e || 0, 0 === e) return this.getDateInfo(t);var i = this.getDateInfo(t).time;return this.getDateInfo(i + l * e);
				}, update: function update(t, e) {
					function i(t, e) {
						return null != t[e] && "auto" !== t[e];
					}this._firstDayOfWeek = this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle.normal").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());var n = this._rangeInfo.weeks || 1,
					    a = ["width", "height"],
					    r = this._model.get("cellSize").slice(),
					    l = this._model.getBoxLayoutParams(),
					    u = "horizontal" === this._orient ? [n, 7] : [7, n];s.each([0, 1], function (t) {
						i(r, t) && (l[a[t]] = r[t] * u[t]);
					});var c = { width: e.getWidth(), height: e.getHeight() },
					    h = this._rect = o.getLayoutRect(l, c);s.each([0, 1], function (t) {
						i(r, t) || (r[t] = h[a[t]] / u[t]);
					}), this._sw = r[0], this._sh = r[1];
				}, dataToPoint: function dataToPoint(t, e) {
					s.isArray(t) && (t = t[0]), null == e && (e = !0);var i = this.getDateInfo(t),
					    n = this._rangeInfo,
					    a = i.formatedDate;if (e && !(i.time >= n.start.time && i.time <= n.end.time)) return [NaN, NaN];var o = i.day,
					    r = this._getRangeInfo([n.start.time, a]).weeks;return "vertical" === this._orient ? [this._rect.x + o * this._sw + this._sw / 2, this._rect.y + (r - 1) * this._sh + this._sh / 2] : [this._rect.x + (r - 1) * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2];
				}, pointToData: function pointToData(t) {
					var e = this.pointToDate(t);return e && e.time;
				}, dataToRect: function dataToRect(t, e) {
					var i = this.dataToPoint(t, e);return { contentShape: { x: i[0] - (this._sw - this._lineWidth) / 2, y: i[1] - (this._sh - this._lineWidth) / 2, width: this._sw - this._lineWidth, height: this._sh - this._lineWidth }, center: i, tl: [i[0] - this._sw / 2, i[1] - this._sh / 2], tr: [i[0] + this._sw / 2, i[1] - this._sh / 2], br: [i[0] + this._sw / 2, i[1] + this._sh / 2], bl: [i[0] - this._sw / 2, i[1] + this._sh / 2] };
				}, pointToDate: function pointToDate(t) {
					var e = Math.floor((t[0] - this._rect.x) / this._sw) + 1,
					    i = Math.floor((t[1] - this._rect.y) / this._sh) + 1,
					    n = this._rangeInfo.range;return "vertical" === this._orient ? this._getDateByWeeksAndDay(i, e - 1, n) : this._getDateByWeeksAndDay(e, i - 1, n);
				}, convertToPixel: s.curry(a, "dataToPoint"), convertFromPixel: s.curry(a, "pointToData"), _initRangeOption: function _initRangeOption() {
					var t = this._model.get("range"),
					    e = t;if (s.isArray(e) && 1 === e.length && (e = e[0]), /^\d{4}$/.test(e) && (t = [e + "-01-01", e + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(e)) {
						var i = this.getDateInfo(e),
						    n = i.date;n.setMonth(n.getMonth() + 1);var a = this.getNextNDay(n, -1);t = [i.formatedDate, a.formatedDate];
					}/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(e) && (t = [e, e]);var o = this._getRangeInfo(t);return o.start.time > o.end.time && t.reverse(), t;
				}, _getRangeInfo: function _getRangeInfo(t) {
					var e = this.getDateInfo(t[0]),
					    i = this.getDateInfo(t[1]),
					    n = Math.floor(i.time / l) - Math.floor(e.time / l) + 1,
					    a = Math.floor((n + e.day + 6) / 7);return { range: [e.formatedDate, i.formatedDate], start: e, end: i, allDay: n, weeks: a, fweek: e.day, lweek: i.day };
				}, _getDateByWeeksAndDay: function _getDateByWeeksAndDay(t, e, i) {
					var n = this._getRangeInfo(i);if (t > n.weeks || 0 === t && e < n.fweek || t === n.weeks && e > n.lweek) return !1;var a = 7 * (t - 1) - n.fweek + e,
					    o = n.start.time + a * l;return this.getDateInfo(o);
				} }, n.dimensions = n.prototype.dimensions, n.getDimensionsInfo = n.prototype.getDimensionsInfo, n.create = function (t, e) {
				var i = [];return t.eachComponent("calendar", function (a) {
					var o = new n(a, t, e);i.push(o), a.coordinateSystem = o;
				}), t.eachSeries(function (t) {
					"calendar" === t.get("coordinateSystem") && (t.coordinateSystem = i[t.get("calendarIndex") || 0]);
				}), i;
			}, i(26).register("calendar", n), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				var i = t.cellSize;o.isArray(i) ? 1 === i.length && (i[1] = i[0]) : i = t.cellSize = [i, i];var n = o.map([0, 1], function (t) {
					return r.sizeCalculable(e, t) && (i[t] = "auto"), null != i[t] && "auto" !== i[t];
				});r.mergeLayoutParam(t, e, { type: "box", ignoreSize: n });
			}var a = i(13),
			    o = i(1),
			    r = i(12),
			    s = a.extend({ type: "calendar", coordinateSystem: null, defaultOption: { zlevel: 0, z: 2, left: 80, top: 60, cellSize: 20, orient: "horizontal", splitLine: { show: !0, lineStyle: { color: "#000", width: 1, type: "solid" } }, itemStyle: { normal: { color: "#fff", borderWidth: 1, borderColor: "#ccc" } }, dayLabel: { show: !0, firstDay: 0, position: "start", margin: "50%", nameMap: "en", textStyle: { color: "#000" } }, monthLabel: { show: !0, position: "start", margin: 5, align: "center", nameMap: "en", formatter: null, textStyle: { color: "#000" } }, yearLabel: { show: !0, position: null, margin: 30, formatter: null, textStyle: { color: "#ccc", fontFamily: "sans-serif", fontWeight: "bolder", fontSize: 20 } } }, init: function init(t, e, i, a) {
					var o = r.getLayoutParams(t);s.superApply(this, "init", arguments), n(t, o);
				}, mergeOption: function mergeOption(t, e) {
					s.superApply(this, "mergeOption", arguments), n(this.option, t);
				} });t.exports = s;
		}, function (t, e, i) {
			function n(t) {
				var e = t.getRect(),
				    i = t.getRangeInfo();return { coordSys: { type: "calendar", x: e.x, y: e.y, width: e.width, height: e.height, cellWidth: t.getCellWidth(), cellHeight: t.getCellHeight(), rangeInfo: { start: i.start, end: i.end, weeks: i.weeks, dayCount: i.allDay } }, api: { coord: a.bind(t.dataToPoint, t) } };
			}var a = i(1);t.exports = n;
		}, function (t, e, i) {
			function n(t, e) {
				return e = e || [0, 0], o.map(["x", "y"], function (i, n) {
					var a = this.getAxis(i),
					    o = e[n],
					    r = t[n] / 2;return "category" === a.type ? a.getBandWidth() : Math.abs(a.dataToCoord(o - r) - a.dataToCoord(o + r));
				}, this);
			}function a(t) {
				var e = t.grid.getRect();return { coordSys: { type: "cartesian2d", x: e.x, y: e.y, width: e.width, height: e.height }, api: { coord: o.bind(t.dataToPoint, t), size: o.bind(n, t) } };
			}var o = i(1);t.exports = a;
		}, function (t, e, i) {
			function n(t, e, i, n, a) {
				l.call(this, t), this.map = e, this._nameCoordMap = r.createHashMap(), this.loadGeoJson(i, n, a);
			}function a(t, e, i, n) {
				var a = i.geoModel,
				    o = i.seriesModel,
				    r = a ? a.coordinateSystem : o ? o.coordinateSystem || (o.getReferringComponents("geo")[0] || {}).coordinateSystem : null;return r === this ? r[t](n) : null;
			}var o = i(262),
			    r = i(1),
			    s = i(11),
			    l = i(260),
			    u = [i(401), i(402), i(400)];n.prototype = { constructor: n, type: "geo", dimensions: ["lng", "lat"], containCoord: function containCoord(t) {
					for (var e = this.regions, i = 0; i < e.length; i++) {
						if (e[i].contain(t)) return !0;
					}return !1;
				}, loadGeoJson: function loadGeoJson(t, e, i) {
					try {
						this.regions = t ? o(t) : [];
					} catch (n) {
						throw "Invalid geoJson format\n" + n.message;
					}e = e || {}, i = i || {};for (var a = this.regions, s = r.createHashMap(), l = 0; l < a.length; l++) {
						var c = a[l].name;c = i.hasOwnProperty(c) ? i[c] : c, a[l].name = c, s.set(c, a[l]), this.addGeoCoord(c, a[l].center);var h = e[c];h && a[l].transformTo(h.left, h.top, h.width, h.height);
					}this._regionsMap = s, this._rect = null, r.each(u, function (t) {
						t(this);
					}, this);
				}, transformTo: function transformTo(t, e, i, n) {
					var a = this.getBoundingRect();a = a.clone(), a.y = -a.y - a.height;var o = this._viewTransform;o.transform = a.calculateTransform(new s(t, e, i, n)), o.decomposeTransform();var r = o.scale;r[1] = -r[1], o.updateTransform(), this._updateTransform();
				}, getRegion: function getRegion(t) {
					return this._regionsMap.get(t);
				}, getRegionByCoord: function getRegionByCoord(t) {
					for (var e = this.regions, i = 0; i < e.length; i++) {
						if (e[i].contain(t)) return e[i];
					}
				}, addGeoCoord: function addGeoCoord(t, e) {
					this._nameCoordMap.set(t, e);
				}, getGeoCoord: function getGeoCoord(t) {
					return this._nameCoordMap.get(t);
				}, getBoundingRect: function getBoundingRect() {
					if (this._rect) return this._rect;for (var t, e = this.regions, i = 0; i < e.length; i++) {
						var n = e[i].getBoundingRect();t = t || n.clone(), t.union(n);
					}return this._rect = t || new s(0, 0, 0, 0);
				}, dataToPoints: function dataToPoints(t) {
					var e = [];return t.mapArray(["lng", "lat"], function (t, i) {
						return e[0] = t, e[1] = i, this.dataToPoint(e);
					}, this);
				}, dataToPoint: function dataToPoint(t) {
					if ("string" == typeof t && (t = this.getGeoCoord(t)), t) return l.prototype.dataToPoint.call(this, t);
				}, convertToPixel: r.curry(a, "dataToPoint"), convertFromPixel: r.curry(a, "pointToData") }, r.mixin(n, l), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			var n = i(5),
			    a = i(13),
			    o = i(10),
			    r = i(1),
			    s = i(78),
			    l = i(186),
			    u = a.extend({ type: "geo", coordinateSystem: null, layoutMode: "box", init: function init(t) {
					a.prototype.init.apply(this, arguments), n.defaultEmphasis(t.label, ["position", "show", "textStyle", "distance", "formatter"]);
				}, optionUpdated: function optionUpdated() {
					var t = this.option,
					    e = this;t.regions = l.getFilledRegions(t.regions, t.map), this._optionModelMap = r.reduce(t.regions || [], function (t, i) {
						return i.name && t.set(i.name, new o(i, e)), t;
					}, r.createHashMap()), this.updateSelectedMap(t.regions);
				}, defaultOption: { zlevel: 0, z: 0, show: !0, left: "center", top: "center", aspectScale: .75, silent: !1, map: "", boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { normal: { show: !1, textStyle: { color: "#000" } }, emphasis: { show: !0, textStyle: { color: "rgb(100,0,0)" } } }, itemStyle: { normal: { borderWidth: .5, borderColor: "#444", color: "#eee" }, emphasis: { color: "rgba(255,215,0,0.8)" } }, regions: [] }, getRegionModel: function getRegionModel(t) {
					return this._optionModelMap.get(t) || new o(null, this, this.ecModel);
				}, getFormattedLabel: function getFormattedLabel(t, e) {
					var i = this.getRegionModel(t),
					    n = i.get("label." + e + ".formatter"),
					    a = { name: t };if ("function" == typeof n) return a.status = e, n(a);if ("string" == typeof n) {
						var o = a.seriesName;return n.replace("{a}", null != o ? o : "");
					}
				}, setZoom: function setZoom(t) {
					this.option.zoom = t;
				}, setCenter: function setCenter(t) {
					this.option.center = t;
				} });r.mixin(u, s), t.exports = u;
		}, function (t, e, i) {
			var n = i(1),
			    a = { Russia: [100, 60], "United States": [-99, 38], "United States of America": [-99, 38] };t.exports = function (t) {
				n.each(t.regions, function (t) {
					var e = a[t.name];if (e) {
						var i = t.center;i[0] = e[0], i[1] = e[1];
					}
				});
			};
		}, function (t, e, i) {
			for (var n = i(261), a = i(1), o = [126, 25], r = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, .7], [52, .7], [56, 7.7], [59, .7], [64, .7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]], s = 0; s < r.length; s++) {
				for (var l = 0; l < r[s].length; l++) {
					r[s][l][0] /= 10.5, r[s][l][1] /= -14, r[s][l][0] += o[0], r[s][l][1] += o[1];
				}
			}t.exports = function (t) {
				"china" === t.map && t.regions.push(new n("", a.map(r, function (t) {
					return { type: "polygon", exterior: t };
				}), o));
			};
		}, function (t, e, i) {
			var n = i(1),
			    a = { "": [32, 80], "": [0, -10], "": [10, 5], "": [-10, 10], "": [5, 5] };t.exports = function (t) {
				n.each(t.regions, function (t) {
					var e = a[t.name];if (e) {
						var i = t.center;i[0] += e[0] / 10.5, i[1] += -e[1] / 14;
					}
				});
			};
		}, function (t, e, i) {
			function n(t, e) {
				return e = e || [0, 0], o.map([0, 1], function (i) {
					var n = e[i],
					    a = t[i] / 2,
					    o = [],
					    r = [];return o[i] = n - a, r[i] = n + a, o[1 - i] = r[1 - i] = e[1 - i], Math.abs(this.dataToPoint(o)[i] - this.dataToPoint(r)[i]);
				}, this);
			}function a(t) {
				var e = t.getBoundingRect();return { coordSys: { type: "geo", x: e.x, y: e.y, width: e.width, height: e.height }, api: { coord: o.bind(t.dataToPoint, t), size: o.bind(n, t) } };
			}var o = i(1);t.exports = a;
		}, function (t, e, i) {
			function n(t, e) {
				return e.type || (e.data ? "category" : "value");
			}var a = i(13),
			    o = i(1),
			    r = i(31),
			    s = i(59),
			    l = i(4),
			    u = a.extend({ type: "baseParallelAxis", axis: null, activeIntervals: [], getAreaSelectStyle: function getAreaSelectStyle() {
					return r([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]]).call(this.getModel("areaSelectStyle"));
				}, setActiveIntervals: function setActiveIntervals(t) {
					var e = this.activeIntervals = o.clone(t);if (e) for (var i = e.length - 1; i >= 0; i--) {
						l.asc(e[i]);
					}
				}, getActiveState: function getActiveState(t) {
					var e = this.activeIntervals;if (!e.length) return "normal";if (null == t) return "inactive";for (var i = 0, n = e.length; i < n; i++) {
						if (e[i][0] <= t && t <= e[i][1]) return "active";
					}return "inactive";
				} }),
			    c = { type: "value", dim: null, areaSelectStyle: { width: 20, borderWidth: 1, borderColor: "rgba(160,197,232)", color: "rgba(160,197,232)", opacity: .3 }, realtime: !0, z: 10 };o.merge(u.prototype, i(42)), s("parallel", u, n, c), t.exports = u;
		}, function (t, e, i) {
			function n(t, e, i) {
				this._axesMap = u.createHashMap(), this._axesLayout = {}, this.dimensions = t.dimensions, this._rect, this._model = t, this._init(t, e, i);
			}function a(t, e) {
				return m(v(t, e[0]), e[1]);
			}function o(t, e) {
				var i = e.layoutLength / (e.axisCount - 1);return { position: i * t, axisNameAvailableWidth: i, axisLabelShow: !0 };
			}function r(t, e) {
				var i,
				    n,
				    a = e.layoutLength,
				    o = e.axisExpandWidth,
				    r = e.axisCount,
				    s = e.axisCollapseWidth,
				    l = e.winInnerIndices,
				    u = s,
				    c = !1;return t < l[0] ? (i = t * s, n = s) : t <= l[1] ? (i = e.axisExpandWindow0Pos + t * o - e.axisExpandWindow[0], u = o, c = !0) : (i = a - (r - 1 - t) * s, n = s), { position: i, axisNameAvailableWidth: u, axisLabelShow: c, nameTruncateMaxWidth: n };
			}var s = i(12),
			    l = i(18),
			    u = i(1),
			    c = i(406),
			    h = i(3),
			    d = i(19),
			    f = i(4),
			    p = i(56),
			    g = u.each,
			    m = Math.min,
			    v = Math.max,
			    y = Math.floor,
			    x = Math.ceil,
			    _ = f.round,
			    b = Math.PI;n.prototype = { type: "parallel", constructor: n, _init: function _init(t, e, i) {
					var n = t.dimensions,
					    a = t.parallelAxisIndex;g(n, function (t, i) {
						var n = a[i],
						    o = e.getComponent("parallelAxis", n),
						    r = this._axesMap.set(t, new c(t, l.createScaleByModel(o), [0, 0], o.get("type"), n)),
						    s = "category" === r.type;r.onBand = s && o.get("boundaryGap"), r.inverse = o.get("inverse"), o.axis = r, r.model = o, r.coordinateSystem = o.coordinateSystem = this;
					}, this);
				}, update: function update(t, e) {
					this._updateAxesFromSeries(this._model, t);
				}, containPoint: function containPoint(t) {
					var e = this._makeLayoutInfo(),
					    i = e.axisBase,
					    n = e.layoutBase,
					    a = e.pixelDimIndex,
					    o = t[1 - a],
					    r = t[a];return o >= i && o <= i + e.axisLength && r >= n && r <= n + e.layoutLength;
				}, _updateAxesFromSeries: function _updateAxesFromSeries(t, e) {
					e.eachSeries(function (i) {
						if (t.contains(i, e)) {
							var n = i.getData();g(this.dimensions, function (t) {
								var e = this._axesMap.get(t);e.scale.unionExtentFromData(n, t), l.niceScaleExtent(e.scale, e.model);
							}, this);
						}
					}, this);
				}, resize: function resize(t, e) {
					this._rect = s.getLayoutRect(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }), this._layoutAxes();
				}, getRect: function getRect() {
					return this._rect;
				}, _makeLayoutInfo: function _makeLayoutInfo() {
					var t,
					    e = this._model,
					    i = this._rect,
					    n = ["x", "y"],
					    o = ["width", "height"],
					    r = e.get("layout"),
					    s = "horizontal" === r ? 0 : 1,
					    l = i[o[s]],
					    u = [0, l],
					    c = this.dimensions.length,
					    h = a(e.get("axisExpandWidth"), u),
					    d = a(e.get("axisExpandCount") || 0, [0, c]),
					    f = e.get("axisExpandable") && c > 3 && c > d && d > 1 && h > 0 && l > 0,
					    p = e.get("axisExpandWindow");if (p) t = a(p[1] - p[0], u), p[1] = p[0] + t;else {
						t = a(h * (d - 1), u);var g = e.get("axisExpandCenter") || y(c / 2);p = [h * g - t / 2], p[1] = p[0] + t;
					}var m = (l - t) / (c - d);m < 3 && (m = 0);var v = [y(_(p[0] / h, 1)) + 1, x(_(p[1] / h, 1)) - 1],
					    b = m / h * p[0];return { layout: r, pixelDimIndex: s, layoutBase: i[n[s]], layoutLength: l, axisBase: i[n[1 - s]], axisLength: i[o[1 - s]], axisExpandable: f, axisExpandWidth: h, axisCollapseWidth: m, axisExpandWindow: p, axisCount: c, winInnerIndices: v, axisExpandWindow0Pos: b };
				}, _layoutAxes: function _layoutAxes() {
					var t = this._rect,
					    e = this._axesMap,
					    i = this.dimensions,
					    n = this._makeLayoutInfo(),
					    a = n.layout;e.each(function (t) {
						var e = [0, n.axisLength],
						    i = t.inverse ? 1 : 0;t.setExtent(e[i], e[1 - i]);
					}), g(i, function (i, s) {
						var l = (n.axisExpandable ? r : o)(s, n),
						    u = { horizontal: { x: l.position, y: n.axisLength }, vertical: { x: 0, y: l.position } },
						    c = { horizontal: b / 2, vertical: 0 },
						    h = [u[a].x + t.x, u[a].y + t.y],
						    f = c[a],
						    p = d.create();d.rotate(p, p, f), d.translate(p, p, h), this._axesLayout[i] = { position: h, rotation: f, transform: p, axisNameAvailableWidth: l.axisNameAvailableWidth, axisLabelShow: l.axisLabelShow, nameTruncateMaxWidth: l.nameTruncateMaxWidth, tickDirection: 1, labelDirection: 1, labelInterval: e.get(i).getLabelInterval() };
					}, this);
				}, getAxis: function getAxis(t) {
					return this._axesMap.get(t);
				}, dataToPoint: function dataToPoint(t, e) {
					return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e);
				}, eachActiveState: function eachActiveState(t, e, i) {
					for (var n = this.dimensions, a = this._axesMap, o = this.hasAxisBrushed(), r = 0, s = t.count(); r < s; r++) {
						var l,
						    u = t.getValues(n, r);if (o) {
							l = "active";for (var c = 0, h = n.length; c < h; c++) {
								var d = n[c],
								    f = a.get(d).model.getActiveState(u[c], c);if ("inactive" === f) {
									l = "inactive";break;
								}
							}
						} else l = "normal";e.call(i, l, r);
					}
				}, hasAxisBrushed: function hasAxisBrushed() {
					for (var t = this.dimensions, e = this._axesMap, i = !1, n = 0, a = t.length; n < a; n++) {
						"normal" !== e.get(t[n]).model.getActiveState() && (i = !0);
					}return i;
				}, axisCoordToPoint: function axisCoordToPoint(t, e) {
					var i = this._axesLayout[e];return h.applyTransform([t, 0], i.transform);
				}, getAxisLayout: function getAxisLayout(t) {
					return u.clone(this._axesLayout[t]);
				}, getSlidedAxisExpandWindow: function getSlidedAxisExpandWindow(t) {
					var e = this._makeLayoutInfo(),
					    i = e.pixelDimIndex,
					    n = e.axisExpandWindow.slice(),
					    a = n[1] - n[0],
					    o = [0, e.axisExpandWidth * (e.axisCount - 1)];if (!this.containPoint(t)) return { behavior: "none", axisExpandWindow: n };var r,
					    s = t[i] - e.layoutBase - e.axisExpandWindow0Pos,
					    l = "slide",
					    u = e.axisCollapseWidth,
					    c = this._model.get("axisExpandSlideTriggerArea"),
					    h = null != c[0];if (u) h && u && s < a * c[0] ? (l = "jump", r = s - a * c[2]) : h && u && s > a * (1 - c[0]) ? (l = "jump", r = s - a * (1 - c[2])) : (r = s - a * c[1]) >= 0 && (r = s - a * (1 - c[1])) <= 0 && (r = 0), r *= e.axisExpandWidth / u, r ? p(r, n, o, "all") : l = "none";else {
						var a = n[1] - n[0],
						    d = o[1] * s / a;n = [v(0, d - a / 2)], n[1] = m(o[1], n[0] + a), n[0] = n[1] - a;
					}return { axisExpandWindow: n, behavior: l };
				} }, t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(33),
			    o = function o(t, e, i, n, _o4) {
				a.call(this, t, e, i), this.type = n || "value", this.axisIndex = _o4;
			};o.prototype = { constructor: o, model: null }, n.inherits(o, a), t.exports = o;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(13);i(404), a.extend({ type: "parallel", dependencies: ["parallelAxis"], coordinateSystem: null, dimensions: null, parallelAxisIndex: null, layoutMode: "box", defaultOption: { zlevel: 0, z: 0, left: 80, top: 60, right: 80, bottom: 60, layout: "horizontal", axisExpandable: !1, axisExpandCenter: null, axisExpandCount: 0, axisExpandWidth: 50, axisExpandRate: 17, axisExpandDebounce: 50, axisExpandSlideTriggerArea: [-.15, .05, .4], axisExpandTriggerOn: "click", parallelAxisDefault: null }, init: function init() {
					a.prototype.init.apply(this, arguments), this.mergeOption({});
				}, mergeOption: function mergeOption(t) {
					var e = this.option;t && n.merge(e, t, !0), this._initDimensions();
				}, contains: function contains(t, e) {
					var i = t.get("parallelIndex");return null != i && e.getComponent("parallel", i) === this;
				}, setAxisExpand: function setAxisExpand(t) {
					n.each(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function (e) {
						t.hasOwnProperty(e) && (this.option[e] = t[e]);
					}, this);
				}, _initDimensions: function _initDimensions() {
					var t = this.dimensions = [],
					    e = this.parallelAxisIndex = [],
					    i = n.filter(this.dependentModels.parallelAxis, function (t) {
						return t.get("parallelIndex") === this.componentIndex;
					});n.each(i, function (i) {
						t.push("dim" + i.get("dim")), e.push(i.componentIndex);
					});
				} });
		}, function (t, e, i) {
			function n(t) {
				if (!t.parallel) {
					var e = !1;o.each(t.series, function (t) {
						t && "parallel" === t.type && (e = !0);
					}), e && (t.parallel = [{}]);
				}
			}function a(t) {
				var e = r.normalizeToArray(t.parallelAxis);o.each(e, function (e) {
					if (o.isObject(e)) {
						var i = e.parallelIndex || 0,
						    n = r.normalizeToArray(t.parallel)[i];n && n.parallelAxisDefault && o.merge(e, n.parallelAxisDefault, !1);
					}
				});
			}var o = i(1),
			    r = i(5);t.exports = function (t) {
				n(t), a(t);
			};
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				e = e || [0, 360], o.call(this, "angle", t, e), this.type = "category";
			}var a = i(1),
			    o = i(33);n.prototype = { constructor: n, pointToData: function pointToData(t, e) {
					return this.polar.pointToData(t, e)["radius" === this.dim ? 0 : 1];
				}, dataToAngle: o.prototype.dataToCoord, angleToData: o.prototype.coordToData }, a.inherits(n, o), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				return e.type || (e.data ? "category" : "value");
			}var a = i(1),
			    o = i(13),
			    r = i(59),
			    s = o.extend({ type: "polarAxis", axis: null, getCoordSysModel: function getCoordSysModel() {
					return this.ecModel.queryComponents({ mainType: "polar", index: this.option.polarIndex, id: this.option.polarId })[0];
				} });a.merge(s.prototype, i(42));var l = { angle: { startAngle: 90, clockwise: !0, splitNumber: 12, axisLabel: { rotate: !1 } }, radius: { splitNumber: 5 } };r("angle", s, n, l.angle), r("radius", s, n, l.radius);
		}, function (t, e, i) {
			"use strict";
			var n = i(413),
			    a = i(409),
			    o = function o(t) {
				this.name = t || "", this.cx = 0, this.cy = 0, this._radiusAxis = new n(), this._angleAxis = new a(), this._radiusAxis.polar = this._angleAxis.polar = this;
			};o.prototype = { type: "polar", axisPointerEnabled: !0, constructor: o, dimensions: ["radius", "angle"], model: null, containPoint: function containPoint(t) {
					var e = this.pointToCoord(t);return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1]);
				}, containData: function containData(t) {
					return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]);
				}, getAxis: function getAxis(t) {
					return this["_" + t + "Axis"];
				}, getAxes: function getAxes() {
					return [this._radiusAxis, this._angleAxis];
				}, getAxesByScale: function getAxesByScale(t) {
					var e = [],
					    i = this._angleAxis,
					    n = this._radiusAxis;return i.scale.type === t && e.push(i), n.scale.type === t && e.push(n), e;
				}, getAngleAxis: function getAngleAxis() {
					return this._angleAxis;
				}, getRadiusAxis: function getRadiusAxis() {
					return this._radiusAxis;
				}, getOtherAxis: function getOtherAxis(t) {
					var e = this._angleAxis;return t === e ? this._radiusAxis : e;
				}, getBaseAxis: function getBaseAxis() {
					return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
				}, getTooltipAxes: function getTooltipAxes(t) {
					var e = null != t && "auto" !== t ? this.getAxis(t) : this.getBaseAxis();return { baseAxes: [e], otherAxes: [this.getOtherAxis(e)] };
				}, dataToPoints: function dataToPoints(t) {
					return t.mapArray(this.dimensions, function (t, e) {
						return this.dataToPoint([t, e]);
					}, !0, this);
				}, dataToPoint: function dataToPoint(t, e) {
					return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)]);
				}, pointToData: function pointToData(t, e) {
					var i = this.pointToCoord(t);return [this._radiusAxis.radiusToData(i[0], e), this._angleAxis.angleToData(i[1], e)];
				}, pointToCoord: function pointToCoord(t) {
					var e = t[0] - this.cx,
					    i = t[1] - this.cy,
					    n = this.getAngleAxis(),
					    a = n.getExtent(),
					    o = Math.min(a[0], a[1]),
					    r = Math.max(a[0], a[1]);n.inverse ? o = r - 360 : r = o + 360;var s = Math.sqrt(e * e + i * i);e /= s, i /= s;for (var l = Math.atan2(-i, e) / Math.PI * 180, u = l < o ? 1 : -1; l < o || l > r;) {
						l += 360 * u;
					}return [s, l];
				}, coordToPoint: function coordToPoint(t) {
					var e = t[0],
					    i = t[1] / 180 * Math.PI,
					    n = Math.cos(i) * e + this.cx,
					    a = -Math.sin(i) * e + this.cy;return [n, a];
				} }, t.exports = o;
		}, function (t, e, i) {
			"use strict";
			i(410), i(2).extendComponentModel({ type: "polar", dependencies: ["polarAxis", "angleAxis"], coordinateSystem: null, findAxisModel: function findAxisModel(t) {
					var e,
					    i = this.ecModel;return i.eachComponent(t, function (t) {
						t.getCoordSysModel() === this && (e = t);
					}, this), e;
				}, defaultOption: { zlevel: 0, z: 0, center: ["50%", "50%"], radius: "80%" } });
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				o.call(this, "radius", t, e), this.type = "category";
			}var a = i(1),
			    o = i(33);n.prototype = { constructor: n, pointToData: function pointToData(t, e) {
					return this.polar.pointToData(t, e)["radius" === this.dim ? 0 : 1];
				}, dataToRadius: o.prototype.dataToCoord, radiusToData: o.prototype.coordToData }, a.inherits(n, o), t.exports = n;
		}, function (t, e, i) {
			function n(t, e) {
				return o.map(["Radius", "Angle"], function (i, n) {
					var a = this["get" + i + "Axis"](),
					    o = e[n],
					    r = t[n] / 2,
					    s = "dataTo" + i,
					    l = "category" === a.type ? a.getBandWidth() : Math.abs(a[s](o - r) - a[s](o + r));return "Angle" === i && (l = l * Math.PI / 180), l;
				}, this);
			}function a(t) {
				var e = t.getRadiusAxis(),
				    i = t.getAngleAxis(),
				    a = e.getExtent();return a[0] > a[1] && a.reverse(), { coordSys: { type: "polar", cx: t.cx, cy: t.cy, r: a[1], r0: a[0] }, api: { coord: o.bind(function (n) {
							var a = e.dataToRadius(n[0]),
							    o = i.dataToAngle(n[1]),
							    r = t.coordToPoint([a, o]);return r.push(a, o * Math.PI / 180), r;
						}), size: o.bind(n, t) } };
			}var o = i(1);t.exports = a;
		}, function (t, e, i) {
			function n(t, e, i) {
				o.call(this, t, e, i), this.type = "value", this.angle = 0, this.name = "", this.model;
			}var a = i(1),
			    o = i(33);a.inherits(n, o), t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i) {
				this._model = t, this.dimensions = [], this._indicatorAxes = a.map(t.getIndicatorModels(), function (t, e) {
					var i = "indicator_" + e,
					    n = new o(i, new r());return n.name = t.get("name"), n.model = t, t.axis = n, this.dimensions.push(i), n;
				}, this), this.resize(t, i), this.cx, this.cy, this.r, this.startAngle;
			}var a = i(1),
			    o = i(415),
			    r = i(43),
			    s = i(4),
			    l = i(18);n.prototype.getIndicatorAxes = function () {
				return this._indicatorAxes;
			}, n.prototype.dataToPoint = function (t, e) {
				var i = this._indicatorAxes[e];return this.coordToPoint(i.dataToCoord(t), e);
			}, n.prototype.coordToPoint = function (t, e) {
				var i = this._indicatorAxes[e],
				    n = i.angle,
				    a = this.cx + t * Math.cos(n),
				    o = this.cy - t * Math.sin(n);return [a, o];
			}, n.prototype.pointToData = function (t) {
				var e = t[0] - this.cx,
				    i = t[1] - this.cy,
				    n = Math.sqrt(e * e + i * i);e /= n, i /= n;for (var a, o = Math.atan2(-i, e), r = 1 / 0, s = -1, l = 0; l < this._indicatorAxes.length; l++) {
					var u = this._indicatorAxes[l],
					    c = Math.abs(o - u.angle);c < r && (a = u, s = l, r = c);
				}return [s, +(a && a.coodToData(n))];
			}, n.prototype.resize = function (t, e) {
				var i = t.get("center"),
				    n = e.getWidth(),
				    o = e.getHeight(),
				    r = Math.min(n, o) / 2;this.cx = s.parsePercent(i[0], n), this.cy = s.parsePercent(i[1], o), this.startAngle = t.get("startAngle") * Math.PI / 180, this.r = s.parsePercent(t.get("radius"), r), a.each(this._indicatorAxes, function (t, e) {
					t.setExtent(0, this.r);var i = this.startAngle + e * Math.PI * 2 / this._indicatorAxes.length;
					i = Math.atan2(Math.sin(i), Math.cos(i)), t.angle = i;
				}, this);
			}, n.prototype.update = function (t, e) {
				function i(t) {
					var e = Math.pow(10, Math.floor(Math.log(t) / Math.LN10)),
					    i = t / e;return 2 === i ? i = 5 : i *= 2, i * e;
				}var n = this._indicatorAxes,
				    o = this._model;a.each(n, function (t) {
					t.scale.setExtent(1 / 0, -(1 / 0));
				}), t.eachSeriesByType("radar", function (e, i) {
					if ("radar" === e.get("coordinateSystem") && t.getComponent("radar", e.get("radarIndex")) === o) {
						var r = e.getData();a.each(n, function (t) {
							t.scale.unionExtentFromData(r, t.dim);
						});
					}
				}, this);var r = o.get("splitNumber");a.each(n, function (t, e) {
					var n = l.getScaleExtent(t.scale, t.model);l.niceScaleExtent(t.scale, t.model);var a = t.model,
					    o = t.scale,
					    u = a.getMin(),
					    c = a.getMax(),
					    h = o.getInterval();if (null != u && null != c) o.setInterval((c - u) / r);else if (null != u) {
						var d;do {
							d = u + h * r, o.setExtent(+u, d), o.setInterval(h), h = i(h);
						} while (d < n[1] && isFinite(d) && isFinite(n[1]));
					} else if (null != c) {
						var f;do {
							f = c - h * r, o.setExtent(f, +c), o.setInterval(h), h = i(h);
						} while (f > n[0] && isFinite(f) && isFinite(n[0]));
					} else {
						var p = o.getTicks().length - 1;p > r && (h = i(h));var g = Math.round((n[0] + n[1]) / 2 / h) * h,
						    m = Math.round(r / 2);o.setExtent(s.round(g - m * h), s.round(g + (r - m) * h)), o.setInterval(h);
					}
				});
			}, n.dimensions = [], n.create = function (t, e) {
				var i = [];return t.eachComponent("radar", function (a) {
					var o = new n(a, t, e);i.push(o), a.coordinateSystem = o;
				}), t.eachSeriesByType("radar", function (t) {
					"radar" === t.get("coordinateSystem") && (t.coordinateSystem = i[t.get("radarIndex") || 0]);
				}), i;
			}, i(26).register("radar", n), t.exports = n;
		}, function (t, e, i) {
			function n(t, e) {
				return s.defaults({ show: e }, t);
			}var a = i(96),
			    o = a.valueAxis,
			    r = i(10),
			    s = i(1),
			    l = i(42),
			    u = i(2).extendComponentModel({ type: "radar", optionUpdated: function optionUpdated() {
					var t = this.get("boundaryGap"),
					    e = this.get("splitNumber"),
					    i = this.get("scale"),
					    n = this.get("axisLine"),
					    a = this.get("axisTick"),
					    o = this.get("axisLabel"),
					    u = this.get("name.textStyle"),
					    c = this.get("name.show"),
					    h = this.get("name.formatter"),
					    d = this.get("nameGap"),
					    f = this.get("triggerEvent"),
					    p = s.map(this.get("indicator") || [], function (p) {
						if (null != p.max && p.max > 0 && !p.min ? p.min = 0 : null != p.min && p.min < 0 && !p.max && (p.max = 0), p = s.merge(s.clone(p), { boundaryGap: t, splitNumber: e, scale: i, axisLine: n, axisTick: a, axisLabel: o, name: p.text, nameLocation: "end", nameGap: d, nameTextStyle: u, triggerEvent: f }, !1), c || (p.name = ""), "string" == typeof h) {
							var g = p.name;p.name = h.replace("{value}", null != g ? g : "");
						} else "function" == typeof h && (p.name = h(p.name, p));var m = s.extend(new r(p, null, this.ecModel), l);return m.mainType = "radar", m.componentIndex = this.componentIndex, m;
					}, this);this.getIndicatorModels = function () {
						return p;
					};
				}, defaultOption: { zlevel: 0, z: 0, center: ["50%", "50%"], radius: "75%", startAngle: 90, name: { show: !0 }, boundaryGap: [0, 0], splitNumber: 5, nameGap: 15, scale: !1, shape: "polygon", axisLine: s.merge({ lineStyle: { color: "#bbb" } }, o.axisLine), axisLabel: n(o.axisLabel, !1), axisTick: n(o.axisTick, !1), splitLine: n(o.splitLine, !0), splitArea: n(o.splitArea, !0), indicator: [] } });t.exports = u;
		}, function (t, e, i) {
			function n(t, e) {
				return e.type || (e.data ? "category" : "value");
			}var a = i(13),
			    o = i(59),
			    r = i(1),
			    s = a.extend({ type: "singleAxis", layoutMode: "box", axis: null, coordinateSystem: null, getCoordSysModel: function getCoordSysModel() {
					return this;
				} }),
			    l = { left: "5%", top: "5%", right: "5%", bottom: "5%", type: "value", position: "bottom", orient: "horizontal", axisLine: { show: !0, lineStyle: { width: 2, type: "solid" } }, tooltip: { show: !0 }, axisTick: { show: !0, length: 6, lineStyle: { width: 2 } }, axisLabel: { show: !0, interval: "auto" }, splitLine: { show: !0, lineStyle: { type: "dashed", opacity: .2 } } };r.merge(s.prototype, i(42)), o("single", s, n, l), t.exports = s;
		}, function (t, e, i) {
			function n(t, e, i) {
				this.dimension = "single", this.dimensions = ["single"], this._axis = null, this._rect, this._init(t, e, i), this.model = t;
			}var a = i(420),
			    o = i(18),
			    r = i(12);n.prototype = { type: "singleAxis", axisPointerEnabled: !0, constructor: n, _init: function _init(t, e, i) {
					var n = this.dimension,
					    r = new a(n, o.createScaleByModel(t), [0, 0], t.get("type"), t.get("position")),
					    s = "category" === r.type;r.onBand = s && t.get("boundaryGap"), r.inverse = t.get("inverse"), r.orient = t.get("orient"), t.axis = r, r.model = t, r.coordinateSystem = this, this._axis = r;
				}, update: function update(t, e) {
					t.eachSeries(function (t) {
						if (t.coordinateSystem === this) {
							var e = t.getData(),
							    i = this.dimension;this._axis.scale.unionExtentFromData(e, t.coordDimToDataDim(i)), o.niceScaleExtent(this._axis.scale, this._axis.model);
						}
					}, this);
				}, resize: function resize(t, e) {
					this._rect = r.getLayoutRect({ left: t.get("left"), top: t.get("top"), right: t.get("right"), bottom: t.get("bottom"), width: t.get("width"), height: t.get("height") }, { width: e.getWidth(), height: e.getHeight() }), this._adjustAxis();
				}, getRect: function getRect() {
					return this._rect;
				}, _adjustAxis: function _adjustAxis() {
					var t = this._rect,
					    e = this._axis,
					    i = e.isHorizontal(),
					    n = i ? [0, t.width] : [0, t.height],
					    a = e.reverse ? 1 : 0;e.setExtent(n[a], n[1 - a]), this._updateAxisTransform(e, i ? t.x : t.y);
				}, _updateAxisTransform: function _updateAxisTransform(t, e) {
					var i = t.getExtent(),
					    n = i[0] + i[1],
					    a = t.isHorizontal();t.toGlobalCoord = a ? function (t) {
						return t + e;
					} : function (t) {
						return n - t + e;
					}, t.toLocalCoord = a ? function (t) {
						return t - e;
					} : function (t) {
						return n - t + e;
					};
				}, getAxis: function getAxis() {
					return this._axis;
				}, getBaseAxis: function getBaseAxis() {
					return this._axis;
				}, getAxes: function getAxes() {
					return [this._axis];
				}, getTooltipAxes: function getTooltipAxes() {
					return { baseAxes: [this.getAxis()] };
				}, containPoint: function containPoint(t) {
					var e = this.getRect(),
					    i = this.getAxis(),
					    n = i.orient;return "horizontal" === n ? i.contain(i.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : i.contain(i.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height;
				}, pointToData: function pointToData(t) {
					var e = this.getAxis();return [e.coordToData(e.toLocalCoord(t["horizontal" === e.orient ? 0 : 1]))];
				}, dataToPoint: function dataToPoint(t) {
					var e = this.getAxis(),
					    i = this.getRect(),
					    n = [],
					    a = "horizontal" === e.orient ? 0 : 1;return t instanceof Array && (t = t[0]), n[a] = e.toGlobalCoord(e.dataToCoord(+t)), n[1 - a] = 0 === a ? i.y + i.height / 2 : i.x + i.width / 2, n;
				} }, t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(33),
			    o = function o(t, e, i, n, _o5) {
				a.call(this, t, e, i), this.type = n || "value", this.position = _o5 || "bottom", this.orient = null, this._labelInterval = null;
			};o.prototype = { constructor: o, model: null, isHorizontal: function isHorizontal() {
					var t = this.position;return "top" === t || "bottom" === t;
				}, pointToData: function pointToData(t, e) {
					return this.coordinateSystem.pointToData(t, e)[0];
				}, toGlobalCoord: null, toLocalCoord: null }, n.inherits(o, a), t.exports = o;
		}, function (t, e, i) {
			function n(t, e) {
				var i = this.getAxis(),
				    n = e instanceof Array ? e[0] : e,
				    a = (t instanceof Array ? t[0] : t) / 2;return "category" === i.type ? i.getBandWidth() : Math.abs(i.dataToCoord(n - a) - i.dataToCoord(n + a));
			}function a(t) {
				var e = t.getRect();return { coordSys: { type: "singleAxis", x: e.x, y: e.y, width: e.width, height: e.height }, api: { coord: o.bind(t.dataToPoint, t), size: o.bind(n, t) } };
			}var o = i(1);t.exports = a;
		}, function (t, e, i) {
			function n(t, e) {
				var i = [];return t.eachComponent("singleAxis", function (n, o) {
					var r = new a(n, t, e);r.name = "single_" + o, r.resize(n, e), n.coordinateSystem = r, i.push(r);
				}), t.eachSeries(function (e) {
					if ("singleAxis" === e.get("coordinateSystem")) {
						var i = t.queryComponents({ mainType: "singleAxis", index: e.get("singleAxisIndex"), id: e.get("singleAxisId") })[0];e.coordinateSystem = i && i.coordinateSystem;
					}
				}), i;
			}var a = i(419);i(26).register("single", { create: n, dimensions: a.prototype.dimensions });
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return "_EC_" + t;
			}function a(t, e) {
				this.id = null == t ? "" : t, this.inEdges = [], this.outEdges = [], this.edges = [], this.hostGraph, this.dataIndex = null == e ? -1 : e;
			}function o(t, e, i) {
				this.node1 = t, this.node2 = e, this.dataIndex = null == i ? -1 : i;
			}var r = i(1),
			    s = function s(t) {
				this._directed = t || !1, this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this.data, this.edgeData;
			},
			    l = s.prototype;l.type = "graph", l.isDirected = function () {
				return this._directed;
			}, l.addNode = function (t, e) {
				t = t || "" + e;var i = this._nodesMap;if (!i[n(t)]) {
					var o = new a(t, e);return o.hostGraph = this, this.nodes.push(o), i[n(t)] = o, o;
				}
			}, l.getNodeByIndex = function (t) {
				var e = this.data.getRawIndex(t);return this.nodes[e];
			}, l.getNodeById = function (t) {
				return this._nodesMap[n(t)];
			}, l.addEdge = function (t, e, i) {
				var r = this._nodesMap,
				    s = this._edgesMap;if ("number" == typeof t && (t = this.nodes[t]), "number" == typeof e && (e = this.nodes[e]), t instanceof a || (t = r[n(t)]), e instanceof a || (e = r[n(e)]), t && e) {
					var l = t.id + "-" + e.id;if (!s[l]) {
						var u = new o(t, e, i);return u.hostGraph = this, this._directed && (t.outEdges.push(u), e.inEdges.push(u)), t.edges.push(u), t !== e && e.edges.push(u), this.edges.push(u), s[l] = u, u;
					}
				}
			}, l.getEdgeByIndex = function (t) {
				var e = this.edgeData.getRawIndex(t);return this.edges[e];
			}, l.getEdge = function (t, e) {
				t instanceof a && (t = t.id), e instanceof a && (e = e.id);var i = this._edgesMap;return this._directed ? i[t + "-" + e] : i[t + "-" + e] || i[e + "-" + t];
			}, l.eachNode = function (t, e) {
				for (var i = this.nodes, n = i.length, a = 0; a < n; a++) {
					i[a].dataIndex >= 0 && t.call(e, i[a], a);
				}
			}, l.eachEdge = function (t, e) {
				for (var i = this.edges, n = i.length, a = 0; a < n; a++) {
					i[a].dataIndex >= 0 && i[a].node1.dataIndex >= 0 && i[a].node2.dataIndex >= 0 && t.call(e, i[a], a);
				}
			}, l.breadthFirstTraverse = function (t, e, i, o) {
				if (e instanceof a || (e = this._nodesMap[n(e)]), e) {
					for (var r = "out" === i ? "outEdges" : "in" === i ? "inEdges" : "edges", s = 0; s < this.nodes.length; s++) {
						this.nodes[s].__visited = !1;
					}if (!t.call(o, e, null)) for (var l = [e]; l.length;) {
						for (var u = l.shift(), c = u[r], s = 0; s < c.length; s++) {
							var h = c[s],
							    d = h.node1 === u ? h.node2 : h.node1;if (!d.__visited) {
								if (t.call(o, d, u)) return;l.push(d), d.__visited = !0;
							}
						}
					}
				}
			}, l.update = function () {
				for (var t = this.data, e = this.edgeData, i = this.nodes, n = this.edges, a = 0, o = i.length; a < o; a++) {
					i[a].dataIndex = -1;
				}for (var a = 0, o = t.count(); a < o; a++) {
					i[t.getRawIndex(a)].dataIndex = a;
				}e.filterSelf(function (t) {
					var i = n[e.getRawIndex(t)];return i.node1.dataIndex >= 0 && i.node2.dataIndex >= 0;
				});for (var a = 0, o = n.length; a < o; a++) {
					n[a].dataIndex = -1;
				}for (var a = 0, o = e.count(); a < o; a++) {
					n[e.getRawIndex(a)].dataIndex = a;
				}
			}, l.clone = function () {
				for (var t = new s(this._directed), e = this.nodes, i = this.edges, n = 0; n < e.length; n++) {
					t.addNode(e[n].id, e[n].dataIndex);
				}for (var n = 0; n < i.length; n++) {
					var a = i[n];t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
				}return t;
			}, a.prototype = { constructor: a, degree: function degree() {
					return this.edges.length;
				}, inDegree: function inDegree() {
					return this.inEdges.length;
				}, outDegree: function outDegree() {
					return this.outEdges.length;
				}, getModel: function getModel(t) {
					if (!(this.dataIndex < 0)) {
						var e = this.hostGraph,
						    i = e.data.getItemModel(this.dataIndex);return i.getModel(t);
					}
				} }, o.prototype.getModel = function (t) {
				if (!(this.dataIndex < 0)) {
					var e = this.hostGraph,
					    i = e.edgeData.getItemModel(this.dataIndex);return i.getModel(t);
				}
			};var u = function u(t, e) {
				return { getValue: function getValue(i) {
						var n = this[t][e];return n.get(n.getDimension(i || "value"), this.dataIndex);
					}, setVisual: function setVisual(i, n) {
						this.dataIndex >= 0 && this[t][e].setItemVisual(this.dataIndex, i, n);
					}, getVisual: function getVisual(i, n) {
						return this[t][e].getItemVisual(this.dataIndex, i, n);
					}, setLayout: function setLayout(i, n) {
						this.dataIndex >= 0 && this[t][e].setItemLayout(this.dataIndex, i, n);
					}, getLayout: function getLayout() {
						return this[t][e].getItemLayout(this.dataIndex);
					}, getGraphicEl: function getGraphicEl() {
						return this[t][e].getItemGraphicEl(this.dataIndex);
					}, getRawIndex: function getRawIndex() {
						return this[t][e].getRawIndex(this.dataIndex);
					} };
			};r.mixin(a, u("hostGraph", "data")), r.mixin(o, u("hostGraph", "edgeData")), s.Node = a, s.Edge = o, t.exports = s;
		}, function (t, e, i) {
			function n(t, e) {
				this.root, this.data, this._nodes = [], this.hostModel = t, this.levelModels = o.map(e || [], function (e) {
					return new r(e, t, t.ecModel);
				});
			}function a(t, e) {
				var i = e.children;t.parentNode !== e && (i.push(t), t.parentNode = e);
			}var o = i(1),
			    r = i(10),
			    s = i(14),
			    l = i(264),
			    u = i(25),
			    c = function c(t, e) {
				this.name = t || "", this.depth = 0, this.height = 0, this.parentNode = null, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.hostTree = e;
			};c.prototype = { constructor: c, isRemoved: function isRemoved() {
					return this.dataIndex < 0;
				}, eachNode: function eachNode(t, e, i) {
					"function" == typeof t && (i = e, e = t, t = null), t = t || {}, o.isString(t) && (t = { order: t });var n,
					    a = t.order || "preorder",
					    r = this[t.attr || "children"];"preorder" === a && (n = e.call(i, this));for (var s = 0; !n && s < r.length; s++) {
						r[s].eachNode(t, e, i);
					}"postorder" === a && e.call(i, this);
				}, updateDepthAndHeight: function updateDepthAndHeight(t) {
					var e = 0;this.depth = t;for (var i = 0; i < this.children.length; i++) {
						var n = this.children[i];n.updateDepthAndHeight(t + 1), n.height > e && (e = n.height);
					}this.height = e + 1;
				}, getNodeById: function getNodeById(t) {
					if (this.getId() === t) return this;for (var e = 0, i = this.children, n = i.length; e < n; e++) {
						var a = i[e].getNodeById(t);if (a) return a;
					}
				}, contains: function contains(t) {
					if (t === this) return !0;for (var e = 0, i = this.children, n = i.length; e < n; e++) {
						var a = i[e].contains(t);if (a) return a;
					}
				}, getAncestors: function getAncestors(t) {
					for (var e = [], i = t ? this : this.parentNode; i;) {
						e.push(i), i = i.parentNode;
					}return e.reverse(), e;
				}, getValue: function getValue(t) {
					var e = this.hostTree.data;return e.get(e.getDimension(t || "value"), this.dataIndex);
				}, setLayout: function setLayout(t, e) {
					this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, e);
				}, getLayout: function getLayout() {
					return this.hostTree.data.getItemLayout(this.dataIndex);
				}, getModel: function getModel(t) {
					if (!(this.dataIndex < 0)) {
						var e = this.hostTree,
						    i = e.data.getItemModel(this.dataIndex),
						    n = this.getLevelModel();return i.getModel(t, (n || e.hostModel).getModel(t));
					}
				}, getLevelModel: function getLevelModel() {
					return (this.hostTree.levelModels || [])[this.depth];
				}, setVisual: function setVisual(t, e) {
					this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, e);
				}, getVisual: function getVisual(t, e) {
					return this.hostTree.data.getItemVisual(this.dataIndex, t, e);
				}, getRawIndex: function getRawIndex() {
					return this.hostTree.data.getRawIndex(this.dataIndex);
				}, getId: function getId() {
					return this.hostTree.data.getId(this.dataIndex);
				} }, n.prototype = { constructor: n, type: "tree", eachNode: function eachNode(t, e, i) {
					this.root.eachNode(t, e, i);
				}, getNodeByDataIndex: function getNodeByDataIndex(t) {
					var e = this.data.getRawIndex(t);return this._nodes[e];
				}, getNodeByName: function getNodeByName(t) {
					return this.root.getNodeByName(t);
				}, update: function update() {
					for (var t = this.data, e = this._nodes, i = 0, n = e.length; i < n; i++) {
						e[i].dataIndex = -1;
					}for (var i = 0, n = t.count(); i < n; i++) {
						e[t.getRawIndex(i)].dataIndex = i;
					}
				}, clearLayouts: function clearLayouts() {
					this.data.clearItemLayouts();
				} }, n.createTree = function (t, e, i) {
				function r(t, e) {
					var i = t.value;f = Math.max(f, o.isArray(i) ? i.length : 1), d.push(t);var n = new c(t.name, h);e ? a(n, e) : h.root = n, h._nodes.push(n);var s = t.children;if (s) for (var l = 0; l < s.length; l++) {
						r(s[l], n);
					}
				}var h = new n(e, i),
				    d = [],
				    f = 1;r(t), h.root.updateDepthAndHeight(0);var p = u([{ name: "value" }], d, { dimCount: f }),
				    g = new s(p, e);return g.initData(d), l({ mainData: g, struct: h, structAttr: "tree" }), h.update(), h;
			}, t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return t.get("stack") || "__ec_stack_" + t.seriesIndex;
			}function a(t) {
				return t.dim;
			}function o(t, e, i) {
				var o = i.getWidth(),
				    u = i.getHeight(),
				    c = {},
				    h = {},
				    d = r(s.filter(e.getSeriesByType(t), function (t) {
					return !e.isSeriesFiltered(t) && t.coordinateSystem && "polar" === t.coordinateSystem.type;
				}));e.eachSeriesByType(t, function (t) {
					if ("polar" === t.coordinateSystem.type) {
						var e = t.getData(),
						    i = t.coordinateSystem,
						    r = i.getAngleAxis(),
						    s = i.getBaseAxis(),
						    f = n(t),
						    p = d[a(s)][f],
						    g = p.offset,
						    m = p.width,
						    v = i.getOtherAxis(s),
						    y = t.get("center") || ["50%", "50%"],
						    x = l(y[0], o),
						    _ = l(y[1], u),
						    b = t.get("barMinHeight") || 0,
						    w = t.get("barMinAngle") || 0,
						    S = v.getExtent()[0],
						    M = v.model.get("max"),
						    I = v.model.get("min"),
						    T = i.dataToPoints(e);c[f] = c[f] || [], h[f] = h[f] || [], e.each(v.dim, function (t, n) {
							if (!isNaN(t)) {
								c[f][n] || (c[f][n] = { p: S, n: S }, h[f][n] = { p: S, n: S });var a,
								    o,
								    s,
								    l,
								    u = t >= 0 ? "p" : "n",
								    d = i.pointToCoord(T[n]),
								    p = h[f][n][u];if ("radius" === v.dim) a = p, o = d[0], s = (-d[1] + g) * Math.PI / 180, l = s + m * Math.PI / 180, Math.abs(o) < b && (o = a + (o < 0 ? -1 : 1) * b), h[f][n][u] = o;else {
									a = d[0] + g, o = a + m, null != M && (t = Math.min(t, M)), null != I && (t = Math.max(t, I));var y = r.dataToAngle(t);Math.abs(y - p) < w && (y = p - (t < 0 ? -1 : 1) * w), s = -p * Math.PI / 180, l = -y * Math.PI / 180;var A = r.getExtent(),
									    C = y;C === A[0] && t > 0 ? C = A[1] : C === A[1] && t < 0 && (C = A[0]), h[f][n][u] = C;
								}e.setItemLayout(n, { cx: x, cy: _, r0: a, r: o, startAngle: s, endAngle: l });
							}
						}, !0);
					}
				}, this);
			}function r(t, e) {
				var i = {};s.each(t, function (t, e) {
					var o = t.getData(),
					    r = t.coordinateSystem,
					    s = r.getBaseAxis(),
					    u = s.getExtent(),
					    c = "category" === s.type ? s.getBandWidth() : Math.abs(u[1] - u[0]) / o.count(),
					    h = i[a(s)] || { bandWidth: c, remainedWidth: c, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {} },
					    d = h.stacks;i[a(s)] = h;var f = n(t);d[f] || h.autoWidthCount++, d[f] = d[f] || { width: 0, maxWidth: 0 };var p = l(t.get("barWidth"), c),
					    g = l(t.get("barMaxWidth"), c),
					    m = t.get("barGap"),
					    v = t.get("barCategoryGap");p && !d[f].width && (p = Math.min(h.remainedWidth, p), d[f].width = p, h.remainedWidth -= p), g && (d[f].maxWidth = g), null != m && (h.gap = m), null != v && (h.categoryGap = v);
				});var o = {};return s.each(i, function (t, e) {
					o[e] = {};var i = t.stacks,
					    n = t.bandWidth,
					    a = l(t.categoryGap, n),
					    r = l(t.gap, 1),
					    u = t.remainedWidth,
					    c = t.autoWidthCount,
					    h = (u - a) / (c + (c - 1) * r);h = Math.max(h, 0), s.each(i, function (t, e) {
						var i = t.maxWidth;i && i < h && (i = Math.min(i, u), t.width && (i = Math.min(i, t.width)), u -= i, t.width = i, c--);
					}), h = (u - a) / (c + (c - 1) * r), h = Math.max(h, 0);var d,
					    f = 0;s.each(i, function (t, e) {
						t.width || (t.width = h), d = t, f += t.width * (1 + r);
					}), d && (f -= d.width * r);var p = -f / 2;s.each(i, function (t, i) {
						o[e][i] = o[e][i] || { offset: p, width: t.width }, p += t.width * (1 + r);
					});
				}), o;
			}var s = i(1),
			    l = i(4).parsePercent;t.exports = o;
		}, function (t, e, i) {
			function n() {
				var t,
				    e = [],
				    i = {};return { add: function add(t, n, o, r, s) {
						return a.isString(r) && (s = r, r = 0), !i[t.id] && (i[t.id] = 1, e.push({ el: t, target: n, time: o, delay: r, easing: s }), !0);
					}, done: function done(e) {
						return t = e, this;
					}, start: function start() {
						function n() {
							a--, a || (e.length = 0, i = {}, t && t());
						}for (var a = e.length, o = 0, r = e.length; o < r; o++) {
							var s = e[o];s.el.animateTo(s.target, s.time, s.delay, s.easing, n);
						}return this;
					} };
			}var a = i(1);t.exports = { createWrap: n };
		}]);
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(209)(module)))

/***/ }),
/* 209 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ })
/******/ ]);