/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(37);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _Page = __webpack_require__(184);

	var _Page2 = _interopRequireDefault(_Page);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	_reactDom2.default.render(_react2.default.createElement(_Page2.default, null), document.getElementById('page'));

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(2);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var ReactBaseClasses = __webpack_require__(5);
	var ReactChildren = __webpack_require__(14);
	var ReactDOMFactories = __webpack_require__(22);
	var ReactElement = __webpack_require__(16);
	var ReactPropTypes = __webpack_require__(28);
	var ReactVersion = __webpack_require__(33);

	var createReactClass = __webpack_require__(34);
	var onlyChild = __webpack_require__(36);

	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;

	if (process.env.NODE_ENV !== 'production') {
	  var lowPriorityWarning = __webpack_require__(13);
	  var canDefineProperty = __webpack_require__(10);
	  var ReactElementValidator = __webpack_require__(23);
	  var didWarnPropTypesDeprecated = false;
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}

	var __spread = _assign;
	var createMixin = function (mixin) {
	  return mixin;
	};

	if (process.env.NODE_ENV !== 'production') {
	  var warnedForSpread = false;
	  var warnedForCreateMixin = false;
	  __spread = function () {
	    lowPriorityWarning(warnedForSpread, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.');
	    warnedForSpread = true;
	    return _assign.apply(null, arguments);
	  };

	  createMixin = function (mixin) {
	    lowPriorityWarning(warnedForCreateMixin, 'React.createMixin is deprecated and should not be used. ' + 'In React v16.0, it will be removed. ' + 'You can use this mixin directly instead. ' + 'See https://fb.me/createmixin-was-never-implemented for more info.');
	    warnedForCreateMixin = true;
	    return mixin;
	  };
	}

	var React = {
	  // Modern

	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },

	  Component: ReactBaseClasses.Component,
	  PureComponent: ReactBaseClasses.PureComponent,

	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,

	  // Classic

	  PropTypes: ReactPropTypes,
	  createClass: createReactClass,
	  createFactory: createFactory,
	  createMixin: createMixin,

	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,

	  version: ReactVersion,

	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};

	if (process.env.NODE_ENV !== 'production') {
	  var warnedForCreateClass = false;
	  if (canDefineProperty) {
	    Object.defineProperty(React, 'PropTypes', {
	      get: function () {
	        lowPriorityWarning(didWarnPropTypesDeprecated, 'Accessing PropTypes via the main React package is deprecated,' + ' and will be removed in  React v16.0.' + ' Use the latest available v15.* prop-types package from npm instead.' + ' For info on usage, compatibility, migration and more, see ' + 'https://fb.me/prop-types-docs');
	        didWarnPropTypesDeprecated = true;
	        return ReactPropTypes;
	      }
	    });

	    Object.defineProperty(React, 'createClass', {
	      get: function () {
	        lowPriorityWarning(warnedForCreateClass, 'Accessing createClass via the main React package is deprecated,' + ' and will be removed in React v16.0.' + " Use a plain JavaScript class instead. If you're not yet " + 'ready to migrate, create-react-class v15.* is available ' + 'on npm as a temporary, drop-in replacement. ' + 'For more info see https://fb.me/react-create-class');
	        warnedForCreateClass = true;
	        return createReactClass;
	      }
	    });
	  }

	  // React.DOM factories are deprecated. Wrap these methods so that
	  // invocations of the React.DOM namespace and alert users to switch
	  // to the `react-dom-factories` package.
	  React.DOM = {};
	  var warnedForFactories = false;
	  Object.keys(ReactDOMFactories).forEach(function (factory) {
	    React.DOM[factory] = function () {
	      if (!warnedForFactories) {
	        lowPriorityWarning(false, 'Accessing factories like React.DOM.%s has been deprecated ' + 'and will be removed in v16.0+. Use the ' + 'react-dom-factories package instead. ' + ' Version 1.0 provides a drop-in replacement.' + ' For more info, see https://fb.me/react-dom-factories', factory);
	        warnedForFactories = true;
	      }
	      return ReactDOMFactories[factory].apply(ReactDOMFactories, arguments);
	    };
	  });
	}

	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(6),
	    _assign = __webpack_require__(4);

	var ReactNoopUpdateQueue = __webpack_require__(7);

	var canDefineProperty = __webpack_require__(10);
	var emptyObject = __webpack_require__(11);
	var invariant = __webpack_require__(12);
	var lowPriorityWarning = __webpack_require__(13);

	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}

	ReactComponent.prototype.isReactComponent = {};

	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};

	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};

	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          lowPriorityWarning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}

	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}

	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;

	module.exports = {
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	'use strict';

	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */

	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;

	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }

	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

	  throw error;
	}

	module.exports = reactProdInvariant;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var warning = __webpack_require__(8);

	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}

	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};

	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var emptyFunction = __webpack_require__(9);

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = emptyFunction;

	if (process.env.NODE_ENV !== 'production') {
	  var printWarning = function printWarning(format) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    var argIndex = 0;
	    var message = 'Warning: ' + format.replace(/%s/g, function () {
	      return args[argIndex++];
	    });
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };

	  warning = function warning(condition, format) {
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }

	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }

	    if (!condition) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments[_key2];
	      }

	      printWarning.apply(undefined, [format].concat(args));
	    }
	  };
	}

	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    // $FlowFixMe https://github.com/facebook/flow/issues/285
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}

	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var emptyObject = {};

	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}

	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var validateFormat = function validateFormat(format) {};

	if (process.env.NODE_ENV !== 'production') {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}

	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * Forked from fbjs/warning:
	 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
	 *
	 * Only change is we use console.warn instead of console.error,
	 * and do nothing when 'console' is not supported.
	 * This really simplifies the code.
	 * ---
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var lowPriorityWarning = function () {};

	if (process.env.NODE_ENV !== 'production') {
	  var printWarning = function (format) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    var argIndex = 0;
	    var message = 'Warning: ' + format.replace(/%s/g, function () {
	      return args[argIndex++];
	    });
	    if (typeof console !== 'undefined') {
	      console.warn(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };

	  lowPriorityWarning = function (condition, format) {
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	    if (!condition) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments[_key2];
	      }

	      printWarning.apply(undefined, [format].concat(args));
	    }
	  };
	}

	module.exports = lowPriorityWarning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var PooledClass = __webpack_require__(15);
	var ReactElement = __webpack_require__(16);

	var emptyFunction = __webpack_require__(9);
	var traverseAllChildren = __webpack_require__(19);

	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;

	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}

	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func,
	      context = bookKeeping.context;

	  func.call(context, child, bookKeeping.count++);
	}

	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}

	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result,
	      keyPrefix = bookKeeping.keyPrefix,
	      func = bookKeeping.func,
	      context = bookKeeping.context;


	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}

	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}

	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}

	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}

	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}

	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}

	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};

	module.exports = ReactChildren;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(6);

	var invariant = __webpack_require__(12);

	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};

	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};

	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};

	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};

	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};

	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;

	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};

	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler
	};

	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var ReactCurrentOwner = __webpack_require__(17);

	var warning = __webpack_require__(8);
	var canDefineProperty = __webpack_require__(10);
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	var REACT_ELEMENT_TYPE = __webpack_require__(18);

	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};

	var specialPropKeyWarningShown, specialPropRefWarningShown;

	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}

	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}

	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function () {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}

	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function () {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}

	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,

	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,

	    // Record the component responsible for creating this element.
	    _owner: owner
	  };

	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};

	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }

	  return element;
	};

	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;

	  // Reserved names are extracted
	  var props = {};

	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;

	  if (config != null) {
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }

	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (Object.freeze) {
	        Object.freeze(childArray);
	      }
	    }
	    props.children = childArray;
	  }

	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};

	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};

	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

	  return newElement;
	};

	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;

	  // Original props are copied
	  var props = _assign({}, element.props);

	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;

	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;

	  if (config != null) {
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }

	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }

	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};

	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};

	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	var ReactCurrentOwner = {
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	};

	module.exports = ReactCurrentOwner;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.

	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

	module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(6);

	var ReactCurrentOwner = __webpack_require__(17);
	var REACT_ELEMENT_TYPE = __webpack_require__(18);

	var getIteratorFn = __webpack_require__(20);
	var invariant = __webpack_require__(12);
	var KeyEscapeUtils = __webpack_require__(21);
	var warning = __webpack_require__(8);

	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';

	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */

	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */

	var didWarnAboutMaps = false;

	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}

	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;

	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }

	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }

	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }

	  return subtreeCount;
	}

	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }

	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}

	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	/* global Symbol */

	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}

	module.exports = getIteratorFn;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */

	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });

	  return '$' + escapedString;
	}

	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}

	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};

	module.exports = KeyEscapeUtils;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ReactElement = __webpack_require__(16);

	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(23);
	  createDOMFactory = ReactElementValidator.createFactory;
	}

	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),

	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};

	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */

	'use strict';

	var ReactCurrentOwner = __webpack_require__(17);
	var ReactComponentTreeHook = __webpack_require__(24);
	var ReactElement = __webpack_require__(16);

	var checkReactTypeSpec = __webpack_require__(25);

	var canDefineProperty = __webpack_require__(10);
	var getIteratorFn = __webpack_require__(20);
	var warning = __webpack_require__(8);
	var lowPriorityWarning = __webpack_require__(13);

	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	function getSourceInfoErrorAddendum(elementProps) {
	  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
	    var source = elementProps.__source;
	    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
	    var lineNumber = source.lineNumber;
	    return ' Check your code at ' + fileName + ':' + lineNumber + '.';
	  }
	  return '';
	}

	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};

	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();

	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}

	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;

	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;

	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }

	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}

	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}

	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}

	var ReactElementValidator = {
	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      if (typeof type !== 'function' && typeof type !== 'string') {
	        var info = '';
	        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
	          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
	        }

	        var sourceInfo = getSourceInfoErrorAddendum(props);
	        if (sourceInfo) {
	          info += sourceInfo;
	        } else {
	          info += getDeclarationErrorAddendum();
	        }

	        info += ReactComponentTreeHook.getCurrentStackAddendum();

	        var currentSource = props !== null && props !== undefined && props.__source !== undefined ? props.__source : null;
	        ReactComponentTreeHook.pushNonStandardWarningStack(true, currentSource);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
	        ReactComponentTreeHook.popNonStandardWarningStack();
	      }
	    }

	    var element = ReactElement.createElement.apply(this, arguments);

	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }

	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }

	    validatePropTypes(element);

	    return element;
	  },

	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;

	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            lowPriorityWarning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }

	    return validatedFactory;
	  },

	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	};

	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2016-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(6);

	var ReactCurrentOwner = __webpack_require__(17);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty
	  // Strip regex characters so we can use it for regex
	  ).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&'
	  // Remove hasOwnProperty from the template to make it generic
	  ).replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}

	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

	var setItem;
	var getItem;
	var removeItem;
	var getItemIDs;
	var addRoot;
	var removeRoot;
	var getRootIDs;

	if (canUseCollections) {
	  var itemMap = new Map();
	  var rootIDSet = new Set();

	  setItem = function (id, item) {
	    itemMap.set(id, item);
	  };
	  getItem = function (id) {
	    return itemMap.get(id);
	  };
	  removeItem = function (id) {
	    itemMap['delete'](id);
	  };
	  getItemIDs = function () {
	    return Array.from(itemMap.keys());
	  };

	  addRoot = function (id) {
	    rootIDSet.add(id);
	  };
	  removeRoot = function (id) {
	    rootIDSet['delete'](id);
	  };
	  getRootIDs = function () {
	    return Array.from(rootIDSet.keys());
	  };
	} else {
	  var itemByKey = {};
	  var rootByKey = {};

	  // Use non-numeric keys to prevent V8 performance issues:
	  // https://github.com/facebook/react/pull/7232
	  var getKeyFromID = function (id) {
	    return '.' + id;
	  };
	  var getIDFromKey = function (key) {
	    return parseInt(key.substr(1), 10);
	  };

	  setItem = function (id, item) {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  };
	  getItem = function (id) {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  };
	  removeItem = function (id) {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  };
	  getItemIDs = function () {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  };

	  addRoot = function (id) {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  };
	  removeRoot = function (id) {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  };
	  getRootIDs = function () {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  };
	}

	var unmountedIDs = [];

	function purgeDeep(id) {
	  var item = getItem(id);
	  if (item) {
	    var childIDs = item.childIDs;

	    removeItem(id);
	    childIDs.forEach(purgeDeep);
	  }
	}

	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}

	function getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}

	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}

	var ReactComponentTreeHook = {
	  onSetChildren: function (id, nextChildIDs) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.childIDs = nextChildIDs;

	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = getItem(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent id is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function (id, element, parentID) {
	    var item = {
	      element: element,
	      parentID: parentID,
	      text: null,
	      childIDs: [],
	      isMounted: false,
	      updateCount: 0
	    };
	    setItem(id, item);
	  },
	  onBeforeUpdateComponent: function (id, element) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function (id) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function (id) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function (id) {
	    var item = getItem(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function () {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }

	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function (id) {
	    var item = getItem(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function (topElement) {
	    var info = '';
	    if (topElement) {
	      var name = getDisplayName(topElement);
	      var owner = topElement._owner;
	      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
	    }

	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;

	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function (id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function (id) {
	    var item = getItem(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return getDisplayName(element);
	  },
	  getElement: function (id) {
	    var item = getItem(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function (id) {
	    var item = getItem(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function (id) {
	    var item = getItem(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function (id) {
	    var item = getItem(id);
	    return item ? item.updateCount : 0;
	  },


	  getRootIDs: getRootIDs,
	  getRegisteredIDs: getItemIDs,

	  pushNonStandardWarningStack: function (isCreatingElement, currentSource) {
	    if (typeof console.reactStack !== 'function') {
	      return;
	    }

	    var stack = [];
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;

	    try {
	      if (isCreatingElement) {
	        stack.push({
	          name: id ? ReactComponentTreeHook.getDisplayName(id) : null,
	          fileName: currentSource ? currentSource.fileName : null,
	          lineNumber: currentSource ? currentSource.lineNumber : null
	        });
	      }

	      while (id) {
	        var element = ReactComponentTreeHook.getElement(id);
	        var parentID = ReactComponentTreeHook.getParentID(id);
	        var ownerID = ReactComponentTreeHook.getOwnerID(id);
	        var ownerName = ownerID ? ReactComponentTreeHook.getDisplayName(ownerID) : null;
	        var source = element && element._source;
	        stack.push({
	          name: ownerName,
	          fileName: source ? source.fileName : null,
	          lineNumber: source ? source.lineNumber : null
	        });
	        id = parentID;
	      }
	    } catch (err) {
	      // Internal state is messed up.
	      // Stop building the stack (it's just a nice to have).
	    }

	    console.reactStack(stack);
	  },
	  popNonStandardWarningStack: function () {
	    if (typeof console.reactStackEnd !== 'function') {
	      return;
	    }
	    console.reactStackEnd();
	  }
	};

	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(6);

	var ReactPropTypeLocationNames = __webpack_require__(26);
	var ReactPropTypesSecret = __webpack_require__(27);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(24);
	}

	var loggedTypeFailures = {};

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var componentStackInfo = '';

	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(24);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }

	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}

	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var ReactPropTypeLocationNames = {};

	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}

	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _require = __webpack_require__(16),
	    isValidElement = _require.isValidElement;

	var factory = __webpack_require__(29);

	module.exports = factory(isValidElement);

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	// React 15.5 references this module, and assumes PropTypes are still callable in production.
	// Therefore we re-export development-only version with all the PropTypes checks here.
	// However if one is migrating to the `prop-types` npm library, they will go through the
	// `index.js` entry point, and it will branch depending on the environment.
	var factory = __webpack_require__(30);
	module.exports = function(isValidElement) {
	  // It is still allowed in 15.5.
	  var throwOnDirectAccess = false;
	  return factory(isValidElement, throwOnDirectAccess);
	};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	var emptyFunction = __webpack_require__(9);
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);
	var assign = __webpack_require__(4);

	var ReactPropTypesSecret = __webpack_require__(31);
	var checkPropTypes = __webpack_require__(32);

	module.exports = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    if (process.env.NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          invariant(
	            false,
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            warning(
	              false,
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `%s` prop on `%s`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
	              propFullName,
	              componentName
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues);
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (propValue.hasOwnProperty(key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        warning(
	          false,
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received %s at index %s.',
	          getPostfixForTypeWarning(checker),
	          i
	        );
	        return emptyFunction.thatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	          return null;
	        }
	      }

	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from
	      // props.
	      var allKeys = assign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 31 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	if (process.env.NODE_ENV !== 'production') {
	  var invariant = __webpack_require__(12);
	  var warning = __webpack_require__(8);
	  var ReactPropTypesSecret = __webpack_require__(31);
	  var loggedTypeFailures = {};
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (process.env.NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (typeSpecs.hasOwnProperty(typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
	        }
	      }
	    }
	  }
	}

	module.exports = checkPropTypes;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 33 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	module.exports = '15.6.2';

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _require = __webpack_require__(5),
	    Component = _require.Component;

	var _require2 = __webpack_require__(16),
	    isValidElement = _require2.isValidElement;

	var ReactNoopUpdateQueue = __webpack_require__(7);
	var factory = __webpack_require__(35);

	module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue);

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var emptyObject = __webpack_require__(11);
	var _invariant = __webpack_require__(12);

	if (process.env.NODE_ENV !== 'production') {
	  var warning = __webpack_require__(8);
	}

	var MIXINS_KEY = 'mixins';

	// Helper function to allow the creation of anonymous functions which do not
	// have .name set to the name of the variable being assigned to.
	function identity(fn) {
	  return fn;
	}

	var ReactPropTypeLocationNames;
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	} else {
	  ReactPropTypeLocationNames = {};
	}

	function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
	  /**
	   * Policies that describe methods in `ReactClassInterface`.
	   */

	  var injectedMixins = [];

	  /**
	   * Composite components are higher-level components that compose other composite
	   * or host components.
	   *
	   * To create a new type of `ReactClass`, pass a specification of
	   * your new class to `React.createClass`. The only requirement of your class
	   * specification is that you implement a `render` method.
	   *
	   *   var MyComponent = React.createClass({
	   *     render: function() {
	   *       return <div>Hello World</div>;
	   *     }
	   *   });
	   *
	   * The class specification supports a specific protocol of methods that have
	   * special meaning (e.g. `render`). See `ReactClassInterface` for
	   * more the comprehensive protocol. Any other properties and methods in the
	   * class specification will be available on the prototype.
	   *
	   * @interface ReactClassInterface
	   * @internal
	   */
	  var ReactClassInterface = {
	    /**
	     * An array of Mixin objects to include when defining your component.
	     *
	     * @type {array}
	     * @optional
	     */
	    mixins: 'DEFINE_MANY',

	    /**
	     * An object containing properties and methods that should be defined on
	     * the component's constructor instead of its prototype (static methods).
	     *
	     * @type {object}
	     * @optional
	     */
	    statics: 'DEFINE_MANY',

	    /**
	     * Definition of prop types for this component.
	     *
	     * @type {object}
	     * @optional
	     */
	    propTypes: 'DEFINE_MANY',

	    /**
	     * Definition of context types for this component.
	     *
	     * @type {object}
	     * @optional
	     */
	    contextTypes: 'DEFINE_MANY',

	    /**
	     * Definition of context types this component sets for its children.
	     *
	     * @type {object}
	     * @optional
	     */
	    childContextTypes: 'DEFINE_MANY',

	    // ==== Definition methods ====

	    /**
	     * Invoked when the component is mounted. Values in the mapping will be set on
	     * `this.props` if that prop is not specified (i.e. using an `in` check).
	     *
	     * This method is invoked before `getInitialState` and therefore cannot rely
	     * on `this.state` or use `this.setState`.
	     *
	     * @return {object}
	     * @optional
	     */
	    getDefaultProps: 'DEFINE_MANY_MERGED',

	    /**
	     * Invoked once before the component is mounted. The return value will be used
	     * as the initial value of `this.state`.
	     *
	     *   getInitialState: function() {
	     *     return {
	     *       isOn: false,
	     *       fooBaz: new BazFoo()
	     *     }
	     *   }
	     *
	     * @return {object}
	     * @optional
	     */
	    getInitialState: 'DEFINE_MANY_MERGED',

	    /**
	     * @return {object}
	     * @optional
	     */
	    getChildContext: 'DEFINE_MANY_MERGED',

	    /**
	     * Uses props from `this.props` and state from `this.state` to render the
	     * structure of the component.
	     *
	     * No guarantees are made about when or how often this method is invoked, so
	     * it must not have side effects.
	     *
	     *   render: function() {
	     *     var name = this.props.name;
	     *     return <div>Hello, {name}!</div>;
	     *   }
	     *
	     * @return {ReactComponent}
	     * @required
	     */
	    render: 'DEFINE_ONCE',

	    // ==== Delegate methods ====

	    /**
	     * Invoked when the component is initially created and about to be mounted.
	     * This may have side effects, but any external subscriptions or data created
	     * by this method must be cleaned up in `componentWillUnmount`.
	     *
	     * @optional
	     */
	    componentWillMount: 'DEFINE_MANY',

	    /**
	     * Invoked when the component has been mounted and has a DOM representation.
	     * However, there is no guarantee that the DOM node is in the document.
	     *
	     * Use this as an opportunity to operate on the DOM when the component has
	     * been mounted (initialized and rendered) for the first time.
	     *
	     * @param {DOMElement} rootNode DOM element representing the component.
	     * @optional
	     */
	    componentDidMount: 'DEFINE_MANY',

	    /**
	     * Invoked before the component receives new props.
	     *
	     * Use this as an opportunity to react to a prop transition by updating the
	     * state using `this.setState`. Current props are accessed via `this.props`.
	     *
	     *   componentWillReceiveProps: function(nextProps, nextContext) {
	     *     this.setState({
	     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	     *     });
	     *   }
	     *
	     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	     * transition may cause a state change, but the opposite is not true. If you
	     * need it, you are probably looking for `componentWillUpdate`.
	     *
	     * @param {object} nextProps
	     * @optional
	     */
	    componentWillReceiveProps: 'DEFINE_MANY',

	    /**
	     * Invoked while deciding if the component should be updated as a result of
	     * receiving new props, state and/or context.
	     *
	     * Use this as an opportunity to `return false` when you're certain that the
	     * transition to the new props/state/context will not require a component
	     * update.
	     *
	     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	     *     return !equal(nextProps, this.props) ||
	     *       !equal(nextState, this.state) ||
	     *       !equal(nextContext, this.context);
	     *   }
	     *
	     * @param {object} nextProps
	     * @param {?object} nextState
	     * @param {?object} nextContext
	     * @return {boolean} True if the component should update.
	     * @optional
	     */
	    shouldComponentUpdate: 'DEFINE_ONCE',

	    /**
	     * Invoked when the component is about to update due to a transition from
	     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	     * and `nextContext`.
	     *
	     * Use this as an opportunity to perform preparation before an update occurs.
	     *
	     * NOTE: You **cannot** use `this.setState()` in this method.
	     *
	     * @param {object} nextProps
	     * @param {?object} nextState
	     * @param {?object} nextContext
	     * @param {ReactReconcileTransaction} transaction
	     * @optional
	     */
	    componentWillUpdate: 'DEFINE_MANY',

	    /**
	     * Invoked when the component's DOM representation has been updated.
	     *
	     * Use this as an opportunity to operate on the DOM when the component has
	     * been updated.
	     *
	     * @param {object} prevProps
	     * @param {?object} prevState
	     * @param {?object} prevContext
	     * @param {DOMElement} rootNode DOM element representing the component.
	     * @optional
	     */
	    componentDidUpdate: 'DEFINE_MANY',

	    /**
	     * Invoked when the component is about to be removed from its parent and have
	     * its DOM representation destroyed.
	     *
	     * Use this as an opportunity to deallocate any external resources.
	     *
	     * NOTE: There is no `componentDidUnmount` since your component will have been
	     * destroyed by that point.
	     *
	     * @optional
	     */
	    componentWillUnmount: 'DEFINE_MANY',

	    /**
	     * Replacement for (deprecated) `componentWillMount`.
	     *
	     * @optional
	     */
	    UNSAFE_componentWillMount: 'DEFINE_MANY',

	    /**
	     * Replacement for (deprecated) `componentWillReceiveProps`.
	     *
	     * @optional
	     */
	    UNSAFE_componentWillReceiveProps: 'DEFINE_MANY',

	    /**
	     * Replacement for (deprecated) `componentWillUpdate`.
	     *
	     * @optional
	     */
	    UNSAFE_componentWillUpdate: 'DEFINE_MANY',

	    // ==== Advanced methods ====

	    /**
	     * Updates the component's currently mounted DOM representation.
	     *
	     * By default, this implements React's rendering and reconciliation algorithm.
	     * Sophisticated clients may wish to override this.
	     *
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     * @overridable
	     */
	    updateComponent: 'OVERRIDE_BASE'
	  };

	  /**
	   * Similar to ReactClassInterface but for static methods.
	   */
	  var ReactClassStaticInterface = {
	    /**
	     * This method is invoked after a component is instantiated and when it
	     * receives new props. Return an object to update state in response to
	     * prop changes. Return null to indicate no change to state.
	     *
	     * If an object is returned, its keys will be merged into the existing state.
	     *
	     * @return {object || null}
	     * @optional
	     */
	    getDerivedStateFromProps: 'DEFINE_MANY_MERGED'
	  };

	  /**
	   * Mapping from class specification keys to special processing functions.
	   *
	   * Although these are declared like instance properties in the specification
	   * when defining classes using `React.createClass`, they are actually static
	   * and are accessible on the constructor instead of the prototype. Despite
	   * being static, they must be defined outside of the "statics" key under
	   * which all other static methods are defined.
	   */
	  var RESERVED_SPEC_KEYS = {
	    displayName: function(Constructor, displayName) {
	      Constructor.displayName = displayName;
	    },
	    mixins: function(Constructor, mixins) {
	      if (mixins) {
	        for (var i = 0; i < mixins.length; i++) {
	          mixSpecIntoComponent(Constructor, mixins[i]);
	        }
	      }
	    },
	    childContextTypes: function(Constructor, childContextTypes) {
	      if (process.env.NODE_ENV !== 'production') {
	        validateTypeDef(Constructor, childContextTypes, 'childContext');
	      }
	      Constructor.childContextTypes = _assign(
	        {},
	        Constructor.childContextTypes,
	        childContextTypes
	      );
	    },
	    contextTypes: function(Constructor, contextTypes) {
	      if (process.env.NODE_ENV !== 'production') {
	        validateTypeDef(Constructor, contextTypes, 'context');
	      }
	      Constructor.contextTypes = _assign(
	        {},
	        Constructor.contextTypes,
	        contextTypes
	      );
	    },
	    /**
	     * Special case getDefaultProps which should move into statics but requires
	     * automatic merging.
	     */
	    getDefaultProps: function(Constructor, getDefaultProps) {
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps = createMergedResultFunction(
	          Constructor.getDefaultProps,
	          getDefaultProps
	        );
	      } else {
	        Constructor.getDefaultProps = getDefaultProps;
	      }
	    },
	    propTypes: function(Constructor, propTypes) {
	      if (process.env.NODE_ENV !== 'production') {
	        validateTypeDef(Constructor, propTypes, 'prop');
	      }
	      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
	    },
	    statics: function(Constructor, statics) {
	      mixStaticSpecIntoComponent(Constructor, statics);
	    },
	    autobind: function() {}
	  };

	  function validateTypeDef(Constructor, typeDef, location) {
	    for (var propName in typeDef) {
	      if (typeDef.hasOwnProperty(propName)) {
	        // use a warning instead of an _invariant so components
	        // don't show up in prod but only in __DEV__
	        if (process.env.NODE_ENV !== 'production') {
	          warning(
	            typeof typeDef[propName] === 'function',
	            '%s: %s type `%s` is invalid; it must be a function, usually from ' +
	              'React.PropTypes.',
	            Constructor.displayName || 'ReactClass',
	            ReactPropTypeLocationNames[location],
	            propName
	          );
	        }
	      }
	    }
	  }

	  function validateMethodOverride(isAlreadyDefined, name) {
	    var specPolicy = ReactClassInterface.hasOwnProperty(name)
	      ? ReactClassInterface[name]
	      : null;

	    // Disallow overriding of base class methods unless explicitly allowed.
	    if (ReactClassMixin.hasOwnProperty(name)) {
	      _invariant(
	        specPolicy === 'OVERRIDE_BASE',
	        'ReactClassInterface: You are attempting to override ' +
	          '`%s` from your class specification. Ensure that your method names ' +
	          'do not overlap with React methods.',
	        name
	      );
	    }

	    // Disallow defining methods more than once unless explicitly allowed.
	    if (isAlreadyDefined) {
	      _invariant(
	        specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',
	        'ReactClassInterface: You are attempting to define ' +
	          '`%s` on your component more than once. This conflict may be due ' +
	          'to a mixin.',
	        name
	      );
	    }
	  }

	  /**
	   * Mixin helper which handles policy validation and reserved
	   * specification keys when building React classes.
	   */
	  function mixSpecIntoComponent(Constructor, spec) {
	    if (!spec) {
	      if (process.env.NODE_ENV !== 'production') {
	        var typeofSpec = typeof spec;
	        var isMixinValid = typeofSpec === 'object' && spec !== null;

	        if (process.env.NODE_ENV !== 'production') {
	          warning(
	            isMixinValid,
	            "%s: You're attempting to include a mixin that is either null " +
	              'or not an object. Check the mixins included by the component, ' +
	              'as well as any mixins they include themselves. ' +
	              'Expected object but got %s.',
	            Constructor.displayName || 'ReactClass',
	            spec === null ? null : typeofSpec
	          );
	        }
	      }

	      return;
	    }

	    _invariant(
	      typeof spec !== 'function',
	      "ReactClass: You're attempting to " +
	        'use a component class or function as a mixin. Instead, just use a ' +
	        'regular object.'
	    );
	    _invariant(
	      !isValidElement(spec),
	      "ReactClass: You're attempting to " +
	        'use a component as a mixin. Instead, just use a regular object.'
	    );

	    var proto = Constructor.prototype;
	    var autoBindPairs = proto.__reactAutoBindPairs;

	    // By handling mixins before any other properties, we ensure the same
	    // chaining order is applied to methods with DEFINE_MANY policy, whether
	    // mixins are listed before or after these methods in the spec.
	    if (spec.hasOwnProperty(MIXINS_KEY)) {
	      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	    }

	    for (var name in spec) {
	      if (!spec.hasOwnProperty(name)) {
	        continue;
	      }

	      if (name === MIXINS_KEY) {
	        // We have already handled mixins in a special case above.
	        continue;
	      }

	      var property = spec[name];
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      validateMethodOverride(isAlreadyDefined, name);

	      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	        RESERVED_SPEC_KEYS[name](Constructor, property);
	      } else {
	        // Setup methods on prototype:
	        // The following member methods should not be automatically bound:
	        // 1. Expected ReactClass methods (in the "interface").
	        // 2. Overridden methods (that were mixed in).
	        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	        var isFunction = typeof property === 'function';
	        var shouldAutoBind =
	          isFunction &&
	          !isReactClassMethod &&
	          !isAlreadyDefined &&
	          spec.autobind !== false;

	        if (shouldAutoBind) {
	          autoBindPairs.push(name, property);
	          proto[name] = property;
	        } else {
	          if (isAlreadyDefined) {
	            var specPolicy = ReactClassInterface[name];

	            // These cases should already be caught by validateMethodOverride.
	            _invariant(
	              isReactClassMethod &&
	                (specPolicy === 'DEFINE_MANY_MERGED' ||
	                  specPolicy === 'DEFINE_MANY'),
	              'ReactClass: Unexpected spec policy %s for key %s ' +
	                'when mixing in component specs.',
	              specPolicy,
	              name
	            );

	            // For methods which are defined more than once, call the existing
	            // methods before calling the new property, merging if appropriate.
	            if (specPolicy === 'DEFINE_MANY_MERGED') {
	              proto[name] = createMergedResultFunction(proto[name], property);
	            } else if (specPolicy === 'DEFINE_MANY') {
	              proto[name] = createChainedFunction(proto[name], property);
	            }
	          } else {
	            proto[name] = property;
	            if (process.env.NODE_ENV !== 'production') {
	              // Add verbose displayName to the function, which helps when looking
	              // at profiling tools.
	              if (typeof property === 'function' && spec.displayName) {
	                proto[name].displayName = spec.displayName + '_' + name;
	              }
	            }
	          }
	        }
	      }
	    }
	  }

	  function mixStaticSpecIntoComponent(Constructor, statics) {
	    if (!statics) {
	      return;
	    }

	    for (var name in statics) {
	      var property = statics[name];
	      if (!statics.hasOwnProperty(name)) {
	        continue;
	      }

	      var isReserved = name in RESERVED_SPEC_KEYS;
	      _invariant(
	        !isReserved,
	        'ReactClass: You are attempting to define a reserved ' +
	          'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
	          'as an instance property instead; it will still be accessible on the ' +
	          'constructor.',
	        name
	      );

	      var isAlreadyDefined = name in Constructor;
	      if (isAlreadyDefined) {
	        var specPolicy = ReactClassStaticInterface.hasOwnProperty(name)
	          ? ReactClassStaticInterface[name]
	          : null;

	        _invariant(
	          specPolicy === 'DEFINE_MANY_MERGED',
	          'ReactClass: You are attempting to define ' +
	            '`%s` on your component more than once. This conflict may be ' +
	            'due to a mixin.',
	          name
	        );

	        Constructor[name] = createMergedResultFunction(Constructor[name], property);

	        return;
	      }

	      Constructor[name] = property;
	    }
	  }

	  /**
	   * Merge two objects, but throw if both contain the same key.
	   *
	   * @param {object} one The first object, which is mutated.
	   * @param {object} two The second object
	   * @return {object} one after it has been mutated to contain everything in two.
	   */
	  function mergeIntoWithNoDuplicateKeys(one, two) {
	    _invariant(
	      one && two && typeof one === 'object' && typeof two === 'object',
	      'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
	    );

	    for (var key in two) {
	      if (two.hasOwnProperty(key)) {
	        _invariant(
	          one[key] === undefined,
	          'mergeIntoWithNoDuplicateKeys(): ' +
	            'Tried to merge two objects with the same key: `%s`. This conflict ' +
	            'may be due to a mixin; in particular, this may be caused by two ' +
	            'getInitialState() or getDefaultProps() methods returning objects ' +
	            'with clashing keys.',
	          key
	        );
	        one[key] = two[key];
	      }
	    }
	    return one;
	  }

	  /**
	   * Creates a function that invokes two functions and merges their return values.
	   *
	   * @param {function} one Function to invoke first.
	   * @param {function} two Function to invoke second.
	   * @return {function} Function that invokes the two argument functions.
	   * @private
	   */
	  function createMergedResultFunction(one, two) {
	    return function mergedResult() {
	      var a = one.apply(this, arguments);
	      var b = two.apply(this, arguments);
	      if (a == null) {
	        return b;
	      } else if (b == null) {
	        return a;
	      }
	      var c = {};
	      mergeIntoWithNoDuplicateKeys(c, a);
	      mergeIntoWithNoDuplicateKeys(c, b);
	      return c;
	    };
	  }

	  /**
	   * Creates a function that invokes two functions and ignores their return vales.
	   *
	   * @param {function} one Function to invoke first.
	   * @param {function} two Function to invoke second.
	   * @return {function} Function that invokes the two argument functions.
	   * @private
	   */
	  function createChainedFunction(one, two) {
	    return function chainedFunction() {
	      one.apply(this, arguments);
	      two.apply(this, arguments);
	    };
	  }

	  /**
	   * Binds a method to the component.
	   *
	   * @param {object} component Component whose method is going to be bound.
	   * @param {function} method Method to be bound.
	   * @return {function} The bound method.
	   */
	  function bindAutoBindMethod(component, method) {
	    var boundMethod = method.bind(component);
	    if (process.env.NODE_ENV !== 'production') {
	      boundMethod.__reactBoundContext = component;
	      boundMethod.__reactBoundMethod = method;
	      boundMethod.__reactBoundArguments = null;
	      var componentName = component.constructor.displayName;
	      var _bind = boundMethod.bind;
	      boundMethod.bind = function(newThis) {
	        for (
	          var _len = arguments.length,
	            args = Array(_len > 1 ? _len - 1 : 0),
	            _key = 1;
	          _key < _len;
	          _key++
	        ) {
	          args[_key - 1] = arguments[_key];
	        }

	        // User is trying to bind() an autobound method; we effectively will
	        // ignore the value of "this" that the user is trying to use, so
	        // let's warn.
	        if (newThis !== component && newThis !== null) {
	          if (process.env.NODE_ENV !== 'production') {
	            warning(
	              false,
	              'bind(): React component methods may only be bound to the ' +
	                'component instance. See %s',
	              componentName
	            );
	          }
	        } else if (!args.length) {
	          if (process.env.NODE_ENV !== 'production') {
	            warning(
	              false,
	              'bind(): You are binding a component method to the component. ' +
	                'React does this for you automatically in a high-performance ' +
	                'way, so you can safely remove this call. See %s',
	              componentName
	            );
	          }
	          return boundMethod;
	        }
	        var reboundMethod = _bind.apply(boundMethod, arguments);
	        reboundMethod.__reactBoundContext = component;
	        reboundMethod.__reactBoundMethod = method;
	        reboundMethod.__reactBoundArguments = args;
	        return reboundMethod;
	      };
	    }
	    return boundMethod;
	  }

	  /**
	   * Binds all auto-bound methods in a component.
	   *
	   * @param {object} component Component whose method is going to be bound.
	   */
	  function bindAutoBindMethods(component) {
	    var pairs = component.__reactAutoBindPairs;
	    for (var i = 0; i < pairs.length; i += 2) {
	      var autoBindKey = pairs[i];
	      var method = pairs[i + 1];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }

	  var IsMountedPreMixin = {
	    componentDidMount: function() {
	      this.__isMounted = true;
	    }
	  };

	  var IsMountedPostMixin = {
	    componentWillUnmount: function() {
	      this.__isMounted = false;
	    }
	  };

	  /**
	   * Add more to the ReactClass base class. These are all legacy features and
	   * therefore not already part of the modern ReactComponent.
	   */
	  var ReactClassMixin = {
	    /**
	     * TODO: This will be deprecated because state should always keep a consistent
	     * type signature and the only use case for this, is to avoid that.
	     */
	    replaceState: function(newState, callback) {
	      this.updater.enqueueReplaceState(this, newState, callback);
	    },

	    /**
	     * Checks whether or not this composite component is mounted.
	     * @return {boolean} True if mounted, false otherwise.
	     * @protected
	     * @final
	     */
	    isMounted: function() {
	      if (process.env.NODE_ENV !== 'production') {
	        warning(
	          this.__didWarnIsMounted,
	          '%s: isMounted is deprecated. Instead, make sure to clean up ' +
	            'subscriptions and pending requests in componentWillUnmount to ' +
	            'prevent memory leaks.',
	          (this.constructor && this.constructor.displayName) ||
	            this.name ||
	            'Component'
	        );
	        this.__didWarnIsMounted = true;
	      }
	      return !!this.__isMounted;
	    }
	  };

	  var ReactClassComponent = function() {};
	  _assign(
	    ReactClassComponent.prototype,
	    ReactComponent.prototype,
	    ReactClassMixin
	  );

	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  function createClass(spec) {
	    // To keep our warnings more understandable, we'll use a little hack here to
	    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
	    // unnecessarily identify a class without displayName as 'Constructor'.
	    var Constructor = identity(function(props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.

	      if (process.env.NODE_ENV !== 'production') {
	        warning(
	          this instanceof Constructor,
	          'Something is calling a React component directly. Use a factory or ' +
	            'JSX instead. See: https://fb.me/react-legacyfactory'
	        );
	      }

	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }

	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;

	      this.state = null;

	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.

	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (
	          initialState === undefined &&
	          this.getInitialState._isMockFunction
	        ) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      _invariant(
	        typeof initialState === 'object' && !Array.isArray(initialState),
	        '%s.getInitialState(): must return an object or null',
	        Constructor.displayName || 'ReactCompositeComponent'
	      );

	      this.state = initialState;
	    });
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];

	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

	    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
	    mixSpecIntoComponent(Constructor, spec);
	    mixSpecIntoComponent(Constructor, IsMountedPostMixin);

	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }

	    _invariant(
	      Constructor.prototype.render,
	      'createClass(...): Class specification must implement a `render` method.'
	    );

	    if (process.env.NODE_ENV !== 'production') {
	      warning(
	        !Constructor.prototype.componentShouldUpdate,
	        '%s has a method called ' +
	          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
	          'The name is phrased as a question because the function is ' +
	          'expected to return a value.',
	        spec.displayName || 'A component'
	      );
	      warning(
	        !Constructor.prototype.componentWillRecieveProps,
	        '%s has a method called ' +
	          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
	        spec.displayName || 'A component'
	      );
	      warning(
	        !Constructor.prototype.UNSAFE_componentWillRecieveProps,
	        '%s has a method called UNSAFE_componentWillRecieveProps(). ' +
	          'Did you mean UNSAFE_componentWillReceiveProps()?',
	        spec.displayName || 'A component'
	      );
	    }

	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }

	    return Constructor;
	  }

	  return createClass;
	}

	module.exports = factory;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	'use strict';

	var _prodInvariant = __webpack_require__(6);

	var ReactElement = __webpack_require__(16);

	var invariant = __webpack_require__(12);

	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}

	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(38);


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

	'use strict';

	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactDefaultInjection = __webpack_require__(43);
	var ReactMount = __webpack_require__(172);
	var ReactReconciler = __webpack_require__(64);
	var ReactUpdates = __webpack_require__(61);
	var ReactVersion = __webpack_require__(177);

	var findDOMNode = __webpack_require__(178);
	var getHostComponentFromComposite = __webpack_require__(179);
	var renderSubtreeIntoContainer = __webpack_require__(180);
	var warning = __webpack_require__(8);

	ReactDefaultInjection.inject();

	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,

	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	  /* eslint-enable camelcase */
	};

	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function (inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}

	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(53);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }

	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, "It looks like you're using a minified copy of the development build " + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];

	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}

	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(67);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(181);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(182);
	  var ReactDOMInvalidARIAHook = __webpack_require__(183);

	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
	}

	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var DOMProperty = __webpack_require__(41);
	var ReactDOMComponentFlags = __webpack_require__(42);

	var invariant = __webpack_require__(12);

	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;

	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

	/**
	 * Check if a given node should be cached.
	 */
	function shouldPrecacheNode(node, nodeID) {
	  return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
	}

	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}

	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}

	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}

	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (shouldPrecacheNode(childNode, childID)) {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}

	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }

	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }

	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }

	  return closest;
	}

	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}

	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

	  if (inst._hostNode) {
	    return inst._hostNode;
	  }

	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }

	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }

	  return inst._hostNode;
	}

	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};

	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	'use strict';

	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */

	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;

	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }

	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

	  throw error;
	}

	module.exports = reactProdInvariant;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}

	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }

	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];

	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,

	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;

	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }

	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }

	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }

	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }

	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }

	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};

	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */

	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},

	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   *
	   * autofocus is predefined, because adding it to the property whitelist
	   * causes unintended side effects.
	   *
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? { autofocus: 'autoFocus' } : null,

	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],

	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },

	  injection: DOMPropertyInjection
	};

	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};

	module.exports = ReactDOMComponentFlags;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ARIADOMPropertyConfig = __webpack_require__(44);
	var BeforeInputEventPlugin = __webpack_require__(45);
	var ChangeEventPlugin = __webpack_require__(60);
	var DefaultEventPluginOrder = __webpack_require__(78);
	var EnterLeaveEventPlugin = __webpack_require__(79);
	var HTMLDOMPropertyConfig = __webpack_require__(84);
	var ReactComponentBrowserEnvironment = __webpack_require__(85);
	var ReactDOMComponent = __webpack_require__(98);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactDOMEmptyComponent = __webpack_require__(143);
	var ReactDOMTreeTraversal = __webpack_require__(144);
	var ReactDOMTextComponent = __webpack_require__(145);
	var ReactDefaultBatchingStrategy = __webpack_require__(146);
	var ReactEventListener = __webpack_require__(147);
	var ReactInjection = __webpack_require__(150);
	var ReactReconcileTransaction = __webpack_require__(151);
	var SVGDOMPropertyConfig = __webpack_require__(159);
	var SelectEventPlugin = __webpack_require__(160);
	var SimpleEventPlugin = __webpack_require__(161);

	var alreadyInjected = false;

	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;

	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });

	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

	  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });

	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}

	module.exports = {
	  inject: inject
	};

/***/ }),
/* 44 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ARIADOMPropertyConfig = {
	  Properties: {
	    // Global States and Properties
	    'aria-current': 0, // state
	    'aria-details': 0,
	    'aria-disabled': 0, // state
	    'aria-hidden': 0, // state
	    'aria-invalid': 0, // state
	    'aria-keyshortcuts': 0,
	    'aria-label': 0,
	    'aria-roledescription': 0,
	    // Widget Attributes
	    'aria-autocomplete': 0,
	    'aria-checked': 0,
	    'aria-expanded': 0,
	    'aria-haspopup': 0,
	    'aria-level': 0,
	    'aria-modal': 0,
	    'aria-multiline': 0,
	    'aria-multiselectable': 0,
	    'aria-orientation': 0,
	    'aria-placeholder': 0,
	    'aria-pressed': 0,
	    'aria-readonly': 0,
	    'aria-required': 0,
	    'aria-selected': 0,
	    'aria-sort': 0,
	    'aria-valuemax': 0,
	    'aria-valuemin': 0,
	    'aria-valuenow': 0,
	    'aria-valuetext': 0,
	    // Live Region Attributes
	    'aria-atomic': 0,
	    'aria-busy': 0,
	    'aria-live': 0,
	    'aria-relevant': 0,
	    // Drag-and-Drop Attributes
	    'aria-dropeffect': 0,
	    'aria-grabbed': 0,
	    // Relationship Attributes
	    'aria-activedescendant': 0,
	    'aria-colcount': 0,
	    'aria-colindex': 0,
	    'aria-colspan': 0,
	    'aria-controls': 0,
	    'aria-describedby': 0,
	    'aria-errormessage': 0,
	    'aria-flowto': 0,
	    'aria-labelledby': 0,
	    'aria-owns': 0,
	    'aria-posinset': 0,
	    'aria-rowcount': 0,
	    'aria-rowindex': 0,
	    'aria-rowspan': 0,
	    'aria-setsize': 0
	  },
	  DOMAttributeNames: {},
	  DOMPropertyNames: {}
	};

	module.exports = ARIADOMPropertyConfig;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var EventPropagators = __webpack_require__(46);
	var ExecutionEnvironment = __webpack_require__(53);
	var FallbackCompositionState = __webpack_require__(54);
	var SyntheticCompositionEvent = __webpack_require__(57);
	var SyntheticInputEvent = __webpack_require__(59);

	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;

	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}

	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}

	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: 'onBeforeInput',
	      captured: 'onBeforeInputCapture'
	    },
	    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionEnd',
	      captured: 'onCompositionEndCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionStart',
	      captured: 'onCompositionStartCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionUpdate',
	      captured: 'onCompositionUpdateCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  }
	};

	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;

	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}

	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case 'topCompositionStart':
	      return eventTypes.compositionStart;
	    case 'topCompositionEnd':
	      return eventTypes.compositionEnd;
	    case 'topCompositionUpdate':
	      return eventTypes.compositionUpdate;
	  }
	}

	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
	}

	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topKeyUp':
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case 'topKeyDown':
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case 'topKeyPress':
	    case 'topMouseDown':
	    case 'topBlur':
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}

	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}

	// Track the current IME composition fallback object, if any.
	var currentComposition = null;

	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;

	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }

	  if (!eventType) {
	    return null;
	  }

	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }

	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }

	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}

	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topCompositionEnd':
	      return getDataFromCustomEvent(nativeEvent);
	    case 'topKeyPress':
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }

	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;

	    case 'topTextInput':
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;

	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }

	      return chars;

	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}

	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  // If composition event is available, we extract a string only at
	  // compositionevent, otherwise extract it at fallback events.
	  if (currentComposition) {
	    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }

	  switch (topLevelType) {
	    case 'topPaste':
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case 'topKeyPress':
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case 'topCompositionEnd':
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}

	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;

	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }

	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }

	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}

	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	  eventTypes: eventTypes,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};

	module.exports = BeforeInputEventPlugin;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var EventPluginHub = __webpack_require__(47);
	var EventPluginUtils = __webpack_require__(49);

	var accumulateInto = __webpack_require__(51);
	var forEachAccumulated = __webpack_require__(52);
	var warning = __webpack_require__(8);

	var getListener = EventPluginHub.getListener;

	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}

	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, phase, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}

	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}

	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}

	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}

	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}

	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}

	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}

	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}

	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}

	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};

	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var EventPluginRegistry = __webpack_require__(48);
	var EventPluginUtils = __webpack_require__(49);
	var ReactErrorUtils = __webpack_require__(50);

	var accumulateInto = __webpack_require__(51);
	var forEachAccumulated = __webpack_require__(52);
	var invariant = __webpack_require__(12);

	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};

	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;

	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);

	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};

	var getDictionaryKey = function (inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};

	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}

	function shouldPreventMouseEvent(name, type, props) {
	  switch (name) {
	    case 'onClick':
	    case 'onClickCapture':
	    case 'onDoubleClick':
	    case 'onDoubleClickCapture':
	    case 'onMouseDown':
	    case 'onMouseDownCapture':
	    case 'onMouseMove':
	    case 'onMouseMoveCapture':
	    case 'onMouseUp':
	    case 'onMouseUpCapture':
	      return !!(props.disabled && isInteractive(type));
	    default:
	      return false;
	  }
	}

	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	  },

	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function (inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;

	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;

	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },

	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (inst, registrationName) {
	    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
	    // live here; needs to be moved to a better place soon
	    var bankForRegistrationName = listenerBank[registrationName];
	    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
	      return null;
	    }
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },

	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }

	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },

	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function (inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }

	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }

	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }

	      delete listenerBank[registrationName][key];
	    }
	  },

	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },

	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },

	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },

	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },

	  __getListenerBank: function () {
	    return listenerBank;
	  }
	};

	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	/**
	 * Injectable ordering of event plugins.
	 */
	var eventPluginOrder = null;

	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};

	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!eventPluginOrder) {
	    // Wait until an `eventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var pluginModule = namesToPlugins[pluginName];
	    var pluginIndex = eventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
	    var publishedEvents = pluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}

	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
	    return true;
	  }
	  return false;
	}

	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, pluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}

	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],

	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},

	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},

	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},

	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	  // Trust the developer to only use possibleRegistrationNames in __DEV__

	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (injectedEventPluginOrder) {
	    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
	    recomputePluginOrdering();
	  },

	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var pluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = pluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },

	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    if (dispatchConfig.phasedRegistrationNames !== undefined) {
	      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
	      // that it is not undefined.
	      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

	      for (var phase in phasedRegistrationNames) {
	        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
	          continue;
	        }
	        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
	        if (pluginModule) {
	          return pluginModule;
	        }
	      }
	    }
	    return null;
	  },

	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    eventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;

	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }

	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	};

	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactErrorUtils = __webpack_require__(50);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	/**
	 * Injected dependencies:
	 */

	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function (Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function (Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};

	function isEndish(topLevelType) {
	  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
	}

	function isMoveish(topLevelType) {
	  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
	}
	function isStartish(topLevelType) {
	  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
	}

	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;

	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}

	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}

	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}

	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}

	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}

	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}

	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}

	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,

	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,

	  getInstanceFromNode: function (node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function (node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function (a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function (a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function (inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function (target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },

	  injection: injection
	};

	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var caughtError = null;

	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a) {
	  try {
	    func(a);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	  }
	}

	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,

	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};

	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
	      var boundFunc = function () {
	        func(a);
	      };
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}

	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */

	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;

	  if (current == null) {
	    return next;
	  }

	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }

	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }

	  return [current, next];
	}

	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 52 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */

	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}

	module.exports = forEachAccumulated;

/***/ }),
/* 53 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {

	  canUseDOM: canUseDOM,

	  canUseWorkers: typeof Worker !== 'undefined',

	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

	  canUseViewport: canUseDOM && !!window.screen,

	  isInWorker: !canUseDOM // For now, this is true - might change in the future.

	};

	module.exports = ExecutionEnvironment;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var PooledClass = __webpack_require__(55);

	var getTextContentAccessor = __webpack_require__(56);

	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}

	_assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },

	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },

	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }

	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;

	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }

	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }

	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});

	PooledClass.addPoolingTo(FallbackCompositionState);

	module.exports = FallbackCompositionState;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};

	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};

	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};

	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};

	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};

	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;

	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};

	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler
	};

	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);

	var contentKey = null;

	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}

	module.exports = getTextContentAccessor;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(58);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

	module.exports = SyntheticCompositionEvent;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var PooledClass = __webpack_require__(55);

	var emptyFunction = __webpack_require__(9);
	var warning = __webpack_require__(8);

	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';

	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};

	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }

	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;

	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }

	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}

	_assign(SyntheticEvent.prototype, {
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }

	    if (event.preventDefault) {
	      event.preventDefault();
	      // eslint-disable-next-line valid-typeof
	    } else if (typeof event.returnValue !== 'unknown') {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },

	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }

	    if (event.stopPropagation) {
	      event.stopPropagation();
	      // eslint-disable-next-line valid-typeof
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }

	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },

	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },

	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,

	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	});

	SyntheticEvent.Interface = EventInterface;

	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;

	  var E = function () {};
	  E.prototype = Super.prototype;
	  var prototype = new E();

	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;

	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;

	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};

	/** Proxying after everything set on SyntheticEvent
	  * to resolve Proxy issue on some WebKit browsers
	  * in which some Event properties are set to undefined (GH#10010)
	  */
	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function (target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function (constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function (target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}

	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

	module.exports = SyntheticEvent;

	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };

	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }

	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }

	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(58);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

	module.exports = SyntheticInputEvent;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var EventPluginHub = __webpack_require__(47);
	var EventPropagators = __webpack_require__(46);
	var ExecutionEnvironment = __webpack_require__(53);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactUpdates = __webpack_require__(61);
	var SyntheticEvent = __webpack_require__(58);

	var inputValueTracking = __webpack_require__(74);
	var getEventTarget = __webpack_require__(75);
	var isEventSupported = __webpack_require__(76);
	var isTextInputElement = __webpack_require__(77);

	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: 'onChange',
	      captured: 'onChangeCapture'
	    },
	    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
	  }
	};

	function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);
	  event.type = 'change';
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;

	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}

	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
	}

	function manualDispatchChangeEvent(nativeEvent) {
	  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}

	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}

	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}

	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}

	function getInstIfValueChanged(targetInst, nativeEvent) {
	  var updated = inputValueTracking.updateValueIfChanged(targetInst);
	  var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;

	  if (updated || simulated) {
	    return targetInst;
	  }
	}

	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topChange') {
	    return targetInst;
	  }
	}

	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForChangeEventIE8();
	  }
	}

	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.

	  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
	}

	/**
	 * (For IE <=9) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}

	/**
	 * (For IE <=9) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);

	  activeElement = null;
	  activeElementInst = null;
	}

	/**
	 * (For IE <=9) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  if (getInstIfValueChanged(activeElementInst, nativeEvent)) {
	    manualDispatchChangeEvent(nativeEvent);
	  }
	}

	function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForValueChange();
	  }
	}

	// For IE8 and IE9.
	function getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {
	  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    return getInstIfValueChanged(activeElementInst, nativeEvent);
	  }
	}

	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  var nodeName = elem.nodeName;
	  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}

	function getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {
	  if (topLevelType === 'topClick') {
	    return getInstIfValueChanged(targetInst, nativeEvent);
	  }
	}

	function getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {
	  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
	    return getInstIfValueChanged(targetInst, nativeEvent);
	  }
	}

	function handleControlledInputBlur(inst, node) {
	  // TODO: In IE, inst is occasionally null. Why?
	  if (inst == null) {
	    return;
	  }

	  // Fiber and ReactDOM keep wrapper state in separate places
	  var state = inst._wrapperState || node._wrapperState;

	  if (!state || !state.controlled || node.type !== 'number') {
	    return;
	  }

	  // If controlled, assign the value attribute to the current value on blur
	  var value = '' + node.value;
	  if (node.getAttribute('value') !== value) {
	    node.setAttribute('value', value);
	  }
	}

	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	  eventTypes: eventTypes,

	  _allowSimulatedPassThrough: true,
	  _isInputEventSupported: isInputEventSupported,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventPolyfill;
	        handleEventFunc = handleEventsForInputEventPolyfill;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }

	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);
	      if (inst) {
	        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
	        return event;
	      }
	    }

	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }

	    // When blurring, set the value attribute for number inputs
	    if (topLevelType === 'topBlur') {
	      handleControlledInputBlur(targetInst, targetNode);
	    }
	  }
	};

	module.exports = ChangeEventPlugin;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(55);
	var ReactFeatureFlags = __webpack_require__(63);
	var ReactReconciler = __webpack_require__(64);
	var Transaction = __webpack_require__(73);

	var invariant = __webpack_require__(12);

	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;

	var batchingStrategy = null;

	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}

	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};

	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};

	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}

	_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },

	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});

	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}

	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}

	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;

	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);

	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;

	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];

	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;

	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.type.isReactTopLevelWrapper) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }

	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

	    if (markerName) {
	      console.timeEnd(markerName);
	    }

	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}

	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }

	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};

	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();

	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)

	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }

	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}

	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  invariant(batchingStrategy.isBatchingUpdates, "ReactUpdates.asap: Can't enqueue an asap callback in a context where" + 'updates are not being batched.');
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}

	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },

	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};

	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,

	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};

	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var PooledClass = __webpack_require__(55);

	var invariant = __webpack_require__(12);

	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */

	var CallbackQueue = function () {
	  function CallbackQueue(arg) {
	    _classCallCheck(this, CallbackQueue);

	    this._callbacks = null;
	    this._contexts = null;
	    this._arg = arg;
	  }

	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */


	  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._callbacks.push(callback);
	    this._contexts = this._contexts || [];
	    this._contexts.push(context);
	  };

	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */


	  CallbackQueue.prototype.notifyAll = function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    var arg = this._arg;
	    if (callbacks && contexts) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i], arg);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  };

	  CallbackQueue.prototype.checkpoint = function checkpoint() {
	    return this._callbacks ? this._callbacks.length : 0;
	  };

	  CallbackQueue.prototype.rollback = function rollback(len) {
	    if (this._callbacks && this._contexts) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  };

	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */


	  CallbackQueue.prototype.reset = function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  };

	  /**
	   * `PooledClass` looks for this.
	   */


	  CallbackQueue.prototype.destructor = function destructor() {
	    this.reset();
	  };

	  return CallbackQueue;
	}();

	module.exports = PooledClass.addPoolingTo(CallbackQueue);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 63 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};

	module.exports = ReactFeatureFlags;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ReactRef = __webpack_require__(65);
	var ReactInstrumentation = __webpack_require__(67);

	var warning = __webpack_require__(8);

	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}

	var ReactReconciler = {
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID) // 0 in production and for roots
	  {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },

	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function (internalInstance) {
	    return internalInstance.getHostNode();
	  },

	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },

	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;

	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.

	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }

	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }

	    internalInstance.receiveComponent(nextElement, transaction, context);

	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },

	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	};

	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var ReactOwner = __webpack_require__(66);

	var ReactRef = {};

	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}

	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}

	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || typeof element !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};

	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.

	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.

	  var prevRef = null;
	  var prevOwner = null;
	  if (prevElement !== null && typeof prevElement === 'object') {
	    prevRef = prevElement.ref;
	    prevOwner = prevElement._owner;
	  }

	  var nextRef = null;
	  var nextOwner = null;
	  if (nextElement !== null && typeof nextElement === 'object') {
	    nextRef = nextElement.ref;
	    nextOwner = nextElement._owner;
	  }

	  return prevRef !== nextRef ||
	  // If owner changes but we have an unchanged function ref, don't update refs
	  typeof nextRef === 'string' && nextOwner !== prevOwner;
	};

	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || typeof element !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};

	module.exports = ReactRef;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid owner.
	 * @final
	 */
	function isValidOwner(object) {
	  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	}

	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },

	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	};

	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2016-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	// Trust the developer to only use ReactInstrumentation with a __DEV__ check

	var debugTool = null;

	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(68);
	  debugTool = ReactDebugTool;
	}

	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2016-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var ReactInvalidSetStateWarningHook = __webpack_require__(69);
	var ReactHostOperationHistoryHook = __webpack_require__(70);
	var ReactComponentTreeHook = __webpack_require__(24);
	var ExecutionEnvironment = __webpack_require__(53);

	var performanceNow = __webpack_require__(71);
	var warning = __webpack_require__(8);

	var hooks = [];
	var didHookThrowForEvent = {};

	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}

	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}

	var isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = [];
	var currentFlushStartTime = 0;
	var currentTimerDebugID = null;
	var currentTimerStartTime = 0;
	var currentTimerNestedFlushDuration = 0;
	var currentTimerType = null;

	var lifeCycleTimerHasWarned = false;

	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}

	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}

	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements;
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();

	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = 0;
	    currentFlushMeasurements = [];
	    clearHistory();
	    return;
	  }

	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }

	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}

	function checkDebugID(debugID) {
	  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}

	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}

	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}

	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}

	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
	      startTime = _lifeCycleTimerStack$.startTime,
	      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
	      debugID = _lifeCycleTimerStack$.debugID,
	      timerType = _lifeCycleTimerStack$.timerType;

	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}

	var lastMarkTimeStamp = 0;
	var canUsePerformanceMeasure = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

	function shouldMark(debugID) {
	  if (!isProfiling || !canUsePerformanceMeasure) {
	    return false;
	  }
	  var element = ReactComponentTreeHook.getElement(debugID);
	  if (element == null || typeof element !== 'object') {
	    return false;
	  }
	  var isHostElement = typeof element.type === 'string';
	  if (isHostElement) {
	    return false;
	  }
	  return true;
	}

	function markBegin(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }

	  var markName = debugID + '::' + markType;
	  lastMarkTimeStamp = performanceNow();
	  performance.mark(markName);
	}

	function markEnd(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }

	  var markName = debugID + '::' + markType;
	  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';

	  // Chrome has an issue of dropping markers recorded too fast:
	  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
	  // To work around this, we will not report very small measurements.
	  // I determined the magic number by tweaking it back and forth.
	  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
	  // When the bug is fixed, we can `measure()` unconditionally if we want to.
	  var timeStamp = performanceNow();
	  if (timeStamp - lastMarkTimeStamp > 0.1) {
	    var measurementName = displayName + ' [' + markType + ']';
	    performance.measure(measurementName, markName);
	  }

	  performance.clearMarks(markName);
	  if (measurementName) {
	    performance.clearMeasures(measurementName);
	  }
	}

	var ReactDebugTool = {
	  addHook: function (hook) {
	    hooks.push(hook);
	  },
	  removeHook: function (hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function () {
	    return isProfiling;
	  },
	  beginProfiling: function () {
	    if (isProfiling) {
	      return;
	    }

	    isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function () {
	    if (!isProfiling) {
	      return;
	    }

	    isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function () {
	    return flushHistory;
	  },
	  onBeginFlush: function () {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function () {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    markBegin(debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    markEnd(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onBeginProcessingChildContext: function () {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function () {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function (operation) {
	    checkDebugID(operation.instanceID);
	    emitEvent('onHostOperation', operation);
	  },
	  onSetState: function () {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function (debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function (debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	    markBegin(debugID, 'mount');
	  },
	  onMountComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'mount');
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	    markBegin(debugID, 'update');
	  },
	  onUpdateComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'update');
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	    markBegin(debugID, 'unmount');
	  },
	  onUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'unmount');
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function () {
	    emitEvent('onTestEvent');
	  }
	};

	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}

	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2016-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var warning = __webpack_require__(8);

	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;

	  var warnInvalidSetState = function () {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}

	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function () {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function () {
	    processingChildContext = false;
	  },
	  onSetState: function () {
	    warnInvalidSetState();
	  }
	};

	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 70 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2016-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var history = [];

	var ReactHostOperationHistoryHook = {
	  onHostOperation: function (operation) {
	    history.push(operation);
	  },
	  clearHistory: function () {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }

	    history = [];
	  },
	  getHistory: function () {
	    return history;
	  }
	};

	module.exports = ReactHostOperationHistoryHook;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	var performance = __webpack_require__(72);

	var performanceNow;

	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}

	module.exports = performanceNow;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);

	var performance;

	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}

	module.exports = performance || {};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	var OBSERVED_ERROR = {};

	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var TransactionImpl = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },

	  _isInTransaction: false,

	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,

	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },

	  /* eslint-disable space-before-function-paren */

	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    /* eslint-enable space-before-function-paren */
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },

	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },

	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};

	module.exports = TransactionImpl;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ReactDOMComponentTree = __webpack_require__(39);

	function isCheckable(elem) {
	  var type = elem.type;
	  var nodeName = elem.nodeName;
	  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
	}

	function getTracker(inst) {
	  return inst._wrapperState.valueTracker;
	}

	function attachTracker(inst, tracker) {
	  inst._wrapperState.valueTracker = tracker;
	}

	function detachTracker(inst) {
	  inst._wrapperState.valueTracker = null;
	}

	function getValueFromNode(node) {
	  var value;
	  if (node) {
	    value = isCheckable(node) ? '' + node.checked : node.value;
	  }
	  return value;
	}

	var inputValueTracking = {
	  // exposed for testing
	  _getTrackerFromNode: function (node) {
	    return getTracker(ReactDOMComponentTree.getInstanceFromNode(node));
	  },


	  track: function (inst) {
	    if (getTracker(inst)) {
	      return;
	    }

	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var valueField = isCheckable(node) ? 'checked' : 'value';
	    var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

	    var currentValue = '' + node[valueField];

	    // if someone has already defined a value or Safari, then bail
	    // and don't track value will cause over reporting of changes,
	    // but it's better then a hard failure
	    // (needed for certain tests that spyOn input values and Safari)
	    if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
	      return;
	    }

	    Object.defineProperty(node, valueField, {
	      enumerable: descriptor.enumerable,
	      configurable: true,
	      get: function () {
	        return descriptor.get.call(this);
	      },
	      set: function (value) {
	        currentValue = '' + value;
	        descriptor.set.call(this, value);
	      }
	    });

	    attachTracker(inst, {
	      getValue: function () {
	        return currentValue;
	      },
	      setValue: function (value) {
	        currentValue = '' + value;
	      },
	      stopTracking: function () {
	        detachTracker(inst);
	        delete node[valueField];
	      }
	    });
	  },

	  updateValueIfChanged: function (inst) {
	    if (!inst) {
	      return false;
	    }
	    var tracker = getTracker(inst);

	    if (!tracker) {
	      inputValueTracking.track(inst);
	      return true;
	    }

	    var lastValue = tracker.getValue();
	    var nextValue = getValueFromNode(ReactDOMComponentTree.getNodeFromInstance(inst));

	    if (nextValue !== lastValue) {
	      tracker.setValue(nextValue);
	      return true;
	    }

	    return false;
	  },
	  stopTracking: function (inst) {
	    var tracker = getTracker(inst);
	    if (tracker) {
	      tracker.stopTracking();
	    }
	  }
	};

	module.exports = inputValueTracking;

/***/ }),
/* 75 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */

	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;

	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }

	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}

	module.exports = getEventTarget;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);

	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}

	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }

	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;

	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }

	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }

	  return isSupported;
	}

	module.exports = isEventSupported;

/***/ }),
/* 77 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */

	var supportedInputTypes = {
	  color: true,
	  date: true,
	  datetime: true,
	  'datetime-local': true,
	  email: true,
	  month: true,
	  number: true,
	  password: true,
	  range: true,
	  search: true,
	  tel: true,
	  text: true,
	  time: true,
	  url: true,
	  week: true
	};

	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }

	  if (nodeName === 'textarea') {
	    return true;
	  }

	  return false;
	}

	module.exports = isTextInputElement;

/***/ }),
/* 78 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */

	var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

	module.exports = DefaultEventPluginOrder;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var EventPropagators = __webpack_require__(46);
	var ReactDOMComponentTree = __webpack_require__(39);
	var SyntheticMouseEvent = __webpack_require__(80);

	var eventTypes = {
	  mouseEnter: {
	    registrationName: 'onMouseEnter',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  },
	  mouseLeave: {
	    registrationName: 'onMouseLeave',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  }
	};

	var EnterLeaveEventPlugin = {
	  eventTypes: eventTypes,

	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }

	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }

	    var from;
	    var to;
	    if (topLevelType === 'topMouseOut') {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }

	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }

	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;

	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;

	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

	    return [leave, enter];
	  }
	};

	module.exports = EnterLeaveEventPlugin;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(81);
	var ViewportMetrics = __webpack_require__(82);

	var getEventModifierState = __webpack_require__(83);

	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

	module.exports = SyntheticMouseEvent;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(58);

	var getEventTarget = __webpack_require__(75);

	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }

	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }

	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

	module.exports = SyntheticUIEvent;

/***/ }),
/* 82 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ViewportMetrics = {
	  currentScrollLeft: 0,

	  currentScrollTop: 0,

	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	};

	module.exports = ViewportMetrics;

/***/ }),
/* 83 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */

	var modifierKeyToProp = {
	  Alt: 'altKey',
	  Control: 'ctrlKey',
	  Meta: 'metaKey',
	  Shift: 'shiftKey'
	};

	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}

	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}

	module.exports = getEventModifierState;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(41);

	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    // specifies target context for links with `preload` type
	    as: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    controlsList: 0,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    playsInline: HAS_BOOLEAN_VALUE,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,

	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,

	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {},
	  DOMMutationMethods: {
	    value: function (node, value) {
	      if (value == null) {
	        return node.removeAttribute('value');
	      }

	      // Number inputs get special treatment due to some edge cases in
	      // Chrome. Let everything else assign the value attribute as normal.
	      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
	      if (node.type !== 'number' || node.hasAttribute('value') === false) {
	        node.setAttribute('value', '' + value);
	      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
	        // Don't assign an attribute if validation reports bad
	        // input. Chrome will clear the value. Additionally, don't
	        // operate on inputs that have focus, otherwise Chrome might
	        // strip off trailing decimal places and cause the user's
	        // cursor position to jump to the beginning of the input.
	        //
	        // In ReactDOMInput, we have an onBlur event that will trigger
	        // this function again when focus is lost.
	        node.setAttribute('value', '' + value);
	      }
	    }
	  }
	};

	module.exports = HTMLDOMPropertyConfig;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var DOMChildrenOperations = __webpack_require__(86);
	var ReactDOMIDOperations = __webpack_require__(97);

	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	};

	module.exports = ReactComponentBrowserEnvironment;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var DOMLazyTree = __webpack_require__(87);
	var Danger = __webpack_require__(93);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactInstrumentation = __webpack_require__(67);

	var createMicrosoftUnsafeLocalFunction = __webpack_require__(90);
	var setInnerHTML = __webpack_require__(89);
	var setTextContent = __webpack_require__(91);

	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}

	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});

	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}

	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}

	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}

	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}

	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}

	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }

	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation({
	      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
	      type: 'replace text',
	      payload: stringText
	    });
	  }
	}

	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: prevInstance._debugID,
	        type: 'replace with',
	        payload: markup.toString()
	      });
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: nextInstance._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  };
	}

	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

	  replaceDelimitedText: replaceDelimitedText,

	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function (parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }

	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case 'INSERT_MARKUP':
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'insert child',
	              payload: {
	                toIndex: update.toIndex,
	                content: update.content.toString()
	              }
	            });
	          }
	          break;
	        case 'MOVE_EXISTING':
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'move child',
	              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
	            });
	          }
	          break;
	        case 'SET_MARKUP':
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace children',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'TEXT_CONTENT':
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace text',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'REMOVE_NODE':
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'remove child',
	              payload: { fromIndex: update.fromIndex }
	            });
	          }
	          break;
	      }
	    }
	  }
	};

	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var DOMNamespaces = __webpack_require__(88);
	var setInnerHTML = __webpack_require__(89);

	var createMicrosoftUnsafeLocalFunction = __webpack_require__(90);
	var setTextContent = __webpack_require__(91);

	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}

	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});

	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}

	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}

	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}

	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}

	function toString() {
	  return this.node.nodeName;
	}

	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}

	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;

	module.exports = DOMLazyTree;

/***/ }),
/* 88 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};

	module.exports = DOMNamespaces;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);
	var DOMNamespaces = __webpack_require__(88);

	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

	var createMicrosoftUnsafeLocalFunction = __webpack_require__(90);

	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;

	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var svgNode = reusableSVGContainer.firstChild;
	    while (svgNode.firstChild) {
	      node.appendChild(svgNode.firstChild);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});

	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }

	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xfeff) + html;

	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}

	module.exports = setInnerHTML;

/***/ }),
/* 90 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	/* globals MSApp */

	'use strict';

	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */

	var createMicrosoftUnsafeLocalFunction = function (func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};

	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);
	var escapeTextContentForBrowser = __webpack_require__(92);
	var setInnerHTML = __webpack_require__(89);

	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  if (text) {
	    var firstChild = node.firstChild;

	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};

	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      if (node.nodeType === 3) {
	        node.nodeValue = text;
	        return;
	      }
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}

	module.exports = setTextContent;

/***/ }),
/* 92 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2016-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */

	'use strict';

	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */

	var matchHtmlRegExp = /["'&<>]/;

	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */

	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);

	  if (!match) {
	    return str;
	  }

	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;

	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }

	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }

	    lastIndex = index + 1;
	    html += escape;
	  }

	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html

	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}

	module.exports = escapeTextContentForBrowser;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var DOMLazyTree = __webpack_require__(87);
	var ExecutionEnvironment = __webpack_require__(53);

	var createNodesFromMarkup = __webpack_require__(94);
	var emptyFunction = __webpack_require__(9);
	var invariant = __webpack_require__(12);

	var Danger = {
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	};

	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	/*eslint-disable fb-www/unsafe-html*/

	var ExecutionEnvironment = __webpack_require__(53);

	var createArrayFromMixed = __webpack_require__(95);
	var getMarkupWrap = __webpack_require__(96);
	var invariant = __webpack_require__(12);

	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;

	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}

	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);

	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];

	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }

	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }

	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}

	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	var invariant = __webpack_require__(12);

	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;

	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }

	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}

	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}

	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}

	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	/*eslint-disable fb-www/unsafe-html */

	var ExecutionEnvironment = __webpack_require__(53);

	var invariant = __webpack_require__(12);

	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */

	var shouldWrap = {};

	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],

	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],

	  'optgroup': selectWrap,
	  'option': selectWrap,

	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,

	  'td': trWrap,
	  'th': trWrap
	};

	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});

	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}

	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var DOMChildrenOperations = __webpack_require__(86);
	var ReactDOMComponentTree = __webpack_require__(39);

	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};

	module.exports = ReactDOMIDOperations;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	/* global hasOwnProperty:true */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var AutoFocusUtils = __webpack_require__(99);
	var CSSPropertyOperations = __webpack_require__(101);
	var DOMLazyTree = __webpack_require__(87);
	var DOMNamespaces = __webpack_require__(88);
	var DOMProperty = __webpack_require__(41);
	var DOMPropertyOperations = __webpack_require__(109);
	var EventPluginHub = __webpack_require__(47);
	var EventPluginRegistry = __webpack_require__(48);
	var ReactBrowserEventEmitter = __webpack_require__(111);
	var ReactDOMComponentFlags = __webpack_require__(42);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactDOMInput = __webpack_require__(114);
	var ReactDOMOption = __webpack_require__(117);
	var ReactDOMSelect = __webpack_require__(118);
	var ReactDOMTextarea = __webpack_require__(119);
	var ReactInstrumentation = __webpack_require__(67);
	var ReactMultiChild = __webpack_require__(120);
	var ReactServerRenderingTransaction = __webpack_require__(139);

	var emptyFunction = __webpack_require__(9);
	var escapeTextContentForBrowser = __webpack_require__(92);
	var invariant = __webpack_require__(12);
	var isEventSupported = __webpack_require__(76);
	var shallowEqual = __webpack_require__(129);
	var inputValueTracking = __webpack_require__(74);
	var validateDOMNesting = __webpack_require__(142);
	var warning = __webpack_require__(8);

	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;

	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { string: true, number: true };

	var STYLE = 'style';
	var HTML = '__html';
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};

	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;

	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}

	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}

	var styleMutationWarning = {};

	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }

	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }

	  var hash = ownerName + '|' + componentName;

	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }

	  styleMutationWarning[hash] = true;

	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}

	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}

	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), "This browser doesn't support the `onScroll` event") : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}

	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}

	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}

	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}

	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}

	var setAndValidateContentChildDev = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setAndValidateContentChildDev = function (content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;

	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }

	    validateDOMNesting(null, String(content), this, this._ancestorInfo);
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}

	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};

	function trackInputValue() {
	  inputValueTracking.track(this);
	}

	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
	      break;
	  }
	}

	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}

	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.

	var omittedCloseTags = {
	  area: true,
	  base: true,
	  br: true,
	  col: true,
	  embed: true,
	  hr: true,
	  img: true,
	  input: true,
	  keygen: true,
	  link: true,
	  meta: true,
	  param: true,
	  source: true,
	  track: true,
	  wbr: true
	  // NOTE: menuitem's close tag should be omitted, but that causes problems.
	};

	var newlineEatingTags = {
	  listing: true,
	  pre: true,
	  textarea: true
	};

	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.

	var voidElementTags = _assign({
	  menuitem: true
	}, omittedCloseTags);

	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name

	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;

	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}

	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}

	var globalIdCounter = 1;

	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setAndValidateContentChildDev.call(this, null);
	  }
	}

	ReactDOMComponent.displayName = 'ReactDOMComponent';

	ReactDOMComponent.Mixin = {
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;

	    var props = this._currentElement.props;

	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trackInputValue, this);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trackInputValue, this);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }

	    assertValidProps(this, props);

	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;

	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, null, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }

	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }

	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }

	    return mountImage;
	  },

	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;

	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }

	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }

	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },

	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';

	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },

	  _createInitialChildren: function (transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      // TODO: Validate that text is allowed as a child of this node
	      if (contentToUse != null) {
	        // Avoid setting textContent when the text is empty. In IE11 setting
	        // textContent on a text area will cause the placeholder to not
	        // show within the textarea until it has been focused and blurred again.
	        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
	        if (contentToUse !== '') {
	          if (process.env.NODE_ENV !== 'production') {
	            setAndValidateContentChildDev.call(this, contentToUse);
	          }
	          DOMLazyTree.queueText(lazyTree, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },

	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },

	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;

	    switch (this._tag) {
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }

	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);

	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);

	        // We also check that we haven't missed a value update, such as a
	        // Radio group shifting the checked value to another named radio input.
	        inputValueTracking.updateValueIfChanged(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },

	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },

	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;

	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }

	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setAndValidateContentChildDev.call(this, null);
	      }

	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },

	  getHostNode: function () {
	    return getNode(this);
	  },

	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	      case 'textarea':
	        inputValueTracking.stopTracking(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }

	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;

	    if (process.env.NODE_ENV !== 'production') {
	      setAndValidateContentChildDev.call(this, null);
	    }
	  },

	  getPublicInstance: function () {
	    return getNode(this);
	  }
	};

	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ReactDOMComponentTree = __webpack_require__(39);

	var focusNode = __webpack_require__(100);

	var AutoFocusUtils = {
	  focusDOMComponent: function () {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};

	module.exports = AutoFocusUtils;

/***/ }),
/* 100 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * @param {DOMElement} node input/textarea to focus
	 */

	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}

	module.exports = focusNode;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var CSSProperty = __webpack_require__(102);
	var ExecutionEnvironment = __webpack_require__(53);
	var ReactInstrumentation = __webpack_require__(67);

	var camelizeStyleName = __webpack_require__(103);
	var dangerousStyleValue = __webpack_require__(105);
	var hyphenateStyleName = __webpack_require__(106);
	var memoizeStringOnly = __webpack_require__(108);
	var warning = __webpack_require__(8);

	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});

	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}

	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;

	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;

	  var warnHyphenatedStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }

	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };

	  var warnBadVendoredStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }

	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };

	  var warnStyleValueWithSemicolon = function (name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }

	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, "Style property values shouldn't contain a semicolon.%s " + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };

	  var warnStyleValueIsNaN = function (name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }

	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };

	  var checkRenderMessage = function (owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };

	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function (name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }

	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}

	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var isCustomProperty = styleName.indexOf('--') === 0;
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        if (!isCustomProperty) {
	          warnValidStyle(styleName, styleValue, component);
	        }
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component, isCustomProperty) + ';';
	      }
	    }
	    return serialized || null;
	  },

	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function (node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: component._debugID,
	        type: 'update styles',
	        payload: styles
	      });
	    }

	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var isCustomProperty = styleName.indexOf('--') === 0;
	      if (process.env.NODE_ENV !== 'production') {
	        if (!isCustomProperty) {
	          warnValidStyle(styleName, styles[styleName], component);
	        }
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component, isCustomProperty);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (isCustomProperty) {
	        style.setProperty(styleName, styleValue);
	      } else if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	};

	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 102 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */

	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  columns: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridRowEnd: true,
	  gridRowSpan: true,
	  gridRowStart: true,
	  gridColumn: true,
	  gridColumnEnd: true,
	  gridColumnSpan: true,
	  gridColumnStart: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,

	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};

	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}

	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});

	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};

	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};

	module.exports = CSSProperty;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	'use strict';

	var camelize = __webpack_require__(104);

	var msPattern = /^-ms-/;

	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}

	module.exports = camelizeStyleName;

/***/ }),
/* 104 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	var _hyphenPattern = /-(.)/g;

	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}

	module.exports = camelize;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var CSSProperty = __webpack_require__(102);
	var warning = __webpack_require__(8);

	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};

	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component, isCustomProperty) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901

	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }

	  var isNonNumeric = isNaN(value);
	  if (isCustomProperty || isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }

	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}

	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	'use strict';

	var hyphenate = __webpack_require__(107);

	var msPattern = /^ms-/;

	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}

	module.exports = hyphenateStyleName;

/***/ }),
/* 107 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	var _uppercasePattern = /([A-Z])/g;

	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}

	module.exports = hyphenate;

/***/ }),
/* 108 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */

	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}

	module.exports = memoizeStringOnly;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(41);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactInstrumentation = __webpack_require__(67);

	var quoteAttributeValueForBrowser = __webpack_require__(110);
	var warning = __webpack_require__(8);

	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};

	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}

	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}

	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },

	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },

	  createMarkupForRoot: function () {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },

	  setAttributeForRoot: function (node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },

	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },

	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },

	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },

	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },

	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function (node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  },

	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  }
	};

	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var escapeTextContentForBrowser = __webpack_require__(92);

	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}

	module.exports = quoteAttributeValueForBrowser;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var EventPluginRegistry = __webpack_require__(48);
	var ReactEventEmitterMixin = __webpack_require__(112);
	var ViewportMetrics = __webpack_require__(82);

	var getVendorPrefixedEventName = __webpack_require__(113);
	var isEventSupported = __webpack_require__(76);

	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */

	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;

	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};

	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}

	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,

	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },

	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },

	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },

	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === 'topWheel') {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === 'topScroll') {
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === 'topFocus' || dependency === 'topBlur') {
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
	          }

	          // to make sure blur and focus event listeners are only attached once
	          isListening.topBlur = true;
	          isListening.topFocus = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }

	        isListening[dependency] = true;
	      }
	    }
	  },

	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },

	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },

	  /**
	   * Protect against document.createEvent() returning null
	   * Some popup blocker extensions appear to do this:
	   * https://github.com/facebook/react/issues/6887
	   */
	  supportsEventPageXY: function () {
	    if (!document.createEvent) {
	      return false;
	    }
	    var ev = document.createEvent('MouseEvent');
	    return ev != null && 'pageX' in ev;
	  },

	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	});

	module.exports = ReactBrowserEventEmitter;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var EventPluginHub = __webpack_require__(47);

	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}

	var ReactEventEmitterMixin = {
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};

	module.exports = ReactEventEmitterMixin;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);

	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};

	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

	  return prefixes;
	}

	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};

	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};

	/**
	 * Element to check for prefixes on.
	 */
	var style = {};

	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;

	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }

	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}

	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }

	  var prefixMap = vendorPrefixes[eventName];

	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }

	  return '';
	}

	module.exports = getVendorPrefixedEventName;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var DOMPropertyOperations = __webpack_require__(109);
	var LinkedValueUtils = __webpack_require__(115);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactUpdates = __webpack_require__(61);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;

	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}

	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked != null : props.value != null;
	}

	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function (inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);

	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });

	    return hostProps;
	  },

	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

	      var owner = inst._currentElement._owner;

	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }

	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      controlled: isControlled(props)
	    };
	  },

	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;

	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }

	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }

	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      if (value === 0 && node.value === '') {
	        node.value = '0';
	        // Note: IE9 reports a number inputs as 'text', so check props instead.
	      } else if (props.type === 'number') {
	        // Simulate `input.valueAsNumber`. IE9 does not support it
	        var valueAsNumber = parseFloat(node.value, 10) || 0;

	        if (
	        // eslint-disable-next-line
	        value != valueAsNumber ||
	        // eslint-disable-next-line
	        value == valueAsNumber && node.value != value) {
	          // Cast `value` to a string to ensure the value is set correctly. While
	          // browsers typically do this as necessary, jsdom doesn't.
	          node.value = '' + value;
	        }
	      } else if (node.value !== '' + value) {
	        // Cast `value` to a string to ensure the value is set correctly. While
	        // browsers typically do this as necessary, jsdom doesn't.
	        node.value = '' + value;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        // In Chrome, assigning defaultValue to certain input types triggers input validation.
	        // For number inputs, the display value loses trailing decimal points. For email inputs,
	        // Chrome raises "The specified value <x> is not a valid email address".
	        //
	        // Here we check to see if the defaultValue has actually changed, avoiding these problems
	        // when the user is inputting text
	        //
	        // https://github.com/facebook/react/issues/7253
	        if (node.defaultValue !== '' + props.defaultValue) {
	          node.defaultValue = '' + props.defaultValue;
	        }
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },

	  postMountWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.

	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }

	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;

	  var returnValue = LinkedValueUtils.executeOnChange(props, event);

	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);

	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;

	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }

	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }

	  return returnValue;
	}

	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactPropTypesSecret = __webpack_require__(116);
	var propTypesFactory = __webpack_require__(29);

	var React = __webpack_require__(2);
	var PropTypes = propTypesFactory(React.isValidElement);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	var hasReadOnlyValue = {
	  button: true,
	  checkbox: true,
	  image: true,
	  hidden: true,
	  radio: true,
	  reset: true,
	  submit: true
	};

	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}

	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}

	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: PropTypes.func
	};

	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};

	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 116 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var React = __webpack_require__(2);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactDOMSelect = __webpack_require__(118);

	var warning = __webpack_require__(8);
	var didWarnInvalidOptionChildren = false;

	function flattenChildren(children) {
	  var content = '';

	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  React.Children.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });

	  return content;
	}

	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }

	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;

	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }

	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }

	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }

	    inst._wrapperState = { selected: selected };
	  },

	  postMountWrapper: function (inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },

	  getHostProps: function (inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);

	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }

	    var content = flattenChildren(props.children);

	    if (content) {
	      hostProps.children = content;
	    }

	    return hostProps;
	  }
	};

	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var LinkedValueUtils = __webpack_require__(115);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactUpdates = __webpack_require__(61);

	var warning = __webpack_require__(8);

	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;

	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;

	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);

	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}

	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	var valuePropNames = ['value', 'defaultValue'];

	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);

	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }

	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}

	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}

	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function (inst, props) {
	    return _assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },

	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }

	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };

	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },

	  getSelectValueContext: function (inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },

	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;

	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);

	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);

	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}

	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var LinkedValueUtils = __webpack_require__(115);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactUpdates = __webpack_require__(61);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;

	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}

	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function (inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;

	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, props, {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });

	    return hostProps;
	  },

	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }

	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;

	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }

	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }

	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },

	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;

	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },

	  postMountWrapper: function (inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var textContent = node.textContent;

	    // Only set node.value if textContent is equal to the expected
	    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
	    // will populate textContent as well.
	    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
	    if (textContent === inst._wrapperState.initialValue) {
	      node.value = textContent;
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}

	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactComponentEnvironment = __webpack_require__(121);
	var ReactInstanceMap = __webpack_require__(122);
	var ReactInstrumentation = __webpack_require__(67);

	var ReactCurrentOwner = __webpack_require__(17);
	var ReactReconciler = __webpack_require__(64);
	var ReactChildReconciler = __webpack_require__(123);

	var emptyFunction = __webpack_require__(9);
	var flattenChildren = __webpack_require__(138);
	var invariant = __webpack_require__(12);

	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'INSERT_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}

	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'MOVE_EXISTING',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}

	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'REMOVE_NODE',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}

	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'SET_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}

	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'TEXT_CONTENT',
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}

	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}

	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}

	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function (inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function (children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}

	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },

	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },

	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;

	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }

	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }

	      return mountImages;
	    },

	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },

	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },

	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },

	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;

	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },

	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function (safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },

	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },

	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },

	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child, node) {
	      return makeRemove(child, node);
	    },

	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },

	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	  }
	};

	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	var injected = false;

	var ReactComponentEnvironment = {
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,

	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,

	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	};

	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 122 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */

	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

	var ReactInstanceMap = {
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },

	  get: function (key) {
	    return key._reactInternalInstance;
	  },

	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },

	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	};

	module.exports = ReactInstanceMap;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ReactReconciler = __webpack_require__(64);

	var instantiateReactComponent = __webpack_require__(124);
	var KeyEscapeUtils = __webpack_require__(134);
	var shouldUpdateReactComponent = __webpack_require__(130);
	var traverseAllChildren = __webpack_require__(135);
	var warning = __webpack_require__(8);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(24);
	}

	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(24);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}

	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID) // 0 in production and for roots
	  {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};

	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },

	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) // 0 in production and for roots
	  {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },

	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	};

	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var ReactCompositeComponent = __webpack_require__(125);
	var ReactEmptyComponent = __webpack_require__(131);
	var ReactHostComponent = __webpack_require__(132);

	var getNextDebugID = __webpack_require__(133);
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function (element) {
	  this.construct(element);
	};

	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}

	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;

	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    var type = element.type;
	    if (typeof type !== 'function' && typeof type !== 'string') {
	      var info = '';
	      if (process.env.NODE_ENV !== 'production') {
	        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
	          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
	        }
	      }
	      info += getDeclarationErrorAddendum(element._owner);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
	    }

	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);

	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
	  }

	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }

	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;

	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
	  }

	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }

	  return instance;
	}

	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
	  _instantiateReactComponent: instantiateReactComponent
	});

	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var React = __webpack_require__(2);
	var ReactComponentEnvironment = __webpack_require__(121);
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactErrorUtils = __webpack_require__(50);
	var ReactInstanceMap = __webpack_require__(122);
	var ReactInstrumentation = __webpack_require__(67);
	var ReactNodeTypes = __webpack_require__(126);
	var ReactReconciler = __webpack_require__(64);

	if (process.env.NODE_ENV !== 'production') {
	  var checkReactTypeSpec = __webpack_require__(127);
	}

	var emptyObject = __webpack_require__(11);
	var invariant = __webpack_require__(12);
	var shallowEqual = __webpack_require__(129);
	var shouldUpdateReactComponent = __webpack_require__(130);
	var warning = __webpack_require__(8);

	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};

	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};

	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}

	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}

	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}

	// Separated into a function to contain deoptimizations caused by try/finally.
	function measureLifeCyclePerf(fn, debugID, timerType) {
	  if (debugID === 0) {
	    // Top-level wrappers (see ReactMount) and empty components (see
	    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
	    // Both are implementation details that should go away in the future.
	    return fn();
	  }

	  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
	  try {
	    return fn();
	  } finally {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
	  }
	}

	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */

	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;

	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponent = {
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;

	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;

	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;

	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;

	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;

	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },

	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var _this = this;

	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;

	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);

	    var Component = this._currentElement.type;

	    var updateQueue = transaction.getUpdateQueue();

	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;

	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }

	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';

	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", componentName, componentName) : void 0;
	    }

	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;

	    this._instance = inst;

	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);

	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }

	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;

	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;

	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }

	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(function () {
	            return inst.componentDidMount();
	          }, _this._debugID, 'componentDidMount');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }

	    return markup;
	  },

	  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production' && !doConstruct) {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },

	  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;

	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        return measureLifeCyclePerf(function () {
	          return new Component(publicProps, publicContext, updateQueue);
	        }, this._debugID, 'ctor');
	      } else {
	        return new Component(publicProps, publicContext, updateQueue);
	      }
	    }

	    // This can still be an instance in case of factory components
	    // but we'll count this as time spent rendering as the more common case.
	    if (process.env.NODE_ENV !== 'production') {
	      return measureLifeCyclePerf(function () {
	        return Component(publicProps, publicContext, updateQueue);
	      }, this._debugID, 'render');
	    } else {
	      return Component(publicProps, publicContext, updateQueue);
	    }
	  },

	  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();

	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);

	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },

	  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;

	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }

	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillMount();
	        }, debugID, 'componentWillMount');
	      } else {
	        inst.componentWillMount();
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }

	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }

	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;

	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

	    if (process.env.NODE_ENV !== 'production') {
	      if (debugID !== 0) {
	        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	      }
	    }

	    return markup;
	  },

	  getHostNode: function () {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },

	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    if (!this._renderedComponent) {
	      return;
	    }

	    var inst = this._instance;

	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;

	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          measureLifeCyclePerf(function () {
	            return inst.componentWillUnmount();
	          }, this._debugID, 'componentWillUnmount');
	        } else {
	          inst.componentWillUnmount();
	        }
	      }
	    }

	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }

	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;

	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;

	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);

	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },

	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },

	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
	      }
	    }
	    return maskedContext;
	  },

	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext;

	    if (inst.getChildContext) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	        try {
	          childContext = inst.getChildContext();
	        } finally {
	          ReactInstrumentation.debugTool.onEndProcessingChildContext();
	        }
	      } else {
	        childContext = inst.getChildContext();
	      }
	    }

	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, 'child context');
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },

	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function (typeSpecs, values, location) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	    }
	  },

	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;

	    this._pendingElement = null;

	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },

	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },

	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;

	    var willReceive = false;
	    var nextContext;

	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }

	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;

	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }

	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillReceiveProps(nextProps, nextContext);
	        }, this._debugID, 'componentWillReceiveProps');
	      } else {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }

	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;

	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          shouldUpdate = measureLifeCyclePerf(function () {
	            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	          }, this._debugID, 'shouldComponentUpdate');
	        } else {
	          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }

	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },

	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;

	    if (!queue) {
	      return inst.state;
	    }

	    if (replace && queue.length === 1) {
	      return queue[0];
	    }

	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }

	    return nextState;
	  },

	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var _this2 = this;

	    var inst = this._instance;

	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }

	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillUpdate(nextProps, nextState, nextContext);
	        }, this._debugID, 'componentWillUpdate');
	      } else {
	        inst.componentWillUpdate(nextProps, nextState, nextContext);
	      }
	    }

	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;

	    this._updateRenderedComponent(transaction, unmaskedContext);

	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },

	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();

	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }

	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);

	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;

	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

	      if (process.env.NODE_ENV !== 'production') {
	        if (debugID !== 0) {
	          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	        }
	      }

	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },

	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },

	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	    var renderedElement;

	    if (process.env.NODE_ENV !== 'production') {
	      renderedElement = measureLifeCyclePerf(function () {
	        return inst.render();
	      }, this._debugID, 'render');
	    } else {
	      renderedElement = inst.render();
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedElement === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedElement = null;
	      }
	    }

	    return renderedElement;
	  },

	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedElement;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;

	    return renderedElement;
	  },

	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },

	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },

	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },

	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },

	  // Stub
	  _instantiateReactComponent: null
	};

	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var React = __webpack_require__(2);

	var invariant = __webpack_require__(12);

	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,

	  getType: function (node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (React.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};

	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactPropTypeLocationNames = __webpack_require__(128);
	var ReactPropTypesSecret = __webpack_require__(116);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(24);
	}

	var loggedTypeFailures = {};

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var componentStackInfo = '';

	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(24);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }

	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}

	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var ReactPropTypeLocationNames = {};

	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}

	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 129 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 * 
	 */

	/*eslint-disable no-self-compare */

	'use strict';

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}

	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }

	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }

	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);

	  if (keysA.length !== keysB.length) {
	    return false;
	  }

	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }

	  return true;
	}

	module.exports = shallowEqual;

/***/ }),
/* 130 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */

	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }

	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}

	module.exports = shouldUpdateReactComponent;

/***/ }),
/* 131 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var emptyComponentFactory;

	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function (factory) {
	    emptyComponentFactory = factory;
	  }
	};

	var ReactEmptyComponent = {
	  create: function (instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};

	ReactEmptyComponent.injection = ReactEmptyComponentInjection;

	module.exports = ReactEmptyComponent;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	var genericComponentClass = null;
	var textComponentClass = null;

	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  }
	};

	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}

	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}

	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}

	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};

	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 133 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var nextDebugID = 1;

	function getNextDebugID() {
	  return nextDebugID++;
	}

	module.exports = getNextDebugID;

/***/ }),
/* 134 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */

	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });

	  return '$' + escapedString;
	}

	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}

	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};

	module.exports = KeyEscapeUtils;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactCurrentOwner = __webpack_require__(17);
	var REACT_ELEMENT_TYPE = __webpack_require__(136);

	var getIteratorFn = __webpack_require__(137);
	var invariant = __webpack_require__(12);
	var KeyEscapeUtils = __webpack_require__(134);
	var warning = __webpack_require__(8);

	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';

	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */

	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */

	var didWarnAboutMaps = false;

	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}

	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;

	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }

	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }

	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }

	  return subtreeCount;
	}

	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }

	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}

	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 136 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.

	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

	module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 137 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	/* global Symbol */

	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}

	module.exports = getIteratorFn;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var KeyEscapeUtils = __webpack_require__(134);
	var traverseAllChildren = __webpack_require__(135);
	var warning = __webpack_require__(8);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(24);
	}

	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && typeof traverseContext === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(24);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}

	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};

	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}

	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var PooledClass = __webpack_require__(55);
	var Transaction = __webpack_require__(73);
	var ReactInstrumentation = __webpack_require__(67);
	var ReactServerUpdateQueue = __webpack_require__(140);

	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];

	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}

	var noopCallbackQueue = {
	  enqueue: function () {}
	};

	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}

	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return noopCallbackQueue;
	  },

	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return this.updateQueue;
	  },

	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {},

	  checkpoint: function () {},

	  rollback: function () {}
	};

	_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

	PooledClass.addPoolingTo(ReactServerRenderingTransaction);

	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ReactUpdateQueue = __webpack_require__(141);

	var warning = __webpack_require__(8);

	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}

	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */

	var ReactServerUpdateQueue = function () {
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);

	    this.transaction = transaction;
	  }

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */


	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */


	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */


	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */


	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */


	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };

	  return ReactServerUpdateQueue;
	}();

	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactCurrentOwner = __webpack_require__(17);
	var ReactInstanceMap = __webpack_require__(122);
	var ReactInstrumentation = __webpack_require__(67);
	var ReactUpdates = __webpack_require__(61);

	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}

	function formatUnexpectedArgument(arg) {
	  var type = typeof arg;
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}

	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }

	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + "within `render` or another component's constructor). Render methods " + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }

	  return internalInstance;
	}

	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }

	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },

	  enqueueCallbackInternal: function (internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

	    if (!internalInstance) {
	      return;
	    }

	    internalInstance._pendingForceUpdate = true;

	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState, callback) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

	    if (!internalInstance) {
	      return;
	    }

	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;

	    // Future-proof 15.5
	    if (callback !== undefined && callback !== null) {
	      ReactUpdateQueue.validateCallback(callback, 'replaceState');
	      if (internalInstance._pendingCallbacks) {
	        internalInstance._pendingCallbacks.push(callback);
	      } else {
	        internalInstance._pendingCallbacks = [callback];
	      }
	    }

	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }

	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

	    if (!internalInstance) {
	      return;
	    }

	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);

	    enqueueUpdate(internalInstance);
	  },

	  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },

	  validateCallback: function (callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	};

	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var emptyFunction = __webpack_require__(9);
	var warning = __webpack_require__(8);

	var validateDOMNesting = emptyFunction;

	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.

	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];

	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);

	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

	  var emptyAncestorInfo = {
	    current: null,

	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,

	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };

	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };

	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }

	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }

	    ancestorInfo.current = info;

	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }

	    return ancestorInfo;
	  };

	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }

	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;

	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }

	    return true;
	  };

	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	      case 'pre':
	      case 'listing':
	      case 'table':
	      case 'hr':
	      case 'xmp':
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;

	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;

	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;

	      case 'button':
	        return ancestorInfo.buttonTagInScope;

	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;

	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }

	    return null;
	  };

	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }

	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };

	  var didWarn = {};

	  validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;

	    if (childText != null) {
	      process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
	      childTag = '#text';
	    }

	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;

	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;

	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);

	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;

	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }

	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;

	      var tagDisplayName = childTag;
	      var whitespaceInfo = '';
	      if (childTag === '#text') {
	        if (/\S/.test(childText)) {
	          tagDisplayName = 'Text nodes';
	        } else {
	          tagDisplayName = 'Whitespace text nodes';
	          whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
	        }
	      } else {
	        tagDisplayName = '<' + childTag + '>';
	      }

	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };

	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}

	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var DOMLazyTree = __webpack_require__(87);
	var ReactDOMComponentTree = __webpack_require__(39);

	var ReactDOMEmptyComponent = function (instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;

	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function () {},
	  getHostNode: function () {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function () {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});

	module.exports = ReactDOMEmptyComponent;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var invariant = __webpack_require__(12);

	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }

	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }

	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }

	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}

	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;

	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}

	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;

	  return inst._hostParent;
	}

	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], 'captured', arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], 'bubbled', arg);
	  }
	}

	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], 'bubbled', argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], 'captured', argTo);
	  }
	}

	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40),
	    _assign = __webpack_require__(4);

	var DOMChildrenOperations = __webpack_require__(86);
	var DOMLazyTree = __webpack_require__(87);
	var ReactDOMComponentTree = __webpack_require__(39);

	var escapeTextContentForBrowser = __webpack_require__(92);
	var invariant = __webpack_require__(12);
	var validateDOMNesting = __webpack_require__(142);

	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;

	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};

	_assign(ReactDOMTextComponent.prototype, {
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(null, this._stringText, this, parentInfo);
	      }
	    }

	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);

	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }

	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },

	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },

	  getHostNode: function () {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },

	  unmountComponent: function () {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});

	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var ReactUpdates = __webpack_require__(61);
	var Transaction = __webpack_require__(73);

	var emptyFunction = __webpack_require__(9);

	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};

	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};

	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}

	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});

	var transaction = new ReactDefaultBatchingStrategyTransaction();

	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,

	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      return callback(a, b, c, d, e);
	    } else {
	      return transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};

	module.exports = ReactDefaultBatchingStrategy;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var EventListener = __webpack_require__(148);
	var ExecutionEnvironment = __webpack_require__(53);
	var PooledClass = __webpack_require__(55);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactUpdates = __webpack_require__(61);

	var getEventTarget = __webpack_require__(75);
	var getUnboundedScrollPosition = __webpack_require__(149);

	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}

	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);

	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}

	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}

	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,

	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },

	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },

	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },

	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },

	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },

	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },

	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }

	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};

	module.exports = ReactEventListener;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	var emptyFunction = __webpack_require__(9);

	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },

	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },

	  registerDefault: function registerDefault() {}
	};

	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 149 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	'use strict';

	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */

	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable.Window && scrollable instanceof scrollable.Window) {
	    return {
	      x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
	      y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}

	module.exports = getUnboundedScrollPosition;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(41);
	var EventPluginHub = __webpack_require__(47);
	var EventPluginUtils = __webpack_require__(49);
	var ReactComponentEnvironment = __webpack_require__(121);
	var ReactEmptyComponent = __webpack_require__(131);
	var ReactBrowserEventEmitter = __webpack_require__(111);
	var ReactHostComponent = __webpack_require__(132);
	var ReactUpdates = __webpack_require__(61);

	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};

	module.exports = ReactInjection;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _assign = __webpack_require__(4);

	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(55);
	var ReactBrowserEventEmitter = __webpack_require__(111);
	var ReactInputSelection = __webpack_require__(152);
	var ReactInstrumentation = __webpack_require__(67);
	var Transaction = __webpack_require__(73);
	var ReactUpdateQueue = __webpack_require__(141);

	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};

	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },

	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};

	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },

	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};

	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}

	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}

	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },

	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return ReactUpdateQueue;
	  },

	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function () {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },

	  rollback: function (checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },

	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};

	_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

	PooledClass.addPoolingTo(ReactReconcileTransaction);

	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ReactDOMSelection = __webpack_require__(153);

	var containsNode = __webpack_require__(155);
	var focusNode = __webpack_require__(100);
	var getActiveElement = __webpack_require__(158);

	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}

	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },

	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },

	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },

	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;

	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }

	    return selection || { start: 0, end: 0 };
	  },

	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }

	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};

	module.exports = ReactInputSelection;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ExecutionEnvironment = __webpack_require__(53);

	var getNodeForCharacterOffset = __webpack_require__(154);
	var getTextContentAccessor = __webpack_require__(56);

	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}

	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;

	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);

	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;

	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}

	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();

	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }

	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;

	  var currentRange = selection.getRangeAt(0);

	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }

	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;

	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;

	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}

	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;

	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }

	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}

	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }

	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }

	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);

	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();

	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}

	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};

	module.exports = ReactDOMSelection;

/***/ }),
/* 154 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */

	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}

	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}

	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;

	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;

	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }

	      nodeStart = nodeEnd;
	    }

	    node = getLeafNode(getSiblingNode(node));
	  }
	}

	module.exports = getNodeForCharacterOffset;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	var isTextNode = __webpack_require__(156);

	/*eslint-disable no-bitwise */

	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}

	module.exports = containsNode;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	var isNode = __webpack_require__(157);

	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}

	module.exports = isTextNode;

/***/ }),
/* 157 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  var doc = object ? object.ownerDocument || object : document;
	  var defaultView = doc.defaultView || window;
	  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}

	module.exports = isNode;

/***/ }),
/* 158 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	/* eslint-disable fb-www/typeof-undefined */

	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 *
	 * @param {?DOMDocument} doc Defaults to current document.
	 * @return {?DOMElement}
	 */
	function getActiveElement(doc) /*?DOMElement*/{
	  doc = doc || (typeof document !== 'undefined' ? document : undefined);
	  if (typeof doc === 'undefined') {
	    return null;
	  }
	  try {
	    return doc.activeElement || doc.body;
	  } catch (e) {
	    return doc.body;
	  }
	}

	module.exports = getActiveElement;

/***/ }),
/* 159 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};

	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};

	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};

	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});

	module.exports = SVGDOMPropertyConfig;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var EventPropagators = __webpack_require__(46);
	var ExecutionEnvironment = __webpack_require__(53);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactInputSelection = __webpack_require__(152);
	var SyntheticEvent = __webpack_require__(58);

	var getActiveElement = __webpack_require__(158);
	var isTextInputElement = __webpack_require__(77);
	var shallowEqual = __webpack_require__(129);

	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: 'onSelect',
	      captured: 'onSelectCapture'
	    },
	    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
	  }
	};

	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;

	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;

	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}

	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }

	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;

	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;

	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

	    return syntheticEvent;
	  }

	  return null;
	}

	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	  eventTypes: eventTypes,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }

	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case 'topFocus':
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case 'topBlur':
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case 'topMouseDown':
	        mouseDown = true;
	        break;
	      case 'topContextMenu':
	      case 'topMouseUp':
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case 'topSelectionChange':
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case 'topKeyDown':
	      case 'topKeyUp':
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }

	    return null;
	  },

	  didPutListener: function (inst, registrationName, listener) {
	    if (registrationName === 'onSelect') {
	      hasListener = true;
	    }
	  }
	};

	module.exports = SelectEventPlugin;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var EventListener = __webpack_require__(148);
	var EventPropagators = __webpack_require__(46);
	var ReactDOMComponentTree = __webpack_require__(39);
	var SyntheticAnimationEvent = __webpack_require__(162);
	var SyntheticClipboardEvent = __webpack_require__(163);
	var SyntheticEvent = __webpack_require__(58);
	var SyntheticFocusEvent = __webpack_require__(164);
	var SyntheticKeyboardEvent = __webpack_require__(165);
	var SyntheticMouseEvent = __webpack_require__(80);
	var SyntheticDragEvent = __webpack_require__(168);
	var SyntheticTouchEvent = __webpack_require__(169);
	var SyntheticTransitionEvent = __webpack_require__(170);
	var SyntheticUIEvent = __webpack_require__(81);
	var SyntheticWheelEvent = __webpack_require__(171);

	var emptyFunction = __webpack_require__(9);
	var getEventCharCode = __webpack_require__(166);
	var invariant = __webpack_require__(12);

	/**
	 * Turns
	 * ['abort', ...]
	 * into
	 * eventTypes = {
	 *   'abort': {
	 *     phasedRegistrationNames: {
	 *       bubbled: 'onAbort',
	 *       captured: 'onAbortCapture',
	 *     },
	 *     dependencies: ['topAbort'],
	 *   },
	 *   ...
	 * };
	 * topLevelEventsToDispatchConfig = {
	 *   'topAbort': { sameConfig }
	 * };
	 */
	var eventTypes = {};
	var topLevelEventsToDispatchConfig = {};
	['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
	  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
	  var onEvent = 'on' + capitalizedEvent;
	  var topEvent = 'top' + capitalizedEvent;

	  var type = {
	    phasedRegistrationNames: {
	      bubbled: onEvent,
	      captured: onEvent + 'Capture'
	    },
	    dependencies: [topEvent]
	  };
	  eventTypes[event] = type;
	  topLevelEventsToDispatchConfig[topEvent] = type;
	});

	var onClickListeners = {};

	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}

	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}

	var SimpleEventPlugin = {
	  eventTypes: eventTypes,

	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case 'topAbort':
	      case 'topCanPlay':
	      case 'topCanPlayThrough':
	      case 'topDurationChange':
	      case 'topEmptied':
	      case 'topEncrypted':
	      case 'topEnded':
	      case 'topError':
	      case 'topInput':
	      case 'topInvalid':
	      case 'topLoad':
	      case 'topLoadedData':
	      case 'topLoadedMetadata':
	      case 'topLoadStart':
	      case 'topPause':
	      case 'topPlay':
	      case 'topPlaying':
	      case 'topProgress':
	      case 'topRateChange':
	      case 'topReset':
	      case 'topSeeked':
	      case 'topSeeking':
	      case 'topStalled':
	      case 'topSubmit':
	      case 'topSuspend':
	      case 'topTimeUpdate':
	      case 'topVolumeChange':
	      case 'topWaiting':
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case 'topKeyPress':
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case 'topKeyDown':
	      case 'topKeyUp':
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case 'topBlur':
	      case 'topFocus':
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case 'topClick':
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case 'topDoubleClick':
	      case 'topMouseDown':
	      case 'topMouseMove':
	      case 'topMouseUp':
	      // TODO: Disabled elements should not respond to mouse events
	      /* falls through */
	      case 'topMouseOut':
	      case 'topMouseOver':
	      case 'topContextMenu':
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case 'topDrag':
	      case 'topDragEnd':
	      case 'topDragEnter':
	      case 'topDragExit':
	      case 'topDragLeave':
	      case 'topDragOver':
	      case 'topDragStart':
	      case 'topDrop':
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case 'topTouchCancel':
	      case 'topTouchEnd':
	      case 'topTouchMove':
	      case 'topTouchStart':
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case 'topAnimationEnd':
	      case 'topAnimationIteration':
	      case 'topAnimationStart':
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case 'topTransitionEnd':
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case 'topScroll':
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case 'topWheel':
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case 'topCopy':
	      case 'topCut':
	      case 'topPaste':
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },

	  didPutListener: function (inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },

	  willDeleteListener: function (inst, registrationName) {
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	};

	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(58);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

	module.exports = SyntheticAnimationEvent;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(58);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

	module.exports = SyntheticClipboardEvent;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(81);

	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

	module.exports = SyntheticFocusEvent;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(81);

	var getEventCharCode = __webpack_require__(166);
	var getEventKey = __webpack_require__(167);
	var getEventModifierState = __webpack_require__(83);

	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.

	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.

	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

	module.exports = SyntheticKeyboardEvent;

/***/ }),
/* 166 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */

	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;

	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;

	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }

	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }

	  return 0;
	}

	module.exports = getEventCharCode;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var getEventCharCode = __webpack_require__(166);

	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  Esc: 'Escape',
	  Spacebar: ' ',
	  Left: 'ArrowLeft',
	  Up: 'ArrowUp',
	  Right: 'ArrowRight',
	  Down: 'ArrowDown',
	  Del: 'Delete',
	  Win: 'OS',
	  Menu: 'ContextMenu',
	  Apps: 'ContextMenu',
	  Scroll: 'ScrollLock',
	  MozPrintableKey: 'Unidentified'
	};

	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1',
	  113: 'F2',
	  114: 'F3',
	  115: 'F4',
	  116: 'F5',
	  117: 'F6',
	  118: 'F7',
	  119: 'F8',
	  120: 'F9',
	  121: 'F10',
	  122: 'F11',
	  123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};

	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.

	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }

	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);

	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}

	module.exports = getEventKey;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var SyntheticMouseEvent = __webpack_require__(80);

	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

	module.exports = SyntheticDragEvent;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var SyntheticUIEvent = __webpack_require__(81);

	var getEventModifierState = __webpack_require__(83);

	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

	module.exports = SyntheticTouchEvent;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var SyntheticEvent = __webpack_require__(58);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

	module.exports = SyntheticTransitionEvent;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var SyntheticMouseEvent = __webpack_require__(80);

	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,

	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

	module.exports = SyntheticWheelEvent;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var DOMLazyTree = __webpack_require__(87);
	var DOMProperty = __webpack_require__(41);
	var React = __webpack_require__(2);
	var ReactBrowserEventEmitter = __webpack_require__(111);
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactDOMContainerInfo = __webpack_require__(173);
	var ReactDOMFeatureFlags = __webpack_require__(174);
	var ReactFeatureFlags = __webpack_require__(63);
	var ReactInstanceMap = __webpack_require__(122);
	var ReactInstrumentation = __webpack_require__(67);
	var ReactMarkupChecksum = __webpack_require__(175);
	var ReactReconciler = __webpack_require__(64);
	var ReactUpdateQueue = __webpack_require__(141);
	var ReactUpdates = __webpack_require__(61);

	var emptyObject = __webpack_require__(11);
	var instantiateReactComponent = __webpack_require__(124);
	var invariant = __webpack_require__(12);
	var setInnerHTML = __webpack_require__(89);
	var shouldUpdateReactComponent = __webpack_require__(130);
	var warning = __webpack_require__(8);

	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

	var instancesByReactRootID = {};

	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}

	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }

	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}

	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}

	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props.child;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }

	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );

	  if (markerName) {
	    console.timeEnd(markerName);
	  }

	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}

	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}

	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }

	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }

	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}

	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}

	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}

	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}

	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}

	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}

	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}

	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function () {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  return this.props.child;
	};
	TopLevelWrapper.isReactTopLevelWrapper = true;

	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	  TopLevelWrapper: TopLevelWrapper,

	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,

	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },

	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });

	    return prevComponent;
	  },

	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);

	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.

	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;

	    return componentInstance;
	  },

	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },

	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

	    var nextWrappedElement = React.createElement(TopLevelWrapper, {
	      child: nextElement
	    });

	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }

	    var prevComponent = getTopLevelWrapperInContainer(container);

	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props.child;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }

	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }

	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },

	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },

	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.') : void 0;
	    }

	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);

	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }

	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },

	  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }

	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }

	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: hostNode._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  }
	};

	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var validateDOMNesting = __webpack_require__(142);

	var DOC_NODE_TYPE = 9;

	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}

	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 174 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ReactDOMFeatureFlags = {
	  useCreateElement: true,
	  useFiber: false
	};

	module.exports = ReactDOMFeatureFlags;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var adler32 = __webpack_require__(176);

	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;

	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',

	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);

	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },

	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};

	module.exports = ReactMarkupChecksum;

/***/ }),
/* 176 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	'use strict';

	var MOD = 65521;

	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}

	module.exports = adler32;

/***/ }),
/* 177 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	module.exports = '15.6.2';

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(40);

	var ReactCurrentOwner = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(39);
	var ReactInstanceMap = __webpack_require__(122);

	var getHostComponentFromComposite = __webpack_require__(179);
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);

	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }

	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }

	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}

	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ReactNodeTypes = __webpack_require__(126);

	function getHostComponentFromComposite(inst) {
	  var type;

	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }

	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}

	module.exports = getHostComponentFromComposite;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ReactMount = __webpack_require__(172);

	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(41);
	var EventPluginRegistry = __webpack_require__(48);
	var ReactComponentTreeHook = __webpack_require__(24);

	var warning = __webpack_require__(8);

	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,

	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};

	  var validateProperty = function (tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();

	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}

	var warnUnknownProperties = function (debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }

	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');

	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};

	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}

	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};

	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var ReactComponentTreeHook = __webpack_require__(24);

	var warning = __webpack_require__(8);

	var didWarnValueNull = false;

	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

	    didWarnValueNull = true;
	  }
	}

	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};

	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var DOMProperty = __webpack_require__(41);
	var ReactComponentTreeHook = __webpack_require__(24);

	var warning = __webpack_require__(8);

	var warnedProperties = {};
	var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

	function validateProperty(tagName, name, debugID) {
	  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	    return true;
	  }

	  if (rARIA.test(name)) {
	    var lowerCasedName = name.toLowerCase();
	    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

	    // If this is an aria-* attribute, but is not listed in the known DOM
	    // DOM properties, then it is an invalid aria-* attribute.
	    if (standardName == null) {
	      warnedProperties[name] = true;
	      return false;
	    }
	    // aria-* attributes should be lowercase; suggest the lowercase version.
	    if (name !== standardName) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      warnedProperties[name] = true;
	      return true;
	    }
	  }

	  return true;
	}

	function warnInvalidARIAProps(debugID, element) {
	  var invalidProps = [];

	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      invalidProps.push(key);
	    }
	  }

	  var unknownPropString = invalidProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');

	  if (invalidProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (invalidProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}

	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }

	  warnInvalidARIAProps(debugID, element);
	}

	var ReactDOMInvalidARIAHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  }
	};

	module.exports = ReactDOMInvalidARIAHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _reactImmutableRenderMixin = __webpack_require__(185);

	var _Canvas = __webpack_require__(191);

	var _Canvas2 = _interopRequireDefault(_Canvas);

	var _Nav = __webpack_require__(216);

	var _Nav2 = _interopRequireDefault(_Nav);

	var _PopUp = __webpack_require__(217);

	var _PopUp2 = _interopRequireDefault(_PopUp);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Page = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(Page, _Component);

	    function Page(props) {
	        _classCallCheck(this, Page);

	        return _possibleConstructorReturn(this, (Page.__proto__ || Object.getPrototypeOf(Page)).call(this, props));
	    }

	    _createClass(Page, [{
	        key: 'mouseUp',
	        value: function mouseUp(event) {}
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: { width: '100%', height: '100%' } },
	                _react2.default.createElement(_Nav2.default, null),
	                _react2.default.createElement(_Canvas2.default, null),
	                _react2.default.createElement('div', { id: 'dragCopyItem' }),
	                _react2.default.createElement(_PopUp2.default, null)
	            );
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {}
	    }]);

	    return Page;
	}(_react.Component)) || _class;

	exports.default = Page;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.shallowEqualImmutable = exports.shouldComponentUpdate = exports.immutableRenderDecorator = exports.default = undefined;

	var _shouldComponentUpdate = __webpack_require__(186);

	var _shouldComponentUpdate2 = _interopRequireDefault(_shouldComponentUpdate);

	var _shallowEqualImmutable = __webpack_require__(187);

	var _shallowEqualImmutable2 = _interopRequireDefault(_shallowEqualImmutable);

	var _immutableRenderMixin = __webpack_require__(189);

	var _immutableRenderMixin2 = _interopRequireDefault(_immutableRenderMixin);

	var _immutableRenderDecorator = __webpack_require__(190);

	var _immutableRenderDecorator2 = _interopRequireDefault(_immutableRenderDecorator);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _immutableRenderMixin2.default;
	exports.immutableRenderDecorator = _immutableRenderDecorator2.default;
	exports.shouldComponentUpdate = _shouldComponentUpdate2.default;
	exports.shallowEqualImmutable = _shallowEqualImmutable2.default;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = shouldComponentUpdate;

	var _shallowEqualImmutable = __webpack_require__(187);

	var _shallowEqualImmutable2 = _interopRequireDefault(_shallowEqualImmutable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function shouldComponentUpdate(nextProps, nextState) {
	  return !(0, _shallowEqualImmutable2.default)(this.props, nextProps) || !(0, _shallowEqualImmutable2.default)(this.state, nextState);
	}

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.default = shallowEqualImmutable;

	var _immutable = __webpack_require__(188);

	var _immutable2 = _interopRequireDefault(_immutable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var is = _immutable2.default.is.bind(_immutable2.default);

	function shallowEqualImmutable(objA, objB) {
	  if (objA === objB || is(objA, objB)) {
	    return true;
	  }

	  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	    return false;
	  }

	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);

	  if (keysA.length !== keysB.length) {
	    return false;
	  }

	  // Test for A's keys different from B.
	  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }

	  return true;
	}

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^321.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function Iterator(next) {
	      this.next = next;
	    }

	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(Map, KeyedCollection);

	    // @pragma Construction

	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };

	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }

	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }

	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }

	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  createClass(Set, SetCollection);

	    // @pragma Construction

	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },

	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;

	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    keySeq: function() {
	      return Range(0, this.size);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    }

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS

	  };

	  return Immutable;

	}));

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _shouldComponentUpdate = __webpack_require__(186);

	var _shouldComponentUpdate2 = _interopRequireDefault(_shouldComponentUpdate);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	  shouldComponentUpdate: _shouldComponentUpdate2.default
	};

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = immutableRenderDecorator;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _shouldComponentUpdate = __webpack_require__(186);

	var _shouldComponentUpdate2 = _interopRequireDefault(_shouldComponentUpdate);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Makes the given component "pure".
	 *
	 * @param object Target Component.
	 */
	function immutableRenderDecorator(Target) {
	  var Wrapper = function (_Component) {
	    _inherits(Wrapper, _Component);

	    function Wrapper() {
	      _classCallCheck(this, Wrapper);

	      return _possibleConstructorReturn(this, Object.getPrototypeOf(Wrapper).apply(this, arguments));
	    }

	    _createClass(Wrapper, [{
	      key: 'render',
	      value: function render() {
	        return _react2.default.createElement(Target, this.props, this.props.children);
	      }
	    }]);

	    return Wrapper;
	  }(_react.Component);

	  Wrapper.prototype.shouldComponentUpdate = _shouldComponentUpdate2.default;

	  return Wrapper;
	}

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _server = __webpack_require__(192);

	var _server2 = _interopRequireDefault(_server);

	var _List = __webpack_require__(207);

	var _List2 = _interopRequireDefault(_List);

	var _DragItem = __webpack_require__(209);

	var _DragItem2 = _interopRequireDefault(_DragItem);

	var _RightSlider = __webpack_require__(210);

	var _RightSlider2 = _interopRequireDefault(_RightSlider);

	var _Paint = __webpack_require__(215);

	var _Paint2 = _interopRequireDefault(_Paint);

	var _reactImmutableRenderMixin = __webpack_require__(185);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Canvas = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(Canvas, _Component);

	    function Canvas(props) {
	        _classCallCheck(this, Canvas);

	        var _this = _possibleConstructorReturn(this, (Canvas.__proto__ || Object.getPrototypeOf(Canvas)).call(this, props));

	        _this.state = {
	            deleteComponentId: []
	        };
	        return _this;
	    }

	    _createClass(Canvas, [{
	        key: 'mouseMove',
	        value: function mouseMove(event) {
	            if (this.isMove) {
	                var offset = {
	                    left: event.clientX - 22,
	                    top: event.clientY - 28
	                };
	                _server2.default.emit('listItem:drag_move', offset);
	            }
	            var param = {
	                clientX: event.clientX,
	                clientY: event.clientY
	            };
	            if (this.move) {

	                if (this.resizeEvents) {
	                    this.resizeEvents.move(param);
	                } else {
	                    _server2.default.emit('listItem:resize_move', param);
	                }
	            }
	            if (this.boxMove) {
	                if (this.boxEvents) {
	                    this.boxEvents.move(param);
	                } else {
	                    _server2.default.emit('listItem:box_move', param);
	                }
	            }
	        }
	    }, {
	        key: 'mouseUp',
	        value: function mouseUp(event) {
	            if (this.isMove) {
	                var offset = {
	                    left: event.clientX - 200,
	                    top: event.clientY - 35
	                };
	                var canvas = document.querySelector('#canvas'),
	                    canvasW = canvas.offsetWidth,
	                    canvasH = canvas.offsetHeight,
	                    isDrop = false;
	                if (canvasW >= offset.left && offset.left >= 0 && canvasH >= offset.top && offset.top >= 0) {
	                    _server2.default.emit('listItem:drag_end', offset, this.currentIcon);
	                }
	                _server2.default.emit('listItem:drag_end2');
	                this.isMove = false;
	                this.currentIcon = null;
	            }
	            var param = {
	                clientX: event.clientX,
	                clientY: event.clientY
	            };
	            if (this.move) {
	                if (this.resizeEvents) {
	                    this.resizeEvents.up(param);
	                } else {
	                    _server2.default.emit('listItem:resize_end', param);
	                }
	                this.move = false;
	            }
	            if (this.boxMove) {
	                if (this.boxEvents) {
	                    this.boxEvents.up(param);
	                } else {
	                    _server2.default.emit('listItem:box_up', param);
	                }
	                this.boxMove = false;
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { id: 'content', className: 'content', onMouseMove: this.mouseMove.bind(this), onMouseUp: this.mouseUp.bind(this) },
	                _react2.default.createElement(
	                    'div',
	                    { id: 'drag_list', className: 'left_content' },
	                    _react2.default.createElement(_List2.default, null)
	                ),
	                _react2.default.createElement(
	                    'div',
	                    { id: 'paint', className: 'canvas' },
	                    _react2.default.createElement(_Paint2.default, { id: 'canvas', deleteComponent: this.state.deleteComponentId })
	                ),
	                _react2.default.createElement(_RightSlider2.default, null),
	                _react2.default.createElement(_DragItem2.default, null)
	            );
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this2 = this;

	            var canvas = document.getElementById('canvas');
	            _server2.default.on('listItem:drag_start', function (param) {
	                _this2.isMove = true;
	                _this2.currentIcon = param.icon.icon;
	            });
	            _server2.default.on('listItem:resize_start', function (type, resizeEvents) {
	                _this2.move = true;
	                resizeEvents && (_this2.resizeEvents = resizeEvents);
	            });
	            _server2.default.on('listItem:box_start', function (boxEvents) {
	                _this2.boxMove = true;
	                boxEvents && (_this2.boxEvents = boxEvents);
	            });
	        }
	    }]);

	    return Canvas;
	}(_react.Component)) || _class;

	exports.default = Canvas;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * server
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * i hate react
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _componentManage = __webpack_require__(193);

	var _componentManage2 = _interopRequireDefault(_componentManage);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var manage = new _componentManage2.default([]);

	var Server = function () {
	    function Server() {
	        _classCallCheck(this, Server);

	        if (!Server.created) {
	            Server.instance = this;
	            Server.created = true;
	            Server.instance.manage = manage;
	        }
	        return Server.instance;
	    }

	    _createClass(Server, [{
	        key: 'on',
	        value: function on(eventList, callback) {
	            var cache = void 0,
	                event = void 0,
	                list = void 0;
	            if (!callback) return;
	            eventList = eventList.split(/,/);
	            cache = this._eventList || (this._eventList = {});
	            while (event = eventList.shift()) {
	                list = cache[event] || (cache[event] = []);
	                list.push({
	                    f: callback
	                });
	            }
	            return this;
	        }
	    }, {
	        key: 'off',
	        value: function off(evt, func) {
	            if (!arguments.length) return;
	            var event = arguments[0],
	                cache = this._eventList;
	            if (!cache || !cache[event]) return;
	            if (!func) {
	                delete cache[event];return;
	            }
	            var list = cache[event];
	            for (var i = 0; i < list.length; i++) {
	                if (list[i].f === func) {
	                    list.splice(i, 1);
	                }
	            }
	        }
	    }, {
	        key: 'emit',
	        value: function emit() {
	            if (!arguments.length) return;
	            var event = arguments[0],
	                param = Array.prototype.slice.call(arguments, 1),
	                cache = this._eventList,
	                callback = arguments[1];
	            if (!cache || !cache[event]) return;
	            if (callback === Object.prototype.toString.call(callback) === '[object Function]') {
	                param = Array.prototype.slice.call(arguments, 2);
	            } else {
	                callback = null;
	            }
	            var list = cache[event].slice();
	            for (var i = 0, len = list.length; i < len; i++) {
	                if (callback) {
	                    if (list[i].f == callback) {
	                        list[i].f.apply(list[i].c || this, param);
	                        return;
	                    }
	                } else {
	                    list[i].f.apply(list[i].c || this, param);
	                }
	            }
	        }
	    }]);

	    return Server;
	}();

	var server = new Server();
	exports.default = server;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _immutable = __webpack_require__(194);

	var _immutable2 = _interopRequireDefault(_immutable);

	var _utils = __webpack_require__(195);

	var _utils2 = _interopRequireDefault(_utils);

	var _component = __webpack_require__(196);

	var _component2 = _interopRequireDefault(_component);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var maxHistory = 10;
	var history = [];
	var mapHistory = [];
	var plate = null;

	var componentManage = function () {
	    function componentManage(components) {
	        _classCallCheck(this, componentManage);

	        if (components) {
	            var componentMap = {};
	            components.map(function (e, i) {
	                if (!componentMap[e.id]) {
	                    componentMap[e.id] = e;
	                }
	            });
	            this.$$componetMap = _immutable2.default.Map(componentMap); //fromJS 
	            this.$$components = _immutable2.default.List(components);

	            history.splice(0);
	            mapHistory.splice(0);
	            history.push(this.$$components);
	            mapHistory.push(this.$$componetMap);
	            this.historyIndex = 0;
	        }
	    }

	    _createClass(componentManage, [{
	        key: 'getJsonData',
	        value: function getJsonData() {
	            return JSON.stringify(this.$$components);
	        }
	    }, {
	        key: 'recoveryFromJsonData',
	        value: function recoveryFromJsonData(json) {
	            if (json && _utils2.default.isArray(json)) {
	                var components = [],
	                    componentMap = {};
	                json.forEach(function (e, i) {
	                    components[i] = _component2.default.toComponent(e);
	                });
	                components.map(function (e, i) {
	                    if (!componentMap[e.id]) {
	                        componentMap[e.id] = e;
	                    }
	                });
	                this.$$componetMap = _immutable2.default.Map(componentMap);
	                this.$$components = _immutable2.default.List(components);

	                history.splice(0);
	                mapHistory.splice(0);
	                history.push(this.$$components);
	                mapHistory.push(this.$$componetMap);
	                this.historyIndex = 0;
	                this.updatePaint && this.updatePaint();
	            }
	        }
	    }, {
	        key: 'getCurrentComponnets',
	        value: function getCurrentComponnets() {
	            return this.$$components;
	        }
	    }, {
	        key: 'undo',
	        value: function undo() {
	            if (this.historyIndex) {
	                this.$$components = history[--this.historyIndex];
	                this.$$componetMap = mapHistory[this.historyIndex];
	                this.refreshPath();
	                this.updatePaint && this.updatePaint();
	                return this.$$components;
	            }
	            return null;
	        }
	    }, {
	        key: 'refreshPath',
	        value: function refreshPath(list) {
	            var _this = this;

	            if (!list) {
	                list = this.$$components;
	            }
	            list.forEach(function (component, key) {
	                if (!component.parentId) {
	                    component.path = key + '';
	                } else {
	                    var parentComponent = _this.$$componetMap.get(component.parentId);
	                    component.path = parentComponent.path + ".children." + key;
	                }

	                //
	                var children = component.get("children");
	                if (!children && children.size) {
	                    _this.refreshPath(children);
	                }
	            });
	        }
	    }, {
	        key: 'redo',
	        value: function redo() {
	            if (history.length - 1 > this.historyIndex) {
	                this.$$components = history[++this.historyIndex];
	                this.$$componetMap = mapHistory[this.historyIndex];
	                this.refreshPath();
	                this.updatePaint && this.updatePaint();
	                return this.$$components;
	            }
	            return null;
	        }
	    }, {
	        key: 'setPlate',
	        value: function setPlate() {
	            if (this.currentId) {
	                plate = this._hasComponent(this.currentId);
	            }
	        }
	    }, {
	        key: 'getPlate',
	        value: function getPlate() {
	            if (plate) {
	                return plate;
	            }
	        }
	        /**
	         *  @method _hasComponent ,
	         *  @param object/string /ID
	         * */

	    }, {
	        key: '_hasComponent',
	        value: function _hasComponent(component) {
	            var id = _utils2.default.isObject(component) ? component.id : component;
	            return this.$$componetMap.get(id);
	        }
	    }, {
	        key: '_add',
	        value: function _add(component, parentComponentId) {
	            if (component && !this._hasComponent(component)) {
	                var parentComponent = this._hasComponent(parentComponentId);
	                if (parentComponent) {
	                    if (!parentComponent.get("children")) {
	                        this._update(parentComponent.path + ".children", _immutable2.default.List([]));
	                    }
	                    component.parentId = parentComponent.id;
	                    component.path = parentComponent.path + ".children." + parentComponent.children.size;
	                } else {
	                    component.path = '' + this.$$components.size;
	                }
	                this._update(component.path, component);
	            }
	        }
	    }, {
	        key: '_update',
	        value: function _update(path, component) {
	            if (_utils2.default.isObject(path)) {
	                component = path;
	                path = this.$$components.size + '';
	            }
	            this.$$components = this.$$components.updateIn(path.split('.'), function () {
	                return component;
	            });
	        }
	    }, {
	        key: '_delete',
	        value: function _delete(component) {
	            var _this2 = this;

	            if (component && this.$$componetMap.get(component.id)) {
	                var currentIndex = void 0;
	                if (component.parentId) {
	                    var parentCom = this.$$componetMap.get(component.parentId);
	                    parentCom.children.forEach(function (e, i) {
	                        if (e === component) {
	                            currentIndex = i;
	                        } else if (currentIndex !== undefined && currentIndex < i) {
	                            var com = parentCom.children.get(i);
	                            com.path = com.path.slice(0, -1) + --i;
	                        }
	                    });
	                } else {
	                    this.$$components.forEach(function (e, i) {
	                        if (e === component) {
	                            currentIndex = i;
	                        } else if (currentIndex !== undefined && currentIndex < i) {
	                            var com = _this2.$$components.get(i);
	                            com.path = com.path.slice(0, -1) + --i;
	                        }
	                    });
	                }
	                this.$$components = this.$$components.deleteIn(component.path.split('.'));
	                this.$$componetMap = this.$$componetMap.delete(component.id);
	            }
	        }
	        /**
	         *  @methods update 
	         * */

	    }, {
	        key: 'update',
	        value: function update(component, noUpdateHistory) {
	            if (!component || !this._hasComponent(component)) {
	                return false;
	            }
	            this._update(component.path, component);
	            this.$$componetMap = this.$$componetMap.set(component.id, component);
	            !noUpdateHistory && this.updateHistory();
	            this.updatePaint && this.updatePaint();
	            return this.$$components;
	        }
	    }, {
	        key: 'change',
	        value: function change(component, parentComponentId) {
	            var _this3 = this;

	            if (!component) {
	                return;
	            }

	            // 
	            if (_utils2.default.isArray(component)) {
	                component.forEach(function (e) {
	                    _this3._hasComponent(e) && _this3._delete(e);
	                    _this3._add(e, parentComponentId);
	                });
	            } else {
	                this._hasComponent(component) && this._delete(component);
	                this._add(component, parentComponentId);
	            }

	            this.$$componetMap = this.$$componetMap.set(component.id, component);
	            this.updateHistory();
	            this.updatePaint && this.updatePaint();
	            return this.$$components;
	        }
	    }, {
	        key: 'remove',
	        value: function remove(componentId) {
	            if (!componentId) {
	                componentId = this.currentId;
	            }
	            if (componentId) {
	                var com = this.$$componetMap.get(componentId);
	                this._delete(com);
	                this.updateHistory();
	                this.updatePaint && this.updatePaint();
	            }
	            return this.$$components;
	        }
	    }, {
	        key: 'add',
	        value: function add(component, parentComponentId) {
	            if (!component || this.$$componetMap.get(component.id)) {
	                return;
	            }
	            this.change(component, parentComponentId);
	            return this.$$components;
	        }
	    }, {
	        key: 'updateHistory',
	        value: function updateHistory() {
	            this.historyIndex++;
	            history.splice(this.historyIndex);
	            history.push(this.$$components);
	            mapHistory.splice(this.historyIndex);
	            mapHistory.push(this.$$componetMap);
	            if (this.historyIndex > maxHistory - 1) {
	                this.historyIndex = maxHistory - 1;
	                history.shift();
	                mapHistory.shift();
	            }
	        }
	    }, {
	        key: 'setPaintUpdate',
	        value: function setPaintUpdate(fn) {
	            var _this4 = this;

	            if (_utils2.default.isFunction(fn)) {
	                this.updatePaint = function () {
	                    fn(_this4.$$components);
	                };
	            }
	        }
	    }]);

	    return componentManage;
	}();

	exports.default = componentManage;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	(function (global, factory) {
	  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.Immutable = global.Immutable || {});
	})(undefined, function (exports) {
	  'use strict';

	  // Used for setting prototype methods that IE8 chokes on.

	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^321.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    // Sanitize indices using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    return index === undefined ? defaultIndex : index < 0 ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === undefined || size === index ? index : Math.min(size, index) | 0;
	  }

	  function isImmutable(maybeImmutable) {
	    return (isCollection(maybeImmutable) || isRecord(maybeImmutable)) && !maybeImmutable.__ownerID;
	  }

	  function isCollection(maybeCollection) {
	    return !!(maybeCollection && maybeCollection[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  function isRecord(maybeRecord) {
	    return !!(maybeRecord && maybeRecord[IS_RECORD_SENTINEL]);
	  }

	  function isValueObject(maybeValue) {
	    return !!(maybeValue && typeof maybeValue.equals === 'function' && typeof maybeValue.hashCode === 'function');
	  }

	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	  var IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@';

	  var Collection = function Collection(value) {
	    return isCollection(value) ? value : Seq(value);
	  };

	  var KeyedCollection = function (Collection) {
	    function KeyedCollection(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }

	    if (Collection) KeyedCollection.__proto__ = Collection;
	    KeyedCollection.prototype = Object.create(Collection && Collection.prototype);
	    KeyedCollection.prototype.constructor = KeyedCollection;

	    return KeyedCollection;
	  }(Collection);

	  var IndexedCollection = function (Collection) {
	    function IndexedCollection(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }

	    if (Collection) IndexedCollection.__proto__ = Collection;
	    IndexedCollection.prototype = Object.create(Collection && Collection.prototype);
	    IndexedCollection.prototype.constructor = IndexedCollection;

	    return IndexedCollection;
	  }(Collection);

	  var SetCollection = function (Collection) {
	    function SetCollection(value) {
	      return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
	    }

	    if (Collection) SetCollection.__proto__ = Collection;
	    SetCollection.prototype = Object.create(Collection && Collection.prototype);
	    SetCollection.prototype.constructor = SetCollection;

	    return SetCollection;
	  }(Collection);

	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;

	  var Iterator = function Iterator(next) {
	    this.next = next;
	  };

	  Iterator.prototype.toString = function toString() {
	    return '[Iterator]';
	  };

	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
	    return this.toString();
	  };
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };

	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? iteratorResult.value = value : iteratorResult = {
	      value: value,
	      done: false
	    };
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  var Seq = function (Collection$$1) {
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() : isCollection(value) || isRecord(value) ? value.toSeq() : seqFromValue(value);
	    }

	    if (Collection$$1) Seq.__proto__ = Collection$$1;
	    Seq.prototype = Object.create(Collection$$1 && Collection$$1.prototype);
	    Seq.prototype.constructor = Seq;

	    Seq.of = function of() /*...values*/{
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function toSeq() {
	      return this;
	    };

	    Seq.prototype.toString = function toString() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function cacheResult() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var cache = this._cache;
	      if (cache) {
	        var size = cache.length;
	        var i = 0;
	        while (i !== size) {
	          var entry = cache[reverse ? size - ++i : i++];
	          if (fn(entry[1], entry[0], this$1) === false) {
	            break;
	          }
	        }
	        return i;
	      }
	      return this.__iterateUncached(fn, reverse);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function __iterator(type, reverse) {
	      var cache = this._cache;
	      if (cache) {
	        var size = cache.length;
	        var i = 0;
	        return new Iterator(function () {
	          if (i === size) {
	            return iteratorDone();
	          }
	          var entry = cache[reverse ? size - ++i : i++];
	          return iteratorValue(type, entry[0], entry[1]);
	        });
	      }
	      return this.__iteratorUncached(type, reverse);
	    };

	    return Seq;
	  }(Collection);

	  var KeyedSeq = function (Seq) {
	    function KeyedSeq(value) {
	      return value === null || value === undefined ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
	    }

	    if (Seq) KeyedSeq.__proto__ = Seq;
	    KeyedSeq.prototype = Object.create(Seq && Seq.prototype);
	    KeyedSeq.prototype.constructor = KeyedSeq;

	    KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {
	      return this;
	    };

	    return KeyedSeq;
	  }(Seq);

	  var IndexedSeq = function (Seq) {
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
	    }

	    if (Seq) IndexedSeq.__proto__ = Seq;
	    IndexedSeq.prototype = Object.create(Seq && Seq.prototype);
	    IndexedSeq.prototype.constructor = IndexedSeq;

	    IndexedSeq.of = function of() /*...values*/{
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function toString() {
	      return this.__toString('Seq [', ']');
	    };

	    return IndexedSeq;
	  }(Seq);

	  var SetSeq = function (Seq) {
	    function SetSeq(value) {
	      return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
	    }

	    if (Seq) SetSeq.__proto__ = Seq;
	    SetSeq.prototype = Object.create(Seq && Seq.prototype);
	    SetSeq.prototype.constructor = SetSeq;

	    SetSeq.of = function of() /*...values*/{
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function toSetSeq() {
	      return this;
	    };

	    return SetSeq;
	  }(Seq);

	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;

	  // #pragma Root Sequences

	  var ArraySeq = function (IndexedSeq) {
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    if (IndexedSeq) ArraySeq.__proto__ = IndexedSeq;
	    ArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
	    ArraySeq.prototype.constructor = ArraySeq;

	    ArraySeq.prototype.get = function get(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var array = this._array;
	      var size = array.length;
	      var i = 0;
	      while (i !== size) {
	        var ii = reverse ? size - ++i : i++;
	        if (fn(array[ii], ii, this$1) === false) {
	          break;
	        }
	      }
	      return i;
	    };

	    ArraySeq.prototype.__iterator = function __iterator(type, reverse) {
	      var array = this._array;
	      var size = array.length;
	      var i = 0;
	      return new Iterator(function () {
	        if (i === size) {
	          return iteratorDone();
	        }
	        var ii = reverse ? size - ++i : i++;
	        return iteratorValue(type, ii, array[ii]);
	      });
	    };

	    return ArraySeq;
	  }(IndexedSeq);

	  var ObjectSeq = function (KeyedSeq) {
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    if (KeyedSeq) ObjectSeq.__proto__ = KeyedSeq;
	    ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
	    ObjectSeq.prototype.constructor = ObjectSeq;

	    ObjectSeq.prototype.get = function get(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function has(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var object = this._object;
	      var keys = this._keys;
	      var size = keys.length;
	      var i = 0;
	      while (i !== size) {
	        var key = keys[reverse ? size - ++i : i++];
	        if (fn(object[key], key, this$1) === false) {
	          break;
	        }
	      }
	      return i;
	    };

	    ObjectSeq.prototype.__iterator = function __iterator(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var size = keys.length;
	      var i = 0;
	      return new Iterator(function () {
	        if (i === size) {
	          return iteratorDone();
	        }
	        var key = keys[reverse ? size - ++i : i++];
	        return iteratorValue(type, key, object[key]);
	      });
	    };

	    return ObjectSeq;
	  }(KeyedSeq);
	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;

	  var CollectionSeq = function (IndexedSeq) {
	    function CollectionSeq(collection) {
	      this._collection = collection;
	      this.size = collection.length || collection.size;
	    }

	    if (IndexedSeq) CollectionSeq.__proto__ = IndexedSeq;
	    CollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
	    CollectionSeq.prototype.constructor = CollectionSeq;

	    CollectionSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var collection = this._collection;
	      var iterator = getIterator(collection);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this$1) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var collection = this._collection;
	      var iterator = getIterator(collection);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function () {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };

	    return CollectionSeq;
	  }(IndexedSeq);

	  var IteratorSeq = function (IndexedSeq) {
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    if (IndexedSeq) IteratorSeq.__proto__ = IndexedSeq;
	    IteratorSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
	    IteratorSeq.prototype.constructor = IteratorSeq;

	    IteratorSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this$1) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this$1) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function () {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };

	    return IteratorSeq;
	  }(IndexedSeq);

	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq = Array.isArray(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;
	    if (seq) {
	      return seq.fromEntrySeq();
	    }
	    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	      return new ObjectSeq(value);
	    }
	    throw new TypeError('Expected Array or collection object of [k, v] entries, or keyed object: ' + value);
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (seq) {
	      return seq;
	    }
	    throw new TypeError('Expected Array or collection object of values: ' + value);
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (seq) {
	      return seq;
	    }
	    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	      return new ObjectSeq(value);
	    }
	    throw new TypeError('Expected Array or collection object of values, or keyed object: ' + value);
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections are Value Objects: they implement `equals()`
	   * and `hashCode()`.
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
	  }

	  function fromJS(value, converter) {
	    return fromJSWith([], converter || defaultConverter, value, '', converter && converter.length > 2 ? [] : undefined, { '': value });
	  }

	  function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
	    var toSeq = Array.isArray(value) ? IndexedSeq : isPlainObj(value) ? KeyedSeq : null;
	    if (toSeq) {
	      if (~stack.indexOf(value)) {
	        throw new TypeError('Cannot convert circular structure to Immutable');
	      }
	      stack.push(value);
	      keyPath && key !== '' && keyPath.push(key);
	      var converted = converter.call(parentValue, key, toSeq(value).map(function (v, k) {
	        return fromJSWith(stack, converter, v, k, keyPath, value);
	      }), keyPath && keyPath.slice());
	      stack.pop();
	      keyPath && keyPath.pop();
	      return converted;
	    }
	    return value;
	  }

	  function defaultConverter(k, v) {
	    return isKeyed(v) ? v.toMap() : v.toList();
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
	    a |= 0; // int
	    b |= 0; // int
	    var c = a & 0xffff;
	    var d = b & 0xffff;
	    // Shift by 0 fixes the sign on the high part.
	    return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
	  };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o === 'undefined' ? 'undefined' : _typeof(o);
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xffffffff;
	      }
	      while (o > 0xffffffff) {
	        o /= 0xffffffff;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        enumerable: false,
	        configurable: false,
	        writable: false,
	        value: hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function () {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = function () {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }();

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1:
	          // Element
	          return node.uniqueID;
	        case 9:
	          // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  var ToKeyedSequence = function (KeyedSeq$$1) {
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    if (KeyedSeq$$1) ToKeyedSequence.__proto__ = KeyedSeq$$1;
	    ToKeyedSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);
	    ToKeyedSequence.prototype.constructor = ToKeyedSequence;

	    ToKeyedSequence.prototype.get = function get(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function has(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function valueSeq() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function reverse() {
	      var this$1 = this;

	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function () {
	          return this$1._iter.toSeq().reverse();
	        };
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function map(mapper, context) {
	      var this$1 = this;

	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function () {
	          return this$1._iter.toSeq().map(mapper, context);
	        };
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      return this._iter.__iterate(function (v, k) {
	        return fn(v, k, this$1);
	      }, reverse);
	    };

	    ToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {
	      return this._iter.__iterator(type, reverse);
	    };

	    return ToKeyedSequence;
	  }(KeyedSeq);
	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;

	  var ToIndexedSequence = function (IndexedSeq$$1) {
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    if (IndexedSeq$$1) ToIndexedSequence.__proto__ = IndexedSeq$$1;
	    ToIndexedSequence.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
	    ToIndexedSequence.prototype.constructor = ToIndexedSequence;

	    ToIndexedSequence.prototype.includes = function includes(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var i = 0;
	      reverse && ensureSize(this);
	      return this._iter.__iterate(function (v) {
	        return fn(v, reverse ? this$1.size - ++i : i++, this$1);
	      }, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {
	      var this$1 = this;

	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var i = 0;
	      reverse && ensureSize(this);
	      return new Iterator(function () {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, reverse ? this$1.size - ++i : i++, step.value, step);
	      });
	    };

	    return ToIndexedSequence;
	  }(IndexedSeq);

	  var ToSetSequence = function (SetSeq$$1) {
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    if (SetSeq$$1) ToSetSequence.__proto__ = SetSeq$$1;
	    ToSetSequence.prototype = Object.create(SetSeq$$1 && SetSeq$$1.prototype);
	    ToSetSequence.prototype.constructor = ToSetSequence;

	    ToSetSequence.prototype.has = function has(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      return this._iter.__iterate(function (v) {
	        return fn(v, v, this$1);
	      }, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function __iterator(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function () {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, step.value, step.value, step);
	      });
	    };

	    return ToSetSequence;
	  }(SetSeq);

	  var FromEntriesSequence = function (KeyedSeq$$1) {
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    if (KeyedSeq$$1) FromEntriesSequence.__proto__ = KeyedSeq$$1;
	    FromEntriesSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);
	    FromEntriesSequence.prototype.constructor = FromEntriesSequence;

	    FromEntriesSequence.prototype.entrySeq = function entrySeq() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      return this._iter.__iterate(function (entry) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedCollection = isCollection(entry);
	          return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1);
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function __iterator(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function () {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedCollection = isCollection(entry);
	            return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);
	          }
	        }
	      });
	    };

	    return FromEntriesSequence;
	  }(KeyedSeq);

	  ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;

	  function flipFactory(collection) {
	    var flipSequence = makeSequence(collection);
	    flipSequence._iter = collection;
	    flipSequence.size = collection.size;
	    flipSequence.flip = function () {
	      return collection;
	    };
	    flipSequence.reverse = function () {
	      var reversedSequence = collection.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function () {
	        return collection.reverse();
	      };
	      return reversedSequence;
	    };
	    flipSequence.has = function (key) {
	      return collection.includes(key);
	    };
	    flipSequence.includes = function (key) {
	      return collection.has(key);
	    };
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      return collection.__iterate(function (v, k) {
	        return fn(k, v, this$1) !== false;
	      }, reverse);
	    };
	    flipSequence.__iteratorUncached = function (type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = collection.__iterator(type, reverse);
	        return new Iterator(function () {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
	    };
	    return flipSequence;
	  }

	  function mapFactory(collection, mapper, context) {
	    var mappedSequence = makeSequence(collection);
	    mappedSequence.size = collection.size;
	    mappedSequence.has = function (key) {
	      return collection.has(key);
	    };
	    mappedSequence.get = function (key, notSetValue) {
	      var v = collection.get(key, NOT_SET);
	      return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      return collection.__iterate(function (v, k, c) {
	        return fn(mapper.call(context, v, k, c), k, this$1) !== false;
	      }, reverse);
	    };
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function () {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);
	      });
	    };
	    return mappedSequence;
	  }

	  function reverseFactory(collection, useKeys) {
	    var this$1 = this;

	    var reversedSequence = makeSequence(collection);
	    reversedSequence._iter = collection;
	    reversedSequence.size = collection.size;
	    reversedSequence.reverse = function () {
	      return collection;
	    };
	    if (collection.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(collection);
	        flipSequence.reverse = function () {
	          return collection.flip();
	        };
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function (key, notSetValue) {
	      return collection.get(useKeys ? key : -1 - key, notSetValue);
	    };
	    reversedSequence.has = function (key) {
	      return collection.has(useKeys ? key : -1 - key);
	    };
	    reversedSequence.includes = function (value) {
	      return collection.includes(value);
	    };
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {
	      var this$1 = this;

	      var i = 0;
	      reverse && ensureSize(collection);
	      return collection.__iterate(function (v, k) {
	        return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1);
	      }, !reverse);
	    };
	    reversedSequence.__iterator = function (type, reverse) {
	      var i = 0;
	      reverse && ensureSize(collection);
	      var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
	      return new Iterator(function () {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        return iteratorValue(type, useKeys ? entry[0] : reverse ? this$1.size - ++i : i++, entry[1], step);
	      });
	    };
	    return reversedSequence;
	  }

	  function filterFactory(collection, predicate, context, useKeys) {
	    var filterSequence = makeSequence(collection);
	    if (useKeys) {
	      filterSequence.has = function (key) {
	        var v = collection.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, collection);
	      };
	      filterSequence.get = function (key, notSetValue) {
	        var v = collection.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      var iterations = 0;
	      collection.__iterate(function (v, k, c) {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$1);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function () {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, collection)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    };
	    return filterSequence;
	  }

	  function countByFactory(collection, grouper, context) {
	    var groups = Map().asMutable();
	    collection.__iterate(function (v, k) {
	      groups.update(grouper.call(context, v, k, collection), 0, function (a) {
	        return a + 1;
	      });
	    });
	    return groups.asImmutable();
	  }

	  function groupByFactory(collection, grouper, context) {
	    var isKeyedIter = isKeyed(collection);
	    var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();
	    collection.__iterate(function (v, k) {
	      groups.update(grouper.call(context, v, k, collection), function (a) {
	        return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
	      });
	    });
	    var coerce = collectionClass(collection);
	    return groups.map(function (arr) {
	      return reify(collection, coerce(arr));
	    });
	  }

	  function sliceFactory(collection, begin, end, useKeys) {
	    var originalSize = collection.size;

	    if (wholeSlice(begin, end, originalSize)) {
	      return collection;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this collection's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(collection);

	    // If collection.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || undefined;

	    if (!useKeys && isSeq(collection) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
	      };
	    }

	    sliceSeq.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      collection.__iterate(function (v, k) {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$1) !== false && iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function (type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && collection.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function () {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        }
	        if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        }
	        return iteratorValue(type, iterations - 1, step.value[1], step);
	      });
	    };

	    return sliceSeq;
	  }

	  function takeWhileFactory(collection, predicate, context) {
	    var takeSequence = makeSequence(collection);
	    takeSequence.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      collection.__iterate(function (v, k, c) {
	        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1);
	      });
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function (type, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function () {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$1)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }

	  function skipWhileFactory(collection, predicate, context, useKeys) {
	    var skipSequence = makeSequence(collection);
	    skipSequence.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      collection.__iterate(function (v, k, c) {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$1);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function (type, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function () {
	        var step;
	        var k;
	        var v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            }
	            if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            }
	            return iteratorValue(type, iterations++, step.value[1], step);
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$1));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }

	  function concatFactory(collection, values) {
	    var isKeyedCollection = isKeyed(collection);
	    var iters = [collection].concat(values).map(function (v) {
	      if (!isCollection(v)) {
	        v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedCollection) {
	        v = KeyedCollection(v);
	      }
	      return v;
	    }).filter(function (v) {
	      return v.size !== 0;
	    });

	    if (iters.length === 0) {
	      return collection;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedCollection) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(collection)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(function (sum, seq) {
	      if (sum !== undefined) {
	        var size = seq.size;
	        if (size !== undefined) {
	          return sum + size;
	        }
	      }
	    }, 0);
	    return concatSeq;
	  }

	  function flattenFactory(collection, depth, useKeys) {
	    var flatSequence = makeSequence(collection);
	    flatSequence.__iterateUncached = function (fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {
	        iter.__iterate(function (v, k) {
	          if ((!depth || currentDepth < depth) && isCollection(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else {
	            iterations++;
	            if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
	              stopped = true;
	            }
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(collection, 0);
	      return iterations;
	    };
	    flatSequence.__iteratorUncached = function (type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = collection.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function () {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isCollection(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    };
	    return flatSequence;
	  }

	  function flatMapFactory(collection, mapper, context) {
	    var coerce = collectionClass(collection);
	    return collection.toSeq().map(function (v, k) {
	      return coerce(mapper.call(context, v, k, collection));
	    }).flatten(true);
	  }

	  function interposeFactory(collection, separator) {
	    var interposedSequence = makeSequence(collection);
	    interposedSequence.size = collection.size && collection.size * 2 - 1;
	    interposedSequence.__iterateUncached = function (fn, reverse) {
	      var this$1 = this;

	      var iterations = 0;
	      collection.__iterate(function (v) {
	        return (!iterations || fn(separator, iterations++, this$1) !== false) && fn(v, iterations++, this$1) !== false;
	      }, reverse);
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = collection.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function () {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }

	  function sortFactory(collection, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedCollection = isKeyed(collection);
	    var index = 0;
	    var entries = collection.toSeq().map(function (v, k) {
	      return [k, v, index++, mapper ? mapper(v, k, collection) : v];
	    }).toArray();
	    entries.sort(function (a, b) {
	      return comparator(a[3], b[3]) || a[2] - b[2];
	    }).forEach(isKeyedCollection ? function (v, i) {
	      entries[i].length = 2;
	    } : function (v, i) {
	      entries[i] = v[1];
	    });
	    return isKeyedCollection ? KeyedSeq(entries) : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);
	  }

	  function maxFactory(collection, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = collection.toSeq().map(function (v, k) {
	        return [v, mapper(v, k, collection)];
	      }).reduce(function (a, b) {
	        return maxCompare(comparator, a[1], b[1]) ? b : a;
	      });
	      return entry && entry[0];
	    }
	    return collection.reduce(function (a, b) {
	      return maxCompare(comparator, a, b) ? b : a;
	    });
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
	  }

	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function (i) {
	      return i.size;
	    }).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function (fn, reverse) {
	      var this$1 = this;

	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this$1) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function (type, reverse) {
	      var iterators = iters.map(function (i) {
	        return i = Collection(i), getIterator(reverse ? i.reverse() : i);
	      });
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function () {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function (i) {
	            return i.next();
	          });
	          isDone = steps.some(function (s) {
	            return s.done;
	          });
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
	          return s.value;
	        })));
	      });
	    };
	    return zipSequence;
	  }

	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function collectionClass(collection) {
	    return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
	  }

	  function makeSequence(collection) {
	    return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    }
	    return Seq.prototype.cacheResult.call(this);
	  }

	  function defaultComparator(a, b) {
	    if (a === undefined && b === undefined) {
	      return 0;
	    }

	    if (a === undefined) {
	      return 1;
	    }

	    if (b === undefined) {
	      return -1;
	    }

	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function coerceKeyPath(keyPath) {
	    if (isArrayLike(keyPath) && typeof keyPath !== 'string') {
	      return keyPath;
	    }
	    if (isOrdered(keyPath)) {
	      return keyPath.toArray();
	    }
	    throw new TypeError('Invalid keyPath: expected Ordered Collection or Array: ' + keyPath);
	  }

	  function invariant(condition, error) {
	    if (!condition) {
	      throw new Error(error);
	    }
	  }

	  function assertNotInfinite(size) {
	    invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');
	  }

	  /**
	   * Converts a value to a string, adding quotes if a string was provided.
	   */
	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }

	  var Map = function (KeyedCollection$$1) {
	    function Map(value) {
	      return value === null || value === undefined ? emptyMap.bind(this)() : isMap(value) && !isOrdered(value) ? value : emptyMap.bind(this)().withMutations(function (map) {
	        var iter = KeyedCollection$$1(value);
	        assertNotInfinite(iter.size);
	        iter.forEach(function (v, k) {
	          return map.set(k, v);
	        });
	      });
	    }

	    if (KeyedCollection$$1) Map.__proto__ = KeyedCollection$$1;
	    Map.prototype = Object.create(KeyedCollection$$1 && KeyedCollection$$1.prototype);
	    Map.prototype.constructor = Map;

	    Map.of = function of() {
	      var keyValues = [],
	          len = arguments.length;
	      while (len--) {
	        keyValues[len] = arguments[len];
	      }return emptyMap.bind(this)().withMutations(function (map) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };

	    Map.prototype.toString = function toString() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function get(k, notSetValue) {
	      return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function set(k, v) {
	      return updateMap.bind(this)(this, k, v);
	    };

	    Map.prototype.setIn = function setIn(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function () {
	        return v;
	      });
	    };

	    Map.prototype.remove = function remove(k) {
	      return updateMap.bind(this)(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function deleteIn(keyPath) {
	      keyPath = [].concat(coerceKeyPath(keyPath));
	      if (keyPath.length) {
	        var lastKey = keyPath.pop();
	        return this.updateIn(keyPath, function (c) {
	          return c && c.remove(lastKey);
	        });
	      }
	    };

	    Map.prototype.deleteAll = function deleteAll(keys) {
	      var collection = Collection(keys);

	      if (collection.size === 0) {
	        return this;
	      }

	      return this.withMutations(function (map) {
	        collection.forEach(function (key) {
	          return map.remove(key);
	        });
	      });
	    };

	    Map.prototype.update = function update(k, notSetValue, updater) {
	      return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function updateIn(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(this, coerceKeyPath(keyPath), 0, notSetValue, updater);
	      return updatedValue === NOT_SET ? notSetValue : updatedValue;
	    };

	    Map.prototype.clear = function clear() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap.bind(this)();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function merge() /*...iters*/{
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function mergeWith(merger) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function mergeIn(keyPath) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return this.updateIn(keyPath, emptyMap.bind(this)(), function (m) {
	        return typeof m.merge === 'function' ? m.merge.apply(m, iters) : iters[iters.length - 1];
	      });
	    };

	    Map.prototype.mergeDeep = function mergeDeep() /*...iters*/{
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function mergeDeepWith(merger) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function mergeDeepIn(keyPath) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return this.updateIn(keyPath, emptyMap.bind(this)(), function (m) {
	        return typeof m.mergeDeep === 'function' ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];
	      });
	    };

	    Map.prototype.sort = function sort(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function sortBy(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function withMutations(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function asMutable() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function asImmutable() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function wasAltered() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function __iterator(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var iterations = 0;
	      this._root && this._root.iterate(function (entry) {
	        iterations++;
	        return fn(entry[1], entry[0], this$1);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        if (this.size === 0) {
	          return emptyMap.bind(this)();
	        }
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap.bind(this)(this.size, this._root, ownerID, this.__hash);
	    };

	    return Map;
	  }(KeyedCollection);

	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;
	  MapPrototype.removeAll = MapPrototype.deleteAll;

	  // #pragma Trie Nodes

	  var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
	    this.ownerID = ownerID;
	    this.entries = entries;
	  };

	  ArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
	    var entries = this.entries;
	    for (var ii = 0, len = entries.length; ii < len; ii++) {
	      if (is(key, entries[ii][0])) {
	        return entries[ii][1];
	      }
	    }
	    return notSetValue;
	  };

	  ArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    var removed = value === NOT_SET;

	    var entries = this.entries;
	    var idx = 0;
	    var len = entries.length;
	    for (; idx < len; idx++) {
	      if (is(key, entries[idx][0])) {
	        break;
	      }
	    }
	    var exists = idx < len;

	    if (exists ? entries[idx][1] === value : removed) {
	      return this;
	    }

	    SetRef(didAlter);
	    (removed || !exists) && SetRef(didChangeSize);

	    if (removed && entries.length === 1) {
	      return; // undefined
	    }

	    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	      return createNodes(ownerID, entries, key, value);
	    }

	    var isEditable = ownerID && ownerID === this.ownerID;
	    var newEntries = isEditable ? entries : arrCopy(entries);

	    if (exists) {
	      if (removed) {
	        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
	      } else {
	        newEntries[idx] = [key, value];
	      }
	    } else {
	      newEntries.push([key, value]);
	    }

	    if (isEditable) {
	      this.entries = newEntries;
	      return this;
	    }

	    return new ArrayMapNode(ownerID, newEntries);
	  };

	  var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
	    this.ownerID = ownerID;
	    this.bitmap = bitmap;
	    this.nodes = nodes;
	  };

	  BitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
	    var bitmap = this.bitmap;
	    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
	  };

	  BitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	    var bit = 1 << keyHashFrag;
	    var bitmap = this.bitmap;
	    var exists = (bitmap & bit) !== 0;

	    if (!exists && value === NOT_SET) {
	      return this;
	    }

	    var idx = popCount(bitmap & bit - 1);
	    var nodes = this.nodes;
	    var node = exists ? nodes[idx] : undefined;
	    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	    if (newNode === node) {
	      return this;
	    }

	    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	    }

	    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	      return nodes[idx ^ 1];
	    }

	    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	      return newNode;
	    }

	    var isEditable = ownerID && ownerID === this.ownerID;
	    var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	    var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);

	    if (isEditable) {
	      this.bitmap = newBitmap;
	      this.nodes = newNodes;
	      return this;
	    }

	    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	  };

	  var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
	    this.ownerID = ownerID;
	    this.count = count;
	    this.nodes = nodes;
	  };

	  HashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	    var node = this.nodes[idx];
	    return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	  };

	  HashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	    var removed = value === NOT_SET;
	    var nodes = this.nodes;
	    var node = nodes[idx];

	    if (removed && !node) {
	      return this;
	    }

	    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	    if (newNode === node) {
	      return this;
	    }

	    var newCount = this.count;
	    if (!node) {
	      newCount++;
	    } else if (!newNode) {
	      newCount--;
	      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	        return packNodes(ownerID, nodes, newCount, idx);
	      }
	    }

	    var isEditable = ownerID && ownerID === this.ownerID;
	    var newNodes = setIn(nodes, idx, newNode, isEditable);

	    if (isEditable) {
	      this.count = newCount;
	      this.nodes = newNodes;
	      return this;
	    }

	    return new HashArrayMapNode(ownerID, newCount, newNodes);
	  };

	  var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
	    this.ownerID = ownerID;
	    this.keyHash = keyHash;
	    this.entries = entries;
	  };

	  HashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
	    var entries = this.entries;
	    for (var ii = 0, len = entries.length; ii < len; ii++) {
	      if (is(key, entries[ii][0])) {
	        return entries[ii][1];
	      }
	    }
	    return notSetValue;
	  };

	  HashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }

	    var removed = value === NOT_SET;

	    if (keyHash !== this.keyHash) {
	      if (removed) {
	        return this;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	    }

	    var entries = this.entries;
	    var idx = 0;
	    var len = entries.length;
	    for (; idx < len; idx++) {
	      if (is(key, entries[idx][0])) {
	        break;
	      }
	    }
	    var exists = idx < len;

	    if (exists ? entries[idx][1] === value : removed) {
	      return this;
	    }

	    SetRef(didAlter);
	    (removed || !exists) && SetRef(didChangeSize);

	    if (removed && len === 2) {
	      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	    }

	    var isEditable = ownerID && ownerID === this.ownerID;
	    var newEntries = isEditable ? entries : arrCopy(entries);

	    if (exists) {
	      if (removed) {
	        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
	      } else {
	        newEntries[idx] = [key, value];
	      }
	    } else {
	      newEntries.push([key, value]);
	    }

	    if (isEditable) {
	      this.entries = newEntries;
	      return this;
	    }

	    return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	  };

	  var ValueNode = function ValueNode(ownerID, keyHash, entry) {
	    this.ownerID = ownerID;
	    this.keyHash = keyHash;
	    this.entry = entry;
	  };

	  ValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
	    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	  };

	  ValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    var removed = value === NOT_SET;
	    var keyMatch = is(key, this.entry[0]);
	    if (keyMatch ? value === this.entry[1] : removed) {
	      return this;
	    }

	    SetRef(didAlter);

	    if (removed) {
	      SetRef(didChangeSize);
	      return; // undefined
	    }

	    if (keyMatch) {
	      if (ownerID && ownerID === this.ownerID) {
	        this.entry[1] = value;
	        return this;
	      }
	      return new ValueNode(ownerID, this.keyHash, [key, value]);
	    }

	    SetRef(didChangeSize);
	    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	  };

	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  };

	  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  };

	  // eslint-disable-next-line no-unused-vars
	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  };

	  var MapIterator = function (Iterator$$1) {
	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    if (Iterator$$1) MapIterator.__proto__ = Iterator$$1;
	    MapIterator.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
	    MapIterator.prototype.constructor = MapIterator;

	    MapIterator.prototype.next = function next() {
	      var this$1 = this;

	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex = void 0;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this$1._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this$1._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this$1._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this$1._stack = this$1._stack.__prev;
	      }
	      return iteratorDone();
	    };

	    return MapIterator;
	  }(Iterator);

	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash$$1) {
	    var map,
	        prototype = MapPrototype;
	    if (this && this.__proto__) {
	      if (this.constructor && this.constructor !== Object) prototype = this.__proto__;
	    }
	    map = Object.create(prototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash$$1;
	    map.__altered = false;
	    map.recoveryData && map.recoveryData(this);
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap.bind(this)(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap.bind(this)(newSize, newRoot) : emptyMap.bind(this)();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, collections) {
	    var iters = [];
	    for (var ii = 0; ii < collections.length; ii++) {
	      var value = collections[ii];
	      var iter = KeyedCollection(value);
	      if (!isCollection(value)) {
	        iter = iter.map(function (v) {
	          return fromJS(v);
	        });
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(oldVal, newVal) {
	    return oldVal && oldVal.mergeDeep && isCollection(newVal) ? oldVal.mergeDeep(newVal) : is(oldVal, newVal) ? oldVal : newVal;
	  }

	  function deepMergerWith(merger) {
	    return function (oldVal, newVal, key) {
	      if (oldVal && oldVal.mergeDeepWith && isCollection(newVal)) {
	        return oldVal.mergeDeepWith(merger, newVal);
	      }
	      var nextValue = merger(oldVal, newVal, key);
	      return is(oldVal, nextValue) ? oldVal : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function (x) {
	      return x.size !== 0;
	    });
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function (collection) {
	      var mergeIntoMap = merger ? function (value, key) {
	        collection.update(key, NOT_SET, function (oldVal) {
	          return oldVal === NOT_SET ? value : merger(oldVal, value, key);
	        });
	      } : function (value, key) {
	        collection.set(key, value);
	      };
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPath, i, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    if (i === keyPath.length) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    if (!(isNotSet || existing && existing.set)) {
	      throw new TypeError('Invalid keyPath: Value at [' + keyPath.slice(0, i).map(quoteString) + '] does not have a .set() method and cannot be updated: ' + existing);
	    }
	    var key = keyPath[i];
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(nextExisting, keyPath, i + 1, notSetValue, updater);
	    return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap.bind(this)() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x -= x >> 1 & 0x55555555;
	    x = (x & 0x33333333) + (x >> 2 & 0x33333333);
	    x = x + (x >> 4) & 0x0f0f0f0f;
	    x += x >> 8;
	    x += x >> 16;
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  var List = function (IndexedCollection$$1) {
	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedCollection$$1(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function (list) {
	        list.setSize(size);
	        iter.forEach(function (v, i) {
	          return list.set(i, v);
	        });
	      });
	    }

	    if (IndexedCollection$$1) List.__proto__ = IndexedCollection$$1;
	    List.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);
	    List.prototype.constructor = List;

	    List.of = function of() /*...values*/{
	      return this(arguments);
	    };

	    List.prototype.toString = function toString() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function get(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function set(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function remove(index) {
	      return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
	    };

	    List.prototype.insert = function insert(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function clear() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function push() /*...values*/{
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function (list) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function pop() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function unshift() /*...values*/{
	      var values = arguments;
	      return this.withMutations(function (list) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function shift() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function merge() /*...iters*/{
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function mergeWith(merger) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function mergeDeep() /*...iters*/{
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function mergeDeepWith(merger) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function setSize(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function slice(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
	    };

	    List.prototype.__iterator = function __iterator(type, reverse) {
	      var index = reverse ? this.size : 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function () {
	        var value = values();
	        return value === DONE ? iteratorDone() : iteratorValue(type, reverse ? --index : index++, value);
	      });
	    };

	    List.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var index = reverse ? this.size : 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, reverse ? --index : index++, this$1) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function __ensureOwner(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        if (this.size === 0) {
	          return emptyList();
	        }
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };

	    return List;
	  }(IndexedCollection);

	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;

	  var VNode = function VNode(array, ownerID) {
	    this.array = array;
	    this.ownerID = ownerID;
	  };

	  // TODO: seems like these methods are very similar

	  VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
	    if (index === level ? 1 << level : 0 || this.array.length === 0) {
	      return this;
	    }
	    var originIndex = index >>> level & MASK;
	    if (originIndex >= this.array.length) {
	      return new VNode([], ownerID);
	    }
	    var removingFirst = originIndex === 0;
	    var newChild;
	    if (level > 0) {
	      var oldChild = this.array[originIndex];
	      newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	      if (newChild === oldChild && removingFirst) {
	        return this;
	      }
	    }
	    if (removingFirst && !newChild) {
	      return this;
	    }
	    var editable = editableVNode(this, ownerID);
	    if (!removingFirst) {
	      for (var ii = 0; ii < originIndex; ii++) {
	        editable.array[ii] = undefined;
	      }
	    }
	    if (newChild) {
	      editable.array[originIndex] = newChild;
	    }
	    return editable;
	  };

	  VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
	    if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	      return this;
	    }
	    var sizeIndex = index - 1 >>> level & MASK;
	    if (sizeIndex >= this.array.length) {
	      return this;
	    }

	    var newChild;
	    if (level > 0) {
	      var oldChild = this.array[sizeIndex];
	      newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	      if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	        return this;
	      }
	    }

	    var editable = editableVNode(this, ownerID);
	    editable.array.splice(sizeIndex + 1);
	    if (newChild) {
	      editable.array[sizeIndex] = newChild;
	    }
	    return editable;
	  };

	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function () {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : left - offset >> level;
	      var to = (right - offset >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function () {
	        while (true) {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
	        }
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function (list) {
	        index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = index >>> level & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << list._level + SHIFT) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[rawIndex >>> level & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin |= 0;
	    }
	    if (end !== undefined) {
	      end |= 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << newLevel + SHIFT) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = oldTailOffset >>> level & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	      // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = newOrigin >>> newLevel & MASK;
	        if (beginIndex !== newTailOffset >>> newLevel & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, collections) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < collections.length; ii++) {
	      var value = collections[ii];
	      var iter = IndexedCollection(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isCollection(value)) {
	        iter = iter.map(function (v) {
	          return fromJS(v);
	        });
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
	  }

	  var OrderedMap = function (Map$$1) {
	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
	        var iter = KeyedCollection(value);
	        assertNotInfinite(iter.size);
	        iter.forEach(function (v, k) {
	          return map.set(k, v);
	        });
	      });
	    }

	    if (Map$$1) OrderedMap.__proto__ = Map$$1;
	    OrderedMap.prototype = Object.create(Map$$1 && Map$$1.prototype);
	    OrderedMap.prototype.constructor = OrderedMap;

	    OrderedMap.of = function of() /*...values*/{
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function toString() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function get(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function clear() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function set(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function remove(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function wasAltered() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      return this._list.__iterate(function (entry) {
	        return entry && fn(entry[1], entry[0], this$1);
	      }, reverse);
	    };

	    OrderedMap.prototype.__iterator = function __iterator(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        if (this.size === 0) {
	          return emptyOrderedMap();
	        }
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };

	    return OrderedMap;
	  }(Map);

	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;

	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) {
	      // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function (entry, idx) {
	          return entry !== undefined && i !== idx;
	        });
	        newMap = newList.toKeyedSeq().map(function (entry) {
	          return entry[0];
	        }).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else if (has) {
	      if (v === list.get(i)[1]) {
	        return omap;
	      }
	      newMap = map;
	      newList = list.set(i, [k, v]);
	    } else {
	      newMap = map.set(k, list.size);
	      newList = list.set(list.size, [k, v]);
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  var Stack = function (IndexedCollection$$1) {
	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
	    }

	    if (IndexedCollection$$1) Stack.__proto__ = IndexedCollection$$1;
	    Stack.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);
	    Stack.prototype.constructor = Stack;

	    Stack.of = function of() /*...values*/{
	      return this(arguments);
	    };

	    Stack.prototype.toString = function toString() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function get(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function peek() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function push() /*...values*/{
	      var arguments$1 = arguments;

	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments$1[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function pushAll(iter) {
	      iter = IndexedCollection$$1(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      if (this.size === 0 && isStack(iter)) {
	        return iter;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.__iterate(function (value) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      },
	      /* reverse */true);
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function pop() {
	      return this.slice(1);
	    };

	    Stack.prototype.clear = function clear() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function slice(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection$$1.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        if (this.size === 0) {
	          return emptyStack();
	        }
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      if (reverse) {
	        return new ArraySeq(this.toArray()).__iterate(function (v, k) {
	          return fn(v, k, this$1);
	        }, reverse);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this$1) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function __iterator(type, reverse) {
	      if (reverse) {
	        return new ArraySeq(this.toArray()).__iterator(type, reverse);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function () {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };

	    return Stack;
	  }(IndexedCollection);

	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;
	  StackPrototype.shift = StackPrototype.pop;
	  StackPrototype.unshift = StackPrototype.push;
	  StackPrototype.unshiftAll = StackPrototype.pushAll;

	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (!isCollection(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function (v, k) {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function (v, k) {
	      if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function keyCopier(key) {
	      ctor.prototype[key] = methods[key];
	    };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  var Set = function (SetCollection$$1) {
	    function Set(value) {
	      return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
	        var iter = SetCollection$$1(value);
	        assertNotInfinite(iter.size);
	        iter.forEach(function (v) {
	          return set.add(v);
	        });
	      });
	    }

	    if (SetCollection$$1) Set.__proto__ = SetCollection$$1;
	    Set.prototype = Object.create(SetCollection$$1 && SetCollection$$1.prototype);
	    Set.prototype.constructor = Set;

	    Set.of = function of() /*...values*/{
	      return this(arguments);
	    };

	    Set.fromKeys = function fromKeys(value) {
	      return this(KeyedCollection(value).keySeq());
	    };

	    Set.intersect = function intersect(sets) {
	      sets = Collection(sets).toArray();
	      return sets.length ? SetPrototype.intersect.apply(Set(sets.pop()), sets) : emptySet();
	    };

	    Set.union = function union(sets) {
	      sets = Collection(sets).toArray();
	      return sets.length ? SetPrototype.union.apply(Set(sets.pop()), sets) : emptySet();
	    };

	    Set.prototype.toString = function toString() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function has(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function add(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function remove(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function clear() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function union() {
	      var iters = [],
	          len = arguments.length;
	      while (len--) {
	        iters[len] = arguments[len];
	      }iters = iters.filter(function (x) {
	        return x.size !== 0;
	      });
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function (set) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetCollection$$1(iters[ii]).forEach(function (value) {
	            return set.add(value);
	          });
	        }
	      });
	    };

	    Set.prototype.intersect = function intersect() {
	      var iters = [],
	          len = arguments.length;
	      while (len--) {
	        iters[len] = arguments[len];
	      }if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function (iter) {
	        return SetCollection$$1(iter);
	      });
	      var toRemove = [];
	      this.forEach(function (value) {
	        if (!iters.every(function (iter) {
	          return iter.includes(value);
	        })) {
	          toRemove.push(value);
	        }
	      });
	      return this.withMutations(function (set) {
	        toRemove.forEach(function (value) {
	          set.remove(value);
	        });
	      });
	    };

	    Set.prototype.subtract = function subtract() {
	      var iters = [],
	          len = arguments.length;
	      while (len--) {
	        iters[len] = arguments[len];
	      }if (iters.length === 0) {
	        return this;
	      }
	      var toRemove = [];
	      this.forEach(function (value) {
	        if (iters.some(function (iter) {
	          return iter.includes(value);
	        })) {
	          toRemove.push(value);
	        }
	      });
	      return this.withMutations(function (set) {
	        toRemove.forEach(function (value) {
	          set.remove(value);
	        });
	      });
	    };

	    Set.prototype.merge = function merge() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function mergeWith(merger) {
	      var iters = [],
	          len = arguments.length - 1;
	      while (len-- > 0) {
	        iters[len] = arguments[len + 1];
	      }return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function sort(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function sortBy(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function wasAltered() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      return this._map.__iterate(function (_, k) {
	        return fn(k, k, this$1);
	      }, reverse);
	    };

	    Set.prototype.__iterator = function __iterator(type, reverse) {
	      return this._map.map(function (_, k) {
	        return k;
	      }).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        if (this.size === 0) {
	          return emptySet();
	        }
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };

	    return Set;
	  }(SetCollection);

	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  /**
	   * Returns a lazy seq of nums from start (inclusive) to end
	   * (exclusive), by step, where start defaults to 0, step to 1, and end to
	   * infinity. When start is equal to end, returns empty list.
	   */
	  var Range = function (IndexedSeq$$1) {
	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    if (IndexedSeq$$1) Range.__proto__ = IndexedSeq$$1;
	    Range.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
	    Range.prototype.constructor = Range;

	    Range.prototype.toString = function toString() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';
	    };

	    Range.prototype.get = function get(index, notSetValue) {
	      return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
	    };

	    Range.prototype.includes = function includes(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function slice(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function indexOf(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index;
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var size = this.size;
	      var step = this._step;
	      var value = reverse ? this._start + (size - 1) * step : this._start;
	      var i = 0;
	      while (i !== size) {
	        if (fn(value, reverse ? size - ++i : i++, this$1) === false) {
	          break;
	        }
	        value += reverse ? -step : step;
	      }
	      return i;
	    };

	    Range.prototype.__iterator = function __iterator(type, reverse) {
	      var size = this.size;
	      var step = this._step;
	      var value = reverse ? this._start + (size - 1) * step : this._start;
	      var i = 0;
	      return new Iterator(function () {
	        if (i === size) {
	          return iteratorDone();
	        }
	        var v = value;
	        value += reverse ? -step : step;
	        return iteratorValue(type, reverse ? size - ++i : i++, v);
	      });
	    };

	    Range.prototype.equals = function equals(other) {
	      return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
	    };

	    return Range;
	  }(IndexedSeq);

	  var EMPTY_RANGE;

	  // Note: all of these methods are deprecated.
	  Collection.isIterable = isCollection;
	  Collection.isKeyed = isKeyed;
	  Collection.isIndexed = isIndexed;
	  Collection.isAssociative = isAssociative;
	  Collection.isOrdered = isOrdered;

	  Collection.Iterator = Iterator;

	  mixin(Collection, {
	    // ### Conversion to other types

	    toArray: function toArray() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function (v, i) {
	        array[i] = v;
	      });
	      return array;
	    },

	    toIndexedSeq: function toIndexedSeq() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function toJS$1() {
	      return this.toSeq().map(toJS).toJSON();
	    },

	    toKeyedSeq: function toKeyedSeq() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function toMap() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function toObject() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function (v, k) {
	        object[k] = v;
	      });
	      return object;
	    },

	    toOrderedMap: function toOrderedMap() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function toOrderedSet() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function toSet() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function toSetSeq() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function toSeq() {
	      return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
	    },

	    toStack: function toStack() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function toList() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },

	    // ### Common JavaScript methods and properties

	    toString: function toString() {
	      return '[Collection]';
	    },

	    __toString: function __toString(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },

	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function concat() {
	      var values = [],
	          len = arguments.length;
	      while (len--) {
	        values[len] = arguments[len];
	      }return reify(this, concatFactory(this, values));
	    },

	    includes: function includes(searchValue) {
	      return this.some(function (value) {
	        return is(value, searchValue);
	      });
	    },

	    entries: function entries() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function every(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function (v, k, c) {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function filter(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function find(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    forEach: function forEach(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function join(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function (v) {
	        isFirst ? isFirst = false : joined += separator;
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function keys() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function map(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function reduce$1(reducer, initialReduction, context) {
	      return reduce(this, reducer, initialReduction, context, arguments.length < 2, false);
	    },

	    reduceRight: function reduceRight(reducer, initialReduction, context) {
	      return reduce(this, reducer, initialReduction, context, arguments.length < 2, true);
	    },

	    reverse: function reverse() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function slice(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function some(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function sort(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function values() {
	      return this.__iterator(ITERATE_VALUES);
	    },

	    // ### More sequential methods

	    butLast: function butLast() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function isEmpty() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function () {
	        return true;
	      });
	    },

	    count: function count(predicate, context) {
	      return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
	    },

	    countBy: function countBy(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function equals(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function entrySeq() {
	      var collection = this;
	      if (collection._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(collection._cache);
	      }
	      var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function () {
	        return collection.toSeq();
	      };

	      // Entries are plain Array, which do not define toJS, so it must
	      // manually converts keys and values before conversion.
	      entriesSequence.toJS = function () {
	        return this.map(function (entry) {
	          return [toJS(entry[0]), toJS(entry[1])];
	        }).toJSON();
	      };

	      return entriesSequence;
	    },

	    filterNot: function filterNot(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findEntry: function findEntry(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function (v, k, c) {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findKey: function findKey(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLast: function findLast(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    findLastEntry: function findLastEntry(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },

	    findLastKey: function findLastKey(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },

	    first: function first() {
	      return this.find(returnTrue);
	    },

	    flatMap: function flatMap(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function flatten(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function fromEntrySeq() {
	      return new FromEntriesSequence(this);
	    },

	    get: function get(searchKey, notSetValue) {
	      return this.find(function (_, key) {
	        return is(key, searchKey);
	      }, undefined, notSetValue);
	    },

	    getIn: function getIn(searchKeyPath, notSetValue) {
	      var nested = this;
	      var keyPath = coerceKeyPath(searchKeyPath);
	      var i = 0;
	      while (i !== keyPath.length) {
	        if (!nested || !nested.get) {
	          throw new TypeError('Invalid keyPath: Value at [' + keyPath.slice(0, i).map(quoteString) + '] does not have a .get() method: ' + nested);
	        }
	        nested = nested.get(keyPath[i++], NOT_SET);
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	      // var step;
	      // while (!(step = iter.next()).done) {
	      //   var key = step.value;
	      //   nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	      //   if (nested === NOT_SET) {
	      //     return notSetValue;
	      //   }
	      // }
	      // return nested;
	    },

	    groupBy: function groupBy(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function has(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function hasIn(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function isSubset(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Collection(iter);
	      return this.every(function (value) {
	        return iter.includes(value);
	      });
	    },

	    isSuperset: function isSuperset(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);
	      return iter.isSubset(this);
	    },

	    keyOf: function keyOf(searchValue) {
	      return this.findKey(function (value) {
	        return is(value, searchValue);
	      });
	    },

	    keySeq: function keySeq() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function last() {
	      return this.toSeq().reverse().first();
	    },

	    lastKeyOf: function lastKeyOf(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },

	    max: function max(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function maxBy(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function min(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function minBy(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function rest() {
	      return this.slice(1);
	    },

	    skip: function skip(amount) {
	      return amount === 0 ? this : this.slice(Math.max(0, amount));
	    },

	    skipLast: function skipLast(amount) {
	      return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
	    },

	    skipWhile: function skipWhile(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function skipUntil(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function sortBy(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function take(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function takeLast(amount) {
	      return this.slice(-Math.max(0, amount));
	    },

	    takeWhile: function takeWhile(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function takeUntil(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    update: function update(fn) {
	      return fn(this);
	    },

	    valueSeq: function valueSeq() {
	      return this.toIndexedSeq();
	    },

	    // ### Hashable Object

	    hashCode: function hashCode() {
	      return this.__hash || (this.__hash = hashCollection(this));
	    }

	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  var CollectionPrototype = Collection.prototype;
	  CollectionPrototype[IS_ITERABLE_SENTINEL] = true;
	  CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
	  CollectionPrototype.toJSON = CollectionPrototype.toArray;
	  CollectionPrototype.__toStringMapper = quoteString;
	  CollectionPrototype.inspect = CollectionPrototype.toSource = function () {
	    return this.toString();
	  };
	  CollectionPrototype.chain = CollectionPrototype.flatMap;
	  CollectionPrototype.contains = CollectionPrototype.includes;

	  mixin(KeyedCollection, {
	    // ### More sequential methods

	    flip: function flip() {
	      return reify(this, flipFactory(this));
	    },

	    mapEntries: function mapEntries(mapper, context) {
	      var this$1 = this;

	      var iterations = 0;
	      return reify(this, this.toSeq().map(function (v, k) {
	        return mapper.call(context, [k, v], iterations++, this$1);
	      }).fromEntrySeq());
	    },

	    mapKeys: function mapKeys(mapper, context) {
	      var this$1 = this;

	      return reify(this, this.toSeq().flip().map(function (k, v) {
	        return mapper.call(context, k, v, this$1);
	      }).flip());
	    }
	  });

	  var KeyedCollectionPrototype = KeyedCollection.prototype;
	  KeyedCollectionPrototype[IS_KEYED_SENTINEL] = true;
	  KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
	  KeyedCollectionPrototype.toJSON = CollectionPrototype.toObject;
	  KeyedCollectionPrototype.__toStringMapper = function (v, k) {
	    return quoteString(k) + ': ' + quoteString(v);
	  };

	  mixin(IndexedCollection, {
	    // ### Conversion to other types

	    toKeyedSeq: function toKeyedSeq() {
	      return new ToKeyedSequence(this, false);
	    },

	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function filter(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function findIndex(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function indexOf(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function lastIndexOf(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    reverse: function reverse() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function slice(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function splice(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum || 0, 0);
	      if (numArgs === 0 || numArgs === 2 && !removeNum) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
	    },

	    // ### More collection methods

	    findLastIndex: function findLastIndex(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    first: function first() {
	      return this.get(0);
	    },

	    flatten: function flatten(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function get(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {
	        return key === index;
	      }, undefined, notSetValue);
	    },

	    has: function has(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
	    },

	    interpose: function interpose(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function interleave() /*...collections*/{
	      var collections = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * collections.length;
	      }
	      return reify(this, interleaved);
	    },

	    keySeq: function keySeq() {
	      return Range(0, this.size);
	    },

	    last: function last() {
	      return this.get(-1);
	    },

	    skipWhile: function skipWhile(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function zip() /*, ...collections */{
	      var collections = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, collections));
	    },

	    zipWith: function zipWith(zipper /*, ...collections */) {
	      var collections = arrCopy(arguments);
	      collections[0] = this;
	      return reify(this, zipWithFactory(this, zipper, collections));
	    }
	  });

	  var IndexedCollectionPrototype = IndexedCollection.prototype;
	  IndexedCollectionPrototype[IS_INDEXED_SENTINEL] = true;
	  IndexedCollectionPrototype[IS_ORDERED_SENTINEL] = true;

	  mixin(SetCollection, {
	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function get(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function includes(value) {
	      return this.has(value);
	    },

	    // ### More sequential methods

	    keySeq: function keySeq() {
	      return this.valueSeq();
	    }
	  });

	  SetCollection.prototype.has = CollectionPrototype.includes;
	  SetCollection.prototype.contains = SetCollection.prototype.includes;

	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedCollection.prototype);
	  mixin(IndexedSeq, IndexedCollection.prototype);
	  mixin(SetSeq, SetCollection.prototype);

	  // #pragma Helper functions

	  function reduce(collection, reducer, reduction, context, useFirst, reverse) {
	    assertNotInfinite(collection.size);
	    collection.__iterate(function (v, k, c) {
	      if (useFirst) {
	        useFirst = false;
	        reduction = v;
	      } else {
	        reduction = reducer.call(context, reduction, v, k, c);
	      }
	    }, reverse);
	    return reduction;
	  }

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function toJS(value) {
	    return value && typeof value.toJS === 'function' ? value.toJS() : value;
	  }

	  function not(predicate) {
	    return function () {
	      return !predicate.apply(this, arguments);
	    };
	  }

	  function neg(predicate) {
	    return function () {
	      return -predicate.apply(this, arguments);
	    };
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashCollection(collection) {
	    if (collection.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(collection);
	    var keyed = isKeyed(collection);
	    var h = ordered ? 1 : 0;
	    var size = collection.__iterate(keyed ? ordered ? function (v, k) {
	      h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
	    } : function (v, k) {
	      h = h + hashMerge(hash(v), hash(k)) | 0;
	    } : ordered ? function (v) {
	      h = 31 * h + hash(v) | 0;
	    } : function (v) {
	      h = h + hash(v) | 0;
	    });
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xcc9e2d51);
	    h = imul(h << 15 | h >>> -15, 0x1b873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xe6546b64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85ebca6b);
	    h = imul(h ^ h >>> 13, 0xc2b2ae35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var OrderedSet = function (Set$$1) {
	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
	        var iter = SetCollection(value);
	        assertNotInfinite(iter.size);
	        iter.forEach(function (v) {
	          return set.add(v);
	        });
	      });
	    }

	    if (Set$$1) OrderedSet.__proto__ = Set$$1;
	    OrderedSet.prototype = Object.create(Set$$1 && Set$$1.prototype);
	    OrderedSet.prototype.constructor = OrderedSet;

	    OrderedSet.of = function of() /*...values*/{
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function fromKeys(value) {
	      return this(KeyedCollection(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function toString() {
	      return this.__toString('OrderedSet {', '}');
	    };

	    return OrderedSet;
	  }(Set);

	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
	  OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
	  OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  var Record = function Record(defaultValues, name) {
	    var hasInitialized;

	    var RecordType = function Record(values) {
	      var this$1 = this;

	      if (values instanceof RecordType) {
	        return values;
	      }
	      if (!(this instanceof RecordType)) {
	        return new RecordType(values);
	      }
	      if (!hasInitialized) {
	        hasInitialized = true;
	        var keys = Object.keys(defaultValues);
	        var indices = RecordTypePrototype._indices = {};
	        RecordTypePrototype._name = name;
	        RecordTypePrototype._keys = keys;
	        RecordTypePrototype._defaultValues = defaultValues;
	        for (var i = 0; i < keys.length; i++) {
	          var propName = keys[i];
	          indices[propName] = i;
	          if (RecordTypePrototype[propName]) {
	            /* eslint-disable no-console */
	            (typeof console === 'undefined' ? 'undefined' : _typeof(console)) === 'object' && console.warn && console.warn('Cannot define ' + recordName(this$1) + ' with property "' + propName + '" since that property name is part of the Record API.');
	            /* eslint-enable no-console */
	          } else {
	            setProp(RecordTypePrototype, propName);
	          }
	        }
	      }
	      this.__ownerID = undefined;
	      this._values = List().withMutations(function (l) {
	        l.setSize(this$1._keys.length);
	        KeyedCollection(values).forEach(function (v, k) {
	          l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);
	        });
	      });
	    };

	    var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	    RecordTypePrototype.constructor = RecordType;

	    return RecordType;
	  };

	  Record.prototype.toString = function toString() {
	    var this$1 = this;

	    var str = recordName(this) + ' { ';
	    var keys = this._keys;
	    var k;
	    for (var i = 0, l = keys.length; i !== l; i++) {
	      k = keys[i];
	      str += (i ? ', ' : '') + k + ': ' + quoteString(this$1.get(k));
	    }
	    return str + ' }';
	  };

	  Record.prototype.equals = function equals(other) {
	    return this === other || this._keys === other._keys && recordSeq(this).equals(recordSeq(other));
	  };

	  Record.prototype.hashCode = function hashCode() {
	    return recordSeq(this).hashCode();
	  };

	  // @pragma Access

	  Record.prototype.has = function has(k) {
	    return this._indices.hasOwnProperty(k);
	  };

	  Record.prototype.get = function get(k, notSetValue) {
	    if (!this.has(k)) {
	      return notSetValue;
	    }
	    var index = this._indices[k];
	    var value = this._values.get(index);
	    return value === undefined ? this._defaultValues[k] : value;
	  };

	  // @pragma Modification

	  Record.prototype.set = function set(k, v) {
	    if (this.has(k)) {
	      var newValues = this._values.set(this._indices[k], v === this._defaultValues[k] ? undefined : v);
	      if (newValues !== this._values && !this.__ownerID) {
	        return makeRecord(this, newValues);
	      }
	    }
	    return this;
	  };

	  Record.prototype.remove = function remove(k) {
	    return this.set(k);
	  };

	  Record.prototype.clear = function clear() {
	    var newValues = this._values.clear().setSize(this._keys.length);
	    return this.__ownerID ? this : makeRecord(this, newValues);
	  };

	  Record.prototype.wasAltered = function wasAltered() {
	    return this._values.wasAltered();
	  };

	  Record.prototype.toSeq = function toSeq() {
	    return recordSeq(this);
	  };

	  Record.prototype.toJS = function toJS() {
	    return recordSeq(this).toJS();
	  };

	  Record.prototype.__iterator = function __iterator(type, reverse) {
	    return recordSeq(this).__iterator(type, reverse);
	  };

	  Record.prototype.__iterate = function __iterate(fn, reverse) {
	    return recordSeq(this).__iterate(fn, reverse);
	  };

	  Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
	    if (ownerID === this.__ownerID) {
	      return this;
	    }
	    var newValues = this._values.__ensureOwner(ownerID);
	    if (!ownerID) {
	      this.__ownerID = ownerID;
	      this._values = newValues;
	      return this;
	    }
	    return makeRecord(this, newValues, ownerID);
	  };

	  Record.isRecord = isRecord;
	  Record.getDescriptiveName = recordName;
	  var RecordPrototype = Record.prototype;
	  RecordPrototype[IS_RECORD_SENTINEL] = true;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.getIn = CollectionPrototype.getIn;
	  RecordPrototype.hasIn = CollectionPrototype.hasIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;
	  RecordPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
	  RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
	  RecordPrototype.inspect = RecordPrototype.toSource = CollectionPrototype.toSource;

	  function makeRecord(likeRecord, values, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._values = values;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function recordSeq(record) {
	    return keyedSeqFromValue(record._keys.map(function (k) {
	      return [k, record.get(k)];
	    }));
	  }

	  function setProp(prototype, name) {
	    try {
	      Object.defineProperty(prototype, name, {
	        get: function get() {
	          return this.get(name);
	        },
	        set: function set(value) {
	          invariant(this.__ownerID, 'Cannot set on an immutable record.');
	          this.set(name, value);
	        }
	      });
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  /**
	   * Returns a lazy Seq of `value` repeated `times` times. When `times` is
	   * undefined, returns an infinite sequence of `value`.
	   */
	  var Repeat = function (IndexedSeq$$1) {
	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    if (IndexedSeq$$1) Repeat.__proto__ = IndexedSeq$$1;
	    Repeat.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
	    Repeat.prototype.constructor = Repeat;

	    Repeat.prototype.toString = function toString() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function get(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function includes(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function slice(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function reverse() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function indexOf(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function __iterate(fn, reverse) {
	      var this$1 = this;

	      var size = this.size;
	      var i = 0;
	      while (i !== size) {
	        if (fn(this$1._value, reverse ? size - ++i : i++, this$1) === false) {
	          break;
	        }
	      }
	      return i;
	    };

	    Repeat.prototype.__iterator = function __iterator(type, reverse) {
	      var this$1 = this;

	      var size = this.size;
	      var i = 0;
	      return new Iterator(function () {
	        return i === size ? iteratorDone() : iteratorValue(type, reverse ? size - ++i : i++, this$1._value);
	      });
	    };

	    Repeat.prototype.equals = function equals(other) {
	      return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);
	    };

	    return Repeat;
	  }(IndexedSeq);

	  var EMPTY_REPEAT;

	  var Immutable = {
	    Collection: Collection,
	    // Note: Iterable is deprecated
	    Iterable: Collection,

	    Seq: Seq,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS,
	    hash: hash,

	    isImmutable: isImmutable,
	    isCollection: isCollection,
	    isKeyed: isKeyed,
	    isIndexed: isIndexed,
	    isAssociative: isAssociative,
	    isOrdered: isOrdered,
	    isValueObject: isValueObject
	  };

	  // Note: Iterable is deprecated
	  var Iterable = Collection;

	  exports['default'] = Immutable;
	  exports.Collection = Collection;
	  exports.Iterable = Iterable;
	  exports.Seq = Seq;
	  exports.Map = Map;
	  exports.OrderedMap = OrderedMap;
	  exports.List = List;
	  exports.Stack = Stack;
	  exports.Set = Set;
	  exports.OrderedSet = OrderedSet;
	  exports.Record = Record;
	  exports.Range = Range;
	  exports.Repeat = Repeat;
	  exports.is = is;
	  exports.fromJS = fromJS;
	  exports.hash = hash;
	  exports.isImmutable = isImmutable;
	  exports.isCollection = isCollection;
	  exports.isKeyed = isKeyed;
	  exports.isIndexed = isIndexed;
	  exports.isAssociative = isAssociative;
	  exports.isOrdered = isOrdered;
	  exports.isValueObject = isValueObject;

	  Object.defineProperty(exports, '__esModule', { value: true });
	});

/***/ }),
/* 195 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var _typeof2 = function _typeof2(arg) {
	    return Object.prototype.toString.call(arg);
	};

	var isArray = function isArray(arg) {
	    return _typeof2(arg) === '[object Array]';
	};

	var isDate = function isDate(arg) {
	    return _typeof2(arg) === '[object Date]';
	};

	var isRegExp = function isRegExp(arg) {
	    return _typeof2(arg) === '[object RegExp]';
	};

	var isObject = function isObject(arg) {
	    return _typeof2(arg) === '[object Object]';
	};

	var isFunction = function isFunction(arg) {
	    return _typeof2(arg) === '[object Function]';
	};

	var _copy = function _copy(source, destination, stackSource, stackDest) {

	    if (!destination) {
	        destination = source;
	        if (source) {
	            if (isArray(source)) {
	                destination = _copy(source, [], stackSource, stackDest);
	            } else if (isDate(source)) {
	                destination = new Date(source.getTime());
	            } else if (isRegExp(source)) {
	                destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
	                destination.lastIndex = source.lastIndex;
	            } else if (isObject(source)) {
	                var emptyObject = Object.create(Object.getPrototypeOf(source));
	                destination = _copy(source, emptyObject, stackSource, stackDest);
	            }
	        }
	    } else {
	        if (source === destination) throw new Error("Can't copy! Source and destination are identical.");
	        stackSource = stackSource || [];
	        stackDest = stackDest || [];
	        if (isObject(source)) {
	            var index = stackSource.indexOf(source);
	            if (index !== -1) return stackDest[index];
	            stackSource.push(source);
	            stackDest.push(destination);
	        }
	        var result;
	        if (isArray(source)) {
	            destination.length = 0;
	            for (var i = 0; i < source.length; i++) {
	                result = _copy(source[i], null, stackSource, stackDest);
	                if (isObject(source[i])) {
	                    stackSource.push(source[i]);
	                    stackDest.push(result);
	                }
	                destination.push(result);
	            }
	        } else {
	            if (isArray(destination)) {
	                destination.length = 0;
	            } else {
	                for (var key in destination) {
	                    delete destination[key];
	                }
	            }
	            for (var key in source) {
	                if (source.hasOwnProperty(key)) {
	                    result = _copy(source[key], null, stackSource, stackDest);
	                    if (isObject(source[key])) {
	                        stackSource.push(source[key]);
	                        stackDest.push(result);
	                    }
	                    destination[key] = result;
	                }
	            }
	        }
	    }
	    return destination;
	};

	var getCode = function getCode() {
	    return (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
	};

	var offset = function offset(ele) {
	    var top = ele.offsetTop;
	    var left = ele.offsetLeft;
	    while (ele.offsetParent) {
	        ele = ele.offsetParent;
	        if (window.navigator.userAgent.indexOf('MSTE 8') > -1) {
	            top += ele.offsetTop;
	            left += ele.offsetLeft;
	        } else {
	            top += ele.offsetTop + ele.clientTop;
	            left += ele.offsetLeft + ele.clientLeft;
	        }
	    }
	    return {
	        left: left,
	        top: top
	    };
	};

	exports.default = {
	    isArray: isArray,

	    isDate: isDate,

	    isRegExp: isRegExp,

	    isObject: isObject,

	    offset: offset,

	    isFunction: isFunction,

	    /**
	     *   objectfunction
	     **/
	    copy: function copy(arg) {
	        return _copy.call(this, arg);
	    },

	    /**
	     * 
	     **/
	    typeof: function _typeof(arg) {
	        return _typeof2.call(this, arg);
	    },

	    guid: function guid() {
	        return getCode() + getCode() + '-' + getCode() + '-' + getCode() + '-' + getCode() + '-' + getCode() + getCode() + getCode();
	    }
	};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _style2 = __webpack_require__(197);

	var _style3 = _interopRequireDefault(_style2);

	var _immutable = __webpack_require__(194);

	var _immutable2 = _interopRequireDefault(_immutable);

	var _utils = __webpack_require__(195);

	var _utils2 = _interopRequireDefault(_utils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *    @class component immutableMap
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * immutable
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  @constructor offseticon
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                **/

	var componentMap = void 0;

	setTimeout(function () {
	    if (!componentMap) {
	        componentMap = __webpack_require__(198).default; //
	    }
	});

	function OwnerID() {};

	function makeComponent(size, root, ownerID, hash) {
	    var component = Object.create(ComponentPrototype);
	    component.size = size;
	    component._root = root;
	    component.__ownerID = ownerID;
	    component.__hash = hash;
	    component.__altered = false;
	    return component;
	}

	var Component = function (_Immutable$Map) {
	    _inherits(Component, _Immutable$Map);

	    function Component(offset, icon) {
	        _classCallCheck(this, Component);

	        var style = new _style3.default({
	            left: offset.left,
	            top: offset.top,
	            position: 'absolute',
	            width: 300,
	            height: 200
	        }),
	            _attrs = _immutable2.default.Map({ className: "component" });

	        var _this = _possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).call(this, { style: style, _attrs: _attrs, children: _immutable2.default.List([]) }));

	        if (_this.__proto__ !== Component.prototype) {
	            _this.__proto__ = Component.prototype;
	        }
	        _this.icon = icon;
	        _this.id = _utils2.default.guid();
	        _this.style = _this.get("style"); //
	        _this.children = _this.get("children"); //
	        return _this;
	    }
	    /**
	     * @method getNewCom component
	     * */


	    _createClass(Component, [{
	        key: 'getNewCom',
	        value: function getNewCom() {
	            var _this2 = this;

	            var newCom = makeComponent(this.size, this._root, new OwnerID(), this.__hash),
	                methods = void 0;
	            methods = Object.keys(this);
	            methods.map(function (e) {
	                if (!newCom[e]) {
	                    newCom[e] = _this2[e];
	                }
	            });
	            return newCom;
	        }
	    }, {
	        key: 'copy',
	        value: function copy() {
	            //
	            var component = Object.create(Component.prototype),
	                children = _immutable2.default.List([]);
	            component.size = this.size;
	            component.__altered = false;
	            component.id = _utils2.default.guid();
	            component.icon = this.icon;

	            component = component.set('style', new _style3.default(this.style.toObject()));
	            component.style = component.get("style");
	            component = component.set('_attrs', this.get("_attrs"));
	            this.children.forEach(function (e, i) {
	                children = children.push(e.copy());
	            });
	            component = component.set('children', children);
	            component.children = children;

	            return component;
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON() {
	            var object = {};
	            this.__iterate(function (v, k) {
	                object[k] = v;
	            });
	            object.icon = this.icon;
	            object.id = this.id;
	            object.path = this.path;
	            object.parentId = this.parentId;
	            return object;
	        }
	        /**
	         * @method Map
	         * */

	    }, {
	        key: 'recoveryData',
	        value: function recoveryData(prevData) {
	            if (prevData && prevData.constructor === Component) {
	                this.icon = prevData.icon;
	                this.id = prevData.id;
	                this.path = prevData.path;
	                this.parentId = prevData.parentId;
	                this.style = this.get("style");
	                this.children = this.get("children");
	            }
	        }
	    }, {
	        key: 'commonStyle',
	        value: function commonStyle() {
	            return {
	                'box-sizing': 'border-box'
	            };
	        }
	    }, {
	        key: 'getStyle',
	        value: function getStyle() {
	            return this.style.toObject();
	        }
	        /**
	         * style
	         * */

	    }, {
	        key: 'getNoPosStyle',
	        value: function getNoPosStyle() {
	            return this.style.getNoPosStyle();
	        }
	        /**
	         * style 
	         * */

	    }, {
	        key: 'getPosStyle',
	        value: function getPosStyle() {
	            return this.style.getPosStyle();
	        }
	    }, {
	        key: 'setStyle',
	        value: function setStyle(_style) {}
	        /**
	         * REACTDOM
	         * */

	    }, {
	        key: 'getReactComponent',
	        value: function getReactComponent() {
	            if (this.icon) {
	                var comName = this.icon[0].toUpperCase() + this.icon.slice(1),
	                    reactComponent = componentMap[comName];
	                if (!reactComponent) {
	                    throw new Error('no find reactComponent named ' + comName + ',make sure add ' + comName + ' code');
	                    //reactComponent = componentMap.ComponentBase;
	                }
	                return reactComponent;
	            }
	        }
	    }, {
	        key: 'attrs',
	        set: function set(val) {
	            if (_immutable2.default.Map.isMap(val) || _utils2.default.isObject(val)) {
	                this.set("_attrs", val);
	            }
	        },
	        get: function get() {
	            return this.get("_attrs").toObject();
	        }
	    }]);

	    return Component;
	}(_immutable2.default.Map);

	var ComponentPrototype = Component.prototype;
	Component.toComponent = function (comObj) {
	    if (_utils2.default.isObject(comObj) && comObj.constructor !== Component) {
	        var component = Object.create(Component.prototype),
	            children = _immutable2.default.List([]);
	        component.size = comObj.size;
	        component.__altered = false;
	        component.id = comObj.id;
	        component.icon = comObj.icon;
	        component.path = comObj.path;

	        component = component.set('style', new _style3.default(comObj.style));
	        component.style = component.get("style");
	        component = component.set('_attrs', _immutable2.default.Map(comObj._attrs));
	        comObj.children.forEach(function (e, i) {
	            if (_utils2.default.isObject(e)) {
	                children = children.push(Component.toComponent(e));
	            }
	        });
	        component = component.set('children', children);
	        component.children = children;

	        return component;
	    }
	};
	exports.default = Component;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _immutable = __webpack_require__(194);

	var _immutable2 = _interopRequireDefault(_immutable);

	var _utils = __webpack_require__(195);

	var _utils2 = _interopRequireDefault(_utils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var posStyle = ['left', 'top', 'right', 'bottom', 'margin', 'marginLeft', 'marginTOP', 'marginRight', 'marginBottom', 'position', 'zIndex'];
	var comStyle = ['width', 'height'];

	var Style = function (_Immutable$Map) {
	    _inherits(Style, _Immutable$Map);

	    function Style(_style) {
	        _classCallCheck(this, Style);

	        var _this = _possibleConstructorReturn(this, (Style.__proto__ || Object.getPrototypeOf(Style)).call(this, _style));

	        if (_this.__proto__ !== Style.prototype) {
	            _this.__proto__ = Style.prototype;
	        }
	        var instance = _this;
	        if (_style && _typeof(_utils2.default.isObject(_style))) {
	            instance.styleKeys = Object.keys(_style);

	            var _loop = function _loop(name) {
	                Object.defineProperty(_this, name, {
	                    get: function get() {
	                        return instance.get(name);
	                    },
	                    set: function set(val) {
	                        var newStyle = instance.set(name, val);
	                        //
	                        instance.styleChange && instance.styleChange.apply(instance, [name, val]);
	                        return newStyle;
	                    }
	                });
	            };

	            for (var name in _style) {
	                _loop(name);
	            }
	        } else {
	            instance._style = _immutable2.default.Map({});
	        }
	        return _this;
	    }

	    _createClass(Style, [{
	        key: 'recoveryData',
	        value: function recoveryData(prevData) {
	            var _this2 = this;

	            if (prevData && prevData.constructor === Style) {
	                var instance = this;
	                if (prevData.styleKeys) {
	                    this.styleKeys = prevData.styleKeys;
	                    prevData.styleKeys.map(function (name, i) {
	                        Object.defineProperty(_this2, name, {
	                            get: function get() {
	                                return instance.get(name);
	                            },
	                            set: function set(val) {
	                                var newStyle = instance.set(name, val);
	                                //
	                                instance.styleChange && instance.styleChange.apply(instance, [name, val]);
	                                return newStyle;
	                            }
	                        });
	                    });
	                }
	            }
	        }
	        /**
	         * style
	         * */

	    }, {
	        key: 'getNoPosStyle',
	        value: function getNoPosStyle() {
	            var $$noPosStyle = this.toObject();
	            posStyle.forEach(function (e, i) {
	                if ($$noPosStyle[e] !== undefined) {
	                    delete $$noPosStyle[e];
	                }
	            });
	            return $$noPosStyle;
	        }
	        /**
	         * style 
	         * */

	    }, {
	        key: 'getPosStyle',
	        value: function getPosStyle() {
	            var $$noPosStyle = this,
	                style = {};
	            posStyle.forEach(function (e, i) {
	                if ($$noPosStyle.get(e)) {
	                    style[e] = $$noPosStyle.get(e);
	                }
	            });
	            comStyle.forEach(function (e, i) {
	                if ($$noPosStyle.get(e)) {
	                    style[e] = $$noPosStyle.get(e);
	                }
	            });
	            return style;
	        }
	    }, {
	        key: 'addStyle',
	        value: function addStyle(name, val) {
	            var instance = this;
	            if (this.hasOwnProperty(name)) {
	                return;
	            }
	            Object.defineProperty(this, name, {
	                get: function get() {
	                    return instance._style.get(name);
	                },
	                set: function set(val) {
	                    instance._style = instance._style.set(name, val);
	                    instance.styleChange && instance.styleChange.apply(instance, [name, val]);
	                }
	            });
	            if (val) {
	                instance[name] = val;
	            }
	        }
	    }, {
	        key: 'styleChange',
	        value: function styleChange() {}
	    }]);

	    return Style;
	}(_immutable2.default.Map);

	exports.default = Style;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _div = __webpack_require__(199);

	var _div2 = _interopRequireDefault(_div);

	var _ComponentBase = __webpack_require__(202);

	var _ComponentBase2 = _interopRequireDefault(_ComponentBase);

	var _pieChart = __webpack_require__(203);

	var _pieChart2 = _interopRequireDefault(_pieChart);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
	    Div: _div2.default,
	    PieChart: _pieChart2.default,
	    ComponentBase: _ComponentBase2.default
	};

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _componentBase = __webpack_require__(200);

	var _componentBase2 = _interopRequireDefault(_componentBase);

	var _editDecorator = __webpack_require__(201);

	var _editDecorator2 = _interopRequireDefault(_editDecorator);

	var _reactImmutableRenderMixin = __webpack_require__(185);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Div = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = (0, _editDecorator2.default)(_class = function (_ComponentBase) {
	    _inherits(Div, _ComponentBase);

	    function Div(props) {
	        _classCallCheck(this, Div);

	        return _possibleConstructorReturn(this, (Div.__proto__ || Object.getPrototypeOf(Div)).call(this, props));
	    }

	    return Div;
	}(_componentBase2.default)) || _class) || _class;

	exports.default = Div;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ComponentBase = function (_Component) {
	    _inherits(ComponentBase, _Component);

	    function ComponentBase(props) {
	        _classCallCheck(this, ComponentBase);

	        var _this = _possibleConstructorReturn(this, (ComponentBase.__proto__ || Object.getPrototypeOf(ComponentBase)).call(this, props));

	        _this.initComponent(props);
	        _this.state = {
	            id: _this.props.component.id,
	            component: _this.props.component
	        };
	        return _this;
	    }

	    _createClass(ComponentBase, [{
	        key: 'getProps',
	        value: function getProps() {
	            return _extends({
	                id: this.state.id,
	                name: this.props.component.name
	            }, this.props.component.attrs, {
	                style: this.props.component.getNoPosStyle()
	            });
	        }
	    }, {
	        key: 'template',
	        value: function template() {
	            // 
	            var props = this.getProps(),
	                dom = _react2.default.createElement('div', props, this.props.children);
	            return dom;
	        }
	    }, {
	        key: 'initComponent',
	        value: function initComponent(props) {
	            if (!props.component) {
	                console.error('component init error by constructor');
	                return false;
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var template = this.template();
	            return template;
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            if (this.props.component.style.styleChange) {
	                /*this.props.component.style.styleChange = (name,val)=>{
	                    this.setState()
	                }*/
	            }
	        }
	    }]);

	    return ComponentBase;
	}(_react.Component);

	exports.default = ComponentBase;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = editDecorator;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(37);

	var _server = __webpack_require__(192);

	var _server2 = _interopRequireDefault(_server);

	var _utils = __webpack_require__(195);

	var _utils2 = _interopRequireDefault(_utils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   editDecorator.js  
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * **/


	var manage = _server2.default.manage;

	function editDecorator(Target) {
	    var editBox = function (_Component) {
	        _inherits(editBox, _Component);

	        function editBox(props) {
	            _classCallCheck(this, editBox);

	            var _this = _possibleConstructorReturn(this, (editBox.__proto__ || Object.getPrototypeOf(editBox)).call(this, props));

	            _this.state = {
	                drag: false,
	                n: 0,
	                active: true
	            };
	            _this.style = _this.props.component.style.getPosStyle();
	            _this.component = _this.props.component;
	            _this.changePos = _this.changePos.bind(_this);
	            _this.boxMouseUp = _this.boxMouseUp.bind(_this);
	            _this.boxMouseMove = _this.boxMouseMove.bind(_this);
	            _this.boxMouseDown = _this.boxMouseDown.bind(_this);
	            _this.boxMouseOut = _this.boxMouseOut.bind(_this);
	            _this.borderMouseMove = _this.borderMouseMove.bind(_this);
	            _this.borderMouseUp = _this.borderMouseUp.bind(_this);

	            return _this;
	        }

	        _createClass(editBox, [{
	            key: 'changePos',
	            value: function changePos() {
	                this.setState({ n: ++this.state.n });
	            }
	        }, {
	            key: 'borderMouseDown',
	            value: function borderMouseDown(type, evt) {
	                if (evt.target.parentElement.className.indexOf("resizeBox") > -1) {
	                    evt.stopPropagation();
	                    this.move = true;
	                    this.x = evt.clientX;
	                    this.y = evt.clientY;
	                    this.type = type;
	                    _server2.default.emit('listItem:resize_start', type, { up: this.borderMouseUp, move: this.borderMouseMove });
	                    !this.state.active && this.setState({ active: true });
	                    manage.currentId = this.component.id;
	                }
	            }
	        }, {
	            key: 'borderMouseMove',
	            value: function borderMouseMove(evt) {
	                if (this.move) {
	                    var dx = void 0,
	                        dy = void 0,
	                        style = this.style;
	                    switch (this.type) {
	                        case 'n':
	                            {
	                                dy = evt.clientY - this.y;
	                                if (dy <= style.height) {
	                                    style.height -= dy;
	                                    style.top += dy;
	                                }
	                                break;
	                            }
	                        case 'e':
	                            {
	                                dx = evt.clientX - this.x;
	                                if (-dx <= style.width) {
	                                    style.width += dx;
	                                }
	                                break;
	                            }
	                        case 's':
	                            {
	                                dy = this.y - evt.clientY;
	                                if (dy <= style.height) {
	                                    style.height -= dy;
	                                }
	                                break;
	                            }
	                        case 'w':
	                            {
	                                dx = evt.clientX - this.x;
	                                if (dx <= style.width) {
	                                    style.width -= dx;
	                                    style.left += dx;
	                                }
	                                break;
	                            }
	                        case 'se':
	                            {
	                                dx = this.x - evt.clientX;
	                                dy = this.y - evt.clientY;
	                                if (dx <= style.width && dy <= style.height) {
	                                    style.width -= dx;
	                                    style.height -= dy;
	                                }
	                                break;
	                            }
	                        default:
	                            break;
	                    }
	                    manage.update(this.component.mergeIn(['style'], this.style), true);
	                    this.x = evt.clientX;
	                    this.y = evt.clientY;
	                }
	            }
	        }, {
	            key: 'borderMouseUp',
	            value: function borderMouseUp(evt) {
	                this.move = false;
	                this.type = "";
	                manage.update(this.component.mergeIn(['style'], this.style));
	            }
	        }, {
	            key: 'getDropTarget',
	            value: function getDropTarget(evt) {
	                var _this2 = this;

	                var drops = document.querySelectorAll('#canvas .component'),
	                    currentZindex = void 0,
	                    target = void 0;
	                drops.forEach(function (e, i) {
	                    if (e.parentElement === _this2.boxDom) {
	                        return;
	                    }
	                    var left = _utils2.default.offset(e).left,
	                        top = _utils2.default.offset(e).top;
	                    if (evt.clientX > left && evt.clientX < left + e.offsetWidth && evt.clientY > top && evt.clientY < top + e.offsetHeight) {
	                        if (e.parentElement.style.zIndex !== "") {
	                            if (currentZindex === undefined) {
	                                currentZindex = ~~e.parentElement.style.zIndex;
	                                target = e;
	                            } else if (e.parentElement.style.zIndex - currentZindex >= 0) {
	                                currentZindex = ~~e.parentElement.style.zIndex;
	                                target = e;
	                            }
	                        } else if (currentZindex === undefined || currentZindex < 0) {
	                            target = e;
	                        }
	                    }
	                });
	                target && console.log(target.getAttribute('id') + ' can drop');
	            }
	        }, {
	            key: 'boxMouseMove',
	            value: function boxMouseMove(evt) {
	                if (this.isMove) {
	                    var _x = evt.clientX - this.x,
	                        _y = evt.clientY - this.y;
	                    this.style.left = this.startLeft + _x + this.boxParentDom.scrollLeft - this.parentScrollLeft;
	                    this.style.top = this.startTop + _y + this.boxParentDom.scrollTop - this.parentScrollTop;
	                    manage.update(this.component.mergeIn(['style'], this.style), true);
	                }
	            }
	        }, {
	            key: 'boxMouseUp',
	            value: function boxMouseUp(evt) {
	                this.isMove = false;
	                this.setState({ drag: false });
	                this.getDropTarget(evt);
	                manage.update(this.component.mergeIn(['style'], this.style));
	            }
	        }, {
	            key: 'boxMouseDown',
	            value: function boxMouseDown(evt) {
	                if (!this.isMove) {
	                    this.isMove = true;
	                    //
	                    this.x = evt.clientX;
	                    this.y = evt.clientY;
	                    this.parentScrollLeft = this.boxParentDom.scrollLeft;
	                    this.parentScrollTop = this.boxParentDom.scrollTop;
	                    this.startLeft = this.style.left;
	                    this.startTop = this.style.top;
	                    _server2.default.emit('listItem:box_start', { up: this.boxMouseUp, move: this.boxMouseMove, id: this.props.component.id });
	                    _server2.default.emit('listItem:clear_active', this.component.id);
	                    this.setState({ drag: true, active: true });
	                    manage.currentId = this.component.id;
	                }
	            }
	        }, {
	            key: 'boxMouseOut',
	            value: function boxMouseOut() {
	                this.isMove = false;
	                this.setState({ drag: false });
	            }
	        }, {
	            key: 'render',
	            value: function render() {
	                var posStyle = this.style;
	                return _react2.default.createElement(
	                    'div',
	                    { className: (this.state.drag ? "resizeBox drag" : "resizeBox") + (this.state.active ? ' active' : ''), key: this.component.id + "_edit", onMouseDown: this.boxMouseDown, style: _extends({}, posStyle) },
	                    _react2.default.createElement(
	                        Target,
	                        _extends({}, this.props, { isDrag: this.state.drag }),
	                        this.props.children
	                    ),
	                    _react2.default.createElement('div', { className: 'n', onMouseDown: this.borderMouseDown.bind(this, 'n'), style: { width: posStyle.width, left: 0, top: -2 } }),
	                    _react2.default.createElement('div', { className: 'e', onMouseDown: this.borderMouseDown.bind(this, 'e'), style: { height: posStyle.height, right: -2, top: 0 } }),
	                    _react2.default.createElement('div', { className: 's', onMouseDown: this.borderMouseDown.bind(this, 's'), style: { width: posStyle.width, left: 0, bottom: -2 } }),
	                    _react2.default.createElement('div', { className: 'w', onMouseDown: this.borderMouseDown.bind(this, 'w'), style: { height: posStyle.height, left: -2, top: 0 } }),
	                    _react2.default.createElement('div', { className: 'se', onMouseDown: this.borderMouseDown.bind(this, 'se'), style: { right: -2, bottom: -2 } })
	                );
	            }
	        }, {
	            key: 'componentWillUpdate',
	            value: function componentWillUpdate(nextProps, nextState, nextContent) {
	                this.style = nextProps.component.style.getPosStyle();
	                this.component = nextProps.component;
	            }
	        }, {
	            key: 'componentDidMount',
	            value: function componentDidMount() {
	                var _this3 = this;

	                this.boxDom = (0, _reactDom.findDOMNode)(this);
	                this.boxParentDom = this.boxDom.parentElement;

	                _server2.default.emit('listItem:clear_active', this.component.id);
	                manage.currentId = this.component.id;

	                _server2.default.on('listItem:resize_move', this.borderMouseMove);
	                _server2.default.on('listItem:resize_end', this.borderMouseUp);
	                _server2.default.on('listItem:box_move', this.boxMouseMove);
	                _server2.default.on('listItem:box_end', this.boxMouseUp);
	                _server2.default.on('listItem:clear_active', this.clearActive = function (currentActiveId) {
	                    if (currentActiveId === _this3.component.id) {
	                        return;
	                    }
	                    _this3.state.active && _this3.setState({ active: false });
	                });
	            }
	        }, {
	            key: 'componentWillUnmount',
	            value: function componentWillUnmount() {
	                _server2.default.off('listItem:resize_move', this.borderMouseMove);
	                _server2.default.off('listItem:resize_end', this.borderMouseUp);
	                _server2.default.off('listItem:box_move', this.boxMouseMove);
	                _server2.default.off('listItem:box_end', this.boxMouseUp);
	                _server2.default.off('listItem:clear_active', this.clearActive);
	            }
	        }]);

	        return editBox;
	    }(_react.Component);

	    return editBox;
	}

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ComponentBase = function (_Component) {
	    _inherits(ComponentBase, _Component);

	    function ComponentBase(props) {
	        _classCallCheck(this, ComponentBase);

	        var _this = _possibleConstructorReturn(this, (ComponentBase.__proto__ || Object.getPrototypeOf(ComponentBase)).call(this, props));

	        _this.initComponent(props);
	        _this.state = {
	            id: _this.props.component.id,
	            component: _this.props.component
	        };
	        return _this;
	    }

	    _createClass(ComponentBase, [{
	        key: 'getProps',
	        value: function getProps() {
	            return _extends({
	                id: this.state.id,
	                name: this.props.component.name
	            }, this.props.component.attrs, {
	                style: this.props.component.getNoPosStyle()
	            });
	        }
	    }, {
	        key: 'template',
	        value: function template() {
	            // 
	            var props = this.getProps(),
	                dom = _react2.default.createElement('div', props, this.props.children);
	            return dom;
	        }
	    }, {
	        key: 'initComponent',
	        value: function initComponent(props) {
	            if (!props.component) {
	                console.error('component init error by constructor');
	                return false;
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var template = this.template();
	            return template;
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            if (this.props.component.style.styleChange) {
	                /*this.props.component.style.styleChange = (name,val)=>{
	                    this.setState()
	                }*/
	            }
	        }
	    }]);

	    return ComponentBase;
	}(_react.Component);

	exports.default = ComponentBase;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _chartBase = __webpack_require__(204);

	var _chartBase2 = _interopRequireDefault(_chartBase);

	var _editDecorator = __webpack_require__(201);

	var _editDecorator2 = _interopRequireDefault(_editDecorator);

	var _reactImmutableRenderMixin = __webpack_require__(185);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var PieChart = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = (0, _editDecorator2.default)(_class = function (_ChartBase) {
	    _inherits(PieChart, _ChartBase);

	    function PieChart(props) {
	        _classCallCheck(this, PieChart);

	        return _possibleConstructorReturn(this, (PieChart.__proto__ || Object.getPrototypeOf(PieChart)).call(this, props));
	    }

	    _createClass(PieChart, [{
	        key: 'getDefaultOption',
	        value: function getDefaultOption() {
	            return {
	                backgroundColor: '#2c343c',

	                title: {
	                    text: 'Customized Pie',
	                    left: 'center',
	                    top: 20,
	                    textStyle: {
	                        color: '#ccc'
	                    }
	                },

	                tooltip: {
	                    trigger: 'item',
	                    formatter: "{a} <br/>{b} : {c} ({d}%)"
	                },

	                visualMap: {
	                    show: false,
	                    min: 80,
	                    max: 600,
	                    inRange: {
	                        colorLightness: [0, 1]
	                    }
	                },
	                series: [{
	                    name: '',
	                    type: 'pie',
	                    radius: '55%',
	                    center: ['50%', '50%'],
	                    data: [{ value: 335, name: '' }, { value: 310, name: '' }, { value: 274, name: '' }, { value: 235, name: '' }, { value: 400, name: '' }].sort(function (a, b) {
	                        return a.value - b.value;
	                    }),
	                    roseType: 'angle',
	                    label: {
	                        normal: {
	                            textStyle: {
	                                color: 'rgba(255, 255, 255, 0.3)'
	                            }
	                        }
	                    },
	                    labelLine: {
	                        normal: {
	                            lineStyle: {
	                                color: 'rgba(255, 255, 255, 0.3)'
	                            },
	                            smooth: 0.2,
	                            length: 10,
	                            length2: 20
	                        }
	                    },
	                    itemStyle: {
	                        normal: {
	                            color: '#c23531',
	                            shadowBlur: 200,
	                            shadowColor: 'rgba(0, 0, 0, 0.5)'
	                        }
	                    },
	                    animationType: 'scale',
	                    animationEasing: 'elasticOut',
	                    animationDelay: function animationDelay(idx) {
	                        return Math.random() * 200;
	                    }
	                }]
	            };
	        }
	    }]);

	    return PieChart;
	}(_chartBase2.default)) || _class) || _class;

	exports.default = PieChart;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _componentBase = __webpack_require__(200);

	var _componentBase2 = _interopRequireDefault(_componentBase);

	var _echarts = __webpack_require__(205);

	var _echarts2 = _interopRequireDefault(_echarts);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	//let echarts = require('../../lib/echarts.min');

	var ChartBase = function (_ComponentBase) {
	    _inherits(ChartBase, _ComponentBase);

	    function ChartBase(props) {
	        _classCallCheck(this, ChartBase);

	        return _possibleConstructorReturn(this, (ChartBase.__proto__ || Object.getPrototypeOf(ChartBase)).call(this, props));
	    }

	    _createClass(ChartBase, [{
	        key: 'getDefaultOption',
	        value: function getDefaultOption() {
	            return {
	                backgroundColor: '#2c343c',

	                title: {
	                    text: 'Customized Pie',
	                    left: 'center',
	                    top: 20,
	                    textStyle: {
	                        color: '#ccc'
	                    }
	                },

	                tooltip: {
	                    trigger: 'item',
	                    formatter: "{a} <br/>{b} : {c} ({d}%)"
	                },

	                visualMap: {
	                    show: false,
	                    min: 80,
	                    max: 600,
	                    inRange: {
	                        colorLightness: [0, 1]
	                    }
	                },
	                series: [{
	                    name: '',
	                    type: 'pie',
	                    radius: '55%',
	                    center: ['50%', '50%'],
	                    data: [{ value: 335, name: '' }, { value: 310, name: '' }, { value: 274, name: '' }, { value: 235, name: '' }, { value: 400, name: '' }].sort(function (a, b) {
	                        return a.value - b.value;
	                    }),
	                    roseType: 'angle',
	                    label: {
	                        normal: {
	                            textStyle: {
	                                color: 'rgba(255, 255, 255, 0.3)'
	                            }
	                        }
	                    },
	                    labelLine: {
	                        normal: {
	                            lineStyle: {
	                                color: 'rgba(255, 255, 255, 0.3)'
	                            },
	                            smooth: 0.2,
	                            length: 10,
	                            length2: 20
	                        }
	                    },
	                    itemStyle: {
	                        normal: {
	                            color: '#c23531',
	                            shadowBlur: 200,
	                            shadowColor: 'rgba(0, 0, 0, 0.5)'
	                        }
	                    },
	                    animationType: 'scale',
	                    animationEasing: 'elasticOut',
	                    animationDelay: function animationDelay(idx) {
	                        return Math.random() * 200;
	                    }
	                }]
	            };
	        }
	    }, {
	        key: 'refresh',
	        value: function refresh() {
	            if (this.props.isDrag) {
	                return;
	            }
	            var option = this.props.option;

	            if (!this.chart) {
	                this.chart = _echarts2.default.init(this.refs.chart);
	            }
	            if (!option) {
	                option = this.getDefaultOption();
	            }
	            this.chart.setOption(option, true);
	            this.chart.resize();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var props = _get(ChartBase.prototype.__proto__ || Object.getPrototypeOf(ChartBase.prototype), 'getProps', this).call(this);
	            return _react2.default.createElement('div', _extends({ ref: 'chart' }, props));
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.refresh();
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            this.refresh();
	        }
	    }]);

	    return ChartBase;
	}(_componentBase2.default);

	exports.default = ChartBase;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	!function (t, e) {
		"object" == ( false ? "undefined" : _typeof(exports)) && "object" == ( false ? "undefined" : _typeof(module)) ? module.exports = e() :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.echarts = e() : t.echarts = e();
	}(undefined, function () {
		return function (t) {
			function e(n) {
				if (i[n]) return i[n].exports;var a = i[n] = { exports: {}, id: n, loaded: !1 };return t[n].call(a.exports, a, a.exports, e), a.loaded = !0, a.exports;
			}var i = {};return e.m = t, e.c = i, e.p = "", e(0);
		}([function (t, e, i) {
			t.exports = i(2), i(108), i(102), i(112), i(191), i(331), i(319), i(346), i(293), i(289), i(285), i(326), i(336), i(270), i(275), i(282), i(314), i(306), i(330), i(341), i(281), i(207), i(208), i(209), i(232), i(55), i(373), i(370), i(251), i(252), i(361), i(368), i(223), i(197), i(387), i(216), i(215), i(214), i(377), i(224), i(239);
		}, function (t, e) {
			function i(t) {
				if (null == t || "object" != (typeof t === "undefined" ? "undefined" : _typeof(t))) return t;var e = t,
				    n = N.call(t);if ("[object Array]" === n) {
					e = [];for (var a = 0, o = t.length; a < o; a++) {
						e[a] = i(t[a]);
					}
				} else if (R[n]) e = t.constructor.from(t);else if (!E[n] && !P(t) && !I(t)) {
					e = {};for (var r in t) {
						t.hasOwnProperty(r) && (e[r] = i(t[r]));
					}
				}return e;
			}function n(t, e, a) {
				if (!S(e) || !S(t)) return a ? i(e) : t;for (var o in e) {
					if (e.hasOwnProperty(o)) {
						var r = t[o],
						    s = e[o];!S(s) || !S(r) || _(s) || _(r) || I(s) || I(r) || M(s) || M(r) || P(s) || P(r) ? !a && o in t || (t[o] = i(e[o], !0)) : n(r, s, a);
					}
				}return t;
			}function a(t, e) {
				for (var i = t[0], a = 1, o = t.length; a < o; a++) {
					i = n(i, t[a], e);
				}return i;
			}function o(t, e) {
				for (var i in e) {
					e.hasOwnProperty(i) && (t[i] = e[i]);
				}return t;
			}function r(t, e, i) {
				for (var n in e) {
					e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
				}return t;
			}function s() {
				return document.createElement("canvas");
			}function l() {
				return z || (z = U.createCanvas().getContext("2d")), z;
			}function u(t, e) {
				if (t) {
					if (t.indexOf) return t.indexOf(e);for (var i = 0, n = t.length; i < n; i++) {
						if (t[i] === e) return i;
					}
				}return -1;
			}function c(t, e) {
				function i() {}var n = t.prototype;i.prototype = e.prototype, t.prototype = new i();for (var a in n) {
					t.prototype[a] = n[a];
				}t.prototype.constructor = t, t.superClass = e;
			}function h(t, e, i) {
				t = "prototype" in t ? t.prototype : t, e = "prototype" in e ? e.prototype : e, r(t, e, i);
			}function d(t) {
				if (t) return "string" != typeof t && "number" == typeof t.length;
			}function f(t, e, i) {
				if (t && e) if (t.forEach && t.forEach === B) t.forEach(e, i);else if (t.length === +t.length) for (var n = 0, a = t.length; n < a; n++) {
					e.call(i, t[n], n, t);
				} else for (var o in t) {
					t.hasOwnProperty(o) && e.call(i, t[o], o, t);
				}
			}function p(t, e, i) {
				if (t && e) {
					if (t.map && t.map === F) return t.map(e, i);for (var n = [], a = 0, o = t.length; a < o; a++) {
						n.push(e.call(i, t[a], a, t));
					}return n;
				}
			}function g(t, e, i, n) {
				if (t && e) {
					if (t.reduce && t.reduce === W) return t.reduce(e, i, n);for (var a = 0, o = t.length; a < o; a++) {
						i = e.call(n, i, t[a], a, t);
					}return i;
				}
			}function m(t, e, i) {
				if (t && e) {
					if (t.filter && t.filter === G) return t.filter(e, i);for (var n = [], a = 0, o = t.length; a < o; a++) {
						e.call(i, t[a], a, t) && n.push(t[a]);
					}return n;
				}
			}function v(t, e, i) {
				if (t && e) for (var n = 0, a = t.length; n < a; n++) {
					if (e.call(i, t[n], n, t)) return t[n];
				}
			}function y(t, e) {
				var i = H.call(arguments, 2);return function () {
					return t.apply(e, i.concat(H.call(arguments)));
				};
			}function x(t) {
				var e = H.call(arguments, 1);return function () {
					return t.apply(this, e.concat(H.call(arguments)));
				};
			}function _(t) {
				return "[object Array]" === N.call(t);
			}function b(t) {
				return "function" == typeof t;
			}function w(t) {
				return "[object String]" === N.call(t);
			}function S(t) {
				var e = typeof t === "undefined" ? "undefined" : _typeof(t);return "function" === e || !!t && "object" == e;
			}function M(t) {
				return !!E[N.call(t)];
			}function I(t) {
				return "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && "number" == typeof t.nodeType && "object" == _typeof(t.ownerDocument);
			}function T(t) {
				return t !== t;
			}function A(t) {
				for (var e = 0, i = arguments.length; e < i; e++) {
					if (null != arguments[e]) return arguments[e];
				}
			}function C() {
				return Function.call.apply(H, arguments);
			}function L(t, e) {
				if (!t) throw new Error(e);
			}function D(t) {
				t[Z] = !0;
			}function P(t) {
				return t[Z];
			}function k(t) {
				t && f(t, function (t, e) {
					this.set(e, t);
				}, this);
			}function O(t) {
				return new k(t);
			}var z,
			    E = { "[object Function]": 1, "[object RegExp]": 1, "[object Date]": 1, "[object Error]": 1, "[object CanvasGradient]": 1, "[object CanvasPattern]": 1, "[object Image]": 1, "[object Canvas]": 1 },
			    R = { "[object Int8Array]": 1, "[object Uint8Array]": 1, "[object Uint8ClampedArray]": 1, "[object Int16Array]": 1, "[object Uint16Array]": 1, "[object Int32Array]": 1, "[object Uint32Array]": 1, "[object Float32Array]": 1, "[object Float64Array]": 1 },
			    N = Object.prototype.toString,
			    V = Array.prototype,
			    B = V.forEach,
			    G = V.filter,
			    H = V.slice,
			    F = V.map,
			    W = V.reduce,
			    Z = "__ec_primitive__",
			    q = "_ec_",
			    j = 4;k.prototype = { constructor: k, get: function get(t) {
					return this[q + t];
				}, set: function set(t, e) {
					return this[q + t] = e, e;
				}, each: function each(t, e) {
					void 0 !== e && (t = y(t, e));for (var i in this) {
						this.hasOwnProperty(i) && t(this[i], i.slice(j));
					}
				}, removeKey: function removeKey(t) {
					delete this[t];
				} };var U = { inherits: c, mixin: h, clone: i, merge: n, mergeAll: a, extend: o, defaults: r, getContext: l, createCanvas: s, indexOf: u, slice: C, find: v, isArrayLike: d, each: f, map: p, reduce: g, filter: m, bind: y, curry: x, isArray: _, isString: w, isObject: S, isFunction: b, isBuiltInObject: M, isDom: I, eqNaN: T, retrieve: A, assert: L, setAsPrimitive: D, createHashMap: O, noop: function noop() {} };t.exports = U;
		}, function (t, e, i) {
			function n(t) {
				return function (e, i, n) {
					e = e && e.toLowerCase(), V.prototype[t].call(this, e, i, n);
				};
			}function a() {
				V.call(this);
			}function o(t, e, i) {
				function n(t, e) {
					return t.prio - e.prio;
				}i = i || {}, "string" == typeof e && (e = lt[e]), this.id, this.group, this._dom = t;var o = this._zr = E.init(t, { renderer: i.renderer || "canvas", devicePixelRatio: i.devicePixelRatio, width: i.width, height: i.height });this._throttledZrFlush = z.throttle(R.bind(o.flush, o), 17), this._theme = R.clone(e), this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._coordSysMgr = new T(), this._api = b(this), V.call(this), this._messageCenter = new a(), this._initEvents(), this.resize = R.bind(this.resize, this), this._pendingActions = [], B(st, n), B(at, n), o.animation.on("frame", this._onframe, this), R.setAsPrimitive(this);
			}function r(t, e, i) {
				var n,
				    a = this._model,
				    o = this._coordSysMgr.getCoordinateSystems();e = O.parseFinder(a, e);for (var r = 0; r < o.length; r++) {
					var s = o[r];if (s[t] && null != (n = s[t](a, e, i))) return n;
				}
			}function s(t, e, i, n, a) {
				function o(n) {
					n && n.__alive && n[e] && n[e](n.__model, r, t._api, i);
				}var r = t._model;if (!n) return void G(t._componentsViews.concat(t._chartsViews), o);var s = {};s[n + "Id"] = i[n + "Id"], s[n + "Index"] = i[n + "Index"], s[n + "Name"] = i[n + "Name"];var l = { mainType: n, query: s };a && (l.subType = a), r && r.eachComponent(l, function (e, i) {
					o(t["series" === n ? "_chartsMap" : "_componentsMap"][e.__viewId]);
				}, t);
			}function l(t, e) {
				var i = t.type,
				    n = t.escapeConnect,
				    a = it[i],
				    o = a.actionInfo,
				    r = (o.update || "update").split(":"),
				    l = r.pop();r = null != r[0] && H(r[0]), this[Y] = !0;var u = [t],
				    c = !1;t.batch && (c = !0, u = R.map(t.batch, function (e) {
					return e = R.defaults(R.extend({}, e), t), e.batch = null, e;
				}));var h,
				    d = [],
				    f = "highlight" === i || "downplay" === i;G(u, function (t) {
					h = a.action(t, this._model, this._api), h = h || R.extend({}, t), h.type = o.event || h.type, d.push(h), f ? s(this, l, t, "series") : r && s(this, l, t, r.main, r.sub);
				}, this), "none" === l || f || r || (this[K] ? (tt.prepareAndUpdate.call(this, t), this[K] = !1) : tt[l].call(this, t)), h = c ? { type: o.event || i, escapeConnect: n, batch: d } : d[0], this[Y] = !1, !e && this._messageCenter.trigger(h.type, h);
			}function u(t) {
				for (var e = this._pendingActions; e.length;) {
					var i = e.shift();l.call(this, i, t);
				}
			}function c(t) {
				!t && this.trigger("updated");
			}function h(t, e, i) {
				var n = this._api;G(this._componentsViews, function (a) {
					var o = a.__model;a[t](o, e, n, i), _(o, a);
				}, this), e.eachSeries(function (a, o) {
					var r = this._chartsMap[a.__viewId];r[t](a, e, n, i), _(a, r), x(a, r);
				}, this), y(this._zr, e), G(rt, function (t) {
					t(e, n);
				});
			}function d(t, e) {
				for (var i = "component" === t, n = i ? this._componentsViews : this._chartsViews, a = i ? this._componentsMap : this._chartsMap, o = this._zr, r = 0; r < n.length; r++) {
					n[r].__alive = !1;
				}e[i ? "eachComponent" : "eachSeries"](function (t, r) {
					if (i) {
						if ("series" === t) return;
					} else r = t;var s = "_ec_" + r.id + "_" + r.type,
					    l = a[s];if (!l) {
						var u = H(r.type),
						    c = i ? D.getClass(u.main, u.sub) : P.getClass(u.sub);if (!c) return;l = new c(), l.init(e, this._api), a[s] = l, n.push(l), o.add(l.group);
					}r.__viewId = l.__id = s, l.__alive = !0, l.__model = r, l.group.__ecComponentInfo = { mainType: r.mainType, index: r.componentIndex };
				}, this);for (var r = 0; r < n.length;) {
					var s = n[r];s.__alive ? r++ : (o.remove(s.group), s.dispose(e, this._api), n.splice(r, 1), delete a[s.__id], s.__id = s.group.__ecComponentInfo = null);
				}
			}function f(t, e) {
				G(at, function (i) {
					i.func(t, e);
				});
			}function p(t) {
				var e = {};t.eachSeries(function (t) {
					var i = t.get("stack"),
					    n = t.getData();if (i && "list" === n.type) {
						var a = e[i];e.hasOwnProperty(i) && a && (n.stackedOn = a), e[i] = n;
					}
				});
			}function g(t, e) {
				var i = this._api;G(st, function (n) {
					n.isLayout && n.func(t, i, e);
				});
			}function m(t, e, i) {
				var n = this._api;t.clearColorPalette(), t.eachSeries(function (t) {
					t.clearColorPalette();
				}), G(st, function (a) {
					(!i || !a.isLayout) && a.func(t, n, e);
				});
			}function v(t, e) {
				var i = this._api;G(this._componentsViews, function (n) {
					var a = n.__model;n.render(a, t, i, e), _(a, n);
				}, this), G(this._chartsViews, function (t) {
					t.__alive = !1;
				}, this), t.eachSeries(function (n, a) {
					var o = this._chartsMap[n.__viewId];o.__alive = !0, o.render(n, t, i, e), o.group.silent = !!n.get("silent"), _(n, o), x(n, o);
				}, this), y(this._zr, t), G(this._chartsViews, function (e) {
					e.__alive || e.remove(t, i);
				}, this);
			}function y(t, e) {
				var i = t.storage,
				    n = 0;i.traverse(function (t) {
					t.isGroup || n++;
				}), n > e.get("hoverLayerThreshold") && !S.node && i.traverse(function (t) {
					t.isGroup || (t.useHoverLayer = !0);
				});
			}function x(t, e) {
				var i = 0;e.group.traverse(function (t) {
					"group" === t.type || t.ignore || i++;
				});var n = +t.get("progressive"),
				    a = i > t.get("progressiveThreshold") && n && !S.node;a && e.group.traverse(function (t) {
					t.isGroup || (t.progressive = a ? Math.floor(i++ / n) : -1, a && t.stopAnimation(!0));
				});var o = t.get("blendMode") || null;e.group.traverse(function (t) {
					t.isGroup || t.setStyle("blend", o);
				});
			}function _(t, e) {
				var i = t.get("z"),
				    n = t.get("zlevel");e.group.traverse(function (t) {
					"group" !== t.type && (null != i && (t.z = i), null != n && (t.zlevel = n));
				});
			}function b(t) {
				var e = t._coordSysMgr;return R.extend(new I(t), { getCoordinateSystems: R.bind(e.getCoordinateSystems, e), getComponentByElement: function getComponentByElement(e) {
						for (; e;) {
							var i = e.__ecComponentInfo;if (null != i) return t._model.getComponent(i.mainType, i.index);e = e.parent;
						}
					} });
			}function w(t) {
				function e(t, e) {
					for (var i = 0; i < t.length; i++) {
						var n = t[i];n[o] = e;
					}
				}var i = 0,
				    n = 1,
				    a = 2,
				    o = "__connectUpdateStatus";R.each(nt, function (r, s) {
					t._messageCenter.on(s, function (r) {
						if (ht[t.group] && t[o] !== i) {
							if (r && r.escapeConnect) return;var s = t.makeActionFromEvent(r),
							    l = [];R.each(ct, function (e) {
								e !== t && e.group === t.group && l.push(e);
							}), e(l, i), G(l, function (t) {
								t[o] !== n && t.dispatchAction(s);
							}), e(l, a);
						}
					});
				});
			} /*!
	    * ECharts, a javascript interactive chart library.
	    *
	    * Copyright (c) 2015, Baidu Inc.
	    * All rights reserved.
	    *
	    * LICENSE
	    * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt
	    */
			var S = i(9),
			    M = i(137),
			    I = i(101),
			    T = i(26),
			    A = i(138),
			    C = i(13),
			    L = i(17),
			    D = i(65),
			    P = i(30),
			    k = i(3),
			    O = i(5),
			    z = i(37),
			    E = i(88),
			    R = i(1),
			    N = i(22),
			    V = i(23),
			    B = i(51),
			    G = R.each,
			    H = C.parseClassType,
			    F = 1e3,
			    W = 5e3,
			    Z = 1e3,
			    q = 2e3,
			    j = 3e3,
			    U = 4e3,
			    X = 5e3,
			    Y = "__flagInMainProcess",
			    $ = "__hasGradientOrPatternBg",
			    K = "__optionUpdated",
			    J = /^[a-zA-Z0-9_]+$/;a.prototype.on = n("on"), a.prototype.off = n("off"), a.prototype.one = n("one"), R.mixin(a, V);var Q = o.prototype;Q._onframe = function () {
				if (this[K]) {
					var t = this[K].silent;this[Y] = !0, tt.prepareAndUpdate.call(this), this[Y] = !1, this[K] = !1, u.call(this, t), c.call(this, t);
				}
			}, Q.getDom = function () {
				return this._dom;
			}, Q.getZr = function () {
				return this._zr;
			}, Q.setOption = function (t, e, i) {
				var n;if (R.isObject(e) && (i = e.lazyUpdate, n = e.silent, e = e.notMerge), this[Y] = !0, !this._model || e) {
					var a = new A(this._api),
					    o = this._theme,
					    r = this._model = new M(null, null, o, a);r.init(null, null, o, a);
				}this._model.setOption(t, ot), i ? (this[K] = { silent: n }, this[Y] = !1) : (tt.prepareAndUpdate.call(this), this._zr.flush(), this[K] = !1, this[Y] = !1, u.call(this, n), c.call(this, n));
			}, Q.setTheme = function () {
				console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
			}, Q.getModel = function () {
				return this._model;
			}, Q.getOption = function () {
				return this._model && this._model.getOption();
			}, Q.getWidth = function () {
				return this._zr.getWidth();
			}, Q.getHeight = function () {
				return this._zr.getHeight();
			}, Q.getDevicePixelRatio = function () {
				return this._zr.painter.dpr || window.devicePixelRatio || 1;
			}, Q.getRenderedCanvas = function (t) {
				if (S.canvasSupported) {
					t = t || {}, t.pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor");var e = this._zr,
					    i = e.storage.getDisplayList();return R.each(i, function (t) {
						t.stopAnimation(!0);
					}), e.painter.getRenderedCanvas(t);
				}
			}, Q.getDataURL = function (t) {
				t = t || {};var e = t.excludeComponents,
				    i = this._model,
				    n = [],
				    a = this;G(e, function (t) {
					i.eachComponent({ mainType: t }, function (t) {
						var e = a._componentsMap[t.__viewId];e.group.ignore || (n.push(e), e.group.ignore = !0);
					});
				});var o = this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));return G(n, function (t) {
					t.group.ignore = !1;
				}), o;
			}, Q.getConnectedDataURL = function (t) {
				if (S.canvasSupported) {
					var e = this.group,
					    i = Math.min,
					    n = Math.max,
					    a = 1 / 0;if (ht[e]) {
						var o = a,
						    r = a,
						    s = -a,
						    l = -a,
						    u = [],
						    c = t && t.pixelRatio || 1;R.each(ct, function (a, c) {
							if (a.group === e) {
								var h = a.getRenderedCanvas(R.clone(t)),
								    d = a.getDom().getBoundingClientRect();o = i(d.left, o), r = i(d.top, r), s = n(d.right, s), l = n(d.bottom, l), u.push({ dom: h, left: d.left, top: d.top });
							}
						}), o *= c, r *= c, s *= c, l *= c;var h = s - o,
						    d = l - r,
						    f = R.createCanvas();f.width = h, f.height = d;var p = E.init(f);return G(u, function (t) {
							var e = new k.Image({ style: { x: t.left * c - o, y: t.top * c - r, image: t.dom } });p.add(e);
						}), p.refreshImmediately(), f.toDataURL("image/" + (t && t.type || "png"));
					}return this.getDataURL(t);
				}
			}, Q.convertToPixel = R.curry(r, "convertToPixel"), Q.convertFromPixel = R.curry(r, "convertFromPixel"), Q.containPixel = function (t, e) {
				var i,
				    n = this._model;return t = O.parseFinder(n, t), R.each(t, function (t, n) {
					n.indexOf("Models") >= 0 && R.each(t, function (t) {
						var a = t.coordinateSystem;if (a && a.containPoint) i |= !!a.containPoint(e);else if ("seriesModels" === n) {
							var o = this._chartsMap[t.__viewId];o && o.containPoint && (i |= o.containPoint(e, t));
						}
					}, this);
				}, this), !!i;
			}, Q.getVisual = function (t, e) {
				var i = this._model;t = O.parseFinder(i, t, { defaultMainType: "series" });var n = t.seriesModel,
				    a = n.getData(),
				    o = t.hasOwnProperty("dataIndexInside") ? t.dataIndexInside : t.hasOwnProperty("dataIndex") ? a.indexOfRawIndex(t.dataIndex) : null;return null != o ? a.getItemVisual(o, e) : a.getVisual(e);
			}, Q.getViewOfComponentModel = function (t) {
				return this._componentsMap[t.__viewId];
			}, Q.getViewOfSeriesModel = function (t) {
				return this._chartsMap[t.__viewId];
			};var tt = { update: function update(t) {
					var e = this._model,
					    i = this._api,
					    n = this._coordSysMgr,
					    a = this._zr;if (e) {
						e.restoreData(), n.create(this._model, this._api), f.call(this, e, i), p.call(this, e), n.update(e, i), m.call(this, e, t), v.call(this, e, t);var o = e.get("backgroundColor") || "transparent",
						    r = a.painter;if (r.isSingleCanvas && r.isSingleCanvas()) a.configLayer(0, { clearColor: o });else {
							if (!S.canvasSupported) {
								var s = N.parse(o);o = N.stringify(s, "rgb"), 0 === s[3] && (o = "transparent");
							}o.colorStops || o.image ? (a.configLayer(0, { clearColor: o }), this[$] = !0, this._dom.style.background = "transparent") : (this[$] && a.configLayer(0, { clearColor: null }), this[$] = !1, this._dom.style.background = o);
						}G(rt, function (t) {
							t(e, i);
						});
					}
				}, updateView: function updateView(t) {
					var e = this._model;e && (e.eachSeries(function (t) {
						t.getData().clearAllVisual();
					}), m.call(this, e, t), h.call(this, "updateView", e, t));
				}, updateVisual: function updateVisual(t) {
					var e = this._model;e && (e.eachSeries(function (t) {
						t.getData().clearAllVisual();
					}), m.call(this, e, t, !0), h.call(this, "updateVisual", e, t));
				}, updateLayout: function updateLayout(t) {
					var e = this._model;e && (g.call(this, e, t), h.call(this, "updateLayout", e, t));
				}, prepareAndUpdate: function prepareAndUpdate(t) {
					var e = this._model;d.call(this, "component", e), d.call(this, "chart", e), tt.update.call(this, t);
				} };Q.resize = function (t) {
				this[Y] = !0, this._zr.resize(t);var e = this._model && this._model.resetOption("media"),
				    i = e ? "prepareAndUpdate" : "update";tt[i].call(this), this._loadingFX && this._loadingFX.resize(), this[Y] = !1;var n = t && t.silent;u.call(this, n), c.call(this, n);
			}, Q.showLoading = function (t, e) {
				if (R.isObject(t) && (e = t, t = ""), t = t || "default", this.hideLoading(), ut[t]) {
					var i = ut[t](this._api, e),
					    n = this._zr;this._loadingFX = i, n.add(i);
				}
			}, Q.hideLoading = function () {
				this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
			}, Q.makeActionFromEvent = function (t) {
				var e = R.extend({}, t);return e.type = nt[t.type], e;
			}, Q.dispatchAction = function (t, e) {
				if (R.isObject(e) || (e = { silent: !!e }), it[t.type]) {
					if (this[Y]) return void this._pendingActions.push(t);l.call(this, t, e.silent), e.flush ? this._zr.flush(!0) : e.flush !== !1 && S.browser.weChat && this._throttledZrFlush(), u.call(this, e.silent), c.call(this, e.silent);
				}
			}, Q.on = n("on"), Q.off = n("off"), Q.one = n("one");var et = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];Q._initEvents = function () {
				G(et, function (t) {
					this._zr.on(t, function (e) {
						var i,
						    n = this.getModel(),
						    a = e.target;if ("globalout" === t) i = {};else if (a && null != a.dataIndex) {
							var o = a.dataModel || n.getSeriesByIndex(a.seriesIndex);i = o && o.getDataParams(a.dataIndex, a.dataType) || {};
						} else a && a.eventData && (i = R.extend({}, a.eventData));i && (i.event = e, i.type = t, this.trigger(t, i));
					}, this);
				}, this), G(nt, function (t, e) {
					this._messageCenter.on(e, function (t) {
						this.trigger(e, t);
					}, this);
				}, this);
			}, Q.isDisposed = function () {
				return this._disposed;
			}, Q.clear = function () {
				this.setOption({ series: [] }, !0);
			}, Q.dispose = function () {
				if (!this._disposed) {
					this._disposed = !0;var t = this._api,
					    e = this._model;G(this._componentsViews, function (i) {
						i.dispose(e, t);
					}), G(this._chartsViews, function (i) {
						i.dispose(e, t);
					}), this._zr.dispose(), delete ct[this.id];
				}
			}, R.mixin(o, V);var it = {},
			    nt = {},
			    at = [],
			    ot = [],
			    rt = [],
			    st = [],
			    lt = {},
			    ut = {},
			    ct = {},
			    ht = {},
			    dt = new Date() - 0,
			    ft = new Date() - 0,
			    pt = "_echarts_instance_",
			    gt = { version: "3.6.1", dependencies: { zrender: "3.5.1" } };gt.init = function (t, e, i) {
				var n = gt.getInstanceByDom(t);if (n) return n;var a = new o(t, e, i);return a.id = "ec_" + dt++, ct[a.id] = a, t.setAttribute ? t.setAttribute(pt, a.id) : t[pt] = a.id, w(a), a;
			}, gt.connect = function (t) {
				if (R.isArray(t)) {
					var e = t;t = null, R.each(e, function (e) {
						null != e.group && (t = e.group);
					}), t = t || "g_" + ft++, R.each(e, function (e) {
						e.group = t;
					});
				}return ht[t] = !0, t;
			}, gt.disConnect = function (t) {
				ht[t] = !1;
			}, gt.disconnect = gt.disConnect, gt.dispose = function (t) {
				"string" == typeof t ? t = ct[t] : t instanceof o || (t = gt.getInstanceByDom(t)), t instanceof o && !t.isDisposed() && t.dispose();
			}, gt.getInstanceByDom = function (t) {
				var e;return e = t.getAttribute ? t.getAttribute(pt) : t[pt], ct[e];
			}, gt.getInstanceById = function (t) {
				return ct[t];
			}, gt.registerTheme = function (t, e) {
				lt[t] = e;
			}, gt.registerPreprocessor = function (t) {
				ot.push(t);
			}, gt.registerProcessor = function (t, e) {
				"function" == typeof t && (e = t, t = F), at.push({ prio: t, func: e });
			}, gt.registerPostUpdate = function (t) {
				rt.push(t);
			}, gt.registerAction = function (t, e, i) {
				"function" == typeof e && (i = e, e = "");var n = R.isObject(t) ? t.type : [t, t = { event: e }][0];t.event = (t.event || n).toLowerCase(), e = t.event, R.assert(J.test(n) && J.test(e)), it[n] || (it[n] = { action: i, actionInfo: t }), nt[e] = n;
			}, gt.registerCoordinateSystem = function (t, e) {
				T.register(t, e);
			}, gt.registerLayout = function (t, e) {
				"function" == typeof t && (e = t, t = Z), st.push({ prio: t, func: e, isLayout: !0 });
			}, gt.registerVisual = function (t, e) {
				"function" == typeof t && (e = t, t = j), st.push({ prio: t, func: e });
			}, gt.registerLoading = function (t, e) {
				ut[t] = e;
			}, gt.extendComponentModel = function (t) {
				return C.extend(t);
			}, gt.extendComponentView = function (t) {
				return D.extend(t);
			}, gt.extendSeriesModel = function (t) {
				return L.extend(t);
			}, gt.extendChartView = function (t) {
				return P.extend(t);
			}, gt.setCanvasCreator = function (t) {
				R.createCanvas = t;
			}, gt.registerVisual(q, i(151)), gt.registerPreprocessor(i(145)), gt.registerLoading("default", i(136)), gt.registerAction({ type: "highlight", event: "highlight", update: "highlight" }, R.noop), gt.registerAction({ type: "downplay", event: "downplay", update: "downplay" }, R.noop), gt.zrender = E, gt.List = i(14), gt.Model = i(10), gt.Axis = i(33), gt.graphic = i(3), gt.number = i(4), gt.format = i(7), gt.throttle = z.throttle, gt.matrix = i(19), gt.vector = i(6), gt.color = i(22), gt.util = {}, G(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], function (t) {
				gt.util[t] = R[t];
			}), gt.helper = i(135), gt.PRIORITY = { PROCESSOR: { FILTER: F, STATISTIC: W }, VISUAL: { LAYOUT: Z, GLOBAL: q, CHART: j, COMPONENT: U, BRUSH: X } }, t.exports = gt;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return null != t && "none" != t;
			}function a(t) {
				return "string" == typeof t ? x.lift(t, -.1) : t;
			}function o(t) {
				if (t.__hoverStlDirty) {
					var e = t.style.stroke,
					    i = t.style.fill,
					    o = t.__hoverStl;o.fill = o.fill || (n(i) ? a(i) : null), o.stroke = o.stroke || (n(e) ? a(e) : null);var r = {};for (var s in o) {
						o.hasOwnProperty(s) && (r[s] = t.style[s]);
					}t.__normalStl = r, t.__hoverStlDirty = !1;
				}
			}function r(t) {
				t.__isHover || (o(t), t.useHoverLayer ? t.__zr && t.__zr.addHover(t, t.__hoverStl) : (t.setStyle(t.__hoverStl), t.z2 += 1), t.__isHover = !0);
			}function s(t) {
				if (t.__isHover) {
					var e = t.__normalStl;t.useHoverLayer ? t.__zr && t.__zr.removeHover(t) : (e && t.setStyle(e), t.z2 -= 1), t.__isHover = !1;
				}
			}function l(t) {
				"group" === t.type ? t.traverse(function (t) {
					"group" !== t.type && r(t);
				}) : r(t);
			}function u(t) {
				"group" === t.type ? t.traverse(function (t) {
					"group" !== t.type && s(t);
				}) : s(t);
			}function c(t, e) {
				t.__hoverStl = t.hoverStyle || e || {}, t.__hoverStlDirty = !0, t.__isHover && o(t);
			}function h(t) {
				this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasis && l(this);
			}function d(t) {
				this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasis && u(this);
			}function f() {
				this.__isEmphasis = !0, l(this);
			}function p() {
				this.__isEmphasis = !1, u(this);
			}function g(t, e, i, n, a, o) {
				"function" == typeof a && (o = a, a = null);var r = n && n.isAnimationEnabled();if (r) {
					var s = t ? "Update" : "",
					    l = n.getShallow("animationDuration" + s),
					    u = n.getShallow("animationEasing" + s),
					    c = n.getShallow("animationDelay" + s);"function" == typeof c && (c = c(a, n.getAnimationDelayParams ? n.getAnimationDelayParams(e, a) : null)), "function" == typeof l && (l = l(a)), l > 0 ? e.animateTo(i, l, c || 0, u, o) : (e.stopAnimation(), e.attr(i), o && o());
				} else e.stopAnimation(), e.attr(i), o && o();
			}var m = i(1),
			    v = i(180),
			    y = i(8),
			    x = i(22),
			    _ = i(19),
			    b = i(6),
			    w = i(58),
			    S = i(11),
			    M = Math.round,
			    I = Math.max,
			    T = Math.min,
			    A = {};A.Group = i(36), A.Image = i(53), A.Text = i(86), A.Circle = i(171), A.Sector = i(177), A.Ring = i(176), A.Polygon = i(173), A.Polyline = i(174), A.Rect = i(175), A.Line = i(172), A.BezierCurve = i(170), A.Arc = i(169), A.CompoundPath = i(164), A.LinearGradient = i(100), A.RadialGradient = i(165), A.BoundingRect = S, A.extendShape = function (t) {
				return y.extend(t);
			}, A.extendPath = function (t, e) {
				return v.extendFromString(t, e);
			}, A.makePath = function (t, e, i, n) {
				var a = v.createFromString(t, e),
				    o = a.getBoundingRect();if (i) {
					var r = o.width / o.height;if ("center" === n) {
						var s,
						    l = i.height * r;l <= i.width ? s = i.height : (l = i.width, s = l / r);var u = i.x + i.width / 2,
						    c = i.y + i.height / 2;i.x = u - l / 2, i.y = c - s / 2, i.width = l, i.height = s;
					}A.resizePath(a, i);
				}return a;
			}, A.mergePath = v.mergePath, A.resizePath = function (t, e) {
				if (t.applyTransform) {
					var i = t.getBoundingRect(),
					    n = i.calculateTransform(e);t.applyTransform(n);
				}
			}, A.subPixelOptimizeLine = function (t) {
				var e = A.subPixelOptimize,
				    i = t.shape,
				    n = t.style.lineWidth;return M(2 * i.x1) === M(2 * i.x2) && (i.x1 = i.x2 = e(i.x1, n, !0)), M(2 * i.y1) === M(2 * i.y2) && (i.y1 = i.y2 = e(i.y1, n, !0)), t;
			}, A.subPixelOptimizeRect = function (t) {
				var e = A.subPixelOptimize,
				    i = t.shape,
				    n = t.style.lineWidth,
				    a = i.x,
				    o = i.y,
				    r = i.width,
				    s = i.height;return i.x = e(i.x, n, !0), i.y = e(i.y, n, !0), i.width = Math.max(e(a + r, n, !1) - i.x, 0 === r ? 0 : 1), i.height = Math.max(e(o + s, n, !1) - i.y, 0 === s ? 0 : 1), t;
			}, A.subPixelOptimize = function (t, e, i) {
				var n = M(2 * t);return (n + M(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2;
			}, A.setHoverStyle = function (t, e, i) {
				t.__hoverSilentOnTouch = i && i.hoverSilentOnTouch, "group" === t.type ? t.traverse(function (t) {
					"group" !== t.type && c(t, e);
				}) : c(t, e), t.on("mouseover", h).on("mouseout", d), t.on("emphasis", f).on("normal", p);
			}, A.setText = function (t, e, i) {
				var n = e.getShallow("position") || "inside",
				    a = e.getShallow("offset"),
				    o = n.indexOf("inside") >= 0 ? "white" : i,
				    r = e.getModel("textStyle");m.extend(t, { textDistance: e.getShallow("distance") || 5, textFont: r.getFont(), textPosition: n, textOffset: a, textFill: r.getTextColor() || o });
			}, A.getFont = function (t, e) {
				var i = e && e.getModel("textStyle");return [t.fontStyle || i && i.getShallow("fontStyle") || "", t.fontWeight || i && i.getShallow("fontWeight") || "", (t.fontSize || i && i.getShallow("fontSize") || 12) + "px", t.fontFamily || i && i.getShallow("fontFamily") || "sans-serif"].join(" ");
			}, A.updateProps = function (t, e, i, n, a) {
				g(!0, t, e, i, n, a);
			}, A.initProps = function (t, e, i, n, a) {
				g(!1, t, e, i, n, a);
			}, A.getTransform = function (t, e) {
				for (var i = _.identity([]); t && t !== e;) {
					_.mul(i, t.getLocalTransform(), i), t = t.parent;
				}return i;
			}, A.applyTransform = function (t, e, i) {
				return e && !m.isArrayLike(e) && (e = w.getLocalTransform(e)), i && (e = _.invert([], e)), b.applyTransform([], t, e);
			}, A.transformDirection = function (t, e, i) {
				var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]),
				    a = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]),
				    o = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -a : "bottom" === t ? a : 0];return o = A.applyTransform(o, e, i), Math.abs(o[0]) > Math.abs(o[1]) ? o[0] > 0 ? "right" : "left" : o[1] > 0 ? "bottom" : "top";
			}, A.groupTransition = function (t, e, i, n) {
				function a(t) {
					var e = {};return t.traverse(function (t) {
						!t.isGroup && t.anid && (e[t.anid] = t);
					}), e;
				}function o(t) {
					var e = { position: b.clone(t.position), rotation: t.rotation };return t.shape && (e.shape = m.extend({}, t.shape)), e;
				}if (t && e) {
					var r = a(t);e.traverse(function (t) {
						if (!t.isGroup && t.anid) {
							var e = r[t.anid];if (e) {
								var n = o(t);t.attr(o(e)), A.updateProps(t, n, i, t.dataIndex);
							}
						}
					});
				}
			}, A.clipPointsByRect = function (t, e) {
				return m.map(t, function (t) {
					var i = t[0];i = I(i, e.x), i = T(i, e.x + e.width);var n = t[1];return n = I(n, e.y), n = T(n, e.y + e.height), [i, n];
				});
			}, A.clipRectByRect = function (t, e) {
				var i = I(t.x, e.x),
				    n = T(t.x + t.width, e.x + e.width),
				    a = I(t.y, e.y),
				    o = T(t.y + t.height, e.y + e.height);if (n >= i && o >= a) return { x: i, y: a, width: n - i, height: o - a };
			}, t.exports = A;
		}, function (t, e) {
			function i(t) {
				return t.replace(/^\s+/, "").replace(/\s+$/, "");
			}function n(t) {
				return Math.floor(Math.log(t) / Math.LN10);
			}var a = {},
			    o = 1e-4;a.linearMap = function (t, e, i, n) {
				var a = e[1] - e[0],
				    o = i[1] - i[0];if (0 === a) return 0 === o ? i[0] : (i[0] + i[1]) / 2;if (n) {
					if (a > 0) {
						if (t <= e[0]) return i[0];if (t >= e[1]) return i[1];
					} else {
						if (t >= e[0]) return i[0];if (t <= e[1]) return i[1];
					}
				} else {
					if (t === e[0]) return i[0];if (t === e[1]) return i[1];
				}return (t - e[0]) / a * o + i[0];
			}, a.parsePercent = function (t, e) {
				switch (t) {case "center":case "middle":
						t = "50%";break;case "left":case "top":
						t = "0%";break;case "right":case "bottom":
						t = "100%";}return "string" == typeof t ? i(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : null == t ? NaN : +t;
			}, a.round = function (t, e, i) {
				return null == e && (e = 10), e = Math.min(Math.max(0, e), 20), t = (+t).toFixed(e), i ? t : +t;
			}, a.asc = function (t) {
				return t.sort(function (t, e) {
					return t - e;
				}), t;
			}, a.getPrecision = function (t) {
				if (t = +t, isNaN(t)) return 0;for (var e = 1, i = 0; Math.round(t * e) / e !== t;) {
					e *= 10, i++;
				}return i;
			}, a.getPrecisionSafe = function (t) {
				var e = t.toString(),
				    i = e.indexOf("e");if (i > 0) {
					var n = +e.slice(i + 1);return n < 0 ? -n : 0;
				}var a = e.indexOf(".");return a < 0 ? 0 : e.length - 1 - a;
			}, a.getPixelPrecision = function (t, e) {
				var i = Math.log,
				    n = Math.LN10,
				    a = Math.floor(i(t[1] - t[0]) / n),
				    o = Math.round(i(Math.abs(e[1] - e[0])) / n),
				    r = Math.min(Math.max(-a + o, 0), 20);return isFinite(r) ? r : 20;
			}, a.MAX_SAFE_INTEGER = 9007199254740991, a.remRadian = function (t) {
				var e = 2 * Math.PI;return (t % e + e) % e;
			}, a.isRadianAroundZero = function (t) {
				return t > -o && t < o;
			};var r = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;a.getTimezoneOffset = function () {
				return new Date().getTimezoneOffset();
			}, a.parseDate = function (t) {
				if (t instanceof Date) return t;if ("string" == typeof t) {
					var e = r.exec(t);if (!e) return new Date(NaN);var i = a.getTimezoneOffset(),
					    n = e[8] ? "Z" === e[8].toUpperCase() ? i : 60 * +e[8].slice(0, 3) + i : 0;return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0) - n, +e[6] || 0, +e[7] || 0);
				}return null == t ? new Date(NaN) : new Date(Math.round(t));
			}, a.quantity = function (t) {
				return Math.pow(10, n(t));
			}, a.nice = function (t, e) {
				var i,
				    a = n(t),
				    o = Math.pow(10, a),
				    r = t / o;return i = e ? r < 1.5 ? 1 : r < 2.5 ? 2 : r < 4 ? 3 : r < 7 ? 5 : 10 : r < 1 ? 1 : r < 2 ? 2 : r < 3 ? 3 : r < 5 ? 5 : 10, t = i * o, a >= -20 ? +t.toFixed(a < 0 ? -a : 0) : t;
			}, a.reformIntervals = function (t) {
				function e(t, i, n) {
					return t.interval[n] < i.interval[n] || t.interval[n] === i.interval[n] && (t.close[n] - i.close[n] === (n ? -1 : 1) || !n && e(t, i, 1));
				}t.sort(function (t, i) {
					return e(t, i, 0) ? -1 : 1;
				});for (var i = -(1 / 0), n = 1, a = 0; a < t.length;) {
					for (var o = t[a].interval, r = t[a].close, s = 0; s < 2; s++) {
						o[s] <= i && (o[s] = i, r[s] = s ? 1 : 1 - n), i = o[s], n = r[s];
					}o[0] === o[1] && r[0] * r[1] !== 1 ? t.splice(a, 1) : a++;
				}return t;
			}, a.isNumeric = function (t) {
				return t - parseFloat(t) >= 0;
			}, t.exports = a;
		}, function (t, e, i) {
			function n(t, e) {
				return t && t.hasOwnProperty(e);
			}var a = i(7),
			    o = i(4),
			    r = i(10),
			    s = i(1),
			    l = s.each,
			    u = s.isObject,
			    c = {};c.normalizeToArray = function (t) {
				return t instanceof Array ? t : null == t ? [] : [t];
			}, c.defaultEmphasis = function (t, e) {
				if (t) {
					var i = t.emphasis = t.emphasis || {},
					    n = t.normal = t.normal || {};l(e, function (t) {
						var e = s.retrieve(i[t], n[t]);null != e && (i[t] = e);
					});
				}
			}, c.LABEL_OPTIONS = ["position", "offset", "show", "textStyle", "distance", "formatter"], c.getDataItemValue = function (t) {
				return t && (null == t.value ? t : t.value);
			}, c.isDataItemOption = function (t) {
				return u(t) && !(t instanceof Array);
			}, c.converDataValue = function (t, e) {
				var i = e && e.type;return "ordinal" === i ? t : ("time" === i && "number" != typeof t && null != t && "-" !== t && (t = +o.parseDate(t)), null == t || "" === t ? NaN : +t);
			}, c.createDataFormatModel = function (t, e) {
				var i = new r();return s.mixin(i, c.dataFormatMixin), i.seriesIndex = e.seriesIndex, i.name = e.name || "", i.mainType = e.mainType, i.subType = e.subType, i.getData = function () {
					return t;
				}, i;
			}, c.dataFormatMixin = { getDataParams: function getDataParams(t, e) {
					var i = this.getData(e),
					    n = this.getRawValue(t, e),
					    o = i.getRawIndex(t),
					    r = i.getName(t, !0),
					    s = i.getRawDataItem(t),
					    l = i.getItemVisual(t, "color");return { componentType: this.mainType, componentSubType: this.subType, seriesType: "series" === this.mainType ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: this.id, seriesName: this.name, name: r, dataIndex: o, data: s, dataType: e, value: n, color: l, marker: a.getTooltipMarker(l), $vars: ["seriesName", "name", "value"] };
				}, getFormattedLabel: function getFormattedLabel(t, e, i, n) {
					e = e || "normal";var o = this.getData(i),
					    r = o.getItemModel(t),
					    s = this.getDataParams(t, i);null != n && s.value instanceof Array && (s.value = s.value[n]);var l = r.get(["label", e, "formatter"]);return "function" == typeof l ? (s.status = e, l(s)) : "string" == typeof l ? a.formatTpl(l, s) : void 0;
				}, getRawValue: function getRawValue(t, e) {
					var i = this.getData(e),
					    n = i.getRawDataItem(t);if (null != n) return !u(n) || n instanceof Array ? n : n.value;
				}, formatTooltip: s.noop }, c.mappingToExists = function (t, e) {
				e = (e || []).slice();var i = s.map(t || [], function (t, e) {
					return { exist: t };
				});return l(e, function (t, n) {
					if (u(t)) {
						for (var a = 0; a < i.length; a++) {
							if (!i[a].option && null != t.id && i[a].exist.id === t.id + "") return i[a].option = t, void (e[n] = null);
						}for (var a = 0; a < i.length; a++) {
							var o = i[a].exist;if (!(i[a].option || null != o.id && null != t.id || null == t.name || c.isIdInner(t) || c.isIdInner(o) || o.name !== t.name + "")) return i[a].option = t, void (e[n] = null);
						}
					}
				}), l(e, function (t, e) {
					if (u(t)) {
						for (var n = 0; n < i.length; n++) {
							var a = i[n].exist;if (!i[n].option && !c.isIdInner(a) && null == t.id) {
								i[n].option = t;break;
							}
						}n >= i.length && i.push({ option: t });
					}
				}), i;
			}, c.makeIdAndName = function (t) {
				var e = s.createHashMap();l(t, function (t, i) {
					var n = t.exist;n && e.set(n.id, t);
				}), l(t, function (t, i) {
					var n = t.option;s.assert(!n || null == n.id || !e.get(n.id) || e.get(n.id) === t, "id duplicates: " + (n && n.id)), n && null != n.id && e.set(n.id, t), !t.keyInfo && (t.keyInfo = {});
				}), l(t, function (t, i) {
					var n = t.exist,
					    a = t.option,
					    o = t.keyInfo;if (u(a)) {
						if (o.name = null != a.name ? a.name + "" : n ? n.name : "\0-", n) o.id = n.id;else if (null != a.id) o.id = a.id + "";else {
							var r = 0;do {
								o.id = "\0" + o.name + "\0" + r++;
							} while (e.get(o.id));
						}e.set(o.id, t);
					}
				});
			}, c.isIdInner = function (t) {
				return u(t) && t.id && 0 === (t.id + "").indexOf("\0_ec_\0");
			}, c.compressBatches = function (t, e) {
				function i(t, e, i) {
					for (var n = 0, a = t.length; n < a; n++) {
						for (var o = t[n].seriesId, r = c.normalizeToArray(t[n].dataIndex), s = i && i[o], l = 0, u = r.length; l < u; l++) {
							var h = r[l];s && s[h] ? s[h] = null : (e[o] || (e[o] = {}))[h] = 1;
						}
					}
				}function n(t, e) {
					var i = [];for (var a in t) {
						if (t.hasOwnProperty(a) && null != t[a]) if (e) i.push(+a);else {
							var o = n(t[a], !0);o.length && i.push({ seriesId: a, dataIndex: o });
						}
					}return i;
				}var a = {},
				    o = {};return i(t || [], a), i(e || [], o, a), [n(a), n(o)];
			}, c.queryDataIndex = function (t, e) {
				return null != e.dataIndexInside ? e.dataIndexInside : null != e.dataIndex ? s.isArray(e.dataIndex) ? s.map(e.dataIndex, function (e) {
					return t.indexOfRawIndex(e);
				}) : t.indexOfRawIndex(e.dataIndex) : null != e.name ? s.isArray(e.name) ? s.map(e.name, function (e) {
					return t.indexOfName(e);
				}) : t.indexOfName(e.name) : void 0;
			}, c.makeGetter = function () {
				var t = 0;return function () {
					var e = "\0__ec_prop_getter_" + t++;return function (t) {
						return t[e] || (t[e] = {});
					};
				};
			}(), c.parseFinder = function (t, e, i) {
				if (s.isString(e)) {
					var a = {};a[e + "Index"] = 0, e = a;
				}var o = i && i.defaultMainType;!o || n(e, o + "Index") || n(e, o + "Id") || n(e, o + "Name") || (e[o + "Index"] = 0);var r = {};return l(e, function (n, a) {
					var n = e[a];if ("dataIndex" === a || "dataIndexInside" === a) return void (r[a] = n);var o = a.match(/^(\w+)(Index|Id|Name)$/) || [],
					    l = o[1],
					    u = (o[2] || "").toLowerCase();if (!(!l || !u || null == n || "index" === u && "none" === n || i && i.includeMainTypes && s.indexOf(i.includeMainTypes, l) < 0)) {
						var c = { mainType: l };"index" === u && "all" === n || (c[u] = n);var h = t.queryComponents(c);r[l + "Models"] = h, r[l + "Model"] = h[0];
					}
				}), r;
			}, c.dataDimToCoordDim = function (t, e) {
				var i = t.dimensions;e = t.getDimension(e);for (var n = 0; n < i.length; n++) {
					var a = t.getDimensionInfo(i[n]);if (a.name === e) return a.coordDim;
				}
			}, c.coordDimToDataDim = function (t, e) {
				var i = [];return l(t.dimensions, function (n) {
					var a = t.getDimensionInfo(n);a.coordDim === e && (i[a.coordDimIndex] = a.name);
				}), i;
			}, c.otherDimToDataDim = function (t, e) {
				var i = [];return l(t.dimensions, function (n) {
					var a = t.getDimensionInfo(n),
					    o = a.otherDims,
					    r = o[e];null != r && r !== !1 && (i[r] = a.name);
				}), i;
			}, t.exports = c;
		}, function (t, e) {
			var i = "undefined" == typeof Float32Array ? Array : Float32Array,
			    n = { create: function create(t, e) {
					var n = new i(2);return null == t && (t = 0), null == e && (e = 0), n[0] = t, n[1] = e, n;
				}, copy: function copy(t, e) {
					return t[0] = e[0], t[1] = e[1], t;
				}, clone: function clone(t) {
					var e = new i(2);return e[0] = t[0], e[1] = t[1], e;
				}, set: function set(t, e, i) {
					return t[0] = e, t[1] = i, t;
				}, add: function add(t, e, i) {
					return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t;
				}, scaleAndAdd: function scaleAndAdd(t, e, i, n) {
					return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t;
				}, sub: function sub(t, e, i) {
					return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t;
				}, len: function len(t) {
					return Math.sqrt(this.lenSquare(t));
				}, lenSquare: function lenSquare(t) {
					return t[0] * t[0] + t[1] * t[1];
				}, mul: function mul(t, e, i) {
					return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t;
				}, div: function div(t, e, i) {
					return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t;
				}, dot: function dot(t, e) {
					return t[0] * e[0] + t[1] * e[1];
				}, scale: function scale(t, e, i) {
					return t[0] = e[0] * i, t[1] = e[1] * i, t;
				}, normalize: function normalize(t, e) {
					var i = n.len(e);return 0 === i ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / i, t[1] = e[1] / i), t;
				}, distance: function distance(t, e) {
					return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]));
				}, distanceSquare: function distanceSquare(t, e) {
					return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]);
				}, negate: function negate(t, e) {
					return t[0] = -e[0], t[1] = -e[1], t;
				}, lerp: function lerp(t, e, i, n) {
					return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t;
				}, applyTransform: function applyTransform(t, e, i) {
					var n = e[0],
					    a = e[1];return t[0] = i[0] * n + i[2] * a + i[4], t[1] = i[1] * n + i[3] * a + i[5], t;
				}, min: function min(t, e, i) {
					return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t;
				}, max: function max(t, e, i) {
					return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t;
				} };n.length = n.len, n.lengthSquare = n.lenSquare, n.dist = n.distance, n.distSquare = n.distanceSquare, t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(4),
			    o = i(16),
			    r = {};r.addCommas = function (t) {
				return isNaN(t) ? "-" : (t = (t + "").split("."), t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : ""));
			}, r.toCamelCase = function (t, e) {
				return t = (t || "").toLowerCase().replace(/-(.)/g, function (t, e) {
					return e.toUpperCase();
				}), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t;
			}, r.normalizeCssArray = function (t) {
				var e = t.length;return "number" == typeof t ? [t, t, t, t] : 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t;
			};var s = r.encodeHTML = function (t) {
				return String(t).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
			},
			    l = ["a", "b", "c", "d", "e", "f", "g"],
			    u = function u(t, e) {
				return "{" + t + (null == e ? "" : e) + "}";
			};r.formatTpl = function (t, e, i) {
				n.isArray(e) || (e = [e]);var a = e.length;if (!a) return "";for (var o = e[0].$vars || [], r = 0; r < o.length; r++) {
					var c = l[r],
					    h = u(c, 0);t = t.replace(u(c), i ? s(h) : h);
				}for (var d = 0; d < a; d++) {
					for (var f = 0; f < o.length; f++) {
						var h = e[d][o[f]];t = t.replace(u(l[f], d), i ? s(h) : h);
					}
				}return t;
			}, r.formatTplSimple = function (t, e, i) {
				return n.each(e, function (e, n) {
					t = t.replace("{" + n + "}", i ? s(e) : e);
				}), t;
			}, r.getTooltipMarker = function (t, e) {
				return t ? '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + r.encodeHTML(t) + ";" + (e || "") + '"></span>' : "";
			};var c = function c(t) {
				return t < 10 ? "0" + t : t;
			};r.formatTime = function (t, e, i) {
				"week" !== t && "month" !== t && "quarter" !== t && "half-year" !== t && "year" !== t || (t = "MM-dd\nyyyy");var n = a.parseDate(e),
				    o = i ? "UTC" : "",
				    r = n["get" + o + "FullYear"](),
				    s = n["get" + o + "Month"]() + 1,
				    l = n["get" + o + "Date"](),
				    u = n["get" + o + "Hours"](),
				    h = n["get" + o + "Minutes"](),
				    d = n["get" + o + "Seconds"]();return t = t.replace("MM", c(s)).toLowerCase().replace("yyyy", r).replace("yy", r % 100).replace("dd", c(l)).replace("d", l).replace("hh", c(u)).replace("h", u).replace("mm", c(h)).replace("m", h).replace("ss", c(d)).replace("s", d);
			}, r.capitalFirst = function (t) {
				return t ? t.charAt(0).toUpperCase() + t.substr(1) : t;
			}, r.truncateText = o.truncateText, t.exports = r;
		}, function (t, e, i) {
			function n(t) {
				a.call(this, t), this.path = null;
			}var a = i(38),
			    o = i(1),
			    r = i(27),
			    s = i(161),
			    l = i(72),
			    u = l.prototype.getCanvasPattern,
			    c = Math.abs,
			    h = new r(!0);n.prototype = { constructor: n, type: "path", __dirtyPath: !0, strokeContainThreshold: 5, brush: function brush(t, e) {
					var i = this.style,
					    n = this.path || h,
					    a = i.hasStroke(),
					    o = i.hasFill(),
					    r = i.fill,
					    s = i.stroke,
					    l = o && !!r.colorStops,
					    c = a && !!s.colorStops,
					    d = o && !!r.image,
					    f = a && !!s.image;if (i.bind(t, this, e), this.setTransform(t), this.__dirty) {
						var p;l && (p = p || this.getBoundingRect(), this._fillGradient = i.getGradient(t, r, p)), c && (p = p || this.getBoundingRect(), this._strokeGradient = i.getGradient(t, s, p));
					}l ? t.fillStyle = this._fillGradient : d && (t.fillStyle = u.call(r, t)), c ? t.strokeStyle = this._strokeGradient : f && (t.strokeStyle = u.call(s, t));var g = i.lineDash,
					    m = i.lineDashOffset,
					    v = !!t.setLineDash,
					    y = this.getGlobalScale();n.setScale(y[0], y[1]), this.__dirtyPath || g && !v && a ? (n.beginPath(t), g && !v && (n.setLineDash(g), n.setLineDashOffset(m)), this.buildPath(n, this.shape, !1), this.path && (this.__dirtyPath = !1)) : (t.beginPath(), this.path.rebuildPath(t)), o && n.fill(t), g && v && (t.setLineDash(g), t.lineDashOffset = m), a && n.stroke(t), g && v && t.setLineDash([]), this.restoreTransform(t), null != i.text && this.drawRectText(t, this.getBoundingRect());
				}, buildPath: function buildPath(t, e, i) {}, createPathProxy: function createPathProxy() {
					this.path = new r();
				}, getBoundingRect: function getBoundingRect() {
					var t = this._rect,
					    e = this.style,
					    i = !t;if (i) {
						var n = this.path;n || (n = this.path = new r()), this.__dirtyPath && (n.beginPath(), this.buildPath(n, this.shape, !1)), t = n.getBoundingRect();
					}if (this._rect = t, e.hasStroke()) {
						var a = this._rectWithStroke || (this._rectWithStroke = t.clone());if (this.__dirty || i) {
							a.copy(t);var o = e.lineWidth,
							    s = e.strokeNoScale ? this.getLineScale() : 1;e.hasFill() || (o = Math.max(o, this.strokeContainThreshold || 4)), s > 1e-10 && (a.width += o / s, a.height += o / s, a.x -= o / s / 2, a.y -= o / s / 2);
						}return a;
					}return t;
				}, contain: function contain(t, e) {
					var i = this.transformCoordToLocal(t, e),
					    n = this.getBoundingRect(),
					    a = this.style;if (t = i[0], e = i[1], n.contain(t, e)) {
						var o = this.path.data;if (a.hasStroke()) {
							var r = a.lineWidth,
							    l = a.strokeNoScale ? this.getLineScale() : 1;if (l > 1e-10 && (a.hasFill() || (r = Math.max(r, this.strokeContainThreshold)), s.containStroke(o, r / l, t, e))) return !0;
						}if (a.hasFill()) return s.contain(o, t, e);
					}return !1;
				}, dirty: function dirty(t) {
					null == t && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty();
				}, animateShape: function animateShape(t) {
					return this.animate("shape", t);
				}, attrKV: function attrKV(t, e) {
					"shape" === t ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : a.prototype.attrKV.call(this, t, e);
				}, setShape: function setShape(t, e) {
					var i = this.shape;if (i) {
						if (o.isObject(t)) for (var n in t) {
							t.hasOwnProperty(n) && (i[n] = t[n]);
						} else i[t] = e;this.dirty(!0);
					}return this;
				}, getLineScale: function getLineScale() {
					var t = this.transform;return t && c(t[0] - 1) > 1e-10 && c(t[3] - 1) > 1e-10 ? Math.sqrt(c(t[0] * t[3] - t[2] * t[1])) : 1;
				} }, n.extend = function (t) {
				var e = function e(_e) {
					n.call(this, _e), t.style && this.style.extendFrom(t.style, !1);var i = t.shape;if (i) {
						this.shape = this.shape || {};var a = this.shape;for (var o in i) {
							!a.hasOwnProperty(o) && i.hasOwnProperty(o) && (a[o] = i[o]);
						}
					}t.init && t.init.call(this, _e);
				};o.inherits(e, n);for (var i in t) {
					"style" !== i && "shape" !== i && (e.prototype[i] = t[i]);
				}return e;
			}, o.inherits(n, a), t.exports = n;
		}, function (t, e) {
			function i(t) {
				var e = {},
				    i = {},
				    n = t.match(/Firefox\/([\d.]+)/),
				    a = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/),
				    o = t.match(/Edge\/([\d.]+)/),
				    r = /micromessenger/i.test(t);return n && (i.firefox = !0, i.version = n[1]), a && (i.ie = !0, i.version = a[1]), o && (i.edge = !0, i.version = o[1]), r && (i.weChat = !0), { browser: i, os: e, node: !1, canvasSupported: !!document.createElement("canvas").getContext, touchEventsSupported: "ontouchstart" in window && !i.ie && !i.edge, pointerEventsSupported: "onpointerdown" in window && (i.edge || i.ie && i.version >= 11) };
			}var n = {};n = "undefined" == typeof navigator ? { browser: {}, os: {}, node: !0, canvasSupported: !0 } : i(navigator.userAgent), t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i) {
				this.parentModel = e, this.ecModel = i, this.option = t;
			}function a(t, e, i) {
				for (var n = 0; n < e.length && (!e[n] || (t = t && "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) ? t[e[n]] : null, null != t)); n++) {}return null == t && i && (t = i.get(e)), t;
			}function o(t, e) {
				var i = s.get(t, "getParent");return i ? i.call(t, e) : t.parentModel;
			}var r = i(1),
			    s = i(15),
			    l = i(9);n.prototype = { constructor: n, init: null, mergeOption: function mergeOption(t) {
					r.merge(this.option, t, !0);
				}, get: function get(t, e) {
					return null == t ? this.option : a(this.option, this.parsePath(t), !e && o(this, t));
				}, getShallow: function getShallow(t, e) {
					var i = this.option,
					    n = null == i ? i : i[t],
					    a = !e && o(this, t);return null == n && a && (n = a.getShallow(t)), n;
				}, getModel: function getModel(t, e) {
					var i,
					    r = null == t ? this.option : a(this.option, t = this.parsePath(t));return e = e || (i = o(this, t)) && i.getModel(t), new n(r, e, this.ecModel);
				}, isEmpty: function isEmpty() {
					return null == this.option;
				}, restoreData: function restoreData() {}, clone: function clone() {
					var t = this.constructor;return new t(r.clone(this.option));
				}, setReadOnly: function setReadOnly(t) {
					s.setReadOnly(this, t);
				}, parsePath: function parsePath(t) {
					return "string" == typeof t && (t = t.split(".")), t;
				}, customizeGetParent: function customizeGetParent(t) {
					s.set(this, "getParent", t);
				}, isAnimationEnabled: function isAnimationEnabled() {
					if (!l.node) {
						if (null != this.option.animation) return !!this.option.animation;if (this.parentModel) return this.parentModel.isAnimationEnabled();
					}
				} }, s.enableClassExtend(n);var u = r.mixin;u(n, i(143)), u(n, i(140)), u(n, i(144)), u(n, i(142)), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i, n) {
				i < 0 && (t += i, i = -i), n < 0 && (e += n, n = -n), this.x = t, this.y = e, this.width = i, this.height = n;
			}var a = i(6),
			    o = i(19),
			    r = a.applyTransform,
			    s = Math.min,
			    l = Math.max;n.prototype = { constructor: n, union: function union(t) {
					var e = s(t.x, this.x),
					    i = s(t.y, this.y);this.width = l(t.x + t.width, this.x + this.width) - e, this.height = l(t.y + t.height, this.y + this.height) - i, this.x = e, this.y = i;
				}, applyTransform: function () {
					var t = [],
					    e = [],
					    i = [],
					    n = [];return function (a) {
						if (a) {
							t[0] = i[0] = this.x, t[1] = n[1] = this.y, e[0] = n[0] = this.x + this.width, e[1] = i[1] = this.y + this.height, r(t, t, a), r(e, e, a), r(i, i, a), r(n, n, a), this.x = s(t[0], e[0], i[0], n[0]), this.y = s(t[1], e[1], i[1], n[1]);var o = l(t[0], e[0], i[0], n[0]),
							    u = l(t[1], e[1], i[1], n[1]);this.width = o - this.x, this.height = u - this.y;
						}
					};
				}(), calculateTransform: function calculateTransform(t) {
					var e = this,
					    i = t.width / e.width,
					    n = t.height / e.height,
					    a = o.create();return o.translate(a, a, [-e.x, -e.y]), o.scale(a, a, [i, n]), o.translate(a, a, [t.x, t.y]), a;
				}, intersect: function intersect(t) {
					if (!t) return !1;t instanceof n || (t = n.create(t));var e = this,
					    i = e.x,
					    a = e.x + e.width,
					    o = e.y,
					    r = e.y + e.height,
					    s = t.x,
					    l = t.x + t.width,
					    u = t.y,
					    c = t.y + t.height;return !(a < s || l < i || r < u || c < o);
				}, contain: function contain(t, e) {
					var i = this;return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i.height;
				}, clone: function clone() {
					return new n(this.x, this.y, this.width, this.height);
				}, copy: function copy(t) {
					this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height;
				}, plain: function plain() {
					return { x: this.x, y: this.y, width: this.width, height: this.height };
				} }, n.create = function (t) {
				return new n(t.x, t.y, t.width, t.height);
			}, t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i, n, a) {
				var o = 0,
				    r = 0;null == n && (n = 1 / 0), null == a && (a = 1 / 0);var s = 0;e.eachChild(function (l, u) {
					var c,
					    h,
					    d = l.position,
					    f = l.getBoundingRect(),
					    p = e.childAt(u + 1),
					    g = p && p.getBoundingRect();if ("horizontal" === t) {
						var m = f.width + (g ? -g.x + f.x : 0);c = o + m, c > n || l.newline ? (o = 0, c = m, r += s + i, s = f.height) : s = Math.max(s, f.height);
					} else {
						var v = f.height + (g ? -g.y + f.y : 0);h = r + v, h > a || l.newline ? (o += s + i, r = 0, h = v, s = f.width) : s = Math.max(s, f.width);
					}l.newline || (d[0] = o, d[1] = r, "horizontal" === t ? o = c + i : r = h + i);
				});
			}var a = i(1),
			    o = i(11),
			    r = i(4),
			    s = i(7),
			    l = r.parsePercent,
			    u = a.each,
			    c = {},
			    h = c.LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"],
			    d = c.HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];c.box = n, c.vbox = a.curry(n, "vertical"), c.hbox = a.curry(n, "horizontal"), c.getAvailableSize = function (t, e, i) {
				var n = e.width,
				    a = e.height,
				    o = l(t.x, n),
				    r = l(t.y, a),
				    u = l(t.x2, n),
				    c = l(t.y2, a);return (isNaN(o) || isNaN(parseFloat(t.x))) && (o = 0), (isNaN(u) || isNaN(parseFloat(t.x2))) && (u = n), (isNaN(r) || isNaN(parseFloat(t.y))) && (r = 0), (isNaN(c) || isNaN(parseFloat(t.y2))) && (c = a), i = s.normalizeCssArray(i || 0), { width: Math.max(u - o - i[1] - i[3], 0), height: Math.max(c - r - i[0] - i[2], 0) };
			}, c.getLayoutRect = function (t, e, i) {
				i = s.normalizeCssArray(i || 0);var n = e.width,
				    a = e.height,
				    r = l(t.left, n),
				    u = l(t.top, a),
				    c = l(t.right, n),
				    h = l(t.bottom, a),
				    d = l(t.width, n),
				    f = l(t.height, a),
				    p = i[2] + i[0],
				    g = i[1] + i[3],
				    m = t.aspect;switch (isNaN(d) && (d = n - c - g - r), isNaN(f) && (f = a - h - p - u), isNaN(d) && isNaN(f) && (m > n / a ? d = .8 * n : f = .8 * a), null != m && (isNaN(d) && (d = m * f), isNaN(f) && (f = d / m)), isNaN(r) && (r = n - c - d - g), isNaN(u) && (u = a - h - f - p), t.left || t.right) {case "center":
						r = n / 2 - d / 2 - i[3];break;case "right":
						r = n - d - g;}switch (t.top || t.bottom) {case "middle":case "center":
						u = a / 2 - f / 2 - i[0];break;case "bottom":
						u = a - f - p;}r = r || 0, u = u || 0, isNaN(d) && (d = n - r - (c || 0)), isNaN(f) && (f = a - u - (h || 0));var v = new o(r + i[3], u + i[0], d, f);return v.margin = i, v;
			}, c.positionElement = function (t, e, i, n, r) {
				var s = !r || !r.hv || r.hv[0],
				    l = !r || !r.hv || r.hv[1],
				    u = r && r.boundingMode || "all";if (s || l) {
					var h;if ("raw" === u) h = "group" === t.type ? new o(0, 0, +e.width || 0, +e.height || 0) : t.getBoundingRect();else if (h = t.getBoundingRect(), t.needLocalTransform()) {
						var d = t.getLocalTransform();h = h.clone(), h.applyTransform(d);
					}e = c.getLayoutRect(a.defaults({ width: h.width, height: h.height }, e), i, n);var f = t.position,
					    p = s ? e.x - h.x : 0,
					    g = l ? e.y - h.y : 0;t.attr("position", "raw" === u ? [p, g] : [f[0] + p, f[1] + g]);
				}
			}, c.sizeCalculable = function (t, e) {
				return null != t[d[e][0]] || null != t[d[e][1]] && null != t[d[e][2]];
			}, c.mergeLayoutParam = function (t, e, i) {
				function n(i, n) {
					var a = {},
					    s = 0,
					    c = {},
					    h = 0,
					    d = 2;if (u(i, function (e) {
						c[e] = t[e];
					}), u(i, function (t) {
						o(e, t) && (a[t] = c[t] = e[t]), r(a, t) && s++, r(c, t) && h++;
					}), l[n]) return r(e, i[1]) ? c[i[2]] = null : r(e, i[2]) && (c[i[1]] = null), c;if (h !== d && s) {
						if (s >= d) return a;for (var f = 0; f < i.length; f++) {
							var p = i[f];if (!o(a, p) && o(t, p)) {
								a[p] = t[p];break;
							}
						}return a;
					}return c;
				}function o(t, e) {
					return t.hasOwnProperty(e);
				}function r(t, e) {
					return null != t[e] && "auto" !== t[e];
				}function s(t, e, i) {
					u(t, function (t) {
						e[t] = i[t];
					});
				}!a.isObject(i) && (i = {});var l = i.ignoreSize;!a.isArray(l) && (l = [l, l]);var c = n(d[0], 0),
				    h = n(d[1], 1);s(d[0], t, c), s(d[1], t, h);
			}, c.getLayoutParams = function (t) {
				return c.copyLayoutParams({}, t);
			}, c.copyLayoutParams = function (t, e) {
				return e && t && u(h, function (i) {
					e.hasOwnProperty(i) && (t[i] = e[i]);
				}), t;
			}, t.exports = c;
		}, function (t, e, i) {
			function n(t) {
				var e = [];return o.each(c.getClassesByMainType(t), function (t) {
					r.apply(e, t.prototype.dependencies || []);
				}), o.map(e, function (t) {
					return l.parseClassType(t).main;
				});
			}var a = i(10),
			    o = i(1),
			    r = Array.prototype.push,
			    s = i(49),
			    l = i(15),
			    u = i(12),
			    c = a.extend({ type: "component", id: "", name: "", mainType: "", subType: "", componentIndex: 0, defaultOption: null, ecModel: null, dependentModels: [], uid: null, layoutMode: null, $constructor: function $constructor(t, e, i, n) {
					a.call(this, t, e, i, n), this.uid = s.getUID("componentModel");
				}, init: function init(t, e, i, n) {
					this.mergeDefaultAndTheme(t, i);
				}, mergeDefaultAndTheme: function mergeDefaultAndTheme(t, e) {
					var i = this.layoutMode,
					    n = i ? u.getLayoutParams(t) : {},
					    a = e.getTheme();o.merge(t, a.get(this.mainType)), o.merge(t, this.getDefaultOption()), i && u.mergeLayoutParam(t, n, i);
				}, mergeOption: function mergeOption(t, e) {
					o.merge(this.option, t, !0);var i = this.layoutMode;i && u.mergeLayoutParam(this.option, t, i);
				}, optionUpdated: function optionUpdated(t, e) {}, getDefaultOption: function getDefaultOption() {
					if (!l.hasOwn(this, "__defaultOption")) {
						for (var t = [], e = this.constructor; e;) {
							var i = e.prototype.defaultOption;i && t.push(i), e = e.superClass;
						}for (var n = {}, a = t.length - 1; a >= 0; a--) {
							n = o.merge(n, t[a], !0);
						}l.set(this, "__defaultOption", n);
					}return l.get(this, "__defaultOption");
				}, getReferringComponents: function getReferringComponents(t) {
					return this.ecModel.queryComponents({ mainType: t, index: this.get(t + "Index", !0), id: this.get(t + "Id", !0) });
				} });l.enableClassManagement(c, { registerWhenExtend: !0 }), s.enableSubTypeDefaulter(c), s.enableTopologicalTravel(c, n), o.mixin(c, i(141)), t.exports = c;
		}, function (t, e, i) {
			(function (e) {
				function n(t, e) {
					p.each(v.concat(e.__wrappedMethods || []), function (i) {
						e.hasOwnProperty(i) && (t[i] = e[i]);
					}), t.__wrappedMethods = e.__wrappedMethods;
				}function a(t) {
					this._array = t || [];
				}function o(t) {
					return p.isArray(t) || (t = [t]), t;
				}function r(t, e) {
					var i = t.dimensions,
					    a = new y(p.map(i, t.getDimensionInfo, t), t.hostModel);n(a, t);for (var o = a._storage = {}, r = t._storage, s = 0; s < i.length; s++) {
						var l = i[s],
						    u = r[l];p.indexOf(e, l) >= 0 ? o[l] = new u.constructor(r[l].length) : o[l] = r[l];
					}return a;
				}var s = "undefined",
				    l = "undefined" == typeof window ? e : window,
				    u = _typeof(l.Float64Array) === s ? Array : l.Float64Array,
				    c = _typeof(l.Int32Array) === s ? Array : l.Int32Array,
				    h = { "float": u, "int": c, ordinal: Array, number: Array, time: Array },
				    d = i(10),
				    f = i(48),
				    p = i(1),
				    g = i(5),
				    m = p.isObject,
				    v = ["stackedOn", "hasItemOption", "_nameList", "_idList", "_rawData"];a.prototype.pure = !1, a.prototype.count = function () {
					return this._array.length;
				}, a.prototype.getItem = function (t) {
					return this._array[t];
				};var y = function y(t, e) {
					t = t || ["x", "y"];for (var i = {}, n = [], a = 0; a < t.length; a++) {
						var o,
						    r = {};"string" == typeof t[a] ? (o = t[a], r = { name: o, coordDim: o, coordDimIndex: 0, stackable: !1, type: "number" }) : (r = t[a], o = r.name, r.type = r.type || "number", r.coordDim || (r.coordDim = o, r.coordDimIndex = 0)), r.otherDims = r.otherDims || {}, n.push(o), i[o] = r;
					}this.dimensions = n, this._dimensionInfos = i, this.hostModel = e, this.dataType, this.indices = [], this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this.stackedOn = null, this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._rawData, this._extent;
				},
				    x = y.prototype;x.type = "list", x.hasItemOption = !0, x.getDimension = function (t) {
					return isNaN(t) || (t = this.dimensions[t] || t), t;
				}, x.getDimensionInfo = function (t) {
					return p.clone(this._dimensionInfos[this.getDimension(t)]);
				}, x.initData = function (t, e, i) {
					t = t || [];var n = p.isArray(t);n && (t = new a(t)), this._rawData = t;var o,
					    r = this._storage = {},
					    s = this.indices = [],
					    l = this.dimensions,
					    u = this._dimensionInfos,
					    c = t.count(),
					    d = [],
					    f = {};e = e || [];for (var m = 0; m < l.length; m++) {
						var v = u[l[m]];0 === v.otherDims.itemName && (o = m);var y = h[v.type];r[l[m]] = new y(c);
					}var x = this;i || (x.hasItemOption = !1), i = i || function (t, e, i, n) {
						var a = g.getDataItemValue(t);return g.isDataItemOption(t) && (x.hasItemOption = !0), g.converDataValue(a instanceof Array ? a[n] : a, u[e]);
					};for (var m = 0; m < c; m++) {
						for (var _ = t.getItem(m), b = 0; b < l.length; b++) {
							var w = l[b],
							    S = r[w];S[m] = i(_, w, m, b);
						}s.push(m);
					}for (var m = 0; m < c; m++) {
						var _ = t.getItem(m);!e[m] && _ && (null != _.name ? e[m] = _.name : null != o && (e[m] = r[l[o]][m]));var M = e[m] || "",
						    I = _ && _.id;!I && M && (f[M] = f[M] || 0, I = M, f[M] > 0 && (I += "__ec__" + f[M]), f[M]++), I && (d[m] = I);
					}this._nameList = e, this._idList = d;
				}, x.count = function () {
					return this.indices.length;
				}, x.get = function (t, e, i) {
					var n = this._storage,
					    a = this.indices[e];if (null == a || !n[t]) return NaN;var o = n[t][a];if (i) {
						var r = this._dimensionInfos[t];if (r && r.stackable) for (var s = this.stackedOn; s;) {
							var l = s.get(t, e);(o >= 0 && l > 0 || o <= 0 && l < 0) && (o += l), s = s.stackedOn;
						}
					}return o;
				}, x.getValues = function (t, e, i) {
					var n = [];p.isArray(t) || (i = e, e = t, t = this.dimensions);for (var a = 0, o = t.length; a < o; a++) {
						n.push(this.get(t[a], e, i));
					}return n;
				}, x.hasValue = function (t) {
					for (var e = this.dimensions, i = this._dimensionInfos, n = 0, a = e.length; n < a; n++) {
						if ("ordinal" !== i[e[n]].type && isNaN(this.get(e[n], t))) return !1;
					}return !0;
				}, x.getDataExtent = function (t, e, i) {
					t = this.getDimension(t);var n = this._storage[t],
					    a = this.getDimensionInfo(t);e = a && a.stackable && e;var o,
					    r = (this._extent || (this._extent = {}))[t + !!e];if (r) return r;if (n) {
						for (var s = 1 / 0, l = -(1 / 0), u = 0, c = this.count(); u < c; u++) {
							o = this.get(t, u, e), i && !i(o, t, u) || (o < s && (s = o), o > l && (l = o));
						}return this._extent[t + !!e] = [s, l];
					}return [1 / 0, -(1 / 0)];
				}, x.getSum = function (t, e) {
					var i = this._storage[t],
					    n = 0;if (i) for (var a = 0, o = this.count(); a < o; a++) {
						var r = this.get(t, a, e);isNaN(r) || (n += r);
					}return n;
				}, x.indexOf = function (t, e) {
					var i = this._storage,
					    n = i[t],
					    a = this.indices;if (n) for (var o = 0, r = a.length; o < r; o++) {
						var s = a[o];if (n[s] === e) return o;
					}return -1;
				}, x.indexOfName = function (t) {
					for (var e = this.indices, i = this._nameList, n = 0, a = e.length; n < a; n++) {
						var o = e[n];if (i[o] === t) return n;
					}return -1;
				}, x.indexOfRawIndex = function (t) {
					var e = this.indices,
					    i = e[t];if (null != i && i === t) return t;for (var n = 0, a = e.length - 1; n <= a;) {
						var o = (n + a) / 2 | 0;if (e[o] < t) n = o + 1;else {
							if (!(e[o] > t)) return o;a = o - 1;
						}
					}return -1;
				}, x.indicesOfNearest = function (t, e, i, n) {
					var a = this._storage,
					    o = a[t],
					    r = [];if (!o) return r;null == n && (n = 1 / 0);for (var s = Number.MAX_VALUE, l = -1, u = 0, c = this.count(); u < c; u++) {
						var h = e - this.get(t, u, i),
						    d = Math.abs(h);h <= n && d <= s && ((d < s || h >= 0 && l < 0) && (s = d, l = h, r.length = 0), r.push(u));
					}return r;
				}, x.getRawIndex = function (t) {
					var e = this.indices[t];return null == e ? -1 : e;
				}, x.getRawDataItem = function (t) {
					return this._rawData.getItem(this.getRawIndex(t));
				}, x.getName = function (t) {
					return this._nameList[this.indices[t]] || "";
				}, x.getId = function (t) {
					return this._idList[this.indices[t]] || this.getRawIndex(t) + "";
				}, x.each = function (t, e, i, n) {
					"function" == typeof t && (n = i, i = e, e = t, t = []), t = p.map(o(t), this.getDimension, this);var a = [],
					    r = t.length,
					    s = this.indices;n = n || this;for (var l = 0; l < s.length; l++) {
						switch (r) {case 0:
								e.call(n, l);break;case 1:
								e.call(n, this.get(t[0], l, i), l);break;case 2:
								e.call(n, this.get(t[0], l, i), this.get(t[1], l, i), l);break;default:
								for (var u = 0; u < r; u++) {
									a[u] = this.get(t[u], l, i);
								}a[u] = l, e.apply(n, a);}
					}
				}, x.filterSelf = function (t, e, i, n) {
					"function" == typeof t && (n = i, i = e, e = t, t = []), t = p.map(o(t), this.getDimension, this);var a = [],
					    r = [],
					    s = t.length,
					    l = this.indices;n = n || this;for (var u = 0; u < l.length; u++) {
						var c;if (s) {
							if (1 === s) c = e.call(n, this.get(t[0], u, i), u);else {
								for (var h = 0; h < s; h++) {
									r[h] = this.get(t[h], u, i);
								}r[h] = u, c = e.apply(n, r);
							}
						} else c = e.call(n, u);c && a.push(l[u]);
					}return this.indices = a, this._extent = {}, this;
				}, x.mapArray = function (t, e, i, n) {
					"function" == typeof t && (n = i, i = e, e = t, t = []);var a = [];return this.each(t, function () {
						a.push(e && e.apply(this, arguments));
					}, i, n), a;
				}, x.map = function (t, e, i, n) {
					t = p.map(o(t), this.getDimension, this);var a = r(this, t),
					    s = a.indices = this.indices,
					    l = a._storage,
					    u = [];return this.each(t, function () {
						var i = arguments[arguments.length - 1],
						    n = e && e.apply(this, arguments);if (null != n) {
							"number" == typeof n && (u[0] = n, n = u);for (var a = 0; a < n.length; a++) {
								var o = t[a],
								    r = l[o],
								    c = s[i];r && (r[c] = n[a]);
							}
						}
					}, i, n), a;
				}, x.downSample = function (t, e, i, n) {
					for (var a = r(this, [t]), o = this._storage, s = a._storage, l = this.indices, u = a.indices = [], c = [], h = [], d = Math.floor(1 / e), f = s[t], p = this.count(), g = 0; g < o[t].length; g++) {
						s[t][g] = o[t][g];
					}for (var g = 0; g < p; g += d) {
						d > p - g && (d = p - g, c.length = d);for (var m = 0; m < d; m++) {
							var v = l[g + m];c[m] = f[v], h[m] = v;
						}var y = i(c),
						    v = h[n(c, y) || 0];f[v] = y, u.push(v);
					}return a;
				}, x.getItemModel = function (t) {
					var e = this.hostModel;return t = this.indices[t], new d(this._rawData.getItem(t), e, e && e.ecModel);
				}, x.diff = function (t) {
					var e,
					    i = this._idList,
					    n = t && t._idList,
					    a = "e\0\0";return new f(t ? t.indices : [], this.indices, function (t) {
						return null != (e = n[t]) ? e : a + t;
					}, function (t) {
						return null != (e = i[t]) ? e : a + t;
					});
				}, x.getVisual = function (t) {
					var e = this._visual;return e && e[t];
				}, x.setVisual = function (t, e) {
					if (m(t)) for (var i in t) {
						t.hasOwnProperty(i) && this.setVisual(i, t[i]);
					} else this._visual = this._visual || {}, this._visual[t] = e;
				}, x.setLayout = function (t, e) {
					if (m(t)) for (var i in t) {
						t.hasOwnProperty(i) && this.setLayout(i, t[i]);
					} else this._layout[t] = e;
				}, x.getLayout = function (t) {
					return this._layout[t];
				}, x.getItemLayout = function (t) {
					return this._itemLayouts[t];
				}, x.setItemLayout = function (t, e, i) {
					this._itemLayouts[t] = i ? p.extend(this._itemLayouts[t] || {}, e) : e;
				}, x.clearItemLayouts = function () {
					this._itemLayouts.length = 0;
				}, x.getItemVisual = function (t, e, i) {
					var n = this._itemVisuals[t],
					    a = n && n[e];return null != a || i ? a : this.getVisual(e);
				}, x.setItemVisual = function (t, e, i) {
					var n = this._itemVisuals[t] || {};if (this._itemVisuals[t] = n, m(e)) for (var a in e) {
						e.hasOwnProperty(a) && (n[a] = e[a]);
					} else n[e] = i;
				}, x.clearAllVisual = function () {
					this._visual = {}, this._itemVisuals = [];
				};var _ = function _(t) {
					t.seriesIndex = this.seriesIndex, t.dataIndex = this.dataIndex, t.dataType = this.dataType;
				};x.setItemGraphicEl = function (t, e) {
					var i = this.hostModel;e && (e.dataIndex = t, e.dataType = this.dataType, e.seriesIndex = i && i.seriesIndex, "group" === e.type && e.traverse(_, e)), this._graphicEls[t] = e;
				}, x.getItemGraphicEl = function (t) {
					return this._graphicEls[t];
				}, x.eachItemGraphicEl = function (t, e) {
					p.each(this._graphicEls, function (i, n) {
						i && t && t.call(e, i, n);
					});
				}, x.cloneShallow = function () {
					var t = p.map(this.dimensions, this.getDimensionInfo, this),
					    e = new y(t, this.hostModel);return e._storage = this._storage, n(e, this), e.indices = this.indices.slice(), this._extent && (e._extent = p.extend({}, this._extent)), e;
				}, x.wrapMethod = function (t, e) {
					var i = this[t];"function" == typeof i && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function () {
						var t = i.apply(this, arguments);return e.apply(this, [t].concat(p.slice(arguments)));
					});
				}, x.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], x.CHANGABLE_METHODS = ["filterSelf"], t.exports = y;
			}).call(e, function () {
				return this;
			}());
		}, function (t, e, i) {
			function n(t) {
				r.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), 'componentType "' + t + '" illegal');
			}function a(t, e) {
				var i = r.slice(arguments, 2);return this.superClass.prototype[e].apply(t, i);
			}function o(t, e, i) {
				return this.superClass.prototype[e].apply(t, i);
			}var r = i(1),
			    s = {},
			    l = ".",
			    u = "___EC__COMPONENT__CONTAINER___",
			    c = "\0ec_\0";s.set = function (t, e, i) {
				return t[c + e] = i;
			}, s.get = function (t, e) {
				return t[c + e];
			}, s.hasOwn = function (t, e) {
				return t.hasOwnProperty(c + e);
			};var h = s.parseClassType = function (t) {
				var e = { main: "", sub: "" };return t && (t = t.split(l), e.main = t[0] || "", e.sub = t[1] || ""), e;
			};s.enableClassExtend = function (t, e) {
				t.$constructor = t, t.extend = function (t) {
					var e = this,
					    i = function i() {
						t.$constructor ? t.$constructor.apply(this, arguments) : e.apply(this, arguments);
					};return r.extend(i.prototype, t), i.extend = this.extend, i.superCall = a, i.superApply = o, r.inherits(i, this), i.superClass = e, i;
				};
			}, s.enableClassManagement = function (t, e) {
				function i(t) {
					var e = a[t.main];return e && e[u] || (e = a[t.main] = {}, e[u] = !0), e;
				}e = e || {};var a = {};if (t.registerClass = function (t, e) {
					if (e) if (n(e), e = h(e), e.sub) {
						if (e.sub !== u) {
							var o = i(e);o[e.sub] = t;
						}
					} else a[e.main] = t;return t;
				}, t.getClass = function (t, e, i) {
					var n = a[t];if (n && n[u] && (n = e ? n[e] : null), i && !n) throw new Error(e ? "Component " + t + "." + (e || "") + " not exists. Load it first." : t + ".type should be specified.");return n;
				}, t.getClassesByMainType = function (t) {
					t = h(t);var e = [],
					    i = a[t.main];return i && i[u] ? r.each(i, function (t, i) {
						i !== u && e.push(t);
					}) : e.push(i), e;
				}, t.hasClass = function (t) {
					return t = h(t), !!a[t.main];
				}, t.getAllClassMainTypes = function () {
					var t = [];return r.each(a, function (e, i) {
						t.push(i);
					}), t;
				}, t.hasSubTypes = function (t) {
					t = h(t);var e = a[t.main];return e && e[u];
				}, t.parseClassType = h, e.registerWhenExtend) {
					var o = t.extend;o && (t.extend = function (e) {
						var i = o.call(this, e);return t.registerClass(i, e.type);
					});
				}return t;
			}, s.setReadOnly = function (t, e) {}, t.exports = s;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t + ":" + e;if (l[i]) return l[i];for (var n = (t + "").split("\n"), a = 0, o = 0, r = n.length; o < r; o++) {
					a = Math.max(p.measureText(n[o], e).width, a);
				}return u > c && (u = 0, l = {}), u++, l[i] = a, a;
			}function a(t, e, i, a) {
				var o = ((t || "") + "").split("\n").length,
				    r = n(t, e),
				    s = n("", e),
				    l = o * s,
				    u = new d(0, 0, r, l);switch (u.lineHeight = s, a) {case "bottom":case "alphabetic":
						u.y -= s;break;case "middle":
						u.y -= s / 2;}switch (i) {case "end":case "right":
						u.x -= u.width;break;case "center":
						u.x -= u.width / 2;}return u;
			}function o(t, e, i, n) {
				var a = e.x,
				    o = e.y,
				    r = e.height,
				    s = e.width,
				    l = i.height,
				    u = i.lineHeight,
				    c = r / 2 - l / 2 + u,
				    h = "left";switch (t) {case "left":
						a -= n, o += c, h = "right";break;case "right":
						a += n + s, o += c, h = "left";break;case "top":
						a += s / 2, o -= n + l - u, h = "center";break;case "bottom":
						a += s / 2, o += r + n + u, h = "center";break;case "inside":
						a += s / 2, o += c, h = "center";break;case "insideLeft":
						a += n, o += c, h = "left";break;case "insideRight":
						a += s - n, o += c, h = "right";break;case "insideTop":
						a += s / 2, o += n + u, h = "center";break;case "insideBottom":
						a += s / 2, o += r - l - n + u, h = "center";break;case "insideTopLeft":
						a += n, o += n + u, h = "left";break;case "insideTopRight":
						a += s - n, o += n + u, h = "right";break;case "insideBottomLeft":
						a += n, o += r - l - n + u;break;case "insideBottomRight":
						a += s - n, o += r - l - n + u, h = "right";}return { x: a, y: o, textAlign: h, textBaseline: "alphabetic" };
			}function r(t, e, i, a, o) {
				if (!e) return "";o = o || {}, a = f(a, "...");for (var r = f(o.maxIterations, 2), l = f(o.minChar, 0), u = n("", i), c = n("a", i), h = f(o.placeholder, ""), d = e = Math.max(0, e - 1), p = 0; p < l && d >= c; p++) {
					d -= c;
				}var g = n(a);g > d && (a = "", g = 0), d = e - g;for (var m = (t + "").split("\n"), p = 0, v = m.length; p < v; p++) {
					var y = m[p],
					    x = n(y, i);if (!(x <= e)) {
						for (var _ = 0;; _++) {
							if (x <= d || _ >= r) {
								y += a;break;
							}var b = 0 === _ ? s(y, d, c, u) : x > 0 ? Math.floor(y.length * d / x) : 0;y = y.substr(0, b), x = n(y, i);
						}"" === y && (y = h), m[p] = y;
					}
				}return m.join("\n");
			}function s(t, e, i, n) {
				for (var a = 0, o = 0, r = t.length; o < r && a < e; o++) {
					var s = t.charCodeAt(o);a += 0 <= s && s <= 127 ? i : n;
				}return o;
			}var l = {},
			    u = 0,
			    c = 5e3,
			    h = i(1),
			    d = i(11),
			    f = h.retrieve,
			    p = { getWidth: n, getBoundingRect: a, adjustTextPositionOnRect: o, truncateText: r, measureText: function measureText(t, e) {
					var i = h.getContext();return i.font = e || "12px sans-serif", i.measureText(t);
				} };t.exports = p;
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(7),
			    o = i(15),
			    r = i(5),
			    s = i(13),
			    l = i(62),
			    u = i(9),
			    c = i(12),
			    h = o.set,
			    d = o.get,
			    f = a.encodeHTML,
			    p = a.addCommas,
			    g = s.extend({ type: "series.__base__", seriesIndex: 0, coordinateSystem: null, defaultOption: null, legendDataProvider: null, visualColorAccessPath: "itemStyle.normal.color", layoutMode: null, init: function init(t, e, i, n) {
					this.seriesIndex = this.componentIndex, this.mergeDefaultAndTheme(t, i);var a = this.getInitialData(t, i);h(this, "dataBeforeProcessed", a), this.restoreData();
				}, mergeDefaultAndTheme: function mergeDefaultAndTheme(t, e) {
					var i = this.layoutMode,
					    a = i ? c.getLayoutParams(t) : {};n.merge(t, e.getTheme().get(this.subType)), n.merge(t, this.getDefaultOption()), r.defaultEmphasis(t.label, r.LABEL_OPTIONS), this.fillDataTextStyle(t.data), i && c.mergeLayoutParam(t, a, i);
				}, mergeOption: function mergeOption(t, e) {
					t = n.merge(this.option, t, !0), this.fillDataTextStyle(t.data);var i = this.layoutMode;i && c.mergeLayoutParam(this.option, t, i);var a = this.getInitialData(t, e);a && (h(this, "data", a), h(this, "dataBeforeProcessed", a.cloneShallow()));
				}, fillDataTextStyle: function fillDataTextStyle(t) {
					if (t) for (var e = 0; e < t.length; e++) {
						t[e] && t[e].label && r.defaultEmphasis(t[e].label, r.LABEL_OPTIONS);
					}
				}, getInitialData: function getInitialData() {}, getData: function getData(t) {
					var e = d(this, "data");return null == t ? e : e.getLinkedData(t);
				}, setData: function setData(t) {
					h(this, "data", t);
				}, getRawData: function getRawData() {
					return d(this, "dataBeforeProcessed");
				}, coordDimToDataDim: function coordDimToDataDim(t) {
					return r.coordDimToDataDim(this.getData(), t);
				}, dataDimToCoordDim: function dataDimToCoordDim(t) {
					return r.dataDimToCoordDim(this.getData(), t);
				}, getBaseAxis: function getBaseAxis() {
					var t = this.coordinateSystem;return t && t.getBaseAxis && t.getBaseAxis();
				}, formatTooltip: function formatTooltip(t, e, i) {
					function o(i) {
						function o(t, i) {
							var n = s.getDimensionInfo(i);if (n && n.otherDims.tooltip !== !1) {
								var o = n.type,
								    r = (l ? "- " + (n.tooltipName || n.name) + ": " : "") + ("ordinal" === o ? t + "" : "time" === o ? e ? "" : a.formatTime("yyyy/MM/dd hh:mm:ss", t) : p(t));r && u.push(f(r));
							}
						}var l = n.reduce(i, function (t, e, i) {
							var n = s.getDimensionInfo(i);return t |= n.tooltip !== !1 && null != n.tooltipName;
						}, 0),
						    u = [],
						    c = r.otherDimToDataDim(s, "tooltip");return c.length ? n.each(c, function (e) {
							o(s.get(e, t), e);
						}) : n.each(i, o), (l ? "<br/>" : "") + u.join(l ? "<br/>" : ", ");
					}var s = d(this, "data"),
					    l = this.getRawValue(t),
					    u = n.isArray(l) ? o(l) : f(p(l)),
					    c = s.getName(t),
					    h = s.getItemVisual(t, "color");n.isObject(h) && h.colorStops && (h = (h.colorStops[0] || {}).color), h = h || "transparent";var g = a.getTooltipMarker(h),
					    m = this.name;return "\0-" === m && (m = ""), m = m ? f(m) + (e ? ": " : "<br/>") : "", e ? g + m + u : m + g + (c ? f(c) + ": " + u : u);
				}, isAnimationEnabled: function isAnimationEnabled() {
					if (u.node) return !1;var t = this.getShallow("animation");return t && this.getData().count() > this.getShallow("animationThreshold") && (t = !1), t;
				}, restoreData: function restoreData() {
					h(this, "data", d(this, "dataBeforeProcessed").cloneShallow());
				}, getColorFromPalette: function getColorFromPalette(t, e) {
					var i = this.ecModel,
					    n = l.getColorFromPalette.call(this, t, e);return n || (n = i.getColorFromPalette(t, e)), n;
				}, getAxisTooltipData: null, getTooltipPosition: null });n.mixin(g, r.dataFormatMixin), n.mixin(g, l), t.exports = g;
		}, function (t, e, i) {
			var n = i(149),
			    a = i(43);i(150), i(148);var o = i(34),
			    r = i(4),
			    s = i(1),
			    l = i(16),
			    u = {};u.getScaleExtent = function (t, e) {
				var i,
				    n,
				    a,
				    o = t.type,
				    l = e.getMin(),
				    u = e.getMax(),
				    c = null != l,
				    h = null != u,
				    d = t.getExtent();return "ordinal" === o ? i = (e.get("data") || []).length : (n = e.get("boundaryGap"), s.isArray(n) || (n = [n || 0, n || 0]), "boolean" == typeof n[0] && (n = [0, 0]), n[0] = r.parsePercent(n[0], 1), n[1] = r.parsePercent(n[1], 1), a = d[1] - d[0] || Math.abs(d[0])), null == l && (l = "ordinal" === o ? i ? 0 : NaN : d[0] - n[0] * a), null == u && (u = "ordinal" === o ? i ? i - 1 : NaN : d[1] + n[1] * a), "dataMin" === l && (l = d[0]), "dataMax" === u && (u = d[1]), (null == l || !isFinite(l)) && (l = NaN), (null == u || !isFinite(u)) && (u = NaN), t.setBlank(s.eqNaN(l) || s.eqNaN(u)), e.getNeedCrossZero() && (l > 0 && u > 0 && !c && (l = 0), l < 0 && u < 0 && !h && (u = 0)), [l, u];
			}, u.niceScaleExtent = function (t, e) {
				var i = u.getScaleExtent(t, e),
				    n = null != e.getMin(),
				    a = null != e.getMax(),
				    o = e.get("splitNumber");"log" === t.type && (t.base = e.get("logBase")), t.setExtent(i[0], i[1]), t.niceExtent({ splitNumber: o, fixMin: n, fixMax: a, minInterval: "interval" === t.type ? e.get("minInterval") : null });var r = e.get("interval");null != r && t.setInterval && t.setInterval(r);
			}, u.createScaleByModel = function (t, e) {
				if (e = e || t.get("type")) switch (e) {case "category":
						return new n(t.getCategories(), [1 / 0, -(1 / 0)]);case "value":
						return new a();default:
						return (o.getClass(e) || a).create(t);}
			}, u.ifAxisCrossZero = function (t) {
				var e = t.scale.getExtent(),
				    i = e[0],
				    n = e[1];return !(i > 0 && n > 0 || i < 0 && n < 0);
			}, u.getAxisLabelInterval = function (t, e, i, n) {
				var a,
				    o = 0,
				    r = 0,
				    s = 1;e.length > 40 && (s = Math.floor(e.length / 40));for (var u = 0; u < t.length; u += s) {
					var c = t[u],
					    h = l.getBoundingRect(e[u], i, "center", "top");h[n ? "x" : "y"] += c, h[n ? "width" : "height"] *= 1.3, a ? a.intersect(h) ? (r++, o = Math.max(o, r)) : (a.union(h), r = 0) : a = h.clone();
				}return 0 === o && s > 1 ? s : (o + 1) * s - 1;
			}, u.getFormattedLabels = function (t, e) {
				var i = t.scale,
				    n = i.getTicksLabels(),
				    a = i.getTicks();return "string" == typeof e ? (e = function (t) {
					return function (e) {
						return t.replace("{value}", null != e ? e : "");
					};
				}(e), s.map(n, e)) : "function" == typeof e ? s.map(a, function (i, n) {
					return e(u.getAxisRawValue(t, i), n);
				}, this) : n;
			}, u.getAxisRawValue = function (t, e) {
				return "category" === t.type ? t.scale.getLabel(e) : e;
			}, t.exports = u;
		}, function (t, e) {
			var i = "undefined" == typeof Float32Array ? Array : Float32Array,
			    n = { create: function create() {
					var t = new i(6);return n.identity(t), t;
				}, identity: function identity(t) {
					return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;
				}, copy: function copy(t, e) {
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t;
				}, mul: function mul(t, e, i) {
					var n = e[0] * i[0] + e[2] * i[1],
					    a = e[1] * i[0] + e[3] * i[1],
					    o = e[0] * i[2] + e[2] * i[3],
					    r = e[1] * i[2] + e[3] * i[3],
					    s = e[0] * i[4] + e[2] * i[5] + e[4],
					    l = e[1] * i[4] + e[3] * i[5] + e[5];return t[0] = n, t[1] = a, t[2] = o, t[3] = r, t[4] = s, t[5] = l, t;
				}, translate: function translate(t, e, i) {
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t;
				}, rotate: function rotate(t, e, i) {
					var n = e[0],
					    a = e[2],
					    o = e[4],
					    r = e[1],
					    s = e[3],
					    l = e[5],
					    u = Math.sin(i),
					    c = Math.cos(i);return t[0] = n * c + r * u, t[1] = -n * u + r * c, t[2] = a * c + s * u, t[3] = -a * u + c * s, t[4] = c * o + u * l, t[5] = c * l - u * o, t;
				}, scale: function scale(t, e, i) {
					var n = i[0],
					    a = i[1];return t[0] = e[0] * n, t[1] = e[1] * a, t[2] = e[2] * n, t[3] = e[3] * a, t[4] = e[4] * n, t[5] = e[5] * a, t;
				}, invert: function invert(t, e) {
					var i = e[0],
					    n = e[2],
					    a = e[4],
					    o = e[1],
					    r = e[3],
					    s = e[5],
					    l = i * r - o * n;return l ? (l = 1 / l, t[0] = r * l, t[1] = -o * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - r * a) * l, t[5] = (o * a - i * s) * l, t) : null;
				} };t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return t > -w && t < w;
			}function a(t) {
				return t > w || t < -w;
			}function o(t, e, i, n, a) {
				var o = 1 - a;return o * o * (o * t + 3 * a * e) + a * a * (a * n + 3 * o * i);
			}function r(t, e, i, n, a) {
				var o = 1 - a;return 3 * (((e - t) * o + 2 * (i - e) * a) * o + (n - i) * a * a);
			}function s(t, e, i, a, o, r) {
				var s = a + 3 * (e - i) - t,
				    l = 3 * (i - 2 * e + t),
				    u = 3 * (e - t),
				    c = t - o,
				    h = l * l - 3 * s * u,
				    d = l * u - 9 * s * c,
				    f = u * u - 3 * l * c,
				    p = 0;if (n(h) && n(d)) {
					if (n(l)) r[0] = 0;else {
						var g = -u / l;g >= 0 && g <= 1 && (r[p++] = g);
					}
				} else {
					var m = d * d - 4 * h * f;if (n(m)) {
						var v = d / h,
						    g = -l / s + v,
						    y = -v / 2;g >= 0 && g <= 1 && (r[p++] = g), y >= 0 && y <= 1 && (r[p++] = y);
					} else if (m > 0) {
						var x = b(m),
						    w = h * l + 1.5 * s * (-d + x),
						    S = h * l + 1.5 * s * (-d - x);w = w < 0 ? -_(-w, I) : _(w, I), S = S < 0 ? -_(-S, I) : _(S, I);var g = (-l - (w + S)) / (3 * s);g >= 0 && g <= 1 && (r[p++] = g);
					} else {
						var T = (2 * h * l - 3 * s * d) / (2 * b(h * h * h)),
						    A = Math.acos(T) / 3,
						    C = b(h),
						    L = Math.cos(A),
						    g = (-l - 2 * C * L) / (3 * s),
						    y = (-l + C * (L + M * Math.sin(A))) / (3 * s),
						    D = (-l + C * (L - M * Math.sin(A))) / (3 * s);g >= 0 && g <= 1 && (r[p++] = g), y >= 0 && y <= 1 && (r[p++] = y), D >= 0 && D <= 1 && (r[p++] = D);
					}
				}return p;
			}function l(t, e, i, o, r) {
				var s = 6 * i - 12 * e + 6 * t,
				    l = 9 * e + 3 * o - 3 * t - 9 * i,
				    u = 3 * e - 3 * t,
				    c = 0;if (n(l)) {
					if (a(s)) {
						var h = -u / s;h >= 0 && h <= 1 && (r[c++] = h);
					}
				} else {
					var d = s * s - 4 * l * u;if (n(d)) r[0] = -s / (2 * l);else if (d > 0) {
						var f = b(d),
						    h = (-s + f) / (2 * l),
						    p = (-s - f) / (2 * l);h >= 0 && h <= 1 && (r[c++] = h), p >= 0 && p <= 1 && (r[c++] = p);
					}
				}return c;
			}function u(t, e, i, n, a, o) {
				var r = (e - t) * a + t,
				    s = (i - e) * a + e,
				    l = (n - i) * a + i,
				    u = (s - r) * a + r,
				    c = (l - s) * a + s,
				    h = (c - u) * a + u;o[0] = t, o[1] = r, o[2] = u, o[3] = h, o[4] = h, o[5] = c, o[6] = l, o[7] = n;
			}function c(t, e, i, n, a, r, s, l, u, c, h) {
				var d,
				    f,
				    p,
				    g,
				    m,
				    v = .005,
				    y = 1 / 0;T[0] = u, T[1] = c;for (var _ = 0; _ < 1; _ += .05) {
					A[0] = o(t, i, a, s, _), A[1] = o(e, n, r, l, _), g = x(T, A), g < y && (d = _, y = g);
				}y = 1 / 0;for (var w = 0; w < 32 && !(v < S); w++) {
					f = d - v, p = d + v, A[0] = o(t, i, a, s, f), A[1] = o(e, n, r, l, f), g = x(A, T), f >= 0 && g < y ? (d = f, y = g) : (C[0] = o(t, i, a, s, p), C[1] = o(e, n, r, l, p), m = x(C, T), p <= 1 && m < y ? (d = p, y = m) : v *= .5);
				}return h && (h[0] = o(t, i, a, s, d), h[1] = o(e, n, r, l, d)), b(y);
			}function h(t, e, i, n) {
				var a = 1 - n;return a * (a * t + 2 * n * e) + n * n * i;
			}function d(t, e, i, n) {
				return 2 * ((1 - n) * (e - t) + n * (i - e));
			}function f(t, e, i, o, r) {
				var s = t - 2 * e + i,
				    l = 2 * (e - t),
				    u = t - o,
				    c = 0;if (n(s)) {
					if (a(l)) {
						var h = -u / l;h >= 0 && h <= 1 && (r[c++] = h);
					}
				} else {
					var d = l * l - 4 * s * u;if (n(d)) {
						var h = -l / (2 * s);h >= 0 && h <= 1 && (r[c++] = h);
					} else if (d > 0) {
						var f = b(d),
						    h = (-l + f) / (2 * s),
						    p = (-l - f) / (2 * s);h >= 0 && h <= 1 && (r[c++] = h), p >= 0 && p <= 1 && (r[c++] = p);
					}
				}return c;
			}function p(t, e, i) {
				var n = t + i - 2 * e;return 0 === n ? .5 : (t - e) / n;
			}function g(t, e, i, n, a) {
				var o = (e - t) * n + t,
				    r = (i - e) * n + e,
				    s = (r - o) * n + o;a[0] = t, a[1] = o, a[2] = s, a[3] = s, a[4] = r, a[5] = i;
			}function m(t, e, i, n, a, o, r, s, l) {
				var u,
				    c = .005,
				    d = 1 / 0;T[0] = r, T[1] = s;for (var f = 0; f < 1; f += .05) {
					A[0] = h(t, i, a, f), A[1] = h(e, n, o, f);var p = x(T, A);p < d && (u = f, d = p);
				}d = 1 / 0;for (var g = 0; g < 32 && !(c < S); g++) {
					var m = u - c,
					    v = u + c;A[0] = h(t, i, a, m), A[1] = h(e, n, o, m);var p = x(A, T);if (m >= 0 && p < d) u = m, d = p;else {
						C[0] = h(t, i, a, v), C[1] = h(e, n, o, v);var y = x(C, T);v <= 1 && y < d ? (u = v, d = y) : c *= .5;
					}
				}return l && (l[0] = h(t, i, a, u), l[1] = h(e, n, o, u)), b(d);
			}var v = i(6),
			    y = v.create,
			    x = v.distSquare,
			    _ = Math.pow,
			    b = Math.sqrt,
			    w = 1e-8,
			    S = 1e-4,
			    M = b(3),
			    I = 1 / 3,
			    T = y(),
			    A = y(),
			    C = y();t.exports = { cubicAt: o, cubicDerivativeAt: r, cubicRootAt: s, cubicExtrema: l, cubicSubdivide: u, cubicProjectPoint: c, quadraticAt: h, quadraticDerivativeAt: d, quadraticRootAt: f, quadraticExtremum: p, quadraticSubdivide: g, quadraticProjectPoint: m };
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return t.getBoundingClientRect ? t.getBoundingClientRect() : { left: 0, top: 0 };
			}function a(t, e, i, n) {
				return i = i || {}, n || !c.canvasSupported ? o(t, e, i) : c.browser.firefox && null != e.layerX && e.layerX !== e.offsetX ? (i.zrX = e.layerX, i.zrY = e.layerY) : null != e.offsetX ? (i.zrX = e.offsetX, i.zrY = e.offsetY) : o(t, e, i), i;
			}function o(t, e, i) {
				var a = n(t);i.zrX = e.clientX - a.left, i.zrY = e.clientY - a.top;
			}function r(t, e, i) {
				if (e = e || window.event, null != e.zrX) return e;var n = e.type,
				    o = n && n.indexOf("touch") >= 0;if (o) {
					var r = "touchend" != n ? e.targetTouches[0] : e.changedTouches[0];r && a(t, r, e, i);
				} else a(t, e, e, i), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;return e;
			}function s(t, e, i) {
				h ? t.addEventListener(e, i) : t.attachEvent("on" + e, i);
			}function l(t, e, i) {
				h ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i);
			}var u = i(23),
			    c = i(9),
			    h = "undefined" != typeof window && !!window.addEventListener,
			    d = h ? function (t) {
				t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0;
			} : function (t) {
				t.returnValue = !1, t.cancelBubble = !0;
			};t.exports = { clientToLocal: a, normalizeEvent: r, addEventListener: s, removeEventListener: l, stop: d, Dispatcher: u };
		}, function (t, e, i) {
			function n(t) {
				return t = Math.round(t), t < 0 ? 0 : t > 255 ? 255 : t;
			}function a(t) {
				return t = Math.round(t), t < 0 ? 0 : t > 360 ? 360 : t;
			}function o(t) {
				return t < 0 ? 0 : t > 1 ? 1 : t;
			}function r(t) {
				return n(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 * 255 : parseInt(t, 10));
			}function s(t) {
				return o(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 : parseFloat(t));
			}function l(t, e, i) {
				return i < 0 ? i += 1 : i > 1 && (i -= 1), 6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t;
			}function u(t, e, i) {
				return t + (e - t) * i;
			}function c(t, e, i, n, a) {
				return t[0] = e, t[1] = i, t[2] = n, t[3] = a, t;
			}function h(t, e) {
				return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;
			}function d(t, e) {
				T && h(T, e), T = I.put(t, T || e.slice());
			}function f(t, e) {
				if (t) {
					e = e || [];var i = I.get(t);if (i) return h(e, i);t += "";var n = t.replace(/ /g, "").toLowerCase();if (n in M) return h(e, M[n]), d(t, e), e;if ("#" !== n.charAt(0)) {
						var a = n.indexOf("("),
						    o = n.indexOf(")");if (a !== -1 && o + 1 === n.length) {
							var l = n.substr(0, a),
							    u = n.substr(a + 1, o - (a + 1)).split(","),
							    f = 1;switch (l) {case "rgba":
									if (4 !== u.length) return void c(e, 0, 0, 0, 1);f = s(u.pop());case "rgb":
									return 3 !== u.length ? void c(e, 0, 0, 0, 1) : (c(e, r(u[0]), r(u[1]), r(u[2]), f), d(t, e), e);case "hsla":
									return 4 !== u.length ? void c(e, 0, 0, 0, 1) : (u[3] = s(u[3]), p(u, e), d(t, e), e);case "hsl":
									return 3 !== u.length ? void c(e, 0, 0, 0, 1) : (p(u, e), d(t, e), e);default:
									return;}
						}c(e, 0, 0, 0, 1);
					} else {
						if (4 === n.length) {
							var g = parseInt(n.substr(1), 16);return g >= 0 && g <= 4095 ? (c(e, (3840 & g) >> 4 | (3840 & g) >> 8, 240 & g | (240 & g) >> 4, 15 & g | (15 & g) << 4, 1), d(t, e), e) : void c(e, 0, 0, 0, 1);
						}if (7 === n.length) {
							var g = parseInt(n.substr(1), 16);return g >= 0 && g <= 16777215 ? (c(e, (16711680 & g) >> 16, (65280 & g) >> 8, 255 & g, 1), d(t, e), e) : void c(e, 0, 0, 0, 1);
						}
					}
				}
			}function p(t, e) {
				var i = (parseFloat(t[0]) % 360 + 360) % 360 / 360,
				    a = s(t[1]),
				    o = s(t[2]),
				    r = o <= .5 ? o * (a + 1) : o + a - o * a,
				    u = 2 * o - r;return e = e || [], c(e, n(255 * l(u, r, i + 1 / 3)), n(255 * l(u, r, i)), n(255 * l(u, r, i - 1 / 3)), 1), 4 === t.length && (e[3] = t[3]), e;
			}function g(t) {
				if (t) {
					var e,
					    i,
					    n = t[0] / 255,
					    a = t[1] / 255,
					    o = t[2] / 255,
					    r = Math.min(n, a, o),
					    s = Math.max(n, a, o),
					    l = s - r,
					    u = (s + r) / 2;if (0 === l) e = 0, i = 0;else {
						i = u < .5 ? l / (s + r) : l / (2 - s - r);var c = ((s - n) / 6 + l / 2) / l,
						    h = ((s - a) / 6 + l / 2) / l,
						    d = ((s - o) / 6 + l / 2) / l;n === s ? e = d - h : a === s ? e = 1 / 3 + c - d : o === s && (e = 2 / 3 + h - c), e < 0 && (e += 1), e > 1 && (e -= 1);
					}var f = [360 * e, i, u];return null != t[3] && f.push(t[3]), f;
				}
			}function m(t, e) {
				var i = f(t);if (i) {
					for (var n = 0; n < 3; n++) {
						e < 0 ? i[n] = i[n] * (1 - e) | 0 : i[n] = (255 - i[n]) * e + i[n] | 0;
					}return w(i, 4 === i.length ? "rgba" : "rgb");
				}
			}function v(t, e) {
				var i = f(t);if (i) return ((1 << 24) + (i[0] << 16) + (i[1] << 8) + +i[2]).toString(16).slice(1);
			}function y(t, e, i) {
				if (e && e.length && t >= 0 && t <= 1) {
					i = i || [];var a = t * (e.length - 1),
					    r = Math.floor(a),
					    s = Math.ceil(a),
					    l = e[r],
					    c = e[s],
					    h = a - r;return i[0] = n(u(l[0], c[0], h)), i[1] = n(u(l[1], c[1], h)), i[2] = n(u(l[2], c[2], h)), i[3] = o(u(l[3], c[3], h)), i;
				}
			}function x(t, e, i) {
				if (e && e.length && t >= 0 && t <= 1) {
					var a = t * (e.length - 1),
					    r = Math.floor(a),
					    s = Math.ceil(a),
					    l = f(e[r]),
					    c = f(e[s]),
					    h = a - r,
					    d = w([n(u(l[0], c[0], h)), n(u(l[1], c[1], h)), n(u(l[2], c[2], h)), o(u(l[3], c[3], h))], "rgba");return i ? { color: d, leftIndex: r, rightIndex: s, value: a } : d;
				}
			}function _(t, e, i, n) {
				if (t = f(t)) return t = g(t), null != e && (t[0] = a(e)), null != i && (t[1] = s(i)), null != n && (t[2] = s(n)), w(p(t), "rgba");
			}function b(t, e) {
				if (t = f(t), t && null != e) return t[3] = o(e), w(t, "rgba");
			}function w(t, e) {
				if (t && t.length) {
					var i = t[0] + "," + t[1] + "," + t[2];return "rgba" !== e && "hsva" !== e && "hsla" !== e || (i += "," + t[3]), e + "(" + i + ")";
				}
			}var S = i(70),
			    M = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1],
				darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] },
			    I = new S(20),
			    T = null;t.exports = { parse: f, lift: m, toHex: v, fastMapToColor: y, mapToColor: x, modifyHSL: _, modifyAlpha: b, stringify: w };
		}, function (t, e) {
			var i = Array.prototype.slice,
			    n = function n() {
				this._$handlers = {};
			};n.prototype = { constructor: n, one: function one(t, e, i) {
					var n = this._$handlers;if (!e || !t) return this;n[t] || (n[t] = []);for (var a = 0; a < n[t].length; a++) {
						if (n[t][a].h === e) return this;
					}return n[t].push({ h: e, one: !0, ctx: i || this }), this;
				}, on: function on(t, e, i) {
					var n = this._$handlers;if (!e || !t) return this;n[t] || (n[t] = []);for (var a = 0; a < n[t].length; a++) {
						if (n[t][a].h === e) return this;
					}return n[t].push({ h: e, one: !1, ctx: i || this }), this;
				}, isSilent: function isSilent(t) {
					var e = this._$handlers;return e[t] && e[t].length;
				}, off: function off(t, e) {
					var i = this._$handlers;if (!t) return this._$handlers = {}, this;if (e) {
						if (i[t]) {
							for (var n = [], a = 0, o = i[t].length; a < o; a++) {
								i[t][a].h != e && n.push(i[t][a]);
							}i[t] = n;
						}i[t] && 0 === i[t].length && delete i[t];
					} else delete i[t];return this;
				}, trigger: function trigger(t) {
					if (this._$handlers[t]) {
						var e = arguments,
						    n = e.length;n > 3 && (e = i.call(e, 1));for (var a = this._$handlers[t], o = a.length, r = 0; r < o;) {
							switch (n) {case 1:
									a[r].h.call(a[r].ctx);break;case 2:
									a[r].h.call(a[r].ctx, e[1]);break;case 3:
									a[r].h.call(a[r].ctx, e[1], e[2]);break;default:
									a[r].h.apply(a[r].ctx, e);}a[r].one ? (a.splice(r, 1), o--) : r++;
						}
					}return this;
				}, triggerWithContext: function triggerWithContext(t) {
					if (this._$handlers[t]) {
						var e = arguments,
						    n = e.length;n > 4 && (e = i.call(e, 1, e.length - 1));for (var a = e[e.length - 1], o = this._$handlers[t], r = o.length, s = 0; s < r;) {
							switch (n) {case 1:
									o[s].h.call(a);break;case 2:
									o[s].h.call(a, e[1]);break;case 3:
									o[s].h.call(a, e[1], e[2]);break;default:
									o[s].h.apply(a, e);}o[s].one ? (o.splice(s, 1), r--) : s++;
						}
					}return this;
				} }, t.exports = n;
		}, function (t, e, i) {
			"use strict";
			var n = i(3),
			    a = i(11),
			    o = n.extendShape({ type: "triangle", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function buildPath(t, e) {
					var i = e.cx,
					    n = e.cy,
					    a = e.width / 2,
					    o = e.height / 2;t.moveTo(i, n - o), t.lineTo(i + a, n + o), t.lineTo(i - a, n + o), t.closePath();
				} }),
			    r = n.extendShape({ type: "diamond", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function buildPath(t, e) {
					var i = e.cx,
					    n = e.cy,
					    a = e.width / 2,
					    o = e.height / 2;t.moveTo(i, n - o), t.lineTo(i + a, n), t.lineTo(i, n + o), t.lineTo(i - a, n), t.closePath();
				} }),
			    s = n.extendShape({ type: "pin", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function buildPath(t, e) {
					var i = e.x,
					    n = e.y,
					    a = e.width / 5 * 3,
					    o = Math.max(a, e.height),
					    r = a / 2,
					    s = r * r / (o - r),
					    l = n - o + r + s,
					    u = Math.asin(s / r),
					    c = Math.cos(u) * r,
					    h = Math.sin(u),
					    d = Math.cos(u);t.arc(i, l, r, Math.PI - u, 2 * Math.PI + u);var f = .6 * r,
					    p = .7 * r;t.bezierCurveTo(i + c - h * f, l + s + d * f, i, n - p, i, n), t.bezierCurveTo(i, n - p, i - c + h * f, l + s + d * f, i - c, l + s), t.closePath();
				} }),
			    l = n.extendShape({ type: "arrow", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function buildPath(t, e) {
					var i = e.height,
					    n = e.width,
					    a = e.x,
					    o = e.y,
					    r = n / 3 * 2;t.moveTo(a, o), t.lineTo(a + r, o + i), t.lineTo(a, o + i / 4 * 3), t.lineTo(a - r, o + i), t.lineTo(a, o), t.closePath();
				} }),
			    u = { line: n.Line, rect: n.Rect, roundRect: n.Rect, square: n.Rect, circle: n.Circle, diamond: r, pin: s, arrow: l, triangle: o },
			    c = { line: function line(t, e, i, n, a) {
					a.x1 = t, a.y1 = e + n / 2, a.x2 = t + i, a.y2 = e + n / 2;
				}, rect: function rect(t, e, i, n, a) {
					a.x = t, a.y = e, a.width = i, a.height = n;
				}, roundRect: function roundRect(t, e, i, n, a) {
					a.x = t, a.y = e, a.width = i, a.height = n, a.r = Math.min(i, n) / 4;
				}, square: function square(t, e, i, n, a) {
					var o = Math.min(i, n);a.x = t, a.y = e, a.width = o, a.height = o;
				}, circle: function circle(t, e, i, n, a) {
					a.cx = t + i / 2, a.cy = e + n / 2, a.r = Math.min(i, n) / 2;
				}, diamond: function diamond(t, e, i, n, a) {
					a.cx = t + i / 2, a.cy = e + n / 2, a.width = i, a.height = n;
				}, pin: function pin(t, e, i, n, a) {
					a.x = t + i / 2, a.y = e + n / 2, a.width = i, a.height = n;
				}, arrow: function arrow(t, e, i, n, a) {
					a.x = t + i / 2, a.y = e + n / 2, a.width = i, a.height = n;
				}, triangle: function triangle(t, e, i, n, a) {
					a.cx = t + i / 2, a.cy = e + n / 2, a.width = i, a.height = n;
				} },
			    h = {};for (var d in u) {
				u.hasOwnProperty(d) && (h[d] = new u[d]());
			}var f = n.extendShape({ type: "symbol", shape: { symbolType: "", x: 0, y: 0, width: 0, height: 0 }, beforeBrush: function beforeBrush() {
					var t = this.style,
					    e = this.shape;"pin" === e.symbolType && "inside" === t.textPosition && (t.textPosition = ["50%", "40%"], t.textAlign = "center", t.textVerticalAlign = "middle");
				}, buildPath: function buildPath(t, e, i) {
					var n = e.symbolType,
					    a = h[n];"none" !== e.symbolType && (a || (n = "rect", a = h[n]), c[n](e.x, e.y, e.width, e.height, a.shape), a.buildPath(t, a.shape, i));
				} }),
			    p = function p(t) {
				if ("image" !== this.type) {
					var e = this.style,
					    i = this.shape;i && "line" === i.symbolType ? e.stroke = t : this.__isEmptyBrush ? (e.stroke = t, e.fill = "#fff") : (e.fill && (e.fill = t), e.stroke && (e.stroke = t)), this.dirty(!1);
				}
			},
			    g = { createSymbol: function createSymbol(t, e, i, o, r, s) {
					var l = 0 === t.indexOf("empty");l && (t = t.substr(5, 1).toLowerCase() + t.substr(6));var u;return u = 0 === t.indexOf("image://") ? new n.Image({ style: { image: t.slice(8), x: e, y: i, width: o, height: r } }) : 0 === t.indexOf("path://") ? n.makePath(t.slice(7), {}, new a(e, i, o, r)) : new f({ shape: { symbolType: t, x: e, y: i, width: o, height: r } }), u.__isEmptyBrush = l, u.setColor = p, u.setColor(s), u;
				} };t.exports = g;
		}, function (t, e, i) {
			function n(t, e, i) {
				function n(t, e, i) {
					h[e] ? t.otherDims[e] = i : (t.coordDim = e, t.coordDimIndex = i, m.set(e, !0));
				}function r(t, e, i) {
					if (i || null != e.get(t)) {
						for (var n = 0; null != e.get(t + n);) {
							n++;
						}t += n;
					}return e.set(t, !0), t;
				}e = e || [], i = i || {}, t = (t || []).slice();var f = (i.dimsDef || []).slice(),
				    p = o.createHashMap(i.encodeDef),
				    g = o.createHashMap(),
				    m = o.createHashMap(),
				    v = [],
				    y = i.dimCount;if (null == y) {
					var x = a(e[0]);y = Math.max(o.isArray(x) && x.length || 1, t.length, f.length), s(t, function (t) {
						var e = t.dimsDef;e && (y = Math.max(y, e.length));
					});
				}for (var _ = 0; _ < y; _++) {
					var b = l(f[_]) ? { name: f[_] } : f[_] || {},
					    w = b.name,
					    S = v[_] = { otherDims: {} };null != w && null == g.get(w) && (S.name = S.tooltipName = w, g.set(w, _)), null != b.type && (S.type = b.type);
				}p.each(function (t, e) {
					t = p.set(e, c(t).slice()), s(t, function (i, a) {
						l(i) && (i = g.get(i)), null != i && i < y && (t[a] = i, n(v[i], e, a));
					});
				});var M = 0;s(t, function (t, e) {
					var i, t, a, r;l(t) ? (i = t, t = {}) : (i = t.name, t = o.clone(t), a = t.dimsDef, r = t.otherDims, t.name = t.coordDim = t.coordDimIndex = t.dimsDef = t.otherDims = null);var h = c(p.get(i));if (!h.length) for (var d = 0; d < (a && a.length || 1); d++) {
						for (; M < v.length && null != v[M].coordDim;) {
							M++;
						}M < v.length && h.push(M++);
					}s(h, function (e, o) {
						var s = v[e];n(u(s, t), i, o), null == s.name && a && (s.name = s.tooltipName = a[o]), r && u(s.otherDims, r);
					});
				});for (var I = i.extraPrefix || "value", T = 0; T < y; T++) {
					var S = v[T] = v[T] || {},
					    A = S.coordDim;null == A && (S.coordDim = r(I, m, i.extraFromZero), S.coordDimIndex = 0, S.isExtraCoord = !0), null == S.name && (S.name = r(S.coordDim, g)), null == S.type && d(e, T) && (S.type = "ordinal");
				}return v;
			}function a(t) {
				return o.isArray(t) ? t : o.isObject(t) ? t.value : t;
			}var o = i(1),
			    r = i(5),
			    s = o.each,
			    l = o.isString,
			    u = o.defaults,
			    c = r.normalizeToArray,
			    h = { tooltip: 1, label: 1, itemName: 1 },
			    d = n.guessOrdinal = function (t, e) {
				for (var i = 0, n = t.length; i < n; i++) {
					var r = a(t[i]);if (!o.isArray(r)) return !1;var r = r[e];if (null != r && isFinite(r)) return !1;if (l(r) && "-" !== r) return !0;
				}return !1;
			};t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n() {
				this._coordinateSystems = [];
			}var a = i(1),
			    o = {};n.prototype = { constructor: n, create: function create(t, e) {
					var i = [];a.each(o, function (n, a) {
						var o = n.create(t, e);i = i.concat(o || []);
					}), this._coordinateSystems = i;
				}, update: function update(t, e) {
					a.each(this._coordinateSystems, function (i) {
						i.update && i.update(t, e);
					});
				}, getCoordinateSystems: function getCoordinateSystems() {
					return this._coordinateSystems.slice();
				} }, n.register = function (t, e) {
				o[t] = e;
			}, n.get = function (t) {
				return o[t];
			}, t.exports = n;
		}, function (t, e, i) {
			"use strict";
			var n = i(20),
			    a = i(6),
			    o = i(85),
			    r = i(11),
			    s = i(35).devicePixelRatio,
			    l = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 },
			    u = [],
			    c = [],
			    h = [],
			    d = [],
			    f = Math.min,
			    p = Math.max,
			    g = Math.cos,
			    m = Math.sin,
			    v = Math.sqrt,
			    y = Math.abs,
			    x = "undefined" != typeof Float32Array,
			    _ = function _(t) {
				this._saveData = !t, this._saveData && (this.data = []), this._ctx = null;
			};_.prototype = { constructor: _, _xi: 0, _yi: 0, _x0: 0, _y0: 0, _ux: 0, _uy: 0, _len: 0, _lineDash: null, _dashOffset: 0, _dashIdx: 0, _dashSum: 0, setScale: function setScale(t, e) {
					this._ux = y(1 / s / t) || 0, this._uy = y(1 / s / e) || 0;
				}, getContext: function getContext() {
					return this._ctx;
				}, beginPath: function beginPath(t) {
					return this._ctx = t, t && t.beginPath(), t && (this.dpr = t.dpr), this._saveData && (this._len = 0), this._lineDash && (this._lineDash = null, this._dashOffset = 0), this;
				}, moveTo: function moveTo(t, e) {
					return this.addData(l.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this;
				}, lineTo: function lineTo(t, e) {
					var i = y(t - this._xi) > this._ux || y(e - this._yi) > this._uy || this._len < 5;return this.addData(l.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), i && (this._xi = t, this._yi = e), this;
				}, bezierCurveTo: function bezierCurveTo(t, e, i, n, a, o) {
					return this.addData(l.C, t, e, i, n, a, o), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, a, o) : this._ctx.bezierCurveTo(t, e, i, n, a, o)), this._xi = a, this._yi = o, this;
				}, quadraticCurveTo: function quadraticCurveTo(t, e, i, n) {
					return this.addData(l.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this;
				}, arc: function arc(t, e, i, n, a, o) {
					return this.addData(l.A, t, e, i, i, n, a - n, 0, o ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, a, o), this._xi = g(a) * i + t, this._yi = m(a) * i + t, this;
				}, arcTo: function arcTo(t, e, i, n, a) {
					return this._ctx && this._ctx.arcTo(t, e, i, n, a), this;
				}, rect: function rect(t, e, i, n) {
					return this._ctx && this._ctx.rect(t, e, i, n), this.addData(l.R, t, e, i, n), this;
				}, closePath: function closePath() {
					this.addData(l.Z);var t = this._ctx,
					    e = this._x0,
					    i = this._y0;return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this;
				}, fill: function fill(t) {
					t && t.fill(), this.toStatic();
				}, stroke: function stroke(t) {
					t && t.stroke(), this.toStatic();
				}, setLineDash: function setLineDash(t) {
					if (t instanceof Array) {
						this._lineDash = t, this._dashIdx = 0;for (var e = 0, i = 0; i < t.length; i++) {
							e += t[i];
						}this._dashSum = e;
					}return this;
				}, setLineDashOffset: function setLineDashOffset(t) {
					return this._dashOffset = t, this;
				}, len: function len() {
					return this._len;
				}, setData: function setData(t) {
					var e = t.length;this.data && this.data.length == e || !x || (this.data = new Float32Array(e));for (var i = 0; i < e; i++) {
						this.data[i] = t[i];
					}this._len = e;
				}, appendPath: function appendPath(t) {
					t instanceof Array || (t = [t]);for (var e = t.length, i = 0, n = this._len, a = 0; a < e; a++) {
						i += t[a].len();
					}x && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));for (var a = 0; a < e; a++) {
						for (var o = t[a].data, r = 0; r < o.length; r++) {
							this.data[n++] = o[r];
						}
					}this._len = n;
				}, addData: function addData(t) {
					if (this._saveData) {
						var e = this.data;this._len + arguments.length > e.length && (this._expandData(), e = this.data);for (var i = 0; i < arguments.length; i++) {
							e[this._len++] = arguments[i];
						}this._prevCmd = t;
					}
				}, _expandData: function _expandData() {
					if (!(this.data instanceof Array)) {
						for (var t = [], e = 0; e < this._len; e++) {
							t[e] = this.data[e];
						}this.data = t;
					}
				}, _needsDash: function _needsDash() {
					return this._lineDash;
				}, _dashedLineTo: function _dashedLineTo(t, e) {
					var i,
					    n,
					    a = this._dashSum,
					    o = this._dashOffset,
					    r = this._lineDash,
					    s = this._ctx,
					    l = this._xi,
					    u = this._yi,
					    c = t - l,
					    h = e - u,
					    d = v(c * c + h * h),
					    g = l,
					    m = u,
					    y = r.length;for (c /= d, h /= d, o < 0 && (o = a + o), o %= a, g -= o * c, m -= o * h; c > 0 && g <= t || c < 0 && g >= t || 0 == c && (h > 0 && m <= e || h < 0 && m >= e);) {
						n = this._dashIdx, i = r[n], g += c * i, m += h * i, this._dashIdx = (n + 1) % y, c > 0 && g < l || c < 0 && g > l || h > 0 && m < u || h < 0 && m > u || s[n % 2 ? "moveTo" : "lineTo"](c >= 0 ? f(g, t) : p(g, t), h >= 0 ? f(m, e) : p(m, e));
					}c = g - t, h = m - e, this._dashOffset = -v(c * c + h * h);
				}, _dashedBezierTo: function _dashedBezierTo(t, e, i, a, o, r) {
					var s,
					    l,
					    u,
					    c,
					    h,
					    d = this._dashSum,
					    f = this._dashOffset,
					    p = this._lineDash,
					    g = this._ctx,
					    m = this._xi,
					    y = this._yi,
					    x = n.cubicAt,
					    _ = 0,
					    b = this._dashIdx,
					    w = p.length,
					    S = 0;for (f < 0 && (f = d + f), f %= d, s = 0; s < 1; s += .1) {
						l = x(m, t, i, o, s + .1) - x(m, t, i, o, s), u = x(y, e, a, r, s + .1) - x(y, e, a, r, s), _ += v(l * l + u * u);
					}for (; b < w && (S += p[b], !(S > f)); b++) {}for (s = (S - f) / _; s <= 1;) {
						c = x(m, t, i, o, s), h = x(y, e, a, r, s), b % 2 ? g.moveTo(c, h) : g.lineTo(c, h), s += p[b] / _, b = (b + 1) % w;
					}b % 2 !== 0 && g.lineTo(o, r), l = o - c, u = r - h, this._dashOffset = -v(l * l + u * u);
				}, _dashedQuadraticTo: function _dashedQuadraticTo(t, e, i, n) {
					var a = i,
					    o = n;i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, a, o);
				}, toStatic: function toStatic() {
					var t = this.data;t instanceof Array && (t.length = this._len, x && (this.data = new Float32Array(t)));
				}, getBoundingRect: function getBoundingRect() {
					u[0] = u[1] = h[0] = h[1] = Number.MAX_VALUE, c[0] = c[1] = d[0] = d[1] = -Number.MAX_VALUE;for (var t = this.data, e = 0, i = 0, n = 0, s = 0, f = 0; f < t.length;) {
						var p = t[f++];switch (1 == f && (e = t[f], i = t[f + 1], n = e, s = i), p) {case l.M:
								n = t[f++], s = t[f++], e = n, i = s, h[0] = n, h[1] = s, d[0] = n, d[1] = s;break;case l.L:
								o.fromLine(e, i, t[f], t[f + 1], h, d), e = t[f++], i = t[f++];break;case l.C:
								o.fromCubic(e, i, t[f++], t[f++], t[f++], t[f++], t[f], t[f + 1], h, d), e = t[f++], i = t[f++];break;case l.Q:
								o.fromQuadratic(e, i, t[f++], t[f++], t[f], t[f + 1], h, d), e = t[f++], i = t[f++];break;case l.A:
								var v = t[f++],
								    y = t[f++],
								    x = t[f++],
								    _ = t[f++],
								    b = t[f++],
								    w = t[f++] + b,
								    S = (t[f++], 1 - t[f++]);1 == f && (n = g(b) * x + v, s = m(b) * _ + y), o.fromArc(v, y, x, _, b, w, S, h, d), e = g(w) * x + v, i = m(w) * _ + y;break;case l.R:
								n = e = t[f++], s = i = t[f++];var M = t[f++],
								    I = t[f++];o.fromLine(n, s, n + M, s + I, h, d);break;case l.Z:
								e = n, i = s;}a.min(u, u, h), a.max(c, c, d);
					}return 0 === f && (u[0] = u[1] = c[0] = c[1] = 0), new r(u[0], u[1], c[0] - u[0], c[1] - u[1]);
				}, rebuildPath: function rebuildPath(t) {
					for (var e, i, n, a, o, r, s = this.data, u = this._ux, c = this._uy, h = this._len, d = 0; d < h;) {
						var f = s[d++];switch (1 == d && (n = s[d], a = s[d + 1], e = n, i = a), f) {case l.M:
								e = n = s[d++], i = a = s[d++], t.moveTo(n, a);break;case l.L:
								o = s[d++], r = s[d++], (y(o - n) > u || y(r - a) > c || d === h - 1) && (t.lineTo(o, r), n = o, a = r);break;case l.C:
								t.bezierCurveTo(s[d++], s[d++], s[d++], s[d++], s[d++], s[d++]), n = s[d - 2], a = s[d - 1];break;case l.Q:
								t.quadraticCurveTo(s[d++], s[d++], s[d++], s[d++]), n = s[d - 2], a = s[d - 1];break;case l.A:
								var p = s[d++],
								    v = s[d++],
								    x = s[d++],
								    _ = s[d++],
								    b = s[d++],
								    w = s[d++],
								    S = s[d++],
								    M = s[d++],
								    I = x > _ ? x : _,
								    T = x > _ ? 1 : x / _,
								    A = x > _ ? _ / x : 1,
								    C = Math.abs(x - _) > .001,
								    L = b + w;C ? (t.translate(p, v), t.rotate(S), t.scale(T, A), t.arc(0, 0, I, b, L, 1 - M), t.scale(1 / T, 1 / A), t.rotate(-S), t.translate(-p, -v)) : t.arc(p, v, I, b, L, 1 - M), 1 == d && (e = g(b) * x + p, i = m(b) * _ + v), n = g(L) * x + p, a = m(L) * _ + v;break;case l.R:
								e = n = s[d], i = a = s[d + 1], t.rect(s[d++], s[d++], s[d++], s[d++]);break;case l.Z:
								t.closePath(), n = e, a = i;}
					}
				} }, _.CMD = l, t.exports = _;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				for (var e = 0; e < t.length && null == t[e];) {
					e++;
				}return t[e];
			}function a(t) {
				var e = n(t);return null != e && !h.isArray(p(e));
			}function o(t, e, i) {
				t = t || [];var n = e.get("coordinateSystem"),
				    o = m[n],
				    r = f.get(n),
				    s = { encodeDef: e.get("encode"), dimsDef: e.get("dimensions") },
				    v = o && o(t, e, i, s),
				    y = v && v.dimensions;y || (y = r && (r.getDimensionsInfo ? r.getDimensionsInfo() : r.dimensions.slice()) || ["x", "y"], y = c(y, t, s));var x = v ? v.categoryIndex : -1,
				    _ = new u(y, e),
				    b = l(v, t),
				    w = {},
				    S = x >= 0 && a(t) ? function (t, e, i, n) {
					return d.isDataItemOption(t) && (_.hasItemOption = !0), n === x ? i : g(p(t), y[n]);
				} : function (t, e, i, n) {
					var a = p(t),
					    o = g(a && a[n], y[n]);d.isDataItemOption(t) && (_.hasItemOption = !0);var r = v && v.categoryAxesModels;return r && r[e] && "string" == typeof o && (w[e] = w[e] || r[e].getCategories(), o = h.indexOf(w[e], o), o < 0 && !isNaN(o) && (o = +o)), o;
				};return _.hasItemOption = !1, _.initData(t, b, S), _;
			}function r(t) {
				return "category" !== t && "time" !== t;
			}function s(t) {
				return "category" === t ? "ordinal" : "time" === t ? "time" : "float";
			}function l(t, e) {
				var i,
				    n = [],
				    a = t && t.dimensions[t.categoryIndex];if (a && (i = t.categoryAxesModels[a.name]), i) {
					var o = i.getCategories();if (o) {
						var r = e.length;if (h.isArray(e[0]) && e[0].length > 1) {
							n = [];for (var s = 0; s < r; s++) {
								n[s] = o[e[s][t.categoryIndex || 0]];
							}
						} else n = o.slice(0);
					}
				}return n;
			}var u = i(14),
			    c = i(25),
			    h = i(1),
			    d = i(5),
			    f = i(26),
			    p = d.getDataItemValue,
			    g = d.converDataValue,
			    m = { cartesian2d: function cartesian2d(t, e, i, n) {
					var a = h.map(["xAxis", "yAxis"], function (t) {
						return i.queryComponents({ mainType: t, index: e.get(t + "Index"), id: e.get(t + "Id") })[0];
					}),
					    o = a[0],
					    l = a[1],
					    u = o.get("type"),
					    d = l.get("type"),
					    f = [{ name: "x", type: s(u), stackable: r(u) }, { name: "y", type: s(d), stackable: r(d) }],
					    p = "category" === u,
					    g = "category" === d;f = c(f, t, n);var m = {};return p && (m.x = o), g && (m.y = l), { dimensions: f, categoryIndex: p ? 0 : g ? 1 : -1, categoryAxesModels: m };
				}, singleAxis: function singleAxis(t, e, i, n) {
					var a = i.queryComponents({ mainType: "singleAxis", index: e.get("singleAxisIndex"), id: e.get("singleAxisId") })[0],
					    o = a.get("type"),
					    l = "category" === o,
					    u = [{ name: "single", type: s(o), stackable: r(o) }];u = c(u, t, n);var h = {};return l && (h.single = a), { dimensions: u, categoryIndex: l ? 0 : -1, categoryAxesModels: h };
				}, polar: function polar(t, e, i, n) {
					var a = i.queryComponents({ mainType: "polar", index: e.get("polarIndex"), id: e.get("polarId") })[0],
					    o = a.findAxisModel("angleAxis"),
					    l = a.findAxisModel("radiusAxis"),
					    u = l.get("type"),
					    h = o.get("type"),
					    d = [{ name: "radius", type: s(u), stackable: r(u) }, { name: "angle", type: s(h), stackable: r(h) }],
					    f = "category" === h,
					    p = "category" === u;d = c(d, t, n);var g = {};return p && (g.radius = l), f && (g.angle = o), { dimensions: d, categoryIndex: f ? 1 : p ? 0 : -1, categoryAxesModels: g };
				}, geo: function geo(t, e, i, n) {
					return { dimensions: c([{ name: "lng" }, { name: "lat" }], t, n) };
				} };t.exports = o;
		}, function (t, e) {
			"use strict";
			var i = {};t.exports = { register: function register(t, e) {
					i[t] = e;
				}, get: function get(t) {
					return i[t];
				} };
		}, function (t, e, i) {
			function n() {
				this.group = new r(), this.uid = s.getUID("viewChart");
			}function a(t, e) {
				if (t && (t.trigger(e), "group" === t.type)) for (var i = 0; i < t.childCount(); i++) {
					a(t.childAt(i), e);
				}
			}function o(t, e, i) {
				var n = u.queryDataIndex(t, e);null != n ? c.each(u.normalizeToArray(n), function (e) {
					a(t.getItemGraphicEl(e), i);
				}) : t.eachItemGraphicEl(function (t) {
					a(t, i);
				});
			}var r = i(36),
			    s = i(49),
			    l = i(15),
			    u = i(5),
			    c = i(1);n.prototype = { type: "chart", init: function init(t, e) {}, render: function render(t, e, i, n) {}, highlight: function highlight(t, e, i, n) {
					o(t.getData(), n, "emphasis");
				}, downplay: function downplay(t, e, i, n) {
					o(t.getData(), n, "normal");
				}, remove: function remove(t, e) {
					this.group.removeAll();
				}, dispose: function dispose() {} };var h = n.prototype;h.updateView = h.updateLayout = h.updateVisual = function (t, e, i, n) {
				this.render(t, e, i, n);
			}, l.enableClassExtend(n, ["dispose"]), l.enableClassManagement(n, { registerWhenExtend: !0 }), t.exports = n;
		}, function (t, e, i) {
			var n = i(1);t.exports = function (t) {
				for (var e = 0; e < t.length; e++) {
					t[e][1] || (t[e][1] = t[e][0]);
				}return function (e, i) {
					for (var a = {}, o = 0; o < t.length; o++) {
						var r = t[o][1];if (!(e && n.indexOf(e, r) >= 0 || i && n.indexOf(i, r) < 0)) {
							var s = this.getShallow(r);null != s && (a[t[o][0]] = s);
						}
					}return a;
				};
			};
		}, function (t, e, i) {
			"use strict";
			var n = i(3),
			    a = i(1),
			    o = i(2);i(57), i(117), o.extendComponentView({ type: "grid", render: function render(t, e) {
					this.group.removeAll(), t.get("show") && this.group.add(new n.Rect({ shape: t.coordinateSystem.getRect(), style: a.defaults({ fill: t.get("backgroundColor") }, t.getItemStyle()), silent: !0, z2: -1 }));
				} }), o.registerPreprocessor(function (t) {
				t.xAxis && t.yAxis && !t.grid && (t.grid = {});
			});
		}, function (t, e, i) {
			function n(t, e) {
				var i = t[1] - t[0],
				    n = e,
				    a = i / n / 2;t[0] += a, t[1] -= a;
			}var a = i(4),
			    o = a.linearMap,
			    r = i(1),
			    s = i(18),
			    l = [0, 1],
			    u = function u(t, e, i) {
				this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1, this._labelInterval;
			};u.prototype = { constructor: u, contain: function contain(t) {
					var e = this._extent,
					    i = Math.min(e[0], e[1]),
					    n = Math.max(e[0], e[1]);return t >= i && t <= n;
				}, containData: function containData(t) {
					return this.contain(this.dataToCoord(t));
				}, getExtent: function getExtent() {
					return this._extent.slice();
				}, getPixelPrecision: function getPixelPrecision(t) {
					return a.getPixelPrecision(t || this.scale.getExtent(), this._extent);
				}, setExtent: function setExtent(t, e) {
					var i = this._extent;i[0] = t, i[1] = e;
				}, dataToCoord: function dataToCoord(t, e) {
					var i = this._extent,
					    a = this.scale;return t = a.normalize(t), this.onBand && "ordinal" === a.type && (i = i.slice(), n(i, a.count())), o(t, l, i, e);
				}, coordToData: function coordToData(t, e) {
					var i = this._extent,
					    a = this.scale;this.onBand && "ordinal" === a.type && (i = i.slice(), n(i, a.count()));var r = o(t, i, l, e);return this.scale.scale(r);
				}, pointToData: function pointToData(t, e) {}, getTicksCoords: function getTicksCoords(t) {
					if (this.onBand && !t) {
						for (var e = this.getBands(), i = [], n = 0; n < e.length; n++) {
							i.push(e[n][0]);
						}return e[n - 1] && i.push(e[n - 1][1]), i;
					}return r.map(this.scale.getTicks(), this.dataToCoord, this);
				}, getLabelsCoords: function getLabelsCoords() {
					return r.map(this.scale.getTicks(), this.dataToCoord, this);
				}, getBands: function getBands() {
					for (var t = this.getExtent(), e = [], i = this.scale.count(), n = t[0], a = t[1], o = a - n, r = 0; r < i; r++) {
						e.push([o * r / i + n, o * (r + 1) / i + n]);
					}return e;
				}, getBandWidth: function getBandWidth() {
					var t = this._extent,
					    e = this.scale.getExtent(),
					    i = e[1] - e[0] + (this.onBand ? 1 : 0);0 === i && (i = 1);var n = Math.abs(t[1] - t[0]);return Math.abs(n) / i;
				}, getLabelInterval: function getLabelInterval() {
					var t = this._labelInterval;if (!t) {
						var e = this.model,
						    i = e.getModel("axisLabel"),
						    n = i.get("interval");"category" !== this.type || "auto" !== n ? t = "auto" === n ? 0 : n : this.isHorizontal && (t = s.getAxisLabelInterval(r.map(this.scale.getTicks(), this.dataToCoord, this), e.getFormattedLabels(), i.getModel("textStyle").getFont(), this.isHorizontal())), this._labelInterval = t;
					}return t;
				} }, t.exports = u;
		}, function (t, e, i) {
			function n(t) {
				this._setting = t || {}, this._extent = [1 / 0, -(1 / 0)], this._interval = 0, this.init && this.init.apply(this, arguments);
			}var a = i(15),
			    o = n.prototype;o.parse = function (t) {
				return t;
			}, o.getSetting = function (t) {
				return this._setting[t];
			}, o.contain = function (t) {
				var e = this._extent;return t >= e[0] && t <= e[1];
			}, o.normalize = function (t) {
				var e = this._extent;return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0]);
			}, o.scale = function (t) {
				var e = this._extent;return t * (e[1] - e[0]) + e[0];
			}, o.unionExtent = function (t) {
				var e = this._extent;t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]);
			}, o.unionExtentFromData = function (t, e) {
				this.unionExtent(t.getDataExtent(e, !0));
			}, o.getExtent = function () {
				return this._extent.slice();
			}, o.setExtent = function (t, e) {
				var i = this._extent;isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e);
			}, o.getTicksLabels = function () {
				for (var t = [], e = this.getTicks(), i = 0; i < e.length; i++) {
					t.push(this.getLabel(e[i]));
				}return t;
			}, o.isBlank = function () {
				return this._isBlank;
			}, o.setBlank = function (t) {
				this._isBlank = t;
			}, a.enableClassExtend(n), a.enableClassManagement(n, { registerWhenExtend: !0 }), t.exports = n;
		}, function (t, e) {
			var i = 1;"undefined" != typeof window && (i = Math.max(window.devicePixelRatio || 1, 1));var n = { debugMode: 0, devicePixelRatio: i };t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(66),
			    o = i(11),
			    r = function r(t) {
				t = t || {}, a.call(this, t);for (var e in t) {
					t.hasOwnProperty(e) && (this[e] = t[e]);
				}this._children = [], this.__storage = null, this.__dirty = !0;
			};r.prototype = { constructor: r, isGroup: !0, type: "group", silent: !1, children: function children() {
					return this._children.slice();
				}, childAt: function childAt(t) {
					return this._children[t];
				}, childOfName: function childOfName(t) {
					for (var e = this._children, i = 0; i < e.length; i++) {
						if (e[i].name === t) return e[i];
					}
				}, childCount: function childCount() {
					return this._children.length;
				}, add: function add(t) {
					return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this;
				}, addBefore: function addBefore(t, e) {
					if (t && t !== this && t.parent !== this && e && e.parent === this) {
						var i = this._children,
						    n = i.indexOf(e);n >= 0 && (i.splice(n, 0, t), this._doAdd(t));
					}return this;
				}, _doAdd: function _doAdd(t) {
					t.parent && t.parent.remove(t), t.parent = this;var e = this.__storage,
					    i = this.__zr;e && e !== t.__storage && (e.addToStorage(t), t instanceof r && t.addChildrenToStorage(e)), i && i.refresh();
				}, remove: function remove(t) {
					var e = this.__zr,
					    i = this.__storage,
					    a = this._children,
					    o = n.indexOf(a, t);return o < 0 ? this : (a.splice(o, 1), t.parent = null, i && (i.delFromStorage(t), t instanceof r && t.delChildrenFromStorage(i)), e && e.refresh(), this);
				}, removeAll: function removeAll() {
					var t,
					    e,
					    i = this._children,
					    n = this.__storage;for (e = 0; e < i.length; e++) {
						t = i[e], n && (n.delFromStorage(t), t instanceof r && t.delChildrenFromStorage(n)), t.parent = null;
					}return i.length = 0, this;
				}, eachChild: function eachChild(t, e) {
					for (var i = this._children, n = 0; n < i.length; n++) {
						var a = i[n];t.call(e, a, n);
					}return this;
				}, traverse: function traverse(t, e) {
					for (var i = 0; i < this._children.length; i++) {
						var n = this._children[i];t.call(e, n), "group" === n.type && n.traverse(t, e);
					}return this;
				}, addChildrenToStorage: function addChildrenToStorage(t) {
					for (var e = 0; e < this._children.length; e++) {
						var i = this._children[e];t.addToStorage(i), i instanceof r && i.addChildrenToStorage(t);
					}
				}, delChildrenFromStorage: function delChildrenFromStorage(t) {
					for (var e = 0; e < this._children.length; e++) {
						var i = this._children[e];t.delFromStorage(i), i instanceof r && i.delChildrenFromStorage(t);
					}
				}, dirty: function dirty() {
					return this.__dirty = !0, this.__zr && this.__zr.refresh(), this;
				}, getBoundingRect: function getBoundingRect(t) {
					for (var e = null, i = new o(0, 0, 0, 0), n = t || this._children, a = [], r = 0; r < n.length; r++) {
						var s = n[r];if (!s.ignore && !s.invisible) {
							var l = s.getBoundingRect(),
							    u = s.getLocalTransform(a);u ? (i.copy(l), i.applyTransform(u), e = e || i.clone(), e.union(i)) : (e = e || l.clone(), e.union(l));
						}
					}return e || i;
				} }, n.inherits(r, a), t.exports = r;
		}, function (t, e) {
			var i = {},
			    n = "\0__throttleOriginMethod",
			    a = "\0__throttleRate",
			    o = "\0__throttleType";i.throttle = function (t, e, i) {
				function n() {
					c = new Date().getTime(), h = null, t.apply(r, s || []);
				}var a,
				    o,
				    r,
				    s,
				    l,
				    u = 0,
				    c = 0,
				    h = null;e = e || 0;var d = function d() {
					a = new Date().getTime(), r = this, s = arguments;var t = l || e,
					    d = l || i;l = null, o = a - (d ? u : c) - t, clearTimeout(h), d ? h = setTimeout(n, t) : o >= 0 ? n() : h = setTimeout(n, -o), u = a;
				};return d.clear = function () {
					h && (clearTimeout(h), h = null);
				}, d.debounceNextCall = function (t) {
					l = t;
				}, d;
			}, i.createOrUpdate = function (t, e, r, s) {
				var l = t[e];if (l) {
					var u = l[n] || l,
					    c = l[o],
					    h = l[a];if (h !== r || c !== s) {
						if (null == r || !s) return t[e] = u;l = t[e] = i.throttle(u, r, "debounce" === s), l[n] = u, l[o] = s, l[a] = r;
					}return l;
				}
			}, i.clear = function (t, e) {
				var i = t[e];i && i[n] && (t[e] = i[n]);
			}, t.exports = i;
		}, function (t, e, i) {
			function n(t) {
				t = t || {}, r.call(this, t);for (var e in t) {
					t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
				}this.style = new o(t.style), this._rect = null, this.__clipPaths = [];
			}var a = i(1),
			    o = i(73),
			    r = i(66),
			    s = i(87);n.prototype = { constructor: n, type: "displayable", __dirty: !0, invisible: !1, z: 0, z2: 0, zlevel: 0, draggable: !1, dragging: !1, silent: !1, culling: !1, cursor: "pointer", rectHover: !1, progressive: -1, beforeBrush: function beforeBrush(t) {}, afterBrush: function afterBrush(t) {}, brush: function brush(t, e) {}, getBoundingRect: function getBoundingRect() {}, contain: function contain(t, e) {
					return this.rectContain(t, e);
				}, traverse: function traverse(t, e) {
					t.call(e, this);
				}, rectContain: function rectContain(t, e) {
					var i = this.transformCoordToLocal(t, e),
					    n = this.getBoundingRect();return n.contain(i[0], i[1]);
				}, dirty: function dirty() {
					this.__dirty = !0, this._rect = null, this.__zr && this.__zr.refresh();
				}, animateStyle: function animateStyle(t) {
					return this.animate("style", t);
				}, attrKV: function attrKV(t, e) {
					"style" !== t ? r.prototype.attrKV.call(this, t, e) : this.style.set(e);
				}, setStyle: function setStyle(t, e) {
					return this.style.set(t, e), this.dirty(!1), this;
				}, useStyle: function useStyle(t) {
					return this.style = new o(t), this.dirty(!1), this;
				} }, a.inherits(n, r), a.mixin(n, s), t.exports = n;
		}, function (t, e) {
			var i = function i(t) {
				this.colorStops = t || [];
			};i.prototype = { constructor: i, addColorStop: function addColorStop(t, e) {
					this.colorStops.push({ offset: t, color: e });
				} }, t.exports = i;
		}, function (t, e, i) {
			function n(t) {
				var e = { componentType: t.mainType };return e[t.mainType + "Index"] = t.componentIndex, e;
			}function a(t, e, i, n) {
				var a,
				    o,
				    r = f(i - t.rotation),
				    s = n[0] > n[1],
				    l = "start" === e && !s || "start" !== e && s;return p(r - x / 2) ? (o = l ? "bottom" : "top", a = "center") : p(r - 1.5 * x) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", a = r < 1.5 * x && r > x / 2 ? l ? "left" : "right" : l ? "right" : "left"), { rotation: r, textAlign: a, textVerticalAlign: o };
			}function o(t) {
				var e = t.get("tooltip");return t.get("silent") || !(t.get("triggerEvent") || e && e.show);
			}function r(t, e) {
				var i = t.get("axisLabel.showMinLabel"),
				    n = t.get("axisLabel.showMaxLabel"),
				    a = e[0],
				    o = e[1],
				    r = e[e.length - 1],
				    l = e[e.length - 2];i === !1 ? a.ignore = !0 : null != t.getMin() && s(a, o) && (i ? o.ignore = !0 : a.ignore = !0), n === !1 ? r.ignore = !0 : null != t.getMax() && s(l, r) && (n ? l.ignore = !0 : r.ignore = !0);
			}function s(t, e, i) {
				var n = t && t.getBoundingRect().clone(),
				    a = e && e.getBoundingRect().clone();if (n && a) {
					var o = m.identity([]);return m.rotate(o, o, -t.rotation), n.applyTransform(m.mul([], o, t.getLocalTransform())), a.applyTransform(m.mul([], o, e.getLocalTransform())), n.intersect(a);
				}
			}var l = i(1),
			    u = i(7),
			    c = i(3),
			    h = i(10),
			    d = i(4),
			    f = d.remRadian,
			    p = d.isRadianAroundZero,
			    g = i(6),
			    m = i(19),
			    v = g.applyTransform,
			    y = l.retrieve,
			    x = Math.PI,
			    _ = function _(t, e) {
				this.opt = e, this.axisModel = t, l.defaults(e, { labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: !0 }), this.group = new c.Group();var i = new c.Group({ position: e.position.slice(), rotation: e.rotation });i.updateTransform(), this._transform = i.transform, this._dumbGroup = i;
			};_.prototype = { constructor: _, hasBuilder: function hasBuilder(t) {
					return !!b[t];
				}, add: function add(t) {
					b[t].call(this);
				}, getGroup: function getGroup() {
					return this.group;
				} };var b = { axisLine: function axisLine() {
					var t = this.opt,
					    e = this.axisModel;if (e.get("axisLine.show")) {
						var i = this.axisModel.axis.getExtent(),
						    n = this._transform,
						    a = [i[0], 0],
						    o = [i[1], 0];n && (v(a, a, n), v(o, o, n)), this.group.add(new c.Line(c.subPixelOptimizeLine({ anid: "line", shape: { x1: a[0], y1: a[1], x2: o[0], y2: o[1] }, style: l.extend({ lineCap: "round" }, e.getModel("axisLine.lineStyle").getLineStyle()), strokeContainThreshold: t.strokeContainThreshold || 5, silent: !0, z2: 1 })));
					}
				}, axisTick: function axisTick() {
					var t = this.axisModel,
					    e = t.axis;if (t.get("axisTick.show") && !e.scale.isBlank()) for (var i = t.getModel("axisTick"), n = this.opt, a = i.getModel("lineStyle"), o = i.get("length"), r = M(i, n.labelInterval), s = e.getTicksCoords(i.get("alignWithLabel")), u = e.scale.getTicks(), h = [], d = [], f = this._transform, p = 0; p < s.length; p++) {
						if (!S(e, p, r)) {
							var g = s[p];h[0] = g, h[1] = 0, d[0] = g, d[1] = n.tickDirection * o, f && (v(h, h, f), v(d, d, f)), this.group.add(new c.Line(c.subPixelOptimizeLine({ anid: "tick_" + u[p], shape: { x1: h[0], y1: h[1], x2: d[0], y2: d[1] }, style: l.defaults(a.getLineStyle(), { stroke: t.get("axisLine.lineStyle.color") }), z2: 2, silent: !0 })));
						}
					}
				}, axisLabel: function axisLabel() {
					var t = this.opt,
					    e = this.axisModel,
					    i = e.axis,
					    a = y(t.axisLabelShow, e.get("axisLabel.show"));if (a && !i.scale.isBlank()) {
						var s = e.getModel("axisLabel"),
						    u = s.getModel("textStyle"),
						    d = s.get("margin"),
						    f = i.scale.getTicks(),
						    p = e.getFormattedLabels(),
						    g = (y(t.labelRotate, s.get("rotate")) || 0) * x / 180,
						    m = w(t.rotation, g, t.labelDirection),
						    v = e.get("data"),
						    _ = [],
						    b = o(e),
						    M = e.get("triggerEvent");l.each(f, function (a, o) {
							if (!S(i, o, t.labelInterval)) {
								var r = u;v && v[a] && v[a].textStyle && (r = new h(v[a].textStyle, u, e.ecModel));var s = r.getTextColor() || e.get("axisLine.lineStyle.color"),
								    l = i.dataToCoord(a),
								    f = [l, t.labelOffset + t.labelDirection * d],
								    g = i.scale.getLabel(a),
								    y = new c.Text({ anid: "label_" + a, style: { text: p[o], textAlign: r.get("align", !0) || m.textAlign, textVerticalAlign: r.get("baseline", !0) || m.textVerticalAlign, textFont: r.getFont(), fill: "function" == typeof s ? s("category" === i.type ? g : "value" === i.type ? a + "" : a, o) : s }, position: f, rotation: m.rotation, silent: b, z2: 10 });M && (y.eventData = n(e), y.eventData.targetType = "axisLabel", y.eventData.value = g), this._dumbGroup.add(y), y.updateTransform(), _.push(y), this.group.add(y), y.decomposeTransform();
							}
						}, this), r(e, _);
					}
				}, axisName: function axisName() {
					var t = this.opt,
					    e = this.axisModel,
					    i = y(t.axisName, e.get("name"));if (i) {
						var r,
						    s = e.get("nameLocation"),
						    h = t.nameDirection,
						    d = e.getModel("nameTextStyle"),
						    f = e.get("nameGap") || 0,
						    p = this.axisModel.axis.getExtent(),
						    g = p[0] > p[1] ? -1 : 1,
						    m = ["start" === s ? p[0] - g * f : "end" === s ? p[1] + g * f : (p[0] + p[1]) / 2, "middle" === s ? t.labelOffset + h * f : 0],
						    v = e.get("nameRotate");
						null != v && (v = v * x / 180);var _;"middle" === s ? r = w(t.rotation, null != v ? v : t.rotation, h) : (r = a(t, s, v || 0, p), _ = t.axisNameAvailableWidth, null != _ && (_ = Math.abs(_ / Math.sin(r.rotation)), !isFinite(_) && (_ = null)));var b = d.getFont(),
						    S = e.get("nameTruncate", !0) || {},
						    M = S.ellipsis,
						    I = y(t.nameTruncateMaxWidth, S.maxWidth, _),
						    T = null != M && null != I ? u.truncateText(i, I, b, M, { minChar: 2, placeholder: S.placeholder }) : i,
						    A = e.get("tooltip", !0),
						    C = e.mainType,
						    L = { componentType: C, name: i, $vars: ["name"] };L[C + "Index"] = e.componentIndex;var D = new c.Text({ anid: "name", __fullText: i, __truncatedText: T, style: { text: T, textFont: b, fill: d.getTextColor() || e.get("axisLine.lineStyle.color"), textAlign: r.textAlign, textVerticalAlign: r.textVerticalAlign }, position: m, rotation: r.rotation, silent: o(e), z2: 1, tooltip: A && A.show ? l.extend({ content: i, formatter: function formatter() {
									return i;
								}, formatterParams: L }, A) : null });e.get("triggerEvent") && (D.eventData = n(e), D.eventData.targetType = "axisName", D.eventData.name = i), this._dumbGroup.add(D), D.updateTransform(), this.group.add(D), D.decomposeTransform();
					}
				} },
			    w = _.innerTextLayout = function (t, e, i) {
				var n,
				    a,
				    o = f(e - t);return p(o) ? (a = i > 0 ? "top" : "bottom", n = "center") : p(o - x) ? (a = i > 0 ? "bottom" : "top", n = "center") : (a = "middle", n = o > 0 && o < x ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), { rotation: o, textAlign: n, textVerticalAlign: a };
			},
			    S = _.ifIgnoreOnTick = function (t, e, i) {
				var n,
				    a = t.scale;return "ordinal" === a.type && ("function" == typeof i ? (n = a.getTicks()[e], !i(n, a.getLabel(n))) : e % (i + 1));
			},
			    M = _.getInterval = function (t, e) {
				var i = t.get("interval");return null != i && "auto" != i || (i = e), i;
			};t.exports = _;
		}, function (t, e, i) {
			function n(t, e, i, n, s, l) {
				var u = r.getAxisPointerClass(t.axisPointerClass);if (u) {
					var c = o.getAxisPointerModel(e);c ? (t._axisPointer || (t._axisPointer = new u())).render(e, c, n, l) : a(t, n);
				}
			}function a(t, e, i) {
				var n = t._axisPointer;n && n.dispose(e, i), t._axisPointer = null;
			}var o = i(45),
			    r = i(2).extendComponentView({ type: "axis", _axisPointer: null, axisPointerClass: null, render: function render(t, e, i, a) {
					this.axisPointerClass && o.fixValue(t), r.superApply(this, "render", arguments), n(this, t, e, i, a, !0);
				}, updateAxisPointer: function updateAxisPointer(t, e, i, a, o) {
					n(this, t, e, i, a, !1);
				}, remove: function remove(t, e) {
					var i = this._axisPointer;i && i.remove(e), r.superApply(this, "remove", arguments);
				}, dispose: function dispose(t, e) {
					a(this, e), r.superApply(this, "dispose", arguments);
				} }),
			    s = [];r.registerAxisPointerClass = function (t, e) {
				s[t] = e;
			}, r.getAxisPointerClass = function (t) {
				return t && s[t];
			}, t.exports = r;
		}, function (t, e, i) {
			function n(t) {
				return a.isObject(t) && null != t.value ? t.value : t + "";
			}var a = i(1),
			    o = i(18);t.exports = { getFormattedLabels: function getFormattedLabels() {
					return o.getFormattedLabels(this.axis, this.get("axisLabel.formatter"));
				}, getCategories: function getCategories() {
					return "category" === this.get("type") && a.map(this.get("data"), n);
				}, getMin: function getMin(t) {
					var e = this.option,
					    i = t || null == e.rangeStart ? e.min : e.rangeStart;return this.axis && null != i && "dataMin" !== i && !a.eqNaN(i) && (i = this.axis.scale.parse(i)), i;
				}, getMax: function getMax(t) {
					var e = this.option,
					    i = t || null == e.rangeEnd ? e.max : e.rangeEnd;return this.axis && null != i && "dataMax" !== i && !a.eqNaN(i) && (i = this.axis.scale.parse(i)), i;
				}, getNeedCrossZero: function getNeedCrossZero() {
					var t = this.option;return null == t.rangeStart && null == t.rangeEnd && !t.scale;
				}, getCoordSysModel: a.noop, setRange: function setRange(t, e) {
					this.option.rangeStart = t, this.option.rangeEnd = e;
				}, resetRange: function resetRange() {
					this.option.rangeStart = this.option.rangeEnd = null;
				} };
		}, function (t, e, i) {
			var n = i(4),
			    a = i(7),
			    o = i(34),
			    r = i(64),
			    s = n.round,
			    l = o.extend({ type: "interval", _interval: 0, _intervalPrecision: 2, setExtent: function setExtent(t, e) {
					var i = this._extent;isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e));
				}, unionExtent: function unionExtent(t) {
					var e = this._extent;t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), l.prototype.setExtent.call(this, e[0], e[1]);
				}, getInterval: function getInterval() {
					return this._interval;
				}, setInterval: function setInterval(t) {
					this._interval = t, this._niceExtent = this._extent.slice();
				}, getTicks: function getTicks() {
					return r.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision);
				}, getTicksLabels: function getTicksLabels() {
					for (var t = [], e = this.getTicks(), i = 0; i < e.length; i++) {
						t.push(this.getLabel(e[i]));
					}return t;
				}, getLabel: function getLabel(t, e) {
					if (null == t) return "";var i = e && e.precision;return null == i ? i = n.getPrecisionSafe(t) || 0 : "auto" === i && (i = this._intervalPrecision), t = s(t, i, !0), a.addCommas(t);
				}, niceTicks: function niceTicks(t, e) {
					t = t || 5;var i = this._extent,
					    n = i[1] - i[0];if (isFinite(n)) {
						n < 0 && (n = -n, i.reverse());var a = r.intervalScaleNiceTicks(i, t, e);this._intervalPrecision = a.intervalPrecision, this._interval = a.interval, this._niceExtent = a.niceTickExtent;
					}
				}, niceExtent: function niceExtent(t) {
					var e = this._extent;if (e[0] === e[1]) if (0 !== e[0]) {
						var i = e[0];t.fixMax ? e[0] -= i / 2 : (e[1] += i / 2, e[0] -= i / 2);
					} else e[1] = 1;var n = e[1] - e[0];isFinite(n) || (e[0] = 0, e[1] = 1), this.niceTicks(t.splitNumber, t.minInterval);var a = this._interval;t.fixMin || (e[0] = s(Math.floor(e[0] / a) * a)), t.fixMax || (e[1] = s(Math.ceil(e[1] / a) * a));
				} });l.create = function () {
				return new l();
			}, t.exports = l;
		}, function (t, e, i) {
			function n(t) {
				this.group = new o.Group(), this._symbolCtor = t || r;
			}function a(t, e, i) {
				var n = t.getItemLayout(e);return n && !isNaN(n[0]) && !isNaN(n[1]) && !(i && i(e)) && "none" !== t.getItemVisual(e, "symbol");
			}var o = i(3),
			    r = i(54),
			    s = n.prototype;s.updateData = function (t, e) {
				var i = this.group,
				    n = t.hostModel,
				    r = this._data,
				    s = this._symbolCtor,
				    l = { itemStyle: n.getModel("itemStyle.normal").getItemStyle(["color"]), hoverItemStyle: n.getModel("itemStyle.emphasis").getItemStyle(), symbolRotate: n.get("symbolRotate"), symbolOffset: n.get("symbolOffset"), hoverAnimation: n.get("hoverAnimation"), labelModel: n.getModel("label.normal"), hoverLabelModel: n.getModel("label.emphasis") };t.diff(r).add(function (n) {
					var o = t.getItemLayout(n);if (a(t, n, e)) {
						var r = new s(t, n, l);r.attr("position", o), t.setItemGraphicEl(n, r), i.add(r);
					}
				}).update(function (u, c) {
					var h = r.getItemGraphicEl(c),
					    d = t.getItemLayout(u);return a(t, u, e) ? (h ? (h.updateData(t, u, l), o.updateProps(h, { position: d }, n)) : (h = new s(t, u), h.attr("position", d)), i.add(h), void t.setItemGraphicEl(u, h)) : void i.remove(h);
				}).remove(function (t) {
					var e = r.getItemGraphicEl(t);e && e.fadeOut(function () {
						i.remove(e);
					});
				}).execute(), this._data = t;
			}, s.updateLayout = function () {
				var t = this._data;t && t.eachItemGraphicEl(function (e, i) {
					var n = t.getItemLayout(i);e.attr("position", n);
				});
			}, s.remove = function (t) {
				var e = this.group,
				    i = this._data;i && (t ? i.eachItemGraphicEl(function (t) {
					t.fadeOut(function () {
						e.remove(t);
					});
				}) : e.removeAll());
			}, t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = e.getComponent("tooltip"),
				    o = e.getComponent("axisPointer"),
				    s = o.get("link", !0) || [],
				    u = [];h(i.getCoordinateSystems(), function (i) {
					function c(n, c, h) {
						var d = h.model.getModel("axisPointer", o),
						    f = d.get("show");if (f && ("auto" !== f || n || l(d))) {
							null == c && (c = d.get("triggerTooltip")), d = n ? a(h, v, o, e, n, c) : d;var m = d.get("snap"),
							    y = p(h.model),
							    x = c || m || "category" === h.type,
							    _ = t.axesInfo[y] = { key: y, axis: h, coordSys: i, axisPointerModel: d, triggerTooltip: c, involveSeries: x, snap: m, useHandle: l(d), seriesModels: [] };g[y] = _, t.seriesInvolved |= x;var b = r(s, h);if (null != b) {
								var w = u[b] || (u[b] = { axesInfo: {} });w.axesInfo[y] = _, w.mapper = s[b].mapper, _.linkGroup = w;
							}
						}
					}if (i.axisPointerEnabled) {
						var f = p(i.model),
						    g = t.coordSysAxesInfo[f] = {};t.coordSysMap[f] = i;var m = i.model,
						    v = m.getModel("tooltip", n);if (h(i.getAxes(), d(c, !1, null)), i.getTooltipAxes && n && v.get("show")) {
							var y = "axis" === v.get("trigger"),
							    x = "cross" === v.get("axisPointer.type"),
							    _ = i.getTooltipAxes(v.get("axisPointer.axis"));(y || x) && h(_.baseAxes, d(c, !x || "cross", y)), x && h(_.otherAxes, d(c, "cross", !1));
						}
					}
				});
			}function a(t, e, i, n, a, o) {
				var r = e.getModel("axisPointer"),
				    s = {};h(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], function (t) {
					s[t] = u.clone(r.get(t));
				}), s.snap = "category" !== t.type && !!o, "cross" === r.get("type") && (s.type = "line");var l = s.label || (s.label = {});if (null == l.show && (l.show = !1), "cross" === a && (l.show = !0, !o)) {
					var d = s.lineStyle = r.get("crossStyle");d && u.defaults(l.textStyle || (l.textStyle = {}), d.textStyle);
				}return t.model.getModel("axisPointer", new c(s, i, n));
			}function o(t, e) {
				e.eachSeries(function (e) {
					var i = e.coordinateSystem,
					    n = e.get("tooltip.trigger", !0);i && "none" !== n && n !== !1 && "item" !== n && e.get("axisPointer.show", !0) !== !1 && h(t.coordSysAxesInfo[p(i.model)], function (t) {
						var n = t.axis;i.getAxis(n.dim) === n && (t.seriesModels.push(e), null == t.seriesDataCount && (t.seriesDataCount = 0), t.seriesDataCount += e.getData().count());
					});
				}, this);
			}function r(t, e) {
				for (var i = e.model, n = e.dim, a = 0; a < t.length; a++) {
					var o = t[a] || {};if (s(o[n + "AxisId"], i.id) || s(o[n + "AxisIndex"], i.componentIndex) || s(o[n + "AxisName"], i.name)) return a;
				}
			}function s(t, e) {
				return "all" === t || u.isArray(t) && u.indexOf(t, e) >= 0 || t === e;
			}function l(t) {
				return !!t.get("handle.show");
			}var u = i(1),
			    c = i(10),
			    h = u.each,
			    d = u.curry,
			    f = {};f.collect = function (t, e) {
				var i = { axesInfo: {}, seriesInvolved: !1, coordSysAxesInfo: {}, coordSysMap: {} };return n(i, t, e), i.seriesInvolved && o(i, t), i;
			}, f.fixValue = function (t) {
				var e = f.getAxisInfo(t);if (e) {
					var i = e.axisPointerModel,
					    n = e.axis.scale,
					    a = i.option,
					    o = i.get("status"),
					    r = i.get("value");null != r && (r = n.parse(r));var s = l(i);null == o && (a.status = s ? "show" : "hide");var u = n.getExtent().slice();u[0] > u[1] && u.reverse(), (null == r || r > u[1]) && (r = u[1]), r < u[0] && (r = u[0]), a.value = r, s && (a.status = e.axis.scale.isBlank() ? "hide" : "show");
				}
			}, f.getAxisInfo = function (t) {
				var e = (t.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;return e && e.axesInfo[p(t)];
			}, f.getAxisPointerModel = function (t) {
				var e = f.getAxisInfo(t);return e && e.axisPointerModel;
			};var p = f.makeKey = function (t) {
				return t.type + "||" + t.id;
			};t.exports = f;
		}, function (t, e, i) {
			function n(t) {
				var e = {};return h(["start", "end", "startValue", "endValue", "throttle"], function (i) {
					t.hasOwnProperty(i) && (e[i] = t[i]);
				}), e;
			}function a(t, e) {
				h([["start", "startValue"], ["end", "endValue"]], function (i, n) {
					var a = t._rangePropMode;null != e[i[0]] ? a[n] = "percent" : null != e[i[1]] && (a[n] = "value");
				});
			}var o = i(1),
			    r = i(9),
			    s = i(2),
			    l = i(5),
			    u = i(77),
			    c = i(198),
			    h = o.each,
			    d = u.eachAxisDim,
			    f = s.extendComponentModel({ type: "dataZoom", dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series"], defaultOption: { zlevel: 0, z: 4, orient: null, xAxisIndex: null, yAxisIndex: null, filterMode: "filter", throttle: null, start: 0, end: 100, startValue: null, endValue: null, minSpan: null, maxSpan: null, minValueSpan: null, maxValueSpan: null }, init: function init(t, e, i) {
					this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel, this._autoThrottle = !0, this._rangePropMode = ["percent", "percent"];var a = n(t);this.mergeDefaultAndTheme(t, i), this.doInit(a);
				}, mergeOption: function mergeOption(t) {
					var e = n(t);o.merge(this.option, t, !0), this.doInit(e);
				}, doInit: function doInit(t) {
					var e = this.option;r.canvasSupported || (e.realtime = !1), this._setDefaultThrottle(t), a(this, t), h([["start", "startValue"], ["end", "endValue"]], function (t, i) {
						"value" === this._rangePropMode[i] && (e[t[0]] = null);
					}, this), this.textStyleModel = this.getModel("textStyle"), this._resetTarget(), this._giveAxisProxies();
				}, _giveAxisProxies: function _giveAxisProxies() {
					var t = this._axisProxies;this.eachTargetAxis(function (e, i, n, a) {
						var o = this.dependentModels[e.axis][i],
						    r = o.__dzAxisProxy || (o.__dzAxisProxy = new c(e.name, i, this, a));t[e.name + "_" + i] = r;
					}, this);
				}, _resetTarget: function _resetTarget() {
					var t = this.option,
					    e = this._judgeAutoMode();d(function (e) {
						var i = e.axisIndex;t[i] = l.normalizeToArray(t[i]);
					}, this), "axisIndex" === e ? this._autoSetAxisIndex() : "orient" === e && this._autoSetOrient();
				}, _judgeAutoMode: function _judgeAutoMode() {
					var t = this.option,
					    e = !1;d(function (i) {
						null != t[i.axisIndex] && (e = !0);
					}, this);var i = t.orient;return null == i && e ? "orient" : e ? void 0 : (null == i && (t.orient = "horizontal"), "axisIndex");
				}, _autoSetAxisIndex: function _autoSetAxisIndex() {
					var t = !0,
					    e = this.get("orient", !0),
					    i = this.option,
					    n = this.dependentModels;if (t) {
						var a = "vertical" === e ? "y" : "x";n[a + "Axis"].length ? (i[a + "AxisIndex"] = [0], t = !1) : h(n.singleAxis, function (n) {
							t && n.get("orient", !0) === e && (i.singleAxisIndex = [n.componentIndex], t = !1);
						});
					}t && d(function (e) {
						if (t) {
							var n = [],
							    a = this.dependentModels[e.axis];if (a.length && !n.length) for (var o = 0, r = a.length; o < r; o++) {
								"category" === a[o].get("type") && n.push(o);
							}i[e.axisIndex] = n, n.length && (t = !1);
						}
					}, this), t && this.ecModel.eachSeries(function (t) {
						this._isSeriesHasAllAxesTypeOf(t, "value") && d(function (e) {
							var n = i[e.axisIndex],
							    a = t.get(e.axisIndex),
							    r = t.get(e.axisId),
							    s = t.ecModel.queryComponents({ mainType: e.axis, index: a, id: r })[0];a = s.componentIndex, o.indexOf(n, a) < 0 && n.push(a);
						});
					}, this);
				}, _autoSetOrient: function _autoSetOrient() {
					var t;this.eachTargetAxis(function (e) {
						!t && (t = e.name);
					}, this), this.option.orient = "y" === t ? "vertical" : "horizontal";
				}, _isSeriesHasAllAxesTypeOf: function _isSeriesHasAllAxesTypeOf(t, e) {
					var i = !0;return d(function (n) {
						var a = t.get(n.axisIndex),
						    o = this.dependentModels[n.axis][a];o && o.get("type") === e || (i = !1);
					}, this), i;
				}, _setDefaultThrottle: function _setDefaultThrottle(t) {
					if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
						var e = this.ecModel.option;this.option.throttle = e.animation && e.animationDurationUpdate > 0 ? 100 : 20;
					}
				}, getFirstTargetAxisModel: function getFirstTargetAxisModel() {
					var t;return d(function (e) {
						if (null == t) {
							var i = this.get(e.axisIndex);i.length && (t = this.dependentModels[e.axis][i[0]]);
						}
					}, this), t;
				}, eachTargetAxis: function eachTargetAxis(t, e) {
					var i = this.ecModel;d(function (n) {
						h(this.get(n.axisIndex), function (a) {
							t.call(e, n, a, this, i);
						}, this);
					}, this);
				}, getAxisProxy: function getAxisProxy(t, e) {
					return this._axisProxies[t + "_" + e];
				}, getAxisModel: function getAxisModel(t, e) {
					var i = this.getAxisProxy(t, e);return i && i.getAxisModel();
				}, setRawRange: function setRawRange(t, e) {
					h(["start", "end", "startValue", "endValue"], function (e) {
						this.option[e] = t[e];
					}, this), !e && a(this, t);
				}, getPercentRange: function getPercentRange() {
					var t = this.findRepresentativeAxisProxy();if (t) return t.getDataPercentWindow();
				}, getValueRange: function getValueRange(t, e) {
					if (null != t || null != e) return this.getAxisProxy(t, e).getDataValueWindow();var i = this.findRepresentativeAxisProxy();return i ? i.getDataValueWindow() : void 0;
				}, findRepresentativeAxisProxy: function findRepresentativeAxisProxy(t) {
					if (t) return t.__dzAxisProxy;var e = this._axisProxies;for (var i in e) {
						if (e.hasOwnProperty(i) && e[i].hostedBy(this)) return e[i];
					}for (var i in e) {
						if (e.hasOwnProperty(i) && !e[i].hostedBy(this)) return e[i];
					}
				}, getRangePropMode: function getRangePropMode() {
					return this._rangePropMode.slice();
				} });t.exports = f;
		}, function (t, e, i) {
			var n = i(65);t.exports = n.extend({ type: "dataZoom", render: function render(t, e, i, n) {
					this.dataZoomModel = t, this.ecModel = e, this.api = i;
				}, getTargetCoordInfo: function getTargetCoordInfo() {
					function t(t, e, i, n) {
						for (var a, o = 0; o < i.length; o++) {
							if (i[o].model === t) {
								a = i[o];break;
							}
						}a || i.push(a = { model: t, axisModels: [], coordIndex: n }), a.axisModels.push(e);
					}var e = this.dataZoomModel,
					    i = this.ecModel,
					    n = {};return e.eachTargetAxis(function (e, a) {
						var o = i.getComponent(e.axis, a);if (o) {
							var r = o.getCoordSysModel();r && t(r, o, n[r.mainType] || (n[r.mainType] = []), r.componentIndex);
						}
					}, this), n;
				} });
		}, function (t, e) {
			"use strict";
			function i(t) {
				return t;
			}function n(t, e, n, a) {
				this._old = t, this._new = e, this._oldKeyGetter = n || i, this._newKeyGetter = a || i;
			}function a(t, e, i, n) {
				for (var a = 0; a < t.length; a++) {
					var o = "_ec_" + n(t[a], a),
					    r = e[o];null == r ? (i.push(o), e[o] = a) : (r.length || (e[o] = r = [r]), r.push(a));
				}
			}n.prototype = { constructor: n, add: function add(t) {
					return this._add = t, this;
				}, update: function update(t) {
					return this._update = t, this;
				}, remove: function remove(t) {
					return this._remove = t, this;
				}, execute: function execute() {
					var t,
					    e = this._old,
					    i = this._new,
					    n = this._oldKeyGetter,
					    o = this._newKeyGetter,
					    r = {},
					    s = {},
					    l = [],
					    u = [];for (a(e, r, l, n), a(i, s, u, o), t = 0; t < e.length; t++) {
						var c = l[t],
						    h = s[c];if (null != h) {
							var d = h.length;d ? (1 === d && (s[c] = null), h = h.unshift()) : s[c] = null, this._update && this._update(h, t);
						} else this._remove && this._remove(t);
					}for (var t = 0; t < u.length; t++) {
						var c = u[t];if (s.hasOwnProperty(c)) {
							var h = s[c];if (null == h) continue;if (h.length) for (var f = 0, d = h.length; f < d; f++) {
								this._add && this._add(h[f]);
							} else this._add && this._add(h);
						}
					}
				} }, t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(15),
			    o = a.parseClassType,
			    r = 0,
			    s = {},
			    l = "_";s.getUID = function (t) {
				return [t || "", r++, Math.random()].join(l);
			}, s.enableSubTypeDefaulter = function (t) {
				var e = {};return t.registerSubTypeDefaulter = function (t, i) {
					t = o(t), e[t.main] = i;
				}, t.determineSubType = function (i, n) {
					var a = n.type;if (!a) {
						var r = o(i).main;t.hasSubTypes(i) && e[r] && (a = e[r](n));
					}return a;
				}, t;
			}, s.enableTopologicalTravel = function (t, e) {
				function i(t) {
					var i = {},
					    r = [];return n.each(t, function (s) {
						var l = a(i, s),
						    u = l.originalDeps = e(s),
						    c = o(u, t);l.entryCount = c.length, 0 === l.entryCount && r.push(s), n.each(c, function (t) {
							n.indexOf(l.predecessor, t) < 0 && l.predecessor.push(t);var e = a(i, t);n.indexOf(e.successor, t) < 0 && e.successor.push(s);
						});
					}), { graph: i, noEntryList: r };
				}function a(t, e) {
					return t[e] || (t[e] = { predecessor: [], successor: [] }), t[e];
				}function o(t, e) {
					var i = [];return n.each(t, function (t) {
						n.indexOf(e, t) >= 0 && i.push(t);
					}), i;
				}t.topologicalTravel = function (t, e, a, o) {
					function r(t) {
						u[t].entryCount--, 0 === u[t].entryCount && c.push(t);
					}function s(t) {
						h[t] = !0, r(t);
					}if (t.length) {
						var l = i(e),
						    u = l.graph,
						    c = l.noEntryList,
						    h = {};for (n.each(t, function (t) {
							h[t] = !0;
						}); c.length;) {
							var d = c.pop(),
							    f = u[d],
							    p = !!h[d];p && (a.call(o, d, f.originalDeps.slice()), delete h[d]), n.each(f.successor, p ? s : r);
						}n.each(h, function () {
							throw new Error("Circle dependency may exists");
						});
					}
				};
			}, t.exports = s;
		}, function (t, e) {
			t.exports = function (t, e, i, n, a) {
				n.eachRawSeriesByType(t, function (t) {
					var a = t.getData(),
					    o = t.get("symbol") || e,
					    r = t.get("symbolSize");a.setVisual({ legendSymbol: i || o, symbol: o, symbolSize: r }), n.isSeriesFiltered(t) || ("function" == typeof r && a.each(function (e) {
						var i = t.getRawValue(e),
						    n = t.getDataParams(e);a.setItemVisual(e, "symbolSize", r(i, n));
					}), a.each(function (t) {
						var e = a.getItemModel(t),
						    i = e.getShallow("symbol", !0),
						    n = e.getShallow("symbolSize", !0);null != i && a.setItemVisual(t, "symbol", i), null != n && a.setItemVisual(t, "symbolSize", n);
					}));
				});
			};
		}, function (t, e) {
			function i(t) {
				for (var e = 0; t >= c;) {
					e |= 1 & t, t >>= 1;
				}return t + e;
			}function n(t, e, i, n) {
				var o = e + 1;if (o === i) return 1;if (n(t[o++], t[e]) < 0) {
					for (; o < i && n(t[o], t[o - 1]) < 0;) {
						o++;
					}a(t, e, o);
				} else for (; o < i && n(t[o], t[o - 1]) >= 0;) {
					o++;
				}return o - e;
			}function a(t, e, i) {
				for (i--; e < i;) {
					var n = t[e];t[e++] = t[i], t[i--] = n;
				}
			}function o(t, e, i, n, a) {
				for (n === e && n++; n < i; n++) {
					for (var o, r = t[n], s = e, l = n; s < l;) {
						o = s + l >>> 1, a(r, t[o]) < 0 ? l = o : s = o + 1;
					}var u = n - s;switch (u) {case 3:
							t[s + 3] = t[s + 2];case 2:
							t[s + 2] = t[s + 1];case 1:
							t[s + 1] = t[s];break;default:
							for (; u > 0;) {
								t[s + u] = t[s + u - 1], u--;
							}}t[s] = r;
				}
			}function r(t, e, i, n, a, o) {
				var r = 0,
				    s = 0,
				    l = 1;if (o(t, e[i + a]) > 0) {
					for (s = n - a; l < s && o(t, e[i + a + l]) > 0;) {
						r = l, l = (l << 1) + 1, l <= 0 && (l = s);
					}l > s && (l = s), r += a, l += a;
				} else {
					for (s = a + 1; l < s && o(t, e[i + a - l]) <= 0;) {
						r = l, l = (l << 1) + 1, l <= 0 && (l = s);
					}l > s && (l = s);var u = r;r = a - l, l = a - u;
				}for (r++; r < l;) {
					var c = r + (l - r >>> 1);o(t, e[i + c]) > 0 ? r = c + 1 : l = c;
				}return l;
			}function s(t, e, i, n, a, o) {
				var r = 0,
				    s = 0,
				    l = 1;if (o(t, e[i + a]) < 0) {
					for (s = a + 1; l < s && o(t, e[i + a - l]) < 0;) {
						r = l, l = (l << 1) + 1, l <= 0 && (l = s);
					}l > s && (l = s);var u = r;r = a - l, l = a - u;
				} else {
					for (s = n - a; l < s && o(t, e[i + a + l]) >= 0;) {
						r = l, l = (l << 1) + 1, l <= 0 && (l = s);
					}l > s && (l = s), r += a, l += a;
				}for (r++; r < l;) {
					var c = r + (l - r >>> 1);o(t, e[i + c]) < 0 ? l = c : r = c + 1;
				}return l;
			}function l(t, e) {
				function i(t, e) {
					c[y] = t, f[y] = e, y += 1;
				}function n() {
					for (; y > 1;) {
						var t = y - 2;if (t >= 1 && f[t - 1] <= f[t] + f[t + 1] || t >= 2 && f[t - 2] <= f[t] + f[t - 1]) f[t - 1] < f[t + 1] && t--;else if (f[t] > f[t + 1]) break;o(t);
					}
				}function a() {
					for (; y > 1;) {
						var t = y - 2;t > 0 && f[t - 1] < f[t + 1] && t--, o(t);
					}
				}function o(i) {
					var n = c[i],
					    a = f[i],
					    o = c[i + 1],
					    h = f[i + 1];f[i] = a + h, i === y - 3 && (c[i + 1] = c[i + 2], f[i + 1] = f[i + 2]), y--;var d = s(t[o], t, n, a, 0, e);n += d, a -= d, 0 !== a && (h = r(t[n + a - 1], t, o, h, h - 1, e), 0 !== h && (a <= h ? l(n, a, o, h) : u(n, a, o, h)));
				}function l(i, n, a, o) {
					var l = 0;for (l = 0; l < n; l++) {
						x[l] = t[i + l];
					}var u = 0,
					    c = a,
					    d = i;if (t[d++] = t[c++], 0 !== --o) {
						if (1 === n) {
							for (l = 0; l < o; l++) {
								t[d + l] = t[c + l];
							}return void (t[d + o] = x[u]);
						}for (var f, g, m, v = p;;) {
							f = 0, g = 0, m = !1;do {
								if (e(t[c], x[u]) < 0) {
									if (t[d++] = t[c++], g++, f = 0, 0 === --o) {
										m = !0;break;
									}
								} else if (t[d++] = x[u++], f++, g = 0, 1 === --n) {
									m = !0;break;
								}
							} while ((f | g) < v);if (m) break;do {
								if (f = s(t[c], x, u, n, 0, e), 0 !== f) {
									for (l = 0; l < f; l++) {
										t[d + l] = x[u + l];
									}if (d += f, u += f, n -= f, n <= 1) {
										m = !0;break;
									}
								}if (t[d++] = t[c++], 0 === --o) {
									m = !0;break;
								}if (g = r(x[u], t, c, o, 0, e), 0 !== g) {
									for (l = 0; l < g; l++) {
										t[d + l] = t[c + l];
									}if (d += g, c += g, o -= g, 0 === o) {
										m = !0;break;
									}
								}if (t[d++] = x[u++], 1 === --n) {
									m = !0;break;
								}v--;
							} while (f >= h || g >= h);if (m) break;v < 0 && (v = 0), v += 2;
						}if (p = v, p < 1 && (p = 1), 1 === n) {
							for (l = 0; l < o; l++) {
								t[d + l] = t[c + l];
							}t[d + o] = x[u];
						} else {
							if (0 === n) throw new Error();for (l = 0; l < n; l++) {
								t[d + l] = x[u + l];
							}
						}
					} else for (l = 0; l < n; l++) {
						t[d + l] = x[u + l];
					}
				}function u(i, n, a, o) {
					var l = 0;for (l = 0; l < o; l++) {
						x[l] = t[a + l];
					}var u = i + n - 1,
					    c = o - 1,
					    d = a + o - 1,
					    f = 0,
					    g = 0;if (t[d--] = t[u--], 0 !== --n) {
						if (1 === o) {
							for (d -= n, u -= n, g = d + 1, f = u + 1, l = n - 1; l >= 0; l--) {
								t[g + l] = t[f + l];
							}return void (t[d] = x[c]);
						}for (var m = p;;) {
							var v = 0,
							    y = 0,
							    _ = !1;do {
								if (e(x[c], t[u]) < 0) {
									if (t[d--] = t[u--], v++, y = 0, 0 === --n) {
										_ = !0;break;
									}
								} else if (t[d--] = x[c--], y++, v = 0, 1 === --o) {
									_ = !0;break;
								}
							} while ((v | y) < m);if (_) break;do {
								if (v = n - s(x[c], t, i, n, n - 1, e), 0 !== v) {
									for (d -= v, u -= v, n -= v, g = d + 1, f = u + 1, l = v - 1; l >= 0; l--) {
										t[g + l] = t[f + l];
									}if (0 === n) {
										_ = !0;break;
									}
								}if (t[d--] = x[c--], 1 === --o) {
									_ = !0;break;
								}if (y = o - r(t[u], x, 0, o, o - 1, e), 0 !== y) {
									for (d -= y, c -= y, o -= y, g = d + 1, f = c + 1, l = 0; l < y; l++) {
										t[g + l] = x[f + l];
									}if (o <= 1) {
										_ = !0;break;
									}
								}if (t[d--] = t[u--], 0 === --n) {
									_ = !0;break;
								}m--;
							} while (v >= h || y >= h);if (_) break;m < 0 && (m = 0), m += 2;
						}if (p = m, p < 1 && (p = 1), 1 === o) {
							for (d -= n, u -= n, g = d + 1, f = u + 1, l = n - 1; l >= 0; l--) {
								t[g + l] = t[f + l];
							}t[d] = x[c];
						} else {
							if (0 === o) throw new Error();for (f = d - (o - 1), l = 0; l < o; l++) {
								t[f + l] = x[l];
							}
						}
					} else for (f = d - (o - 1), l = 0; l < o; l++) {
						t[f + l] = x[l];
					}
				}var c,
				    f,
				    p = h,
				    g = 0,
				    m = d,
				    v = 0,
				    y = 0;g = t.length, g < 2 * d && (m = g >>> 1);var x = [];v = g < 120 ? 5 : g < 1542 ? 10 : g < 119151 ? 19 : 40, c = [], f = [], this.mergeRuns = n, this.forceMergeRuns = a, this.pushRun = i;
			}function u(t, e, a, r) {
				a || (a = 0), r || (r = t.length);var s = r - a;if (!(s < 2)) {
					var u = 0;if (s < c) return u = n(t, a, r, e), void o(t, a, r, a + u, e);var h = new l(t, e),
					    d = i(s);do {
						if (u = n(t, a, r, e), u < d) {
							var f = s;f > d && (f = d), o(t, a, a + f, a + u, e), u = f;
						}h.pushRun(a, u), h.mergeRuns(), s -= u, a += u;
					} while (0 !== s);h.forceMergeRuns();
				}
			}var c = 32,
			    h = 7,
			    d = 256;t.exports = u;
		}, function (t, e, i) {
			var n = i(35);t.exports = function () {
				if (0 !== n.debugMode) if (1 == n.debugMode) for (var t in arguments) {
					throw new Error(arguments[t]);
				} else if (n.debugMode > 1) for (var t in arguments) {
					console.log(arguments[t]);
				}
			};
		}, function (t, e, i) {
			function n(t) {
				a.call(this, t);
			}var a = i(38),
			    o = i(11),
			    r = i(1),
			    s = i(70),
			    l = new s(50);n.prototype = { constructor: n, type: "image", brush: function brush(t, e) {
					var i,
					    n = this.style,
					    a = n.image;if (n.bind(t, this, e), i = "string" == typeof a ? this._image : a, !i && a) {
						var o = l.get(a);if (!o) return i = new Image(), i.onload = function () {
							i.onload = null;for (var t = 0; t < o.pending.length; t++) {
								o.pending[t].dirty();
							}
						}, o = { image: i, pending: [this] }, i.src = a, l.put(a, o), void (this._image = i);if (i = o.image, this._image = i, !i.width || !i.height) return void o.pending.push(this);
					}if (i) {
						var r = n.x || 0,
						    s = n.y || 0;if (!i.width || !i.height) return;var u = n.width,
						    c = n.height,
						    h = i.width / i.height;if (null == u && null != c ? u = c * h : null == c && null != u ? c = u / h : null == u && null == c && (u = i.width, c = i.height), this.setTransform(t), n.sWidth && n.sHeight) {
							var d = n.sx || 0,
							    f = n.sy || 0;t.drawImage(i, d, f, n.sWidth, n.sHeight, r, s, u, c);
						} else if (n.sx && n.sy) {
							var d = n.sx,
							    f = n.sy,
							    p = u - d,
							    g = c - f;t.drawImage(i, d, f, p, g, r, s, u, c);
						} else t.drawImage(i, r, s, u, c);this.restoreTransform(t), null != n.text && this.drawRectText(t, this.getBoundingRect());
					}
				}, getBoundingRect: function getBoundingRect() {
					var t = this.style;return this._rect || (this._rect = new o(t.x || 0, t.y || 0, t.width || 0, t.height || 0)), this._rect;
				} }, r.inherits(n, a), t.exports = n;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t.getItemVisual(e, "symbolSize");return i instanceof Array ? i.slice() : [+i, +i];
			}function a(t) {
				return [t[0] / 2, t[1] / 2];
			}function o(t, e, i) {
				u.Group.call(this), this.updateData(t, e, i);
			}function r(t, e) {
				this.parent.drift(t, e);
			}var s = i(1),
			    l = i(24),
			    u = i(3),
			    c = i(4),
			    h = i(92),
			    d = o.prototype;d._createSymbol = function (t, e, i, n) {
				this.removeAll();var o = e.hostModel,
				    s = e.getItemVisual(i, "color"),
				    c = l.createSymbol(t, -1, -1, 2, 2, s);c.attr({ z2: 100, culling: !0, scale: [0, 0] }), c.drift = r, u.initProps(c, { scale: a(n) }, o, i), this._symbolType = t, this.add(c);
			}, d.stopSymbolAnimation = function (t) {
				this.childAt(0).stopAnimation(t);
			}, d.getSymbolPath = function () {
				return this.childAt(0);
			}, d.getScale = function () {
				return this.childAt(0).scale;
			}, d.highlight = function () {
				this.childAt(0).trigger("emphasis");
			}, d.downplay = function () {
				this.childAt(0).trigger("normal");
			}, d.setZ = function (t, e) {
				var i = this.childAt(0);i.zlevel = t, i.z = e;
			}, d.setDraggable = function (t) {
				var e = this.childAt(0);e.draggable = t, e.cursor = t ? "move" : "pointer";
			}, d.updateData = function (t, e, i) {
				this.silent = !1;var o = t.getItemVisual(e, "symbol") || "circle",
				    r = t.hostModel,
				    s = n(t, e);if (o !== this._symbolType) this._createSymbol(o, t, e, s);else {
					var l = this.childAt(0);l.silent = !1, u.updateProps(l, { scale: a(s) }, r, e);
				}this._updateCommon(t, e, s, i), this._seriesModel = r;
			};var f = ["itemStyle", "normal"],
			    p = ["itemStyle", "emphasis"],
			    g = ["label", "normal"],
			    m = ["label", "emphasis"];d._updateCommon = function (t, e, i, n) {
				var o = this.childAt(0),
				    r = t.hostModel,
				    l = t.getItemVisual(e, "color");"image" !== o.type && o.useStyle({ strokeNoScale: !0 }), n = n || null;var d = n && n.itemStyle,
				    v = n && n.hoverItemStyle,
				    y = n && n.symbolRotate,
				    x = n && n.symbolOffset,
				    _ = n && n.labelModel,
				    b = n && n.hoverLabelModel,
				    w = n && n.hoverAnimation;if (!n || t.hasItemOption) {
					var S = t.getItemModel(e);d = S.getModel(f).getItemStyle(["color"]), v = S.getModel(p).getItemStyle(), y = S.getShallow("symbolRotate"), x = S.getShallow("symbolOffset"), _ = S.getModel(g), b = S.getModel(m), w = S.getShallow("hoverAnimation");
				} else v = s.extend({}, v);var M = o.style;o.attr("rotation", (y || 0) * Math.PI / 180 || 0), x && o.attr("position", [c.parsePercent(x[0], i[0]), c.parsePercent(x[1], i[1])]), o.setColor(l), o.setStyle(d);var I = t.getItemVisual(e, "opacity");null != I && (M.opacity = I);var T = h.findLabelValueDim(t);h.setTextToStyle(t, e, T, M, r, _, l), h.setTextToStyle(t, e, T, v, r, b, l), o.off("mouseover").off("mouseout").off("emphasis").off("normal"), o.hoverStyle = v, u.setHoverStyle(o);var A = a(i);if (w && r.isAnimationEnabled()) {
					var C = function C() {
						var t = A[1] / A[0];this.animateTo({ scale: [Math.max(1.1 * A[0], A[0] + 3), Math.max(1.1 * A[1], A[1] + 3 * t)] }, 400, "elasticOut");
					},
					    L = function L() {
						this.animateTo({ scale: A }, 400, "elasticOut");
					};o.on("mouseover", C).on("mouseout", L).on("emphasis", C).on("normal", L);
				}
			}, d.fadeOut = function (t) {
				var e = this.childAt(0);this.silent = e.silent = !0, e.style.text = "", u.updateProps(e, { scale: [0, 0] }, this._seriesModel, this.dataIndex, t);
			}, s.inherits(o, u.Group), t.exports = o;
		}, function (t, e, i) {
			var n = i(2),
			    a = i(45),
			    o = i(196),
			    r = i(1);i(194), i(195), i(120), n.registerPreprocessor(function (t) {
				if (t) {
					(!t.axisPointer || 0 === t.axisPointer.length) && (t.axisPointer = {});var e = t.axisPointer.link;e && !r.isArray(e) && (t.axisPointer.link = [e]);
				}
			}), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, function (t, e) {
				t.getComponent("axisPointer").coordSysAxesInfo = a.collect(t, e);
			}), n.registerAction({ type: "updateAxisPointer", event: "updateAxisPointer", update: ":updateAxisPointer" }, function (t, e, i) {
				var n = o(e.getComponent("axisPointer").coordSysAxesInfo, t.currTrigger, [t.x, t.y], t, t.dispatchAction || r.bind(i.dispatchAction, i), e, i, t.tooltipOption);return n;
			});
		}, function (t, e) {
			function i(t, e) {
				var i = t[e] - t[1 - e];return { span: Math.abs(i), sign: i > 0 ? -1 : i < 0 ? 1 : e ? -1 : 1 };
			}function n(t, e) {
				return Math.min(e[1], Math.max(e[0], t));
			}t.exports = function (t, e, a, o, r, s) {
				e[0] = n(e[0], a), e[1] = n(e[1], a), t = t || 0;var l = a[1] - a[0];null != r && (r = n(r, [0, l])), null != s && (s = Math.max(s, null != r ? r : 0)), "all" === o && (r = s = Math.abs(e[1] - e[0]), o = 0);var u = i(e, o);e[o] += t;var c = r || 0,
				    h = a.slice();u.sign < 0 ? h[0] += c : h[1] -= c, e[o] = n(e[o], h);var d = i(e, o);null != r && (d.sign !== u.sign || d.span < r) && (e[1 - o] = e[o] + u.sign * r);var d = i(e, o);return null != s && d.span > s && (e[1 - o] = e[o] + d.sign * s), e;
			};
		}, function (t, e, i) {
			function n(t, e, i) {
				return t.getCoordSysModel() === e;
			}function a(t) {
				var e,
				    i = t.model,
				    n = i.getFormattedLabels(),
				    a = i.getModel("axisLabel.textStyle"),
				    o = 1,
				    r = n.length;r > 40 && (o = Math.ceil(r / 40));for (var s = 0; s < r; s += o) {
					if (!t.isLabelIgnored(s)) {
						var l = a.getTextRect(n[s]);e ? e.union(l) : e = l;
					}
				}return e;
			}function o(t, e, i) {
				this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this.model = t;
			}function r(t, e) {
				var i = t.getExtent(),
				    n = i[0] + i[1];t.toGlobalCoord = "x" === t.dim ? function (t) {
					return t + e;
				} : function (t) {
					return n - t + e;
				}, t.toLocalCoord = "x" === t.dim ? function (t) {
					return t - e;
				} : function (t) {
					return n - t + e;
				};
			}function s(t, e) {
				return h.map(y, function (e) {
					var i = t.getReferringComponents(e)[0];return i;
				});
			}function l(t) {
				return "cartesian2d" === t.get("coordinateSystem");
			}var u = i(12),
			    c = i(18),
			    h = i(1),
			    d = i(133),
			    f = i(131),
			    p = h.each,
			    g = c.ifAxisCrossZero,
			    m = c.niceScaleExtent;i(134);var v = o.prototype;v.type = "grid", v.axisPointerEnabled = !0, v.getRect = function () {
				return this._rect;
			}, v.update = function (t, e) {
				function i(t) {
					var e = n[t];for (var i in e) {
						if (e.hasOwnProperty(i)) {
							var a = e[i];if (a && ("category" === a.type || "time" === a.type || !g(a))) return !0;
						}
					}return !1;
				}var n = this._axesMap;this._updateScale(t, this.model), p(n.x, function (t) {
					m(t.scale, t.model);
				}), p(n.y, function (t) {
					m(t.scale, t.model);
				}), p(n.x, function (t) {
					i("y") && (t.onZero = !1);
				}), p(n.y, function (t) {
					i("x") && (t.onZero = !1);
				}), this.resize(this.model, e);
			}, v.resize = function (t, e, i) {
				function n() {
					p(s, function (t) {
						var e = t.isHorizontal(),
						    i = e ? [0, o.width] : [0, o.height],
						    n = t.inverse ? 1 : 0;t.setExtent(i[n], i[1 - n]), r(t, e ? o.x : o.y);
					});
				}var o = u.getLayoutRect(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() });this._rect = o;var s = this._axesList;n(), !i && t.get("containLabel") && (p(s, function (t) {
					if (!t.model.get("axisLabel.inside")) {
						var e = a(t);if (e) {
							var i = t.isHorizontal() ? "height" : "width",
							    n = t.model.get("axisLabel.margin");o[i] -= e[i] + n, "top" === t.position ? o.y += e.height + n : "left" === t.position && (o.x += e.width + n);
						}
					}
				}), n());
			}, v.getAxis = function (t, e) {
				var i = this._axesMap[t];if (null != i) {
					if (null == e) for (var n in i) {
						if (i.hasOwnProperty(n)) return i[n];
					}return i[e];
				}
			}, v.getAxes = function () {
				return this._axesList.slice();
			}, v.getCartesian = function (t, e) {
				if (null != t && null != e) {
					var i = "x" + t + "y" + e;return this._coordsMap[i];
				}h.isObject(t) && (e = t.yAxisIndex, t = t.xAxisIndex);for (var n = 0, a = this._coordsList; n < a.length; n++) {
					if (a[n].getAxis("x").index === t || a[n].getAxis("y").index === e) return a[n];
				}
			}, v.getCartesians = function () {
				return this._coordsList.slice();
			}, v.convertToPixel = function (t, e, i) {
				var n = this._findConvertTarget(t, e);return n.cartesian ? n.cartesian.dataToPoint(i) : n.axis ? n.axis.toGlobalCoord(n.axis.dataToCoord(i)) : null;
			}, v.convertFromPixel = function (t, e, i) {
				var n = this._findConvertTarget(t, e);return n.cartesian ? n.cartesian.pointToData(i) : n.axis ? n.axis.coordToData(n.axis.toLocalCoord(i)) : null;
			}, v._findConvertTarget = function (t, e) {
				var i,
				    n,
				    a = e.seriesModel,
				    o = e.xAxisModel || a && a.getReferringComponents("xAxis")[0],
				    r = e.yAxisModel || a && a.getReferringComponents("yAxis")[0],
				    s = e.gridModel,
				    l = this._coordsList;if (a) i = a.coordinateSystem, h.indexOf(l, i) < 0 && (i = null);else if (o && r) i = this.getCartesian(o.componentIndex, r.componentIndex);else if (o) n = this.getAxis("x", o.componentIndex);else if (r) n = this.getAxis("y", r.componentIndex);else if (s) {
					var u = s.coordinateSystem;u === this && (i = this._coordsList[0]);
				}return { cartesian: i, axis: n };
			}, v.containPoint = function (t) {
				var e = this._coordsList[0];if (e) return e.containPoint(t);
			}, v._initCartesian = function (t, e, i) {
				function a(i) {
					return function (a, l) {
						if (n(a, t, e)) {
							var u = a.get("position");"x" === i ? "top" !== u && "bottom" !== u && (u = "bottom", o[u] && (u = "top" === u ? "bottom" : "top")) : "left" !== u && "right" !== u && (u = "left", o[u] && (u = "left" === u ? "right" : "left")), o[u] = !0;var h = new f(i, c.createScaleByModel(a), [0, 0], a.get("type"), u),
							    d = "category" === h.type;h.onBand = d && a.get("boundaryGap"), h.inverse = a.get("inverse"), h.onZero = a.get("axisLine.onZero"), a.axis = h, h.model = a, h.grid = this, h.index = l, this._axesList.push(h), r[i][l] = h, s[i]++;
						}
					};
				}var o = { left: !1, right: !1, top: !1, bottom: !1 },
				    r = { x: {}, y: {} },
				    s = { x: 0, y: 0 };return e.eachComponent("xAxis", a("x"), this), e.eachComponent("yAxis", a("y"), this), s.x && s.y ? (this._axesMap = r, void p(r.x, function (e, i) {
					p(r.y, function (n, a) {
						var o = "x" + i + "y" + a,
						    r = new d(o);r.grid = this, r.model = t, this._coordsMap[o] = r, this._coordsList.push(r), r.addAxis(e), r.addAxis(n);
					}, this);
				}, this)) : (this._axesMap = {}, void (this._axesList = []));
			}, v._updateScale = function (t, e) {
				function i(t, e, i) {
					p(i.coordDimToDataDim(e.dim), function (i) {
						e.scale.unionExtentFromData(t, i);
					});
				}h.each(this._axesList, function (t) {
					t.scale.setExtent(1 / 0, -(1 / 0));
				}), t.eachSeries(function (a) {
					if (l(a)) {
						var o = s(a, t),
						    r = o[0],
						    u = o[1];if (!n(r, e, t) || !n(u, e, t)) return;var c = this.getCartesian(r.componentIndex, u.componentIndex),
						    h = a.getData(),
						    d = c.getAxis("x"),
						    f = c.getAxis("y");"list" === h.type && (i(h, d, a), i(h, f, a));
					}
				}, this);
			}, v.getTooltipAxes = function (t) {
				var e = [],
				    i = [];return p(this.getCartesians(), function (n) {
					var a = null != t && "auto" !== t ? n.getAxis(t) : n.getBaseAxis(),
					    o = n.getOtherAxis(a);h.indexOf(e, a) < 0 && e.push(a), h.indexOf(i, o) < 0 && i.push(o);
				}), { baseAxes: e, otherAxes: i };
			};var y = ["xAxis", "yAxis"];o.create = function (t, e) {
				var i = [];return t.eachComponent("grid", function (n, a) {
					var r = new o(n, t, e);r.name = "grid_" + a, r.resize(n, e, !0), n.coordinateSystem = r, i.push(r);
				}), t.eachSeries(function (e) {
					if (l(e)) {
						var i = s(e, t),
						    n = i[0],
						    a = i[1],
						    o = n.getCoordSysModel(),
						    r = o.coordinateSystem;e.coordinateSystem = r.getCartesian(n.componentIndex, a.componentIndex);
					}
				}), i;
			}, o.dimensions = o.prototype.dimensions = d.prototype.dimensions, i(26).register("cartesian2d", o), t.exports = o;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return t > s || t < -s;
			}var a = i(19),
			    o = i(6),
			    r = a.identity,
			    s = 5e-5,
			    l = function l(t) {
				t = t || {}, t.position || (this.position = [0, 0]), null == t.rotation && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null;
			},
			    u = l.prototype;
			u.transform = null, u.needLocalTransform = function () {
				return n(this.rotation) || n(this.position[0]) || n(this.position[1]) || n(this.scale[0] - 1) || n(this.scale[1] - 1);
			}, u.updateTransform = function () {
				var t = this.parent,
				    e = t && t.transform,
				    i = this.needLocalTransform(),
				    n = this.transform;return i || e ? (n = n || a.create(), i ? this.getLocalTransform(n) : r(n), e && (i ? a.mul(n, t.transform, n) : a.copy(n, t.transform)), this.transform = n, this.invTransform = this.invTransform || a.create(), void a.invert(this.invTransform, n)) : void (n && r(n));
			}, u.getLocalTransform = function (t) {
				return l.getLocalTransform(this, t);
			}, u.setTransform = function (t) {
				var e = this.transform,
				    i = t.dpr || 1;e ? t.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : t.setTransform(i, 0, 0, i, 0, 0);
			}, u.restoreTransform = function (t) {
				var e = t.dpr || 1;t.setTransform(e, 0, 0, e, 0, 0);
			};var c = [];u.decomposeTransform = function () {
				if (this.transform) {
					var t = this.parent,
					    e = this.transform;t && t.transform && (a.mul(c, t.invTransform, e), e = c);var i = e[0] * e[0] + e[1] * e[1],
					    o = e[2] * e[2] + e[3] * e[3],
					    r = this.position,
					    s = this.scale;n(i - 1) && (i = Math.sqrt(i)), n(o - 1) && (o = Math.sqrt(o)), e[0] < 0 && (i = -i), e[3] < 0 && (o = -o), r[0] = e[4], r[1] = e[5], s[0] = i, s[1] = o, this.rotation = Math.atan2(-e[1] / o, e[0] / i);
				}
			}, u.getGlobalScale = function () {
				var t = this.transform;if (!t) return [1, 1];var e = Math.sqrt(t[0] * t[0] + t[1] * t[1]),
				    i = Math.sqrt(t[2] * t[2] + t[3] * t[3]);return t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), [e, i];
			}, u.transformCoordToLocal = function (t, e) {
				var i = [t, e],
				    n = this.invTransform;return n && o.applyTransform(i, i, n), i;
			}, u.transformCoordToGlobal = function (t, e) {
				var i = [t, e],
				    n = this.transform;return n && o.applyTransform(i, i, n), i;
			}, l.getLocalTransform = function (t, e) {
				e = e || [], r(e);var i = t.origin,
				    n = t.scale || [1, 1],
				    o = t.rotation || 0,
				    s = t.position || [0, 0];return i && (e[4] -= i[0], e[5] -= i[1]), a.scale(e, e, n), o && a.rotate(e, e, o), i && (e[4] += i[0], e[5] += i[1]), e[4] += s[0], e[5] += s[1], e;
			}, t.exports = l;
		}, function (t, e, i) {
			var n = i(96),
			    a = i(1),
			    o = i(13),
			    r = i(12),
			    s = ["value", "category", "time", "log"];t.exports = function (t, e, i, l) {
				a.each(s, function (o) {
					e.extend({ type: t + "Axis." + o, mergeDefaultAndTheme: function mergeDefaultAndTheme(e, n) {
							var s = this.layoutMode,
							    l = s ? r.getLayoutParams(e) : {},
							    u = n.getTheme();a.merge(e, u.get(o + "Axis")), a.merge(e, this.getDefaultOption()), e.type = i(t, e), s && r.mergeLayoutParam(e, l, s);
						}, defaultOption: a.mergeAll([{}, n[o + "Axis"], l], !0) });
				}), o.registerSubTypeDefaulter(t + "Axis", a.curry(i, t));
			};
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				return e.type || (e.data ? "category" : "value");
			}var a = i(13),
			    o = i(1),
			    r = i(59),
			    s = a.extend({ type: "cartesian2dAxis", axis: null, init: function init() {
					s.superApply(this, "init", arguments), this.resetRange();
				}, mergeOption: function mergeOption() {
					s.superApply(this, "mergeOption", arguments), this.resetRange();
				}, restoreData: function restoreData() {
					s.superApply(this, "restoreData", arguments), this.resetRange();
				}, getCoordSysModel: function getCoordSysModel() {
					return this.ecModel.queryComponents({ mainType: "grid", index: this.option.gridIndex, id: this.option.gridId })[0];
				} });o.merge(s.prototype, i(42));var l = { offset: 0 };r("x", s, n, l), r("y", s, n, l), t.exports = s;
		}, function (t, e) {
			t.exports = function (t, e) {
				e.eachSeriesByType(t, function (t) {
					var e = t.getData(),
					    i = t.coordinateSystem;if (i) {
						for (var n = [], a = i.dimensions, o = 0; o < a.length; o++) {
							n.push(t.coordDimToDataDim(i.dimensions[o])[0]);
						}1 === n.length ? e.each(n[0], function (t, n) {
							e.setItemLayout(n, isNaN(t) ? [NaN, NaN] : i.dataToPoint(t));
						}) : 2 === n.length && e.each(n, function (t, n, a) {
							e.setItemLayout(a, isNaN(t) || isNaN(n) ? [NaN, NaN] : i.dataToPoint([t, n]));
						}, !0);
					}
				});
			};
		}, function (t, e, i) {
			var n = i(15),
			    a = n.set,
			    o = n.get;t.exports = { clearColorPalette: function clearColorPalette() {
					a(this, "colorIdx", 0), a(this, "colorNameMap", {});
				}, getColorFromPalette: function getColorFromPalette(t, e) {
					e = e || this;var i = o(e, "colorIdx") || 0,
					    n = o(e, "colorNameMap") || a(e, "colorNameMap", {});if (n.hasOwnProperty(t)) return n[t];var r = this.get("color", !0) || [];if (r.length) {
						var s = r[i];return t && (n[t] = s), a(e, "colorIdx", (i + 1) % r.length), s;
					}
				} };
		}, function (t, e) {
			t.exports = function (t, e) {
				var i = e.findComponents({ mainType: "legend" });i && i.length && e.eachSeriesByType(t, function (t) {
					var e = t.getData();e.filterSelf(function (t) {
						for (var n = e.getName(t), a = 0; a < i.length; a++) {
							if (!i[a].isSelected(n)) return !1;
						}return !0;
					}, this);
				}, this);
			};
		}, function (t, e, i) {
			function n(t, e, i) {
				t[e] = Math.max(Math.min(t[e], i[1]), i[0]);
			}var a = i(4),
			    o = a.round,
			    r = {};r.intervalScaleNiceTicks = function (t, e, i) {
				var n = {},
				    s = t[1] - t[0],
				    l = n.interval = a.nice(s / e, !0);null != i && l < i && (l = n.interval = i);var u = n.intervalPrecision = a.getPrecisionSafe(l) + 2,
				    c = n.niceTickExtent = [o(Math.ceil(t[0] / l) * l, u), o(Math.floor(t[1] / l) * l, u)];return r.fixExtent(c, t), n;
			}, r.fixExtent = function (t, e) {
				!isFinite(t[0]) && (t[0] = e[0]), !isFinite(t[1]) && (t[1] = e[1]), n(t, 0, e), n(t, 1, e), t[0] > t[1] && (t[0] = t[1]);
			}, r.intervalScaleGetTicks = function (t, e, i, n) {
				var a = [];if (!t) return a;var r = 1e4;e[0] < i[0] && a.push(e[0]);for (var s = i[0]; s <= i[1] && (a.push(s), s = o(s + t, n), s !== a[a.length - 1]);) {
					if (a.length > r) return [];
				}return e[1] > (a.length ? a[a.length - 1] : i[1]) && a.push(e[1]), a;
			}, t.exports = r;
		}, function (t, e, i) {
			var n = i(36),
			    a = i(49),
			    o = i(15),
			    r = function r() {
				this.group = new n(), this.uid = a.getUID("viewComponent");
			};r.prototype = { constructor: r, init: function init(t, e) {}, render: function render(t, e, i, n) {}, dispose: function dispose() {} };var s = r.prototype;s.updateView = s.updateLayout = s.updateVisual = function (t, e, i, n) {}, o.enableClassExtend(r), o.enableClassManagement(r, { registerWhenExtend: !0 }), t.exports = r;
		}, function (t, e, i) {
			"use strict";
			var n = i(71),
			    a = i(23),
			    o = i(58),
			    r = i(178),
			    s = i(1),
			    l = function l(t) {
				o.call(this, t), a.call(this, t), r.call(this, t), this.id = t.id || n();
			};l.prototype = { type: "element", name: "", __zr: null, ignore: !1, clipPath: null, drift: function drift(t, e) {
					switch (this.draggable) {case "horizontal":
							e = 0;break;case "vertical":
							t = 0;}var i = this.transform;i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty(!1);
				}, beforeUpdate: function beforeUpdate() {}, afterUpdate: function afterUpdate() {}, update: function update() {
					this.updateTransform();
				}, traverse: function traverse(t, e) {}, attrKV: function attrKV(t, e) {
					if ("position" === t || "scale" === t || "origin" === t) {
						if (e) {
							var i = this[t];i || (i = this[t] = []), i[0] = e[0], i[1] = e[1];
						}
					} else this[t] = e;
				}, hide: function hide() {
					this.ignore = !0, this.__zr && this.__zr.refresh();
				}, show: function show() {
					this.ignore = !1, this.__zr && this.__zr.refresh();
				}, attr: function attr(t, e) {
					if ("string" == typeof t) this.attrKV(t, e);else if (s.isObject(t)) for (var i in t) {
						t.hasOwnProperty(i) && this.attrKV(i, t[i]);
					}return this.dirty(!1), this;
				}, setClipPath: function setClipPath(t) {
					var e = this.__zr;e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty(!1);
				}, removeClipPath: function removeClipPath() {
					var t = this.clipPath;t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1));
				}, addSelfToZr: function addSelfToZr(t) {
					this.__zr = t;var e = this.animators;if (e) for (var i = 0; i < e.length; i++) {
						t.animation.addAnimator(e[i]);
					}this.clipPath && this.clipPath.addSelfToZr(t);
				}, removeSelfFromZr: function removeSelfFromZr(t) {
					this.__zr = null;var e = this.animators;if (e) for (var i = 0; i < e.length; i++) {
						t.animation.removeAnimator(e[i]);
					}this.clipPath && this.clipPath.removeSelfFromZr(t);
				} }, s.mixin(l, r), s.mixin(l, o), s.mixin(l, a), t.exports = l;
		}, function (t, e, i) {
			function n(t, e) {
				return t[e];
			}function a(t, e, i) {
				t[e] = i;
			}function o(t, e, i) {
				return (e - t) * i + t;
			}function r(t, e, i) {
				return i > .5 ? e : t;
			}function s(t, e, i, n, a) {
				var r = t.length;if (1 == a) for (var s = 0; s < r; s++) {
					n[s] = o(t[s], e[s], i);
				} else for (var l = r && t[0].length, s = 0; s < r; s++) {
					for (var u = 0; u < l; u++) {
						n[s][u] = o(t[s][u], e[s][u], i);
					}
				}
			}function l(t, e, i) {
				var n = t.length,
				    a = e.length;if (n !== a) {
					var o = n > a;if (o) t.length = a;else for (var r = n; r < a; r++) {
						t.push(1 === i ? e[r] : _.call(e[r]));
					}
				}for (var s = t[0] && t[0].length, r = 0; r < t.length; r++) {
					if (1 === i) isNaN(t[r]) && (t[r] = e[r]);else for (var l = 0; l < s; l++) {
						isNaN(t[r][l]) && (t[r][l] = e[r][l]);
					}
				}
			}function u(t, e, i) {
				if (t === e) return !0;var n = t.length;if (n !== e.length) return !1;if (1 === i) {
					for (var a = 0; a < n; a++) {
						if (t[a] !== e[a]) return !1;
					}
				} else for (var o = t[0].length, a = 0; a < n; a++) {
					for (var r = 0; r < o; r++) {
						if (t[a][r] !== e[a][r]) return !1;
					}
				}return !0;
			}function c(t, e, i, n, a, o, r, s, l) {
				var u = t.length;if (1 == l) for (var c = 0; c < u; c++) {
					s[c] = h(t[c], e[c], i[c], n[c], a, o, r);
				} else for (var d = t[0].length, c = 0; c < u; c++) {
					for (var f = 0; f < d; f++) {
						s[c][f] = h(t[c][f], e[c][f], i[c][f], n[c][f], a, o, r);
					}
				}
			}function h(t, e, i, n, a, o, r) {
				var s = .5 * (i - t),
				    l = .5 * (n - e);return (2 * (e - i) + s + l) * r + (-3 * (e - i) - 2 * s - l) * o + s * a + e;
			}function d(t) {
				if (x(t)) {
					var e = t.length;if (x(t[0])) {
						for (var i = [], n = 0; n < e; n++) {
							i.push(_.call(t[n]));
						}return i;
					}return _.call(t);
				}return t;
			}function f(t) {
				return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")";
			}function p(t) {
				var e = t[t.length - 1].value;return x(e && e[0]) ? 2 : 1;
			}function g(t, e, i, n, a) {
				var d = t._getter,
				    g = t._setter,
				    y = "spline" === e,
				    _ = n.length;if (_) {
					var b,
					    w = n[0].value,
					    S = x(w),
					    M = !1,
					    I = !1,
					    T = S ? p(n) : 0;n.sort(function (t, e) {
						return t.time - e.time;
					}), b = n[_ - 1].time;for (var A = [], C = [], L = n[0].value, D = !0, P = 0; P < _; P++) {
						A.push(n[P].time / b);var k = n[P].value;if (S && u(k, L, T) || !S && k === L || (D = !1), L = k, "string" == typeof k) {
							var O = v.parse(k);O ? (k = O, M = !0) : I = !0;
						}C.push(k);
					}if (!D) {
						for (var z = C[_ - 1], P = 0; P < _ - 1; P++) {
							S ? l(C[P], z, T) : !isNaN(C[P]) || isNaN(z) || I || M || (C[P] = z);
						}S && l(d(t._target, a), z, T);var E,
						    R,
						    N,
						    V,
						    B,
						    G,
						    H = 0,
						    F = 0;if (M) var W = [0, 0, 0, 0];var Z = function Z(t, e) {
							var i;if (e < 0) i = 0;else if (e < F) {
								for (E = Math.min(H + 1, _ - 1), i = E; i >= 0 && !(A[i] <= e); i--) {}i = Math.min(i, _ - 2);
							} else {
								for (i = H; i < _ && !(A[i] > e); i++) {}i = Math.min(i - 1, _ - 2);
							}H = i, F = e;var n = A[i + 1] - A[i];if (0 !== n) if (R = (e - A[i]) / n, y) {
								if (V = C[i], N = C[0 === i ? i : i - 1], B = C[i > _ - 2 ? _ - 1 : i + 1], G = C[i > _ - 3 ? _ - 1 : i + 2], S) c(N, V, B, G, R, R * R, R * R * R, d(t, a), T);else {
									var l;if (M) l = c(N, V, B, G, R, R * R, R * R * R, W, 1), l = f(W);else {
										if (I) return r(V, B, R);l = h(N, V, B, G, R, R * R, R * R * R);
									}g(t, a, l);
								}
							} else if (S) s(C[i], C[i + 1], R, d(t, a), T);else {
								var l;if (M) s(C[i], C[i + 1], R, W, 1), l = f(W);else {
									if (I) return r(C[i], C[i + 1], R);l = o(C[i], C[i + 1], R);
								}g(t, a, l);
							}
						},
						    q = new m({ target: t._target, life: b, loop: t._loop, delay: t._delay, onframe: Z, ondestroy: i });return e && "spline" !== e && (q.easing = e), q;
					}
				}
			}var m = i(157),
			    v = i(22),
			    y = i(1),
			    x = y.isArrayLike,
			    _ = Array.prototype.slice,
			    b = function b(t, e, i, o) {
				this._tracks = {}, this._target = t, this._loop = e || !1, this._getter = i || n, this._setter = o || a, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = [];
			};b.prototype = { when: function when(t, e) {
					var i = this._tracks;for (var n in e) {
						if (e.hasOwnProperty(n)) {
							if (!i[n]) {
								i[n] = [];var a = this._getter(this._target, n);if (null == a) continue;0 !== t && i[n].push({ time: 0, value: d(a) });
							}i[n].push({ time: t, value: e[n] });
						}
					}return this;
				}, during: function during(t) {
					return this._onframeList.push(t), this;
				}, pause: function pause() {
					for (var t = 0; t < this._clipList.length; t++) {
						this._clipList[t].pause();
					}this._paused = !0;
				}, resume: function resume() {
					for (var t = 0; t < this._clipList.length; t++) {
						this._clipList[t].resume();
					}this._paused = !1;
				}, isPaused: function isPaused() {
					return !!this._paused;
				}, _doneCallback: function _doneCallback() {
					this._tracks = {}, this._clipList.length = 0;for (var t = this._doneList, e = t.length, i = 0; i < e; i++) {
						t[i].call(this);
					}
				}, start: function start(t) {
					var e,
					    i = this,
					    n = 0,
					    a = function a() {
						n--, n || i._doneCallback();
					};for (var o in this._tracks) {
						if (this._tracks.hasOwnProperty(o)) {
							var r = g(this, t, a, this._tracks[o], o);r && (this._clipList.push(r), n++, this.animation && this.animation.addClip(r), e = r);
						}
					}if (e) {
						var s = e.onframe;e.onframe = function (t, e) {
							s(t, e);for (var n = 0; n < i._onframeList.length; n++) {
								i._onframeList[n](t, e);
							}
						};
					}return n || this._doneCallback(), this;
				}, stop: function stop(t) {
					for (var e = this._clipList, i = this.animation, n = 0; n < e.length; n++) {
						var a = e[n];t && a.onframe(this._target, 1), i && i.removeClip(a);
					}e.length = 0;
				}, delay: function delay(t) {
					return this._delay = t, this;
				}, done: function done(t) {
					return t && this._doneList.push(t), this;
				}, getClips: function getClips() {
					return this._clipList;
				} }, t.exports = b;
		}, function (t, e) {
			t.exports = "undefined" != typeof window && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (t) {
				setTimeout(t, 16);
			};
		}, function (t, e) {
			var i = 2 * Math.PI;t.exports = { normalizeRadian: function normalizeRadian(t) {
					return t %= i, t < 0 && (t += i), t;
				} };
		}, function (t, e) {
			var i = function i() {
				this.head = null, this.tail = null, this._len = 0;
			},
			    n = i.prototype;n.insert = function (t) {
				var e = new a(t);return this.insertEntry(e), e;
			}, n.insertEntry = function (t) {
				this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
			}, n.remove = function (t) {
				var e = t.prev,
				    i = t.next;e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--;
			}, n.len = function () {
				return this._len;
			}, n.clear = function () {
				this.head = this.tail = null, this._len = 0;
			};var a = function a(t) {
				this.value = t, this.next, this.prev;
			},
			    o = function o(t) {
				this._list = new i(), this._map = {}, this._maxSize = t || 10, this._lastRemovedEntry = null;
			},
			    r = o.prototype;r.put = function (t, e) {
				var i = this._list,
				    n = this._map,
				    o = null;if (null == n[t]) {
					var r = i.len(),
					    s = this._lastRemovedEntry;if (r >= this._maxSize && r > 0) {
						var l = i.head;i.remove(l), delete n[l.key], o = l.value, this._lastRemovedEntry = l;
					}s ? s.value = e : s = new a(e), s.key = t, i.insertEntry(s), n[t] = s;
				}return o;
			}, r.get = function (t) {
				var e = this._map[t],
				    i = this._list;if (null != e) return e !== i.tail && (i.remove(e), i.insertEntry(e)), e.value;
			}, r.clear = function () {
				this._list.clear(), this._map = {};
			}, t.exports = o;
		}, function (t, e) {
			var i = 2311;t.exports = function () {
				return i++;
			};
		}, function (t, e) {
			var i = function i(t, e) {
				this.image = t, this.repeat = e, this.type = "pattern";
			};i.prototype.getCanvasPattern = function (t) {
				return t.createPattern(this.image, this.repeat || "repeat");
			}, t.exports = i;
		}, function (t, e) {
			function i(t, e, i) {
				var n = null == e.x ? 0 : e.x,
				    a = null == e.x2 ? 1 : e.x2,
				    o = null == e.y ? 0 : e.y,
				    r = null == e.y2 ? 0 : e.y2;e.global || (n = n * i.width + i.x, a = a * i.width + i.x, o = o * i.height + i.y, r = r * i.height + i.y);var s = t.createLinearGradient(n, o, a, r);return s;
			}function n(t, e, i) {
				var n = i.width,
				    a = i.height,
				    o = Math.min(n, a),
				    r = null == e.x ? .5 : e.x,
				    s = null == e.y ? .5 : e.y,
				    l = null == e.r ? .5 : e.r;e.global || (r = r * n + i.x, s = s * a + i.y, l *= o);var u = t.createRadialGradient(r, s, 0, r, s, l);return u;
			}var a = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]],
			    o = function o(t) {
				this.extendFrom(t);
			};o.prototype = { constructor: o, fill: "#000000", stroke: null, opacity: 1, lineDash: null, lineDashOffset: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, lineWidth: 1, strokeNoScale: !1, text: null, textFill: "#000", textStroke: null, textPosition: "inside", textOffset: null, textBaseline: null, textAlign: null, textVerticalAlign: null, textDistance: 5, textShadowBlur: 0, textShadowOffsetX: 0, textShadowOffsetY: 0, textTransform: !1, textRotation: 0, blend: null, bind: function bind(t, e, i) {
					for (var n = this, o = i && i.style, r = !o, s = 0; s < a.length; s++) {
						var l = a[s],
						    u = l[0];(r || n[u] !== o[u]) && (t[u] = n[u] || l[1]);
					}if ((r || n.fill !== o.fill) && (t.fillStyle = n.fill), (r || n.stroke !== o.stroke) && (t.strokeStyle = n.stroke), (r || n.opacity !== o.opacity) && (t.globalAlpha = null == n.opacity ? 1 : n.opacity), (r || n.blend !== o.blend) && (t.globalCompositeOperation = n.blend || "source-over"), this.hasStroke()) {
						var c = n.lineWidth;t.lineWidth = c / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1);
					}
				}, hasFill: function hasFill() {
					var t = this.fill;return null != t && "none" !== t;
				}, hasStroke: function hasStroke() {
					var t = this.stroke;return null != t && "none" !== t && this.lineWidth > 0;
				}, extendFrom: function extendFrom(t, e) {
					if (t) {
						var i = this;for (var n in t) {
							!t.hasOwnProperty(n) || !e && i.hasOwnProperty(n) || (i[n] = t[n]);
						}
					}
				}, set: function set(t, e) {
					"string" == typeof t ? this[t] = e : this.extendFrom(t, !0);
				}, clone: function clone() {
					var t = new this.constructor();return t.extendFrom(this, !0), t;
				}, getGradient: function getGradient(t, e, a) {
					for (var o = "radial" === e.type ? n : i, r = o(t, e, a), s = e.colorStops, l = 0; l < s.length; l++) {
						r.addColorStop(s[l].offset, s[l].color);
					}return r;
				} };for (var r = o.prototype, s = 0; s < a.length; s++) {
				var l = a[s];l[0] in r || (r[l[0]] = l[1]);
			}o.getGradient = r.getGradient, t.exports = o;
		}, function (t, e, i) {
			var n = i(168),
			    a = i(167);t.exports = { buildPath: function buildPath(t, e, i) {
					var o = e.points,
					    r = e.smooth;if (o && o.length >= 2) {
						if (r && "spline" !== r) {
							var s = a(o, r, i, e.smoothConstraint);t.moveTo(o[0][0], o[0][1]);for (var l = o.length, u = 0; u < (i ? l : l - 1); u++) {
								var c = s[2 * u],
								    h = s[2 * u + 1],
								    d = o[(u + 1) % l];t.bezierCurveTo(c[0], c[1], h[0], h[1], d[0], d[1]);
							}
						} else {
							"spline" === r && (o = n(o, i)), t.moveTo(o[0][0], o[0][1]);for (var u = 1, f = o.length; u < f; u++) {
								t.lineTo(o[u][0], o[u][1]);
							}
						}i && t.closePath();
					}
				} };
		}, function (t, e, i) {
			var n = i(1),
			    a = {};a.layout = function (t, e, i) {
				function a(t, e) {
					var i = o.getAxis(t);return i.toGlobalCoord(i.dataToCoord(0));
				}i = i || {};var o = t.coordinateSystem,
				    r = e.axis,
				    s = {},
				    l = r.position,
				    u = r.onZero ? "onZero" : l,
				    c = r.dim,
				    h = o.getRect(),
				    d = [h.x, h.x + h.width, h.y, h.y + h.height],
				    f = e.get("offset") || 0,
				    p = { x: { top: d[2] - f, bottom: d[3] + f }, y: { left: d[0] - f, right: d[1] + f } };p.x.onZero = Math.max(Math.min(a("y"), p.x.bottom), p.x.top), p.y.onZero = Math.max(Math.min(a("x"), p.y.right), p.y.left), s.position = ["y" === c ? p.y[u] : d[0], "x" === c ? p.x[u] : d[3]], s.rotation = Math.PI / 2 * ("x" === c ? 0 : 1);var g = { top: -1, bottom: 1, left: -1, right: 1 };s.labelDirection = s.tickDirection = s.nameDirection = g[l], s.labelOffset = r.onZero ? p[c][l] - p[c].onZero : 0, e.get("axisTick.inside") && (s.tickDirection = -s.tickDirection), n.retrieve(i.labelInside, e.get("axisLabel.inside")) && (s.labelDirection = -s.labelDirection);var m = e.get("axisLabel.rotate");return s.labelRotate = "top" === u ? -m : m, s.labelInterval = r.getLabelInterval(), s.z2 = 1, s;
			}, t.exports = a;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i, n) {
				var a = n.getWidth(),
				    o = n.getHeight();t[0] = Math.min(t[0] + e, a) - e, t[1] = Math.min(t[1] + i, o) - i, t[0] = Math.max(t[0], 0), t[1] = Math.max(t[1], 0);
			}var a = i(1),
			    o = i(3),
			    r = i(16),
			    s = i(7),
			    l = i(19),
			    u = i(18),
			    c = i(40),
			    h = {};h.buildElStyle = function (t) {
				var e,
				    i = t.get("type"),
				    n = t.getModel(i + "Style");return "line" === i ? (e = n.getLineStyle(), e.fill = null) : "shadow" === i && (e = n.getAreaStyle(), e.stroke = null), e;
			}, h.buildLabelElOption = function (t, e, i, a, o) {
				var l = i.get("value"),
				    u = h.getValueLabel(l, e.axis, e.ecModel, i.get("seriesDataIndices"), { precision: i.get("label.precision"), formatter: i.get("label.formatter") }),
				    c = i.getModel("label"),
				    d = c.getModel("textStyle"),
				    f = s.normalizeCssArray(c.get("padding") || 0),
				    p = d.getFont(),
				    g = r.getBoundingRect(u, p, o.textAlign, o.textBaseline),
				    m = o.position,
				    v = g.width + f[1] + f[3],
				    y = g.height + f[0] + f[2],
				    x = o.align;"right" === x && (m[0] -= v), "center" === x && (m[0] -= v / 2);var _ = o.verticalAlign;"bottom" === _ && (m[1] -= y), "middle" === _ && (m[1] -= y / 2), n(m, v, y, a);var b = c.get("backgroundColor");b && "auto" !== b || (b = e.get("axisLine.lineStyle.color")), t.label = { shape: { x: 0, y: 0, width: v, height: y, r: c.get("borderRadius") }, position: m.slice(), style: { text: u, textFont: p, textFill: d.getTextColor(), textPosition: "inside", fill: b, stroke: c.get("borderColor") || "transparent", lineWidth: c.get("borderWidth") || 0, shadowBlur: c.get("shadowBlur"), shadowColor: c.get("shadowColor"), shadowOffsetX: c.get("shadowOffsetX"), shadowOffsetY: c.get("shadowOffsetY") }, z2: 10 };
			}, h.getValueLabel = function (t, e, i, n, o) {
				var r = e.scale.getLabel(t, { precision: o.precision }),
				    s = o.formatter;if (s) {
					var l = { value: u.getAxisRawValue(e, t), seriesData: [] };a.each(n, function (t) {
						var e = i.getSeriesByIndex(t.seriesIndex),
						    n = t.dataIndexInside,
						    a = e && e.getDataParams(n);a && l.seriesData.push(a);
					}), a.isString(s) ? r = s.replace("{value}", r) : a.isFunction(s) && (r = s(l));
				}return r;
			}, h.getTransformedPosition = function (t, e, i) {
				var n = l.create();return l.rotate(n, n, i.rotation), l.translate(n, n, i.position), o.applyTransform([t.dataToCoord(e), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)], n);
			}, h.buildCartesianSingleLabelElOption = function (t, e, i, n, a, o) {
				var r = c.innerTextLayout(i.rotation, 0, i.labelDirection);i.labelMargin = a.get("label.margin"), h.buildLabelElOption(e, n, a, o, { position: h.getTransformedPosition(n.axis, t, i), align: r.textAlign, verticalAlign: r.textVerticalAlign });
			}, h.makeLineShape = function (t, e, i) {
				return i = i || 0, { x1: t[i], y1: t[1 - i], x2: e[i], y2: e[1 - i] };
			}, h.makeRectShape = function (t, e, i) {
				return i = i || 0, { x: t[i], y: t[1 - i], width: e[i], height: e[1 - i] };
			}, h.makeSectorShape = function (t, e, i, n, a, o) {
				return { cx: t, cy: e, r0: i, r: n, startAngle: a, endAngle: o, clockwise: !0 };
			}, t.exports = h;
		}, function (t, e, i) {
			var n = i(7),
			    a = i(1),
			    o = {},
			    r = ["x", "y", "z", "radius", "angle", "single"],
			    s = ["cartesian2d", "polar", "singleAxis"];o.isCoordSupported = function (t) {
				return a.indexOf(s, t) >= 0;
			}, o.createNameEach = function (t, e) {
				t = t.slice();var i = a.map(t, n.capitalFirst);e = (e || []).slice();var o = a.map(e, n.capitalFirst);return function (n, r) {
					a.each(t, function (t, a) {
						for (var s = { name: t, capital: i[a] }, l = 0; l < e.length; l++) {
							s[e[l]] = t + o[l];
						}n.call(r, s);
					});
				};
			}, o.eachAxisDim = o.createNameEach(r, ["axisIndex", "axis", "index", "id"]), o.createLinkedNodesFinder = function (t, e, i) {
				function n(t, e) {
					return a.indexOf(e.nodes, t) >= 0;
				}function o(t, n) {
					var o = !1;return e(function (e) {
						a.each(i(t, e) || [], function (t) {
							n.records[e.name][t] && (o = !0);
						});
					}), o;
				}function r(t, n) {
					n.nodes.push(t), e(function (e) {
						a.each(i(t, e) || [], function (t) {
							n.records[e.name][t] = !0;
						});
					});
				}return function (i) {
					function a(t) {
						!n(t, s) && o(t, s) && (r(t, s), l = !0);
					}var s = { nodes: [], records: {} };if (e(function (t) {
						s.records[t.name] = {};
					}), !i) return s;r(i, s);var l;do {
						l = !1, t(a);
					} while (l);return s;
				};
			}, t.exports = o;
		}, function (t, e, i) {
			var n = i(1);t.exports = { updateSelectedMap: function updateSelectedMap(t) {
					this._selectTargetMap = n.reduce(t || [], function (t, e) {
						return t.set(e.name, e), t;
					}, n.createHashMap());
				}, select: function select(t) {
					var e = this._selectTargetMap,
					    i = e.get(t),
					    n = this.get("selectedMode");"single" === n && e.each(function (t) {
						t.selected = !1;
					}), i && (i.selected = !0);
				}, unSelect: function unSelect(t) {
					var e = this._selectTargetMap.get(t);e && (e.selected = !1);
				}, toggleSelected: function toggleSelected(t) {
					var e = this._selectTargetMap.get(t);if (null != e) return this[e.selected ? "unSelect" : "select"](t), e.selected;
				}, isSelected: function isSelected(t) {
					var e = this._selectTargetMap.get(t);return e && e.selected;
				} };
		}, function (t, e, i) {
			function n(t) {
				a.defaultEmphasis(t.label, a.LABEL_OPTIONS);
			}var a = i(5),
			    o = i(1),
			    r = i(9),
			    s = i(7),
			    l = s.addCommas,
			    u = s.encodeHTML,
			    c = i(2).extendComponentModel({ type: "marker", dependencies: ["series", "grid", "polar", "geo"], init: function init(t, e, i, n) {
					this.mergeDefaultAndTheme(t, i), this.mergeOption(t, i, n.createdBySelf, !0);
				}, isAnimationEnabled: function isAnimationEnabled() {
					if (r.node) return !1;var t = this.__hostSeries;return this.getShallow("animation") && t && t.isAnimationEnabled();
				}, mergeOption: function mergeOption(t, e, i, a) {
					var r = this.constructor,
					    s = this.mainType + "Model";i || e.eachSeries(function (t) {
						var i = t.get(this.mainType),
						    l = t[s];return i && i.data ? (l ? l.mergeOption(i, e, !0) : (a && n(i), o.each(i.data, function (t) {
							t instanceof Array ? (n(t[0]), n(t[1])) : n(t);
						}), l = new r(i, this, e), o.extend(l, { mainType: this.mainType, seriesIndex: t.seriesIndex, name: t.name, createdBySelf: !0 }), l.__hostSeries = t), void (t[s] = l)) : void (t[s] = null);
					}, this);
				}, formatTooltip: function formatTooltip(t) {
					var e = this.getData(),
					    i = this.getRawValue(t),
					    n = o.isArray(i) ? o.map(i, l).join(", ") : l(i),
					    a = e.getName(t),
					    r = u(this.name);return (null != i || a) && (r += "<br />"), a && (r += u(a), null != i && (r += " : ")), null != i && (r += u(n)), r;
				}, getData: function getData() {
					return this._data;
				}, setData: function setData(t) {
					this._data = t;
				} });o.mixin(c, a.dataFormatMixin), t.exports = c;
		}, function (t, e, i) {
			var n = i(1);t.exports = i(2).extendComponentView({ type: "marker", init: function init() {
					this.markerGroupMap = n.createHashMap();
				}, render: function render(t, e, i) {
					var n = this.markerGroupMap;n.each(function (t) {
						t.__keep = !1;
					});var a = this.type + "Model";e.eachSeries(function (t) {
						var n = t[a];n && this.renderSeries(t, n, e, i);
					}, this), n.each(function (t) {
						!t.__keep && this.group.remove(t.group);
					}, this);
				}, renderSeries: function renderSeries() {} });
		}, function (t, e, i) {
			function n(t) {
				return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y)));
			}function a(t) {
				return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y));
			}function o(t, e, i) {
				var n = -1;do {
					n = Math.max(l.getPrecision(t.get(e, i)), n), t = t.stackedOn;
				} while (t);return n;
			}function r(t, e, i, n, a, r) {
				var s = [],
				    l = m(e, n, t),
				    u = e.indicesOfNearest(n, l, !0)[0];s[a] = e.get(i, u, !0), s[r] = e.get(n, u, !0);var c = o(e, n, u);return c >= 0 && (s[r] = +s[r].toFixed(c)), s;
			}var s = i(1),
			    l = i(4),
			    u = s.indexOf,
			    c = s.curry,
			    h = { min: c(r, "min"), max: c(r, "max"), average: c(r, "average") },
			    d = function d(t, e) {
				var i = t.getData(),
				    n = t.coordinateSystem;if (e && !a(e) && !s.isArray(e.coord) && n) {
					var o = n.dimensions,
					    r = f(e, i, n, t);if (e = s.clone(e), e.type && h[e.type] && r.baseAxis && r.valueAxis) {
						var l = u(o, r.baseAxis.dim),
						    c = u(o, r.valueAxis.dim);e.coord = h[e.type](i, r.baseDataDim, r.valueDataDim, l, c), e.value = e.coord[c];
					} else {
						for (var d = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis], p = 0; p < 2; p++) {
							if (h[d[p]]) {
								var g = t.coordDimToDataDim(o[p])[0];d[p] = m(i, g, d[p]);
							}
						}e.coord = d;
					}
				}return e;
			},
			    f = function f(t, e, i, n) {
				var a = {};return null != t.valueIndex || null != t.valueDim ? (a.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, a.valueAxis = i.getAxis(n.dataDimToCoordDim(a.valueDataDim)), a.baseAxis = i.getOtherAxis(a.valueAxis), a.baseDataDim = n.coordDimToDataDim(a.baseAxis.dim)[0]) : (a.baseAxis = n.getBaseAxis(), a.valueAxis = i.getOtherAxis(a.baseAxis), a.baseDataDim = n.coordDimToDataDim(a.baseAxis.dim)[0], a.valueDataDim = n.coordDimToDataDim(a.valueAxis.dim)[0]), a;
			},
			    p = function p(t, e) {
				return !(t && t.containData && e.coord && !n(e)) || t.containData(e.coord);
			},
			    g = function g(t, e, i, n) {
				return n < 2 ? t.coord && t.coord[n] : t.value;
			},
			    m = function m(t, e, i) {
				if ("average" === i) {
					var n = 0,
					    a = 0;return t.each(e, function (t, e) {
						isNaN(t) || (n += t, a++);
					}, !0), n / a;
				}return t.getDataExtent(e, !0)["max" === i ? 1 : 0];
			};t.exports = { dataTransform: d, dataFilter: p, dimValueGetter: g, getAxisInfo: f, numCalculate: m };
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return t.get("stack") || d + t.seriesIndex;
			}function a(t) {
				return t.dim + t.index;
			}function o(t, e) {
				var i = [],
				    n = t.axis,
				    a = "axis0";if ("category" === n.type) {
					for (var o = n.getBandWidth(), r = 0; r < t.count; r++) {
						i.push(u.defaults({ bandWidth: o, axisKey: a, stackId: d + r }, t));
					}for (var l = s(i, e), c = [], r = 0; r < t.count; r++) {
						var h = l[a][d + r];h.offsetCenter = h.offset + h.width / 2, c.push(h);
					}return c;
				}
			}function r(t, e) {
				var i = u.map(t, function (t) {
					var e = t.getData(),
					    i = t.coordinateSystem,
					    o = i.getBaseAxis(),
					    r = o.getExtent(),
					    s = "category" === o.type ? o.getBandWidth() : Math.abs(r[1] - r[0]) / e.count(),
					    l = h(t.get("barWidth"), s),
					    u = h(t.get("barMaxWidth"), s),
					    c = t.get("barGap"),
					    d = t.get("barCategoryGap");return { bandWidth: s, barWidth: l, barMaxWidth: u, barGap: c, barCategoryGap: d, axisKey: a(o), stackId: n(t) };
				});return s(i, e);
			}function s(t, e) {
				var i = {};u.each(t, function (t, e) {
					var n = t.axisKey,
					    a = t.bandWidth,
					    o = i[n] || { bandWidth: a, remainedWidth: a, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {} },
					    r = o.stacks;i[n] = o;var s = t.stackId;r[s] || o.autoWidthCount++, r[s] = r[s] || { width: 0, maxWidth: 0 };var l = t.barWidth;l && !r[s].width && (l = Math.min(o.remainedWidth, l), r[s].width = l, o.remainedWidth -= l);var u = t.barMaxWidth;u && (r[s].maxWidth = u);var c = t.barGap;null != c && (o.gap = c);var h = t.barCategoryGap;null != h && (o.categoryGap = h);
				});var n = {};return u.each(i, function (t, e) {
					n[e] = {};var i = t.stacks,
					    a = t.bandWidth,
					    o = h(t.categoryGap, a),
					    r = h(t.gap, 1),
					    s = t.remainedWidth,
					    l = t.autoWidthCount,
					    c = (s - o) / (l + (l - 1) * r);c = Math.max(c, 0), u.each(i, function (t, e) {
						var i = t.maxWidth;i && i < c && (i = Math.min(i, s), t.width && (i = Math.min(i, t.width)), s -= i, t.width = i, l--);
					}), c = (s - o) / (l + (l - 1) * r), c = Math.max(c, 0);var d,
					    f = 0;u.each(i, function (t, e) {
						t.width || (t.width = c), d = t, f += t.width * (1 + r);
					}), d && (f -= d.width * r);var p = -f / 2;u.each(i, function (t, i) {
						n[e][i] = n[e][i] || { offset: p, width: t.width }, p += t.width * (1 + r);
					});
				}), n;
			}function l(t, e, i) {
				var o = r(u.filter(e.getSeriesByType(t), function (t) {
					return !e.isSeriesFiltered(t) && t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type;
				})),
				    s = {},
				    l = {};e.eachSeriesByType(t, function (t) {
					if ("cartesian2d" === t.coordinateSystem.type) {
						var e = t.getData(),
						    i = t.coordinateSystem,
						    r = i.getBaseAxis(),
						    u = n(t),
						    c = o[a(r)][u],
						    h = c.offset,
						    d = c.width,
						    f = i.getOtherAxis(r),
						    p = t.get("barMinHeight") || 0,
						    g = r.onZero ? f.toGlobalCoord(f.dataToCoord(0)) : f.getGlobalExtent()[0],
						    m = i.dataToPoints(e, !0);s[u] = s[u] || [], l[u] = l[u] || [], e.setLayout({ offset: h, size: d }), e.each(f.dim, function (t, i) {
							if (!isNaN(t)) {
								s[u][i] || (s[u][i] = { p: g, n: g }, l[u][i] = { p: g, n: g });var n,
								    a,
								    o,
								    r,
								    c = t >= 0 ? "p" : "n",
								    v = m[i],
								    y = s[u][i][c],
								    x = l[u][i][c];f.isHorizontal() ? (n = y, a = v[1] + h, o = v[0] - x, r = d, l[u][i][c] += o, Math.abs(o) < p && (o = (o < 0 ? -1 : 1) * p), s[u][i][c] += o) : (n = v[0] + h, a = y, o = d, r = v[1] - x, l[u][i][c] += r, Math.abs(r) < p && (r = (r <= 0 ? -1 : 1) * p), s[u][i][c] += r), e.setItemLayout(i, { x: n, y: a, width: o, height: r });
							}
						}, !0);
					}
				}, this);
			}var u = i(1),
			    c = i(4),
			    h = c.parsePercent,
			    d = "__ec_stack_";l.getLayoutOnAxis = o, t.exports = l;
		}, function (t, e, i) {
			function n(t) {
				var e = t.pieceList;t.hasSpecialVisual = !1, g.each(e, function (e, i) {
					e.originIndex = i, null != e.visual && (t.hasSpecialVisual = !0);
				});
			}function a(t) {
				var e = t.categories,
				    i = t.visual,
				    n = t.categoryMap = {};if (y(e, function (t, e) {
					n[t] = e;
				}), !g.isArray(i)) {
					var a = [];g.isObject(i) ? y(i, function (t, e) {
						var i = n[e];a[null != i ? i : _] = t;
					}) : a[_] = i, i = f(t, a);
				}for (var o = e.length - 1; o >= 0; o--) {
					null == i[o] && (delete n[e[o]], e.pop());
				}
			}function o(t, e) {
				var i = t.visual,
				    n = [];g.isObject(i) ? y(i, function (t) {
					n.push(t);
				}) : null != i && n.push(i);var a = { color: 1, symbol: 1 };e || 1 !== n.length || a.hasOwnProperty(t.type) || (n[1] = n[0]), f(t, n);
			}function r(t) {
				return { applyVisual: function applyVisual(e, i, n) {
						e = this.mapValueToVisual(e), n("color", t(i("color"), e));
					}, _doMap: h([0, 1]) };
			}function s(t) {
				var e = this.option.visual;return e[Math.round(v(t, [0, 1], [0, e.length - 1], !0))] || {};
			}function l(t) {
				return function (e, i, n) {
					n(t, this.mapValueToVisual(e));
				};
			}function u(t) {
				var e = this.option.visual;return e[this.option.loop && t !== _ ? t % e.length : t];
			}function c() {
				return this.option.visual[0];
			}function h(t) {
				return { linear: function linear(e) {
						return v(e, t, this.option.visual, !0);
					}, category: u, piecewise: function piecewise(e, i) {
						var n = d.call(this, i);return null == n && (n = v(e, t, this.option.visual, !0)), n;
					}, fixed: c };
			}function d(t) {
				var e = this.option,
				    i = e.pieceList;if (e.hasSpecialVisual) {
					var n = b.findPieceIndex(t, i),
					    a = i[n];if (a && a.visual) return a.visual[this.type];
				}
			}function f(t, e) {
				return t.visual = e, "color" === t.type && (t.parsedVisual = g.map(e, function (t) {
					return m.parse(t);
				})), e;
			}function p(t, e, i) {
				return t ? e <= i : e < i;
			}var g = i(1),
			    m = i(22),
			    v = i(4).linearMap,
			    y = g.each,
			    x = g.isObject,
			    _ = -1,
			    b = function b(t) {
				var e = t.mappingMethod,
				    i = t.type,
				    r = this.option = g.clone(t);this.type = i, this.mappingMethod = e, this._normalizeData = S[e];var s = w[i];this.applyVisual = s.applyVisual, this.getColorMapper = s.getColorMapper, this._doMap = s._doMap[e], "piecewise" === e ? (o(r), n(r)) : "category" === e ? r.categories ? a(r) : o(r, !0) : (g.assert("linear" !== e || r.dataExtent), o(r));
			};b.prototype = { constructor: b, mapValueToVisual: function mapValueToVisual(t) {
					var e = this._normalizeData(t);return this._doMap(e, t);
				}, getNormalizer: function getNormalizer() {
					return g.bind(this._normalizeData, this);
				} };var w = b.visualHandlers = { color: { applyVisual: l("color"), getColorMapper: function getColorMapper() {
						var t = this.option;return g.bind("category" === t.mappingMethod ? function (t, e) {
							return !e && (t = this._normalizeData(t)), u.call(this, t);
						} : function (e, i, n) {
							var a = !!n;return !i && (e = this._normalizeData(e)), n = m.fastMapToColor(e, t.parsedVisual, n), a ? n : m.stringify(n, "rgba");
						}, this);
					}, _doMap: { linear: function linear(t) {
							return m.stringify(m.fastMapToColor(t, this.option.parsedVisual), "rgba");
						}, category: u, piecewise: function piecewise(t, e) {
							var i = d.call(this, e);return null == i && (i = m.stringify(m.fastMapToColor(t, this.option.parsedVisual), "rgba")), i;
						}, fixed: c } }, colorHue: r(function (t, e) {
					return m.modifyHSL(t, e);
				}), colorSaturation: r(function (t, e) {
					return m.modifyHSL(t, null, e);
				}), colorLightness: r(function (t, e) {
					return m.modifyHSL(t, null, null, e);
				}), colorAlpha: r(function (t, e) {
					return m.modifyAlpha(t, e);
				}), opacity: { applyVisual: l("opacity"), _doMap: h([0, 1]) }, symbol: { applyVisual: function applyVisual(t, e, i) {
						var n = this.mapValueToVisual(t);if (g.isString(n)) i("symbol", n);else if (x(n)) for (var a in n) {
							n.hasOwnProperty(a) && i(a, n[a]);
						}
					}, _doMap: { linear: s, category: u, piecewise: function piecewise(t, e) {
							var i = d.call(this, e);return null == i && (i = s.call(this, t)), i;
						}, fixed: c } }, symbolSize: { applyVisual: l("symbolSize"), _doMap: h([0, 1]) } },
			    S = { linear: function linear(t) {
					return v(t, this.option.dataExtent, [0, 1], !0);
				}, piecewise: function piecewise(t) {
					var e = this.option.pieceList,
					    i = b.findPieceIndex(t, e, !0);if (null != i) return v(i, [0, e.length - 1], [0, 1], !0);
				}, category: function category(t) {
					var e = this.option.categories ? this.option.categoryMap[t] : t;return null == e ? _ : e;
				}, fixed: g.noop };b.listVisualTypes = function () {
				var t = [];return g.each(w, function (e, i) {
					t.push(i);
				}), t;
			}, b.addVisualHandler = function (t, e) {
				w[t] = e;
			}, b.isValidType = function (t) {
				return w.hasOwnProperty(t);
			}, b.eachVisual = function (t, e, i) {
				g.isObject(t) ? g.each(t, e, i) : e.call(i, t);
			}, b.mapVisual = function (t, e, i) {
				var n,
				    a = g.isArray(t) ? [] : g.isObject(t) ? {} : (n = !0, null);return b.eachVisual(t, function (t, o) {
					var r = e.call(i, t, o);n ? a = r : a[o] = r;
				}), a;
			}, b.retrieveVisuals = function (t) {
				var e,
				    i = {};return t && y(w, function (n, a) {
					t.hasOwnProperty(a) && (i[a] = t[a], e = !0);
				}), e ? i : null;
			}, b.prepareVisualTypes = function (t) {
				if (x(t)) {
					var e = [];y(t, function (t, i) {
						e.push(i);
					}), t = e;
				} else {
					if (!g.isArray(t)) return [];t = t.slice();
				}return t.sort(function (t, e) {
					return "color" === e && "color" !== t && 0 === t.indexOf("color") ? 1 : -1;
				}), t;
			}, b.dependsOn = function (t, e) {
				return "color" === e ? !(!t || 0 !== t.indexOf(e)) : t === e;
			}, b.findPieceIndex = function (t, e, i) {
				function n(e, i) {
					var n = Math.abs(e - t);n < o && (o = n, a = i);
				}for (var a, o = 1 / 0, r = 0, s = e.length; r < s; r++) {
					var l = e[r].value;if (null != l) {
						if (l === t || "string" == typeof l && l === t + "") return r;i && n(l, r);
					}
				}for (var r = 0, s = e.length; r < s; r++) {
					var u = e[r],
					    c = u.interval,
					    h = u.close;if (c) {
						if (c[0] === -(1 / 0)) {
							if (p(h[1], t, c[1])) return r;
						} else if (c[1] === 1 / 0) {
							if (p(h[0], c[0], t)) return r;
						} else if (p(h[0], c[0], t) && p(h[1], t, c[1])) return r;i && n(c[0], r), i && n(c[1], r);
					}
				}if (i) return t === 1 / 0 ? e.length - 1 : t === -(1 / 0) ? 0 : a;
			}, t.exports = b;
		}, function (t, e) {
			t.exports = function (t, e) {
				var i = {};e.eachRawSeriesByType(t, function (t) {
					var n = t.getRawData(),
					    a = {};if (!e.isSeriesFiltered(t)) {
						var o = t.getData();o.each(function (t) {
							var e = o.getRawIndex(t);a[e] = t;
						}), n.each(function (e) {
							var r = a[e],
							    s = null != r && o.getItemVisual(r, "color", !0);if (s) n.setItemVisual(e, "color", s);else {
								var l = n.getItemModel(e),
								    u = l.get("itemStyle.normal.color") || t.getColorFromPalette(n.getName(e), i);n.setItemVisual(e, "color", u), null != r && o.setItemVisual(r, "color", u);
							}
						});
					}
				});
			};
		}, function (t, e, i) {
			var n = i(6),
			    a = i(20),
			    o = {},
			    r = Math.min,
			    s = Math.max,
			    l = Math.sin,
			    u = Math.cos,
			    c = n.create(),
			    h = n.create(),
			    d = n.create(),
			    f = 2 * Math.PI;o.fromPoints = function (t, e, i) {
				if (0 !== t.length) {
					var n,
					    a = t[0],
					    o = a[0],
					    l = a[0],
					    u = a[1],
					    c = a[1];for (n = 1; n < t.length; n++) {
						a = t[n], o = r(o, a[0]), l = s(l, a[0]), u = r(u, a[1]), c = s(c, a[1]);
					}e[0] = o, e[1] = u, i[0] = l, i[1] = c;
				}
			}, o.fromLine = function (t, e, i, n, a, o) {
				a[0] = r(t, i), a[1] = r(e, n), o[0] = s(t, i), o[1] = s(e, n);
			};var p = [],
			    g = [];o.fromCubic = function (t, e, i, n, o, l, u, c, h, d) {
				var f,
				    m = a.cubicExtrema,
				    v = a.cubicAt,
				    y = m(t, i, o, u, p);for (h[0] = 1 / 0, h[1] = 1 / 0, d[0] = -(1 / 0), d[1] = -(1 / 0), f = 0; f < y; f++) {
					var x = v(t, i, o, u, p[f]);h[0] = r(x, h[0]), d[0] = s(x, d[0]);
				}for (y = m(e, n, l, c, g), f = 0; f < y; f++) {
					var _ = v(e, n, l, c, g[f]);h[1] = r(_, h[1]), d[1] = s(_, d[1]);
				}h[0] = r(t, h[0]), d[0] = s(t, d[0]), h[0] = r(u, h[0]), d[0] = s(u, d[0]), h[1] = r(e, h[1]), d[1] = s(e, d[1]), h[1] = r(c, h[1]), d[1] = s(c, d[1]);
			}, o.fromQuadratic = function (t, e, i, n, o, l, u, c) {
				var h = a.quadraticExtremum,
				    d = a.quadraticAt,
				    f = s(r(h(t, i, o), 1), 0),
				    p = s(r(h(e, n, l), 1), 0),
				    g = d(t, i, o, f),
				    m = d(e, n, l, p);u[0] = r(t, o, g), u[1] = r(e, l, m), c[0] = s(t, o, g), c[1] = s(e, l, m);
			}, o.fromArc = function (t, e, i, a, o, r, s, p, g) {
				var m = n.min,
				    v = n.max,
				    y = Math.abs(o - r);if (y % f < 1e-4 && y > 1e-4) return p[0] = t - i, p[1] = e - a, g[0] = t + i, void (g[1] = e + a);if (c[0] = u(o) * i + t, c[1] = l(o) * a + e, h[0] = u(r) * i + t, h[1] = l(r) * a + e, m(p, c, h), v(g, c, h), o %= f, o < 0 && (o += f), r %= f, r < 0 && (r += f), o > r && !s ? r += f : o < r && s && (o += f), s) {
					var x = r;r = o, o = x;
				}for (var _ = 0; _ < r; _ += Math.PI / 2) {
					_ > o && (d[0] = u(_) * i + t, d[1] = l(_) * a + e, m(p, d, p), v(g, d, g));
				}
			}, t.exports = o;
		}, function (t, e, i) {
			var n = i(38),
			    a = i(1),
			    o = i(16),
			    r = function r(t) {
				n.call(this, t);
			};r.prototype = { constructor: r, type: "text", brush: function brush(t, e) {
					var i = this.style,
					    n = i.x || 0,
					    a = i.y || 0,
					    r = i.text;if (null != r && (r += ""), i.bind(t, this, e), r) {
						this.setTransform(t);var s,
						    l = i.textAlign,
						    u = i.textFont || i.font;if (i.textVerticalAlign) {
							var c = o.getBoundingRect(r, u, i.textAlign, "top");switch (s = "middle", i.textVerticalAlign) {case "middle":
									a -= c.height / 2 - c.lineHeight / 2;break;case "bottom":
									a -= c.height - c.lineHeight / 2;break;default:
									a += c.lineHeight / 2;}
						} else s = i.textBaseline;t.font = u || "12px sans-serif", t.textAlign = l || "left", t.textAlign !== l && (t.textAlign = "left"), t.textBaseline = s || "alphabetic", t.textBaseline !== s && (t.textBaseline = "alphabetic");for (var h = o.measureText("", t.font).width, d = r.split("\n"), f = 0; f < d.length; f++) {
							i.hasStroke() && t.strokeText(d[f], n, a), i.hasFill() && t.fillText(d[f], n, a), a += h;
						}this.restoreTransform(t);
					}
				}, getBoundingRect: function getBoundingRect() {
					var t = this.style;if (!this._rect) {
						var e = t.textVerticalAlign,
						    i = o.getBoundingRect(t.text + "", t.textFont || t.font, t.textAlign, e ? "top" : t.textBaseline);switch (e) {case "middle":
								i.y -= i.height / 2;break;case "bottom":
								i.y -= i.height;}if (i.x += t.x || 0, i.y += t.y || 0, t.hasStroke()) {
							var n = t.lineWidth;i.x -= n / 2, i.y -= n / 2, i.width += n, i.height += n;
						}this._rect = i;
					}return this._rect;
				} }, a.inherits(r, n), t.exports = r;
		}, function (t, e, i) {
			function n(t, e) {
				return "string" == typeof t ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t;
			}var a = i(16),
			    o = i(11),
			    r = new o(),
			    s = function s() {};s.prototype = { constructor: s, drawRectText: function drawRectText(t, e, i) {
					var o = this.style,
					    s = o.text;if (null != s && (s += ""), s) {
						t.save();var l,
						    u,
						    c = o.textPosition,
						    h = o.textOffset,
						    d = o.textDistance,
						    f = o.textAlign,
						    p = o.textFont || o.font,
						    g = o.textBaseline,
						    m = o.textVerticalAlign;i = i || a.getBoundingRect(s, p, f, g);var v = this.transform;if (o.textTransform ? this.setTransform(t) : v && (r.copy(e), r.applyTransform(v), e = r), c instanceof Array) {
							if (l = e.x + n(c[0], e.width), u = e.y + n(c[1], e.height), f = f || "left", g = g || "top", m) {
								switch (m) {case "middle":
										u -= i.height / 2 - i.lineHeight / 2;break;case "bottom":
										u -= i.height - i.lineHeight / 2;break;default:
										u += i.lineHeight / 2;}g = "middle";
							}
						} else {
							var y = a.adjustTextPositionOnRect(c, e, i, d);l = y.x, u = y.y, f = f || y.textAlign, g = g || y.textBaseline;
						}h && (l += h[0], u += h[1]), t.textAlign = f || "left", t.textBaseline = g || "alphabetic";var x = o.textFill,
						    _ = o.textStroke;x && (t.fillStyle = x), _ && (t.strokeStyle = _), t.font = p || "12px sans-serif", t.shadowBlur = o.textShadowBlur, t.shadowColor = o.textShadowColor || "transparent", t.shadowOffsetX = o.textShadowOffsetX, t.shadowOffsetY = o.textShadowOffsetY;var b = s.split("\n");o.textRotation && (v && t.translate(v[4], v[5]), t.rotate(o.textRotation), v && t.translate(-v[4], -v[5]));for (var w = 0; w < b.length; w++) {
							_ && t.strokeText(b[w], l, u), x && t.fillText(b[w], l, u), u += i.lineHeight;
						}t.restore();
					}
				} }, t.exports = s;
		}, function (t, e, i) {
			function n(t) {
				delete f[t];
			} /*!
	    * ZRender, a high performance 2d drawing library.
	    *
	    * Copyright (c) 2013, Baidu Inc.
	    * All rights reserved.
	    *
	    * LICENSE
	    * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	    */
			var a = i(71),
			    o = i(9),
			    r = i(1),
			    s = i(152),
			    l = i(155),
			    u = i(156),
			    c = i(163),
			    h = !o.canvasSupported,
			    d = { canvas: i(154) },
			    f = {},
			    p = {};p.version = "3.5.1", p.init = function (t, e) {
				var i = new g(a(), t, e);return f[i.id] = i, i;
			}, p.dispose = function (t) {
				if (t) t.dispose();else {
					for (var e in f) {
						f.hasOwnProperty(e) && f[e].dispose();
					}f = {};
				}return p;
			}, p.getInstance = function (t) {
				return f[t];
			}, p.registerPainter = function (t, e) {
				d[t] = e;
			};var g = function g(t, e, i) {
				i = i || {}, this.dom = e, this.id = t;var n = this,
				    a = new l(),
				    f = i.renderer;if (h) {
					if (!d.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8");f = "vml";
				} else f && d[f] || (f = "canvas");var p = new d[f](e, a, i);this.storage = a, this.painter = p;var g = o.node ? null : new c(p.getViewportRoot());this.handler = new s(a, p, g, p.root), this.animation = new u({ stage: { update: r.bind(this.flush, this) } }), this.animation.start(), this._needsRefresh;var m = a.delFromStorage,
				    v = a.addToStorage;a.delFromStorage = function (t) {
					m.call(a, t), t && t.removeSelfFromZr(n);
				}, a.addToStorage = function (t) {
					v.call(a, t), t.addSelfToZr(n);
				};
			};g.prototype = { constructor: g, getId: function getId() {
					return this.id;
				}, add: function add(t) {
					this.storage.addRoot(t), this._needsRefresh = !0;
				}, remove: function remove(t) {
					this.storage.delRoot(t), this._needsRefresh = !0;
				}, configLayer: function configLayer(t, e) {
					this.painter.configLayer(t, e), this._needsRefresh = !0;
				}, refreshImmediately: function refreshImmediately() {
					this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1;
				}, refresh: function refresh() {
					this._needsRefresh = !0;
				}, flush: function flush() {
					this._needsRefresh && this.refreshImmediately(), this._needsRefreshHover && this.refreshHoverImmediately();
				}, addHover: function addHover(t, e) {
					this.painter.addHover && (this.painter.addHover(t, e), this.refreshHover());
				}, removeHover: function removeHover(t) {
					this.painter.removeHover && (this.painter.removeHover(t), this.refreshHover());
				}, clearHover: function clearHover() {
					this.painter.clearHover && (this.painter.clearHover(), this.refreshHover());
				}, refreshHover: function refreshHover() {
					this._needsRefreshHover = !0;
				}, refreshHoverImmediately: function refreshHoverImmediately() {
					this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover();
				}, resize: function resize(t) {
					t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize();
				}, clearAnimation: function clearAnimation() {
					this.animation.clear();
				}, getWidth: function getWidth() {
					return this.painter.getWidth();
				}, getHeight: function getHeight() {
					return this.painter.getHeight();
				}, pathToImage: function pathToImage(t, e) {
					return this.painter.pathToImage(t, e);
				}, setCursorStyle: function setCursorStyle(t) {
					this.handler.setCursorStyle(t);
				}, findHover: function findHover(t, e) {
					return this.handler.findHover(t, e);
				}, on: function on(t, e, i) {
					this.handler.on(t, e, i);
				}, off: function off(t, e) {
					this.handler.off(t, e);
				}, trigger: function trigger(t, e) {
					this.handler.trigger(t, e);
				}, clear: function clear() {
					this.storage.delRoot(), this.painter.clear();
				}, dispose: function dispose() {
					this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, n(this.id);
				} }, t.exports = p;
		}, function (t, e, i) {
			var n = i(2),
			    a = i(1);t.exports = function (t, e) {
				a.each(e, function (e) {
					e.update = "updateView", n.registerAction(e, function (i, n) {
						var a = {};return n.eachComponent({ mainType: "series", subType: t, query: i }, function (t) {
							t[e.method] && t[e.method](i.name);var n = t.getData();n.each(function (e) {
								var i = n.getName(e);a[i] = t.isSelected(i) || !1;
							});
						}), { name: i.name, selected: a };
					});
				});
			};
		}, function (t, e, i) {
			"use strict";
			var n = i(17),
			    a = i(28);t.exports = n.extend({ type: "series.__base_bar__", getInitialData: function getInitialData(t, e) {
					return a(t.data, this, e);
				}, getMarkerPosition: function getMarkerPosition(t) {
					var e = this.coordinateSystem;if (e) {
						var i = e.dataToPoint(t, !0),
						    n = this.getData(),
						    a = n.getLayout("offset"),
						    o = n.getLayout("size"),
						    r = e.getBaseAxis().isHorizontal() ? 0 : 1;return i[r] += a + o / 2, i;
					}return [NaN, NaN];
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, barMinHeight: 0, barMinAngle: 0, itemStyle: { normal: {}, emphasis: {} } } });
		}, function (t, e, i) {
			function n(t, e, i, n, a) {
				o.setText(t, e, i), t.text = n, "outside" === t.textPosition && (t.textPosition = a);
			}var a = i(1),
			    o = i(3),
			    r = {};r.setLabel = function (t, e, i, o, r, s, l) {
				var u = i.getModel("label.normal"),
				    c = i.getModel("label.emphasis");u.get("show") ? n(t, u, o, a.retrieve(r.getFormattedLabel(s, "normal"), r.getRawValue(s)), l) : t.text = "", c.get("show") ? n(e, c, o, a.retrieve(r.getFormattedLabel(s, "emphasis"), r.getRawValue(s)), l) : e.text = "";
			}, t.exports = r;
		}, function (t, e, i) {
			var n = i(3),
			    a = i(1),
			    o = i(5),
			    r = {};r.findLabelValueDim = function (t) {
				var e,
				    i = o.otherDimToDataDim(t, "label");if (i.length) e = i[0];else for (var n, a = t.dimensions.slice(); a.length && (e = a.pop(), n = t.getDimensionInfo(e).type, "ordinal" === n || "time" === n);) {}return e;
			}, r.setTextToStyle = function (t, e, i, o, r, s, l) {
				null != i && s.getShallow("show") ? (n.setText(o, s, l), o.text = a.retrieve(r.getFormattedLabel(e, "normal"), t.get(i, e))) : o.text = "";
			}, t.exports = r;
		}, function (t, e, i) {
			function n(t) {
				return isNaN(t[0]) || isNaN(t[1]);
			}function a(t, e, i, a, o, r, g, m, v, y, x) {
				for (var _ = 0, b = i, w = 0; w < a; w++) {
					var S = e[b];if (b >= o || b < 0) break;if (n(S)) {
						if (x) {
							b += r;continue;
						}break;
					}if (b === i) t[r > 0 ? "moveTo" : "lineTo"](S[0], S[1]), h(f, S);else if (v > 0) {
						var M = b + r,
						    I = e[M];if (x) for (; I && n(e[M]);) {
							M += r, I = e[M];
						}var T = .5,
						    A = e[_],
						    I = e[M];if (!I || n(I)) h(p, S);else {
							n(I) && !x && (I = S), s.sub(d, I, A);var C, L;if ("x" === y || "y" === y) {
								var D = "x" === y ? 0 : 1;C = Math.abs(S[D] - A[D]), L = Math.abs(S[D] - I[D]);
							} else C = s.dist(S, A), L = s.dist(S, I);T = L / (L + C), c(p, S, d, -v * (1 - T));
						}l(f, f, m), u(f, f, g), l(p, p, m), u(p, p, g), t.bezierCurveTo(f[0], f[1], p[0], p[1], S[0], S[1]), c(f, S, d, v * T);
					} else t.lineTo(S[0], S[1]);_ = b, b += r;
				}return w;
			}function o(t, e) {
				var i = [1 / 0, 1 / 0],
				    n = [-(1 / 0), -(1 / 0)];if (e) for (var a = 0; a < t.length; a++) {
					var o = t[a];o[0] < i[0] && (i[0] = o[0]), o[1] < i[1] && (i[1] = o[1]), o[0] > n[0] && (n[0] = o[0]), o[1] > n[1] && (n[1] = o[1]);
				}return { min: e ? i : n, max: e ? n : i };
			}var r = i(8),
			    s = i(6),
			    l = s.min,
			    u = s.max,
			    c = s.scaleAndAdd,
			    h = s.copy,
			    d = [],
			    f = [],
			    p = [];t.exports = { Polyline: r.extend({ type: "ec-polyline", shape: { points: [], smooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1 }, style: { fill: null, stroke: "#000" }, buildPath: function buildPath(t, e) {
						var i = e.points,
						    r = 0,
						    s = i.length,
						    l = o(i, e.smoothConstraint);if (e.connectNulls) {
							for (; s > 0 && n(i[s - 1]); s--) {}for (; r < s && n(i[r]); r++) {}
						}for (; r < s;) {
							r += a(t, i, r, s, s, 1, l.min, l.max, e.smooth, e.smoothMonotone, e.connectNulls) + 1;
						}
					} }), Polygon: r.extend({ type: "ec-polygon", shape: { points: [], stackedOnPoints: [], smooth: 0, stackedOnSmooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1 }, buildPath: function buildPath(t, e) {
						var i = e.points,
						    r = e.stackedOnPoints,
						    s = 0,
						    l = i.length,
						    u = e.smoothMonotone,
						    c = o(i, e.smoothConstraint),
						    h = o(r, e.smoothConstraint);if (e.connectNulls) {
							for (; l > 0 && n(i[l - 1]); l--) {}for (; s < l && n(i[s]); s++) {}
						}for (; s < l;) {
							var d = a(t, i, s, l, l, 1, c.min, c.max, e.smooth, u, e.connectNulls);a(t, r, s + d - 1, d, l, -1, h.min, h.max, e.stackedOnSmooth, u, e.connectNulls), s += d + 1, t.closePath();
						}
					} }) };
		}, function (t, e, i) {
			var n = i(1),
			    a = { retrieveTargetInfo: function retrieveTargetInfo(t, e) {
					if (t && ("treemapZoomToNode" === t.type || "treemapRootToNode" === t.type)) {
						var i = e.getData().tree.root,
						    n = t.targetNode;if (n && i.contains(n)) return { node: n };var a = t.targetNodeId;if (null != a && (n = i.getNodeById(a))) return { node: n };
					}
				}, getPathToRoot: function getPathToRoot(t) {
					for (var e = []; t;) {
						t = t.parentNode, t && e.push(t);
					}return e.reverse();
				}, aboveViewRoot: function aboveViewRoot(t, e) {
					var i = a.getPathToRoot(t);return n.indexOf(i, e) >= 0;
				}, wrapTreePathInfo: function wrapTreePathInfo(t, e) {
					for (var i = []; t;) {
						var n = t.dataIndex;i.push({ name: t.name, dataIndex: n, value: e.getRawValue(n) }), t = t.parentNode;
					}return i.reverse(), i;
				} };t.exports = a;
		}, function (t, e, i) {
			function n(t) {
				this.pointerChecker, this._zr = t, this._opt = {};var e = d.bind,
				    i = e(a, this),
				    n = e(o, this),
				    u = e(r, this),
				    c = e(s, this),
				    f = e(l, this);h.call(this), this.setPointerChecker = function (t) {
					this.pointerChecker = t;
				}, this.enable = function (e, a) {
					this.disable(), this._opt = d.defaults(d.clone(a) || {}, { zoomOnMouseWheel: !0, moveOnMouseMove: !0, preventDefaultMouseMove: !0 }), null == e && (e = !0), e !== !0 && "move" !== e && "pan" !== e || (t.on("mousedown", i), t.on("mousemove", n), t.on("mouseup", u)), e !== !0 && "scale" !== e && "zoom" !== e || (t.on("mousewheel", c), t.on("pinch", f));
				}, this.disable = function () {
					t.off("mousedown", i), t.off("mousemove", n), t.off("mouseup", u), t.off("mousewheel", c), t.off("pinch", f);
				}, this.dispose = this.disable, this.isDragging = function () {
					return this._dragging;
				}, this.isPinching = function () {
					return this._pinching;
				};
			}function a(t) {
				if (!t.target || !t.target.draggable) {
					var e = t.offsetX,
					    i = t.offsetY;this.pointerChecker && this.pointerChecker(t, e, i) && (this._x = e, this._y = i, this._dragging = !0);
				}
			}function o(t) {
				if (c(this, "moveOnMouseMove", t) && this._dragging && "pinch" !== t.gestureEvent && !p.isTaken(this._zr, "globalPan")) {
					var e = t.offsetX,
					    i = t.offsetY,
					    n = this._x,
					    a = this._y,
					    o = e - n,
					    r = i - a;this._x = e, this._y = i, this._opt.preventDefaultMouseMove && f.stop(t.event), this.trigger("pan", o, r, n, a, e, i);
				}
			}function r(t) {
				this._dragging = !1;
			}function s(t) {
				if (c(this, "zoomOnMouseWheel", t) && 0 !== t.wheelDelta) {
					var e = t.wheelDelta > 0 ? 1.1 : 1 / 1.1;u.call(this, t, e, t.offsetX, t.offsetY);
				}
			}function l(t) {
				if (!p.isTaken(this._zr, "globalPan")) {
					var e = t.pinchScale > 1 ? 1.1 : 1 / 1.1;u.call(this, t, e, t.pinchX, t.pinchY);
				}
			}function u(t, e, i, n) {
				this.pointerChecker && this.pointerChecker(t, i, n) && (f.stop(t.event), this.trigger("zoom", e, i, n));
			}function c(t, e, i) {
				var n = t._opt[e];return n && (!d.isString(n) || i.event[n + "Key"]);
			}var h = i(23),
			    d = i(1),
			    f = i(21),
			    p = i(129);d.mixin(n, h), t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = { show: !0, zlevel: 0, z: 0, inverse: !1, name: "", nameLocation: "end", nameRotate: null, nameTruncate: { maxWidth: null, ellipsis: "...", placeholder: "." }, nameTextStyle: {}, nameGap: 15, silent: !1, triggerEvent: !1, tooltip: { show: !1 }, axisPointer: {}, axisLine: { show: !0, onZero: !0, lineStyle: { color: "#333", width: 1, type: "solid" } }, axisTick: { show: !0, inside: !1, length: 5, lineStyle: { width: 1 } }, axisLabel: { show: !0, inside: !1, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, textStyle: { fontSize: 12 } }, splitLine: { show: !0, lineStyle: { color: ["#ccc"], width: 1, type: "solid" } }, splitArea: { show: !1, areaStyle: { color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"] } } },
			    o = n.merge({ boundaryGap: !0, splitLine: { show: !1 }, axisTick: { alignWithLabel: !1, interval: "auto" }, axisLabel: { interval: "auto" } }, a),
			    r = n.merge({ boundaryGap: [0, 0], splitNumber: 5 }, a),
			    s = n.defaults({ scale: !0, min: "dataMin", max: "dataMax" }, r),
			    l = n.defaults({ scale: !0, logBase: 10 }, r);t.exports = { categoryAxis: o, valueAxis: r, timeAxis: s, logAxis: l };
		}, function (t, e) {
			t.exports = { containStroke: function containStroke(t, e, i, n, a, o, r) {
					if (0 === a) return !1;var s = a,
					    l = 0,
					    u = t;if (r > e + s && r > n + s || r < e - s && r < n - s || o > t + s && o > i + s || o < t - s && o < i - s) return !1;if (t === i) return Math.abs(o - t) <= s / 2;l = (e - n) / (t - i), u = (t * n - i * e) / (t - i);var c = l * o - r + u,
					    h = c * c / (l * l + 1);return h <= s / 2 * s / 2;
				} };
		}, function (t, e, i) {
			var n = i(20);t.exports = { containStroke: function containStroke(t, e, i, a, o, r, s, l, u) {
					if (0 === s) return !1;var c = s;if (u > e + c && u > a + c && u > r + c || u < e - c && u < a - c && u < r - c || l > t + c && l > i + c && l > o + c || l < t - c && l < i - c && l < o - c) return !1;var h = n.quadraticProjectPoint(t, e, i, a, o, r, l, u, null);return h <= c / 2;
				} };
		}, function (t, e) {
			t.exports = function (t, e, i, n, a, o) {
				if (o > e && o > n || o < e && o < n) return 0;if (n === e) return 0;var r = n < e ? 1 : -1,
				    s = (o - e) / (n - e);1 !== s && 0 !== s || (r = n < e ? .5 : -.5);var l = s * (i - t) + t;return l > a ? r : 0;
			};
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(39),
			    o = function o(t, e, i, n, _o, r) {
				this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == i ? 1 : i, this.y2 = null == n ? 0 : n, this.type = "linear", this.global = r || !1, a.call(this, _o);
			};o.prototype = { constructor: o }, n.inherits(o, a), t.exports = o;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				a.each(o, function (e) {
					this[e] = a.bind(t[e], t);
				}, this);
			}var a = i(1),
			    o = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"];t.exports = n;
		}, function (t, e, i) {
			var n = i(1);i(57), i(103), i(104);var a = i(82),
			    o = i(2);o.registerLayout(n.curry(a, "bar")), o.registerVisual(function (t) {
				t.eachSeriesByType("bar", function (t) {
					var e = t.getData();e.setVisual("legendSymbol", "roundRect");
				});
			}), i(32);
		}, function (t, e, i) {
			t.exports = i(90).extend({ type: "series.bar", dependencies: ["grid", "polar"], brushSelector: "rect" });
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				i.style.text = "", l.updateProps(i, { shape: { width: 0 } }, e, t, function () {
					i.parent && i.parent.remove(i);
				});
			}function a(t, e, i) {
				i.style.text = "", l.updateProps(i, { shape: { r: i.shape.r0 } }, e, t, function () {
					i.parent && i.parent.remove(i);
				});
			}function o(t, e, i, n, a, o, r, c) {
				var h = e.getItemVisual(i, "color"),
				    d = e.getItemVisual(i, "opacity"),
				    f = n.getModel("itemStyle.normal"),
				    p = n.getModel("itemStyle.emphasis").getBarItemStyle();!c && r && t.setShape("r", f.get("barBorderRadius") || 0), t.useStyle(s.defaults({ fill: h, opacity: d }, f.getBarItemStyle()));var g = r ? a.height > 0 ? "bottom" : "top" : a.width > 0 ? "left" : "right";c || u.setLabel(t.style, p, n, h, o, i, g), l.setHoverStyle(t, p);
			}function r(t, e) {
				var i = t.get(c) || 0;return Math.min(i, Math.abs(e.width), Math.abs(e.height));
			}var s = i(1),
			    l = i(3),
			    u = i(91),
			    c = ["itemStyle", "normal", "barBorderWidth"];s.extend(i(10).prototype, i(105));var h = i(2).extendChartView({ type: "bar", render: function render(t, e, i) {
					var n = t.get("coordinateSystem");return "cartesian2d" !== n && "polar" !== n || this._render(t, e, i), this.group;
				}, dispose: s.noop, _render: function _render(t, e, i) {
					var r,
					    s = this.group,
					    u = t.getData(),
					    c = this._data,
					    h = t.coordinateSystem,
					    p = h.getBaseAxis();"cartesian2d" === h.type ? r = p.isHorizontal() : "polar" === h.type && (r = "angle" === p.dim);var g = t.isAnimationEnabled() ? t : null;u.diff(c).add(function (e) {
						if (u.hasValue(e)) {
							var i = u.getItemModel(e),
							    n = f[h.type](u, e, i),
							    a = d[h.type](u, e, i, n, r, g);u.setItemGraphicEl(e, a), s.add(a), o(a, u, e, i, n, t, r, "polar" === h.type);
						}
					}).update(function (e, i) {
						var n = c.getItemGraphicEl(i);if (!u.hasValue(e)) return void s.remove(n);var a = u.getItemModel(e),
						    p = f[h.type](u, e, a);n ? l.updateProps(n, { shape: p }, g, e) : n = d[h.type](u, e, a, p, r, g, !0), u.setItemGraphicEl(e, n), s.add(n), o(n, u, e, a, p, t, r, "polar" === h.type);
					}).remove(function (t) {
						var e = c.getItemGraphicEl(t);"cartesian2d" === h.type ? e && n(t, g, e) : e && a(t, g, e);
					}).execute(), this._data = u;
				}, remove: function remove(t, e) {
					var i = this.group,
					    o = this._data;t.get("animation") ? o && o.eachItemGraphicEl(function (e) {
						"sector" === e.type ? a(e.dataIndex, t, e) : n(e.dataIndex, t, e);
					}) : i.removeAll();
				} }),
			    d = { cartesian2d: function cartesian2d(t, e, i, n, a, o, r) {
					var u = new l.Rect({ shape: s.extend({}, n) });if (o) {
						var c = u.shape,
						    h = a ? "height" : "width",
						    d = {};c[h] = 0, d[h] = n[h], l[r ? "updateProps" : "initProps"](u, { shape: d }, o, e);
					}return u;
				}, polar: function polar(t, e, i, n, a, o, r) {
					var u = new l.Sector({ shape: s.extend({}, n) });if (o) {
						var c = u.shape,
						    h = a ? "r" : "endAngle",
						    d = {};c[h] = a ? 0 : n.startAngle, d[h] = n[h], l[r ? "updateProps" : "initProps"](u, { shape: d }, o, e);
					}return u;
				} },
			    f = { cartesian2d: function cartesian2d(t, e, i) {
					var n = t.getItemLayout(e),
					    a = r(i, n),
					    o = n.width > 0 ? 1 : -1,
					    s = n.height > 0 ? 1 : -1;return { x: n.x + o * a / 2, y: n.y + s * a / 2, width: n.width - o * a, height: n.height - s * a };
				}, polar: function polar(t, e, i) {
					var n = t.getItemLayout(e);return { cx: n.cx, cy: n.cy, r0: n.r0, r: n.r, startAngle: n.startAngle, endAngle: n.endAngle };
				} };t.exports = h;
		}, function (t, e, i) {
			var n = i(31)([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["stroke", "barBorderColor"], ["lineWidth", "barBorderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);t.exports = { getBarItemStyle: function getBarItemStyle(t) {
					var e = n.call(this, t);if (this.getBorderLineDash) {
						var i = this.getBorderLineDash();i && (e.lineDash = i);
					}return e;
				} };
		}, function (t, e, i) {
			function n(t) {
				return "_" + t + "Type";
			}function a(t, e, i) {
				var n = e.getItemVisual(i, "color"),
				    a = e.getItemVisual(i, t),
				    o = e.getItemVisual(i, t + "Size");if (a && "none" !== a) {
					f.isArray(o) || (o = [o, o]);var r = u.createSymbol(a, -o[0] / 2, -o[1] / 2, o[0], o[1], n);return r.name = t, r;
				}
			}function o(t) {
				var e = new h({ name: "line" });return r(e.shape, t), e;
			}function r(t, e) {
				var i = e[0],
				    n = e[1],
				    a = e[2];t.x1 = i[0], t.y1 = i[1], t.x2 = n[0], t.y2 = n[1], t.percent = 1, a ? (t.cpx1 = a[0], t.cpy1 = a[1]) : (t.cpx1 = NaN, t.cpy1 = NaN);
			}function s() {
				var t = this,
				    e = t.childOfName("fromSymbol"),
				    i = t.childOfName("toSymbol"),
				    n = t.childOfName("label");if (e || i || !n.ignore) {
					for (var a = 1, o = this.parent; o;) {
						o.scale && (a /= o.scale[0]), o = o.parent;
					}var r = t.childOfName("line");if (this.__dirty || r.__dirty) {
						var s = r.shape.percent,
						    l = r.pointAt(0),
						    u = r.pointAt(s),
						    h = c.sub([], u, l);if (c.normalize(h, h), e) {
							e.attr("position", l);var d = r.tangentAt(0);e.attr("rotation", Math.PI / 2 - Math.atan2(d[1], d[0])), e.attr("scale", [a * s, a * s]);
						}if (i) {
							i.attr("position", u);var d = r.tangentAt(1);i.attr("rotation", -Math.PI / 2 - Math.atan2(d[1], d[0])), i.attr("scale", [a * s, a * s]);
						}if (!n.ignore) {
							n.attr("position", u);var f,
							    p,
							    g,
							    m = 5 * a;if ("end" === n.__position) f = [h[0] * m + u[0], h[1] * m + u[1]], p = h[0] > .8 ? "left" : h[0] < -.8 ? "right" : "center", g = h[1] > .8 ? "top" : h[1] < -.8 ? "bottom" : "middle";else if ("middle" === n.__position) {
								var v = s / 2,
								    d = r.tangentAt(v),
								    y = [d[1], -d[0]],
								    x = r.pointAt(v);y[1] > 0 && (y[0] = -y[0], y[1] = -y[1]), f = [x[0] + y[0] * m, x[1] + y[1] * m], p = "center", g = "bottom";var _ = -Math.atan2(d[1], d[0]);u[0] < l[0] && (_ = Math.PI + _), n.attr("rotation", _);
							} else f = [-h[0] * m + l[0], -h[1] * m + l[1]], p = h[0] > .8 ? "right" : h[0] < -.8 ? "left" : "center", g = h[1] > .8 ? "bottom" : h[1] < -.8 ? "top" : "middle";n.attr({ style: { textVerticalAlign: n.__verticalAlign || g, textAlign: n.__textAlign || p }, position: f, scale: [a, a] });
						}
					}
				}
			}function l(t, e, i) {
				d.Group.call(this), this._createLine(t, e, i);
			}var u = i(24),
			    c = i(6),
			    h = i(190),
			    d = i(3),
			    f = i(1),
			    p = i(4),
			    g = ["fromSymbol", "toSymbol"],
			    m = l.prototype;m.beforeUpdate = s, m._createLine = function (t, e, i) {
				var r = t.hostModel,
				    s = t.getItemLayout(e),
				    l = o(s);l.shape.percent = 0, d.initProps(l, { shape: { percent: 1 } }, r, e), this.add(l);var u = new d.Text({ name: "label" });this.add(u), f.each(g, function (i) {
					var o = a(i, t, e);this.add(o), this[n(i)] = t.getItemVisual(e, i);
				}, this), this._updateCommonStl(t, e, i);
			}, m.updateData = function (t, e, i) {
				var o = t.hostModel,
				    s = this.childOfName("line"),
				    l = t.getItemLayout(e),
				    u = { shape: {} };r(u.shape, l), d.updateProps(s, u, o, e), f.each(g, function (i) {
					var o = t.getItemVisual(e, i),
					    r = n(i);if (this[r] !== o) {
						this.remove(this.childOfName(i));var s = a(i, t, e);this.add(s);
					}this[r] = o;
				}, this), this._updateCommonStl(t, e, i);
			}, m._updateCommonStl = function (t, e, i) {
				var n = t.hostModel,
				    a = this.childOfName("line"),
				    o = i && i.lineStyle,
				    r = i && i.hoverLineStyle,
				    s = i && i.labelModel,
				    l = i && i.hoverLabelModel;if (!i || t.hasItemOption) {
					var u = t.getItemModel(e);o = u.getModel("lineStyle.normal").getLineStyle(), r = u.getModel("lineStyle.emphasis").getLineStyle(), s = u.getModel("label.normal"), l = u.getModel("label.emphasis");
				}var c = t.getItemVisual(e, "color"),
				    h = f.retrieve(t.getItemVisual(e, "opacity"), o.opacity, 1);a.useStyle(f.defaults({ strokeNoScale: !0, fill: "none", stroke: c, opacity: h }, o)), a.hoverStyle = r, f.each(g, function (t) {
					var e = this.childOfName(t);e && (e.setColor(c), e.setStyle({ opacity: h }));
				}, this);var m,
				    v,
				    y = s.getShallow("show"),
				    x = l.getShallow("show"),
				    _ = this.childOfName("label");if (y || x) {
					var b = n.getRawValue(e);v = null == b ? v = t.getName(e) : isFinite(b) ? p.round(b) : b, m = c || "#000";
				}if (y) {
					var w = s.getModel("textStyle");_.setStyle({ text: f.retrieve(n.getFormattedLabel(e, "normal", t.dataType), v), textFont: w.getFont(), fill: w.getTextColor() || m }), _.__textAlign = w.get("align"), _.__verticalAlign = w.get("baseline"), _.__position = s.get("position");
				} else _.setStyle("text", "");if (x) {
					var S = l.getModel("textStyle");_.hoverStyle = { text: f.retrieve(n.getFormattedLabel(e, "emphasis", t.dataType), v), textFont: S.getFont(), fill: S.getTextColor() || m };
				} else _.hoverStyle = { text: "" };_.ignore = !y && !x, d.setHoverStyle(this);
			}, m.updateLayout = function (t, e) {
				this.setLinePoints(t.getItemLayout(e));
			}, m.setLinePoints = function (t) {
				var e = this.childOfName("line");r(e.shape, t), e.dirty();
			}, f.inherits(l, d.Group), t.exports = l;
		}, function (t, e, i) {
			function n(t) {
				return isNaN(t[0]) || isNaN(t[1]);
			}function a(t) {
				return !n(t[0]) && !n(t[1]);
			}function o(t) {
				this._ctor = t || s, this.group = new r.Group();
			}var r = i(3),
			    s = i(106),
			    l = o.prototype;l.updateData = function (t) {
				var e = this._lineData,
				    i = this.group,
				    n = this._ctor,
				    o = t.hostModel,
				    r = { lineStyle: o.getModel("lineStyle.normal").getLineStyle(), hoverLineStyle: o.getModel("lineStyle.emphasis").getLineStyle(), labelModel: o.getModel("label.normal"), hoverLabelModel: o.getModel("label.emphasis") };t.diff(e).add(function (e) {
					if (a(t.getItemLayout(e))) {
						var o = new n(t, e, r);t.setItemGraphicEl(e, o), i.add(o);
					}
				}).update(function (o, s) {
					var l = e.getItemGraphicEl(s);return a(t.getItemLayout(o)) ? (l ? l.updateData(t, o, r) : l = new n(t, o, r), t.setItemGraphicEl(o, l), void i.add(l)) : void i.remove(l);
				}).remove(function (t) {
					i.remove(e.getItemGraphicEl(t));
				}).execute(), this._lineData = t;
			}, l.updateLayout = function () {
				var t = this._lineData;t.eachItemGraphicEl(function (e, i) {
					e.updateLayout(t, i);
				}, this);
			}, l.remove = function () {
				this.group.removeAll();
			}, t.exports = o;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(2),
			    o = a.PRIORITY;i(109), i(110), a.registerVisual(n.curry(i(50), "line", "circle", "line")), a.registerLayout(n.curry(i(61), "line")), a.registerProcessor(o.PROCESSOR.STATISTIC, n.curry(i(147), "line")), i(32);
		}, function (t, e, i) {
			"use strict";
			var n = i(28),
			    a = i(17);t.exports = a.extend({ type: "series.line", dependencies: ["grid", "polar"], getInitialData: function getInitialData(t, e) {
					return n(t.data, this, e);
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, hoverAnimation: !0, clipOverflow: !0, label: { normal: { position: "top" } }, lineStyle: { normal: { width: 2, type: "solid" } }, step: !1, smooth: !1, smoothMonotone: null, symbol: "emptyCircle", symbolSize: 4, symbolRotate: null, showSymbol: !0, showAllSymbol: !1, connectNulls: !1, sampling: "none", animationEasing: "linear", progressive: 0, hoverLayerThreshold: 1 / 0 } });
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				if (t.length === e.length) {
					for (var i = 0; i < t.length; i++) {
						var n = t[i],
						    a = e[i];if (n[0] !== a[0] || n[1] !== a[1]) return;
					}return !0;
				}
			}function a(t) {
				return "number" == typeof t ? t : t ? .3 : 0;
			}function o(t) {
				var e = t.getGlobalExtent();if (t.onBand) {
					var i = t.getBandWidth() / 2 - 1,
					    n = e[1] > e[0] ? 1 : -1;e[0] += n * i, e[1] -= n * i;
				}return e;
			}function r(t) {
				return t >= 0 ? 1 : -1;
			}function s(t, e) {
				var i = t.getBaseAxis(),
				    n = t.getOtherAxis(i),
				    a = i.onZero ? 0 : n.scale.getExtent()[0],
				    o = n.dim,
				    s = "x" === o || "radius" === o ? 1 : 0;return e.mapArray([o], function (n, l) {
					for (var u, c = e.stackedOn; c && r(c.get(o, l)) === r(n);) {
						u = c;break;
					}var h = [];return h[s] = e.get(i.dim, l), h[1 - s] = u ? u.get(o, l, !0) : a, t.dataToPoint(h);
				}, !0);
			}function l(t, e, i) {
				var n = o(t.getAxis("x")),
				    a = o(t.getAxis("y")),
				    r = t.getBaseAxis().isHorizontal(),
				    s = Math.min(n[0], n[1]),
				    l = Math.min(a[0], a[1]),
				    u = Math.max(n[0], n[1]) - s,
				    c = Math.max(a[0], a[1]) - l,
				    h = i.get("lineStyle.normal.width") || 2,
				    d = i.get("clipOverflow") ? h / 2 : Math.max(u, c);r ? (l -= d, c += 2 * d) : (s -= d, u += 2 * d);var f = new v.Rect({ shape: { x: s, y: l, width: u, height: c } });return e && (f.shape[r ? "width" : "height"] = 0, v.initProps(f, { shape: { width: u, height: c } }, i)), f;
			}function u(t, e, i) {
				var n = t.getAngleAxis(),
				    a = t.getRadiusAxis(),
				    o = a.getExtent(),
				    r = n.getExtent(),
				    s = Math.PI / 180,
				    l = new v.Sector({ shape: { cx: t.cx, cy: t.cy, r0: o[0], r: o[1], startAngle: -r[0] * s, endAngle: -r[1] * s, clockwise: n.inverse } });return e && (l.shape.endAngle = -r[0] * s, v.initProps(l, { shape: { endAngle: -r[1] * s } }, i)), l;
			}function c(t, e, i) {
				return "polar" === t.type ? u(t, e, i) : l(t, e, i);
			}function h(t, e, i) {
				for (var n = e.getBaseAxis(), a = "x" === n.dim || "radius" === n.dim ? 0 : 1, o = [], r = 0; r < t.length - 1; r++) {
					var s = t[r + 1],
					    l = t[r];o.push(l);var u = [];switch (i) {case "end":
							u[a] = s[a], u[1 - a] = l[1 - a], o.push(u);break;case "middle":
							var c = (l[a] + s[a]) / 2,
							    h = [];u[a] = h[a] = c, u[1 - a] = l[1 - a], h[1 - a] = s[1 - a], o.push(u), o.push(h);break;default:
							u[a] = l[a], u[1 - a] = s[1 - a], o.push(u);}
				}return t[r] && o.push(t[r]), o;
			}function d(t, e) {
				var i = t.getVisual("visualMeta");if (i && i.length && t.count()) {
					for (var n, a = i.length - 1; a >= 0; a--) {
						if (i[a].dimension < 2) {
							n = i[a];break;
						}
					}if (n && "cartesian2d" === e.type) {
						var o = n.dimension,
						    r = t.dimensions[o],
						    s = e.getAxis(r),
						    l = f.map(n.stops, function (t) {
							return { coord: s.toGlobalCoord(s.dataToCoord(t.value)), color: t.color };
						}),
						    u = l.length,
						    c = n.outerColors.slice();u && l[0].coord > l[u - 1].coord && (l.reverse(), c.reverse());var h = 10,
						    d = l[0].coord - h,
						    p = l[u - 1].coord + h,
						    g = p - d;if (g < .001) return "transparent";f.each(l, function (t) {
							t.offset = (t.coord - d) / g;
						}), l.push({ offset: u ? l[u - 1].offset : .5, color: c[1] || "transparent" }), l.unshift({ offset: u ? l[0].offset : .5, color: c[0] || "transparent" });var m = new v.LinearGradient(0, 0, 0, 0, l, !0);return m[r] = d, m[r + "2"] = p, m;
					}
				}
			}var f = i(1),
			    p = i(44),
			    g = i(54),
			    m = i(111),
			    v = i(3),
			    y = i(5),
			    x = i(93),
			    _ = i(30);t.exports = _.extend({ type: "line", init: function init() {
					var t = new v.Group(),
					    e = new p();this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t;
				}, render: function render(t, e, i) {
					var o = t.coordinateSystem,
					    r = this.group,
					    l = t.getData(),
					    u = t.getModel("lineStyle.normal"),
					    p = t.getModel("areaStyle.normal"),
					    g = l.mapArray(l.getItemLayout, !0),
					    m = "polar" === o.type,
					    v = this._coordSys,
					    y = this._symbolDraw,
					    x = this._polyline,
					    _ = this._polygon,
					    b = this._lineGroup,
					    w = t.get("animation"),
					    S = !p.isEmpty(),
					    M = s(o, l),
					    I = t.get("showSymbol"),
					    T = I && !m && !t.get("showAllSymbol") && this._getSymbolIgnoreFunc(l, o),
					    A = this._data;A && A.eachItemGraphicEl(function (t, e) {
						t.__temp && (r.remove(t), A.setItemGraphicEl(e, null));
					}), I || y.remove(), r.add(b);var C = !m && t.get("step");x && v.type === o.type && C === this._step ? (S && !_ ? _ = this._newPolygon(g, M, o, w) : _ && !S && (b.remove(_), _ = this._polygon = null), b.setClipPath(c(o, !1, t)), I && y.updateData(l, T), l.eachItemGraphicEl(function (t) {
						t.stopAnimation(!0);
					}), n(this._stackedOnPoints, M) && n(this._points, g) || (w ? this._updateAnimation(l, M, o, i, C) : (C && (g = h(g, o, C), M = h(M, o, C)), x.setShape({ points: g }), _ && _.setShape({ points: g, stackedOnPoints: M })))) : (I && y.updateData(l, T), C && (g = h(g, o, C), M = h(M, o, C)), x = this._newPolyline(g, o, w), S && (_ = this._newPolygon(g, M, o, w)), b.setClipPath(c(o, !0, t)));var L = d(l, o) || l.getVisual("color");x.useStyle(f.defaults(u.getLineStyle(), { fill: "none", stroke: L, lineJoin: "bevel" }));var D = t.get("smooth");if (D = a(t.get("smooth")), x.setShape({ smooth: D, smoothMonotone: t.get("smoothMonotone"), connectNulls: t.get("connectNulls") }), _) {
						var P = l.stackedOn,
						    k = 0;if (_.useStyle(f.defaults(p.getAreaStyle(), { fill: L, opacity: .7, lineJoin: "bevel" })), P) {
							var O = P.hostModel;k = a(O.get("smooth"));
						}_.setShape({ smooth: D, stackedOnSmooth: k, smoothMonotone: t.get("smoothMonotone"), connectNulls: t.get("connectNulls") });
					}this._data = l, this._coordSys = o, this._stackedOnPoints = M, this._points = g, this._step = C;
				}, dispose: function dispose() {}, highlight: function highlight(t, e, i, n) {
					var a = t.getData(),
					    o = y.queryDataIndex(a, n);if (!(o instanceof Array) && null != o && o >= 0) {
						var r = a.getItemGraphicEl(o);if (!r) {
							var s = a.getItemLayout(o);if (!s) return;r = new g(a, o), r.position = s, r.setZ(t.get("zlevel"), t.get("z")), r.ignore = isNaN(s[0]) || isNaN(s[1]), r.__temp = !0, a.setItemGraphicEl(o, r), r.stopSymbolAnimation(!0), this.group.add(r);
						}r.highlight();
					} else _.prototype.highlight.call(this, t, e, i, n);
				}, downplay: function downplay(t, e, i, n) {
					var a = t.getData(),
					    o = y.queryDataIndex(a, n);if (null != o && o >= 0) {
						var r = a.getItemGraphicEl(o);r && (r.__temp ? (a.setItemGraphicEl(o, null), this.group.remove(r)) : r.downplay());
					} else _.prototype.downplay.call(this, t, e, i, n);
				}, _newPolyline: function _newPolyline(t) {
					var e = this._polyline;return e && this._lineGroup.remove(e), e = new x.Polyline({ shape: { points: t }, silent: !0, z2: 10 }), this._lineGroup.add(e), this._polyline = e, e;
				}, _newPolygon: function _newPolygon(t, e) {
					var i = this._polygon;return i && this._lineGroup.remove(i), i = new x.Polygon({ shape: { points: t, stackedOnPoints: e }, silent: !0 }), this._lineGroup.add(i), this._polygon = i, i;
				}, _getSymbolIgnoreFunc: function _getSymbolIgnoreFunc(t, e) {
					var i = e.getAxesByScale("ordinal")[0];if (i && i.isLabelIgnored) return f.bind(i.isLabelIgnored, i);
				}, _updateAnimation: function _updateAnimation(t, e, i, n, a) {
					var o = this._polyline,
					    r = this._polygon,
					    s = t.hostModel,
					    l = m(this._data, t, this._stackedOnPoints, e, this._coordSys, i),
					    u = l.current,
					    c = l.stackedOnCurrent,
					    d = l.next,
					    f = l.stackedOnNext;a && (u = h(l.current, i, a), c = h(l.stackedOnCurrent, i, a), d = h(l.next, i, a), f = h(l.stackedOnNext, i, a)), o.shape.__points = l.current, o.shape.points = u, v.updateProps(o, { shape: { points: d } }, s), r && (r.setShape({ points: u, stackedOnPoints: c }), v.updateProps(r, { shape: { points: d, stackedOnPoints: f } }, s));for (var p = [], g = l.status, y = 0; y < g.length; y++) {
						var x = g[y].cmd;if ("=" === x) {
							var _ = t.getItemGraphicEl(g[y].idx1);_ && p.push({ el: _, ptIdx: y });
						}
					}o.animators && o.animators.length && o.animators[0].during(function () {
						for (var t = 0; t < p.length; t++) {
							var e = p[t].el;e.attr("position", o.shape.__points[p[t].ptIdx]);
						}
					});
				}, remove: function remove(t) {
					var e = this.group,
					    i = this._data;this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function (t, n) {
						t.__temp && (e.remove(t), i.setItemGraphicEl(n, null));
					}), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
				} });
		}, function (t, e) {
			function i(t) {
				return t >= 0 ? 1 : -1;
			}function n(t, e, n) {
				for (var a, o = t.getBaseAxis(), r = t.getOtherAxis(o), s = o.onZero ? 0 : r.scale.getExtent()[0], l = r.dim, u = "x" === l || "radius" === l ? 1 : 0, c = e.stackedOn, h = e.get(l, n); c && i(c.get(l, n)) === i(h);) {
					a = c;break;
				}var d = [];return d[u] = e.get(o.dim, n), d[1 - u] = a ? a.get(l, n, !0) : s, t.dataToPoint(d);
			}function a(t, e) {
				var i = [];return e.diff(t).add(function (t) {
					i.push({ cmd: "+", idx: t });
				}).update(function (t, e) {
					i.push({ cmd: "=", idx: e, idx1: t });
				}).remove(function (t) {
					i.push({ cmd: "-", idx: t });
				}).execute(), i;
			}t.exports = function (t, e, i, o, r, s) {
				for (var l = a(t, e), u = [], c = [], h = [], d = [], f = [], p = [], g = [], m = s.dimensions, v = 0; v < l.length; v++) {
					var y = l[v],
					    x = !0;switch (y.cmd) {case "=":
							var _ = t.getItemLayout(y.idx),
							    b = e.getItemLayout(y.idx1);(isNaN(_[0]) || isNaN(_[1])) && (_ = b.slice()), u.push(_), c.push(b), h.push(i[y.idx]), d.push(o[y.idx1]), g.push(e.getRawIndex(y.idx1));break;case "+":
							var w = y.idx;u.push(r.dataToPoint([e.get(m[0], w, !0), e.get(m[1], w, !0)])), c.push(e.getItemLayout(w).slice()), h.push(n(r, e, w)), d.push(o[w]), g.push(e.getRawIndex(w));break;case "-":
							var w = y.idx,
							    S = t.getRawIndex(w);S !== w ? (u.push(t.getItemLayout(w)), c.push(s.dataToPoint([t.get(m[0], w, !0), t.get(m[1], w, !0)])), h.push(i[w]), d.push(n(s, t, w)), g.push(S)) : x = !1;}x && (f.push(y), p.push(p.length));
				}p.sort(function (t, e) {
					return g[t] - g[e];
				});for (var M = [], I = [], T = [], A = [], C = [], v = 0; v < p.length; v++) {
					var w = p[v];M[v] = u[w], I[v] = c[w], T[v] = h[w], A[v] = d[w], C[v] = f[w];
				}return { current: M, next: I, stackedOnCurrent: T, stackedOnNext: A, status: C };
			};
		}, function (t, e, i) {
			var n = i(1),
			    a = i(2);i(113), i(114), i(89)("pie", [{ type: "pieToggleSelect", event: "pieselectchanged", method: "toggleSelected" }, { type: "pieSelect", event: "pieselected", method: "select" }, { type: "pieUnSelect", event: "pieunselected", method: "unSelect" }]), a.registerVisual(n.curry(i(84), "pie")), a.registerLayout(n.curry(i(116), "pie")), a.registerProcessor(n.curry(i(63), "pie"));
		}, function (t, e, i) {
			"use strict";
			var n = i(14),
			    a = i(1),
			    o = i(5),
			    r = i(25),
			    s = i(78),
			    l = i(2).extendSeriesModel({ type: "series.pie", init: function init(t) {
					l.superApply(this, "init", arguments), this.legendDataProvider = function () {
						return this.getRawData();
					}, this.updateSelectedMap(t.data), this._defaultLabelLine(t);
				}, mergeOption: function mergeOption(t) {
					l.superCall(this, "mergeOption", t), this.updateSelectedMap(this.option.data);
				}, getInitialData: function getInitialData(t, e) {
					var i = r(["value"], t.data),
					    a = new n(i, this);return a.initData(t.data), a;
				}, getDataParams: function getDataParams(t) {
					var e = this.getData(),
					    i = l.superCall(this, "getDataParams", t),
					    n = e.getSum("value");return i.percent = n ? +(e.get("value", t) / n * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
				}, _defaultLabelLine: function _defaultLabelLine(t) {
					o.defaultEmphasis(t.labelLine, ["show"]);var e = t.labelLine.normal,
					    i = t.labelLine.emphasis;e.show = e.show && t.label.normal.show, i.show = i.show && t.label.emphasis.show;
				}, defaultOption: { zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, center: ["50%", "50%"], radius: [0, "75%"], clockwise: !0, startAngle: 90, minAngle: 0, selectedOffset: 10, avoidLabelOverlap: !0, stillShowZeroSum: !0, label: { normal: { rotate: !1, show: !0, position: "outer" }, emphasis: {} }, labelLine: { normal: { show: !0, length: 15, length2: 15, smooth: !1, lineStyle: { width: 1, type: "solid" } } }, itemStyle: { normal: { borderWidth: 1 }, emphasis: {} }, animationType: "expansion", animationEasing: "cubicOut", data: [] } });a.mixin(l, s), t.exports = l;
		}, function (t, e, i) {
			function n(t, e, i, n) {
				var o = e.getData(),
				    r = this.dataIndex,
				    s = o.getName(r),
				    l = e.get("selectedOffset");n.dispatchAction({ type: "pieToggleSelect", from: t, name: s, seriesId: e.id }), o.each(function (t) {
					a(o.getItemGraphicEl(t), o.getItemLayout(t), e.isSelected(o.getName(t)), l, i);
				});
			}function a(t, e, i, n, a) {
				var o = (e.startAngle + e.endAngle) / 2,
				    r = Math.cos(o),
				    s = Math.sin(o),
				    l = i ? n : 0,
				    u = [r * l, s * l];a ? t.animate().when(200, { position: u }).start("bounceOut") : t.attr("position", u);
			}function o(t, e) {
				function i() {
					o.ignore = o.hoverIgnore, r.ignore = r.hoverIgnore;
				}function n() {
					o.ignore = o.normalIgnore, r.ignore = r.normalIgnore;
				}s.Group.call(this);var a = new s.Sector({ z2: 2 }),
				    o = new s.Polyline(),
				    r = new s.Text();this.add(a), this.add(o), this.add(r), this.updateData(t, e, !0), this.on("emphasis", i).on("normal", n).on("mouseover", i).on("mouseout", n);
			}function r(t, e, i, n, a) {
				var o = n.getModel("textStyle"),
				    r = "inside" === a || "inner" === a;return { fill: o.getTextColor() || (r ? "#fff" : t.getItemVisual(e, "color")), opacity: t.getItemVisual(e, "opacity"), textFont: o.getFont(), text: l.retrieve(t.hostModel.getFormattedLabel(e, i), t.getName(e)) };
			}var s = i(3),
			    l = i(1),
			    u = o.prototype;u.updateData = function (t, e, i) {
				function n() {
					r.stopAnimation(!0), r.animateTo({ shape: { r: h.r + 10 } }, 300, "elasticOut");
				}function o() {
					r.stopAnimation(!0), r.animateTo({ shape: { r: h.r } }, 300, "elasticOut");
				}var r = this.childAt(0),
				    u = t.hostModel,
				    c = t.getItemModel(e),
				    h = t.getItemLayout(e),
				    d = l.extend({}, h);if (d.label = null, i) {
					r.setShape(d);var f = u.getShallow("animationType");"scale" === f ? (r.shape.r = h.r0, s.initProps(r, { shape: { r: h.r } }, u, e)) : (r.shape.endAngle = h.startAngle, s.updateProps(r, {
						shape: { endAngle: h.endAngle } }, u, e));
				} else s.updateProps(r, { shape: d }, u, e);var p = c.getModel("itemStyle"),
				    g = t.getItemVisual(e, "color");r.useStyle(l.defaults({ lineJoin: "bevel", fill: g }, p.getModel("normal").getItemStyle())), r.hoverStyle = p.getModel("emphasis").getItemStyle(), a(this, t.getItemLayout(e), c.get("selected"), u.get("selectedOffset"), u.get("animation")), r.off("mouseover").off("mouseout").off("emphasis").off("normal"), c.get("hoverAnimation") && u.isAnimationEnabled() && r.on("mouseover", n).on("mouseout", o).on("emphasis", n).on("normal", o), this._updateLabel(t, e), s.setHoverStyle(this);
			}, u._updateLabel = function (t, e) {
				var i = this.childAt(1),
				    n = this.childAt(2),
				    a = t.hostModel,
				    o = t.getItemModel(e),
				    l = t.getItemLayout(e),
				    u = l.label,
				    c = t.getItemVisual(e, "color");s.updateProps(i, { shape: { points: u.linePoints || [[u.x, u.y], [u.x, u.y], [u.x, u.y]] } }, a, e), s.updateProps(n, { style: { x: u.x, y: u.y } }, a, e), n.attr({ style: { textVerticalAlign: u.verticalAlign, textAlign: u.textAlign, textFont: u.font }, rotation: u.rotation, origin: [u.x, u.y], z2: 10 });var h = o.getModel("label.normal"),
				    d = o.getModel("label.emphasis"),
				    f = o.getModel("labelLine.normal"),
				    p = o.getModel("labelLine.emphasis"),
				    g = h.get("position") || d.get("position");n.setStyle(r(t, e, "normal", h, g)), n.ignore = n.normalIgnore = !h.get("show"), n.hoverIgnore = !d.get("show"), i.ignore = i.normalIgnore = !f.get("show"), i.hoverIgnore = !p.get("show"), i.setStyle({ stroke: c, opacity: t.getItemVisual(e, "opacity") }), i.setStyle(f.getModel("lineStyle").getLineStyle()), n.hoverStyle = r(t, e, "emphasis", d, g), i.hoverStyle = p.getModel("lineStyle").getLineStyle();var m = f.get("smooth");m && m === !0 && (m = .4), i.setShape({ smooth: m });
			}, l.inherits(o, s.Group);var c = i(30).extend({ type: "pie", init: function init() {
					var t = new s.Group();this._sectorGroup = t;
				}, render: function render(t, e, i, a) {
					if (!a || a.from !== this.uid) {
						var r = t.getData(),
						    s = this._data,
						    u = this.group,
						    c = e.get("animation"),
						    h = !s,
						    d = t.get("animationType"),
						    f = l.curry(n, this.uid, t, c, i),
						    p = t.get("selectedMode");if (r.diff(s).add(function (t) {
							var e = new o(r, t);h && "scale" !== d && e.eachChild(function (t) {
								t.stopAnimation(!0);
							}), p && e.on("click", f), r.setItemGraphicEl(t, e), u.add(e);
						}).update(function (t, e) {
							var i = s.getItemGraphicEl(e);i.updateData(r, t), i.off("click"), p && i.on("click", f), u.add(i), r.setItemGraphicEl(t, i);
						}).remove(function (t) {
							var e = s.getItemGraphicEl(t);u.remove(e);
						}).execute(), c && h && r.count() > 0 && "scale" !== d) {
							var g = r.getItemLayout(0),
							    m = Math.max(i.getWidth(), i.getHeight()) / 2,
							    v = l.bind(u.removeClipPath, u);u.setClipPath(this._createClipPath(g.cx, g.cy, m, g.startAngle, g.clockwise, v, t));
						}this._data = r;
					}
				}, dispose: function dispose() {}, _createClipPath: function _createClipPath(t, e, i, n, a, o, r) {
					var l = new s.Sector({ shape: { cx: t, cy: e, r0: 0, r: i, startAngle: n, endAngle: n, clockwise: a } });return s.initProps(l, { shape: { endAngle: n + (a ? 1 : -1) * Math.PI * 2 } }, r, o), l;
				}, containPoint: function containPoint(t, e) {
					var i = e.getData(),
					    n = i.getItemLayout(0);if (n) {
						var a = t[0] - n.cx,
						    o = t[1] - n.cy,
						    r = Math.sqrt(a * a + o * o);return r <= n.r && r >= n.r0;
					}
				} });t.exports = c;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i, n, a, o, r) {
				function s(e, i, n, a) {
					for (var o = e; o < i; o++) {
						if (t[o].y += n, o > e && o + 1 < i && t[o + 1].y > t[o].y + t[o].height) return void l(o, n / 2);
					}l(i - 1, n / 2);
				}function l(e, i) {
					for (var n = e; n >= 0 && (t[n].y -= i, !(n > 0 && t[n].y > t[n - 1].y + t[n - 1].height)); n--) {}
				}function u(t, e, i, n, a, o) {
					for (var r = o > 0 ? e ? Number.MAX_VALUE : 0 : e ? Number.MAX_VALUE : 0, s = 0, l = t.length; s < l; s++) {
						if ("center" !== t[s].position) {
							var u = Math.abs(t[s].y - n),
							    c = t[s].len,
							    h = t[s].len2,
							    d = u < a + c ? Math.sqrt((a + c + h) * (a + c + h) - u * u) : Math.abs(t[s].x - i);e && d >= r && (d = r - 10), !e && d <= r && (d = r + 10), t[s].x = i + d * o, r = d;
						}
					}
				}t.sort(function (t, e) {
					return t.y - e.y;
				});for (var c, h = 0, d = t.length, f = [], p = [], g = 0; g < d; g++) {
					c = t[g].y - h, c < 0 && s(g, d, -c, a), h = t[g].y + t[g].height;
				}r - h < 0 && l(d - 1, h - r);for (var g = 0; g < d; g++) {
					t[g].y >= i ? p.push(t[g]) : f.push(t[g]);
				}u(f, !1, e, i, n, a), u(p, !0, e, i, n, a);
			}function a(t, e, i, a, o, r) {
				for (var s = [], l = [], u = 0; u < t.length; u++) {
					t[u].x < e ? s.push(t[u]) : l.push(t[u]);
				}n(l, e, i, a, 1, o, r), n(s, e, i, a, -1, o, r);for (var u = 0; u < t.length; u++) {
					var c = t[u].linePoints;if (c) {
						var h = c[1][0] - c[2][0];t[u].x < e ? c[2][0] = t[u].x + 3 : c[2][0] = t[u].x - 3, c[1][1] = c[2][1] = t[u].y, c[1][0] = c[2][0] + h;
					}
				}
			}var o = i(16);t.exports = function (t, e, i, n) {
				var r,
				    s,
				    l = t.getData(),
				    u = [],
				    c = !1;l.each(function (i) {
					var n,
					    a,
					    h,
					    d,
					    f = l.getItemLayout(i),
					    p = l.getItemModel(i),
					    g = p.getModel("label.normal"),
					    m = g.get("position") || p.get("label.emphasis.position"),
					    v = p.getModel("labelLine.normal"),
					    y = v.get("length"),
					    x = v.get("length2"),
					    _ = (f.startAngle + f.endAngle) / 2,
					    b = Math.cos(_),
					    w = Math.sin(_);r = f.cx, s = f.cy;var S = "inside" === m || "inner" === m;if ("center" === m) n = f.cx, a = f.cy, d = "center";else {
						var M = (S ? (f.r + f.r0) / 2 * b : f.r * b) + r,
						    I = (S ? (f.r + f.r0) / 2 * w : f.r * w) + s;if (n = M + 3 * b, a = I + 3 * w, !S) {
							var T = M + b * (y + e - f.r),
							    A = I + w * (y + e - f.r),
							    C = T + (b < 0 ? -1 : 1) * x,
							    L = A;n = C + (b < 0 ? -5 : 5), a = L, h = [[M, I], [T, A], [C, L]];
						}d = S ? "center" : b > 0 ? "left" : "right";
					}var D = g.getModel("textStyle").getFont(),
					    P = g.get("rotate") ? b < 0 ? -_ + Math.PI : -_ : 0,
					    k = t.getFormattedLabel(i, "normal") || l.getName(i),
					    O = o.getBoundingRect(k, D, d, "top");c = !!P, f.label = { x: n, y: a, position: m, height: O.height, len: y, len2: x, linePoints: h, textAlign: d, verticalAlign: "middle", font: D, rotation: P }, S || u.push(f.label);
				}), !c && t.get("avoidLabelOverlap") && a(u, r, s, e, i, n);
			};
		}, function (t, e, i) {
			var n = i(4),
			    a = n.parsePercent,
			    o = i(115),
			    r = i(1),
			    s = 2 * Math.PI,
			    l = Math.PI / 180;t.exports = function (t, e, i, u) {
				e.eachSeriesByType(t, function (t) {
					var e = t.get("center"),
					    u = t.get("radius");r.isArray(u) || (u = [0, u]), r.isArray(e) || (e = [e, e]);var c = i.getWidth(),
					    h = i.getHeight(),
					    d = Math.min(c, h),
					    f = a(e[0], c),
					    p = a(e[1], h),
					    g = a(u[0], d / 2),
					    m = a(u[1], d / 2),
					    v = t.getData(),
					    y = -t.get("startAngle") * l,
					    x = t.get("minAngle") * l,
					    _ = 0;v.each("value", function (t) {
						!isNaN(t) && _++;
					});var b = v.getSum("value"),
					    w = Math.PI / (b || _) * 2,
					    S = t.get("clockwise"),
					    M = t.get("roseType"),
					    I = t.get("stillShowZeroSum"),
					    T = v.getDataExtent("value");T[0] = 0;var A = s,
					    C = 0,
					    L = y,
					    D = S ? 1 : -1;if (v.each("value", function (t, e) {
						var i;if (isNaN(t)) return void v.setItemLayout(e, { angle: NaN, startAngle: NaN, endAngle: NaN, clockwise: S, cx: f, cy: p, r0: g, r: M ? NaN : m });i = "area" !== M ? 0 === b && I ? w : t * w : s / _, i < x ? (i = x, A -= x) : C += t;var a = L + D * i;v.setItemLayout(e, { angle: i, startAngle: L, endAngle: a, clockwise: S, cx: f, cy: p, r0: g, r: M ? n.linearMap(t, T, [g, m]) : m }), L = a;
					}, !0), A < s && _) if (A <= .001) {
						var P = s / _;v.each("value", function (t, e) {
							if (!isNaN(t)) {
								var i = v.getItemLayout(e);i.angle = P, i.startAngle = y + D * e * P, i.endAngle = y + D * (e + 1) * P;
							}
						});
					} else w = A / C, L = y, v.each("value", function (t, e) {
						if (!isNaN(t)) {
							var i = v.getItemLayout(e),
							    n = i.angle === x ? x : t * w;i.startAngle = L, i.endAngle = L + D * n, L += D * n;
						}
					});o(t, m, c, h);
				});
			};
		}, function (t, e, i) {
			"use strict";
			i(60), i(118);
		}, function (t, e, i) {
			var n = i(1),
			    a = i(3),
			    o = i(40),
			    r = i(41),
			    s = i(75),
			    l = o.ifIgnoreOnTick,
			    u = o.getInterval,
			    c = ["axisLine", "axisLabel", "axisTick", "axisName"],
			    h = ["splitArea", "splitLine"],
			    d = r.extend({ type: "cartesianAxis", axisPointerClass: "CartesianAxisPointer", render: function render(t, e, i, r) {
					this.group.removeAll();var l = this._axisGroup;if (this._axisGroup = new a.Group(), this.group.add(this._axisGroup), t.get("show")) {
						var u = t.getCoordSysModel(),
						    f = s.layout(u, t),
						    p = new o(t, f);n.each(c, p.add, p), this._axisGroup.add(p.getGroup()), n.each(h, function (e) {
							t.get(e + ".show") && this["_" + e](t, u, f.labelInterval);
						}, this), a.groupTransition(l, this._axisGroup, t), d.superCall(this, "render", t, e, i, r);
					}
				}, _splitLine: function _splitLine(t, e, i) {
					var o = t.axis;if (!o.scale.isBlank()) {
						var r = t.getModel("splitLine"),
						    s = r.getModel("lineStyle"),
						    c = s.get("color"),
						    h = u(r, i);c = n.isArray(c) ? c : [c];for (var d = e.coordinateSystem.getRect(), f = o.isHorizontal(), p = 0, g = o.getTicksCoords(), m = o.scale.getTicks(), v = [], y = [], x = s.getLineStyle(), _ = 0; _ < g.length; _++) {
							if (!l(o, _, h)) {
								var b = o.toGlobalCoord(g[_]);f ? (v[0] = b, v[1] = d.y, y[0] = b, y[1] = d.y + d.height) : (v[0] = d.x, v[1] = b, y[0] = d.x + d.width, y[1] = b);var w = p++ % c.length;this._axisGroup.add(new a.Line(a.subPixelOptimizeLine({ anid: "line_" + m[_], shape: { x1: v[0], y1: v[1], x2: y[0], y2: y[1] }, style: n.defaults({ stroke: c[w] }, x), silent: !0 })));
							}
						}
					}
				}, _splitArea: function _splitArea(t, e, i) {
					var o = t.axis;if (!o.scale.isBlank()) {
						var r = t.getModel("splitArea"),
						    s = r.getModel("areaStyle"),
						    c = s.get("color"),
						    h = e.coordinateSystem.getRect(),
						    d = o.getTicksCoords(),
						    f = o.scale.getTicks(),
						    p = o.toGlobalCoord(d[0]),
						    g = o.toGlobalCoord(d[0]),
						    m = 0,
						    v = u(r, i),
						    y = s.getAreaStyle();c = n.isArray(c) ? c : [c];for (var x = 1; x < d.length; x++) {
							if (!l(o, x, v)) {
								var _,
								    b,
								    w,
								    S,
								    M = o.toGlobalCoord(d[x]);o.isHorizontal() ? (_ = p, b = h.y, w = M - _, S = h.height) : (_ = h.x, b = g, w = h.width, S = M - b);var I = m++ % c.length;this._axisGroup.add(new a.Rect({ anid: "area_" + f[x], shape: { x: _, y: b, width: w, height: S }, style: n.defaults({ fill: c[I] }, y), silent: !0 })), p = _ + w, g = b + S;
							}
						}
					}
				} });d.extend({ type: "xAxis" }), d.extend({ type: "yAxis" });
		}, function (t, e, i) {
			"use strict";
			function n() {}function a(t, e, i, n) {
				o(f(i).lastProp, n) || (f(i).lastProp = n, e ? d.updateProps(i, n, t) : (i.stopAnimation(), i.attr(n)));
			}function o(t, e) {
				if (c.isObject(t) && c.isObject(e)) {
					var i = !0;return c.each(e, function (e, n) {
						i &= o(t[n], e);
					}), !!i;
				}return t === e;
			}function r(t, e) {
				t[e.get("label.show") ? "show" : "hide"]();
			}function s(t) {
				return { position: t.position.slice(), rotation: t.rotation || 0 };
			}function l(t, e) {
				var i = t.get("icon"),
				    n = { x: -1, y: -1, width: 2, height: 2 },
				    a = c.extend({ style: { strokeNoScale: !0 }, rectHover: !0, cursor: "move", draggable: !0 }, e);return 0 === i.indexOf("image://") ? (n.image = i.slice(8), a.style = n, new d.Image(a)) : d.makePath(i.replace("path://", ""), a, n, "center");
			}function u(t, e, i) {
				var n = e.get("z"),
				    a = e.get("zlevel");t && t.traverse(function (t) {
					"group" !== t.type && (null != n && (t.z = n), null != a && (t.zlevel = a), t.silent = i);
				});
			}var c = i(1),
			    h = i(15),
			    d = i(3),
			    f = i(5).makeGetter(),
			    p = i(45),
			    g = i(21),
			    m = i(37),
			    v = c.clone,
			    y = c.bind;n.prototype = { _group: null, _lastGraphicKey: null, _handle: null, _dragging: !1, _lastValue: null, _lastStatus: null, _payloadInfo: null, animationThreshold: 15, render: function render(t, e, i, n) {
					var o = e.get("value"),
					    r = e.get("status");if (this._axisModel = t, this._axisPointerModel = e, this._api = i, n || this._lastValue !== o || this._lastStatus !== r) {
						this._lastValue = o, this._lastStatus = r;var s = this._group,
						    l = this._handle;if (!r || "hide" === r) return s && s.hide(), void (l && l.hide());s && s.show(), l && l.show();var h = {};this.makeElOption(h, o, t, e, i);var f = h.graphicKey;f !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = f;var p = this._moveAnimation = this.determineAnimation(t, e);if (s) {
							var g = c.curry(a, e, p);this.updatePointerEl(s, h, g, e), this.updateLabelEl(s, h, g, e);
						} else s = this._group = new d.Group(), this.createPointerEl(s, h, t, e), this.createLabelEl(s, h, t, e), i.getZr().add(s);u(s, e, !0), this._renderHandle(o);
					}
				}, remove: function remove(t) {
					this.clear(t);
				}, dispose: function dispose(t) {
					this.clear(t);
				}, determineAnimation: function determineAnimation(t, e) {
					var i = e.get("animation"),
					    n = t.axis,
					    a = "category" === n.type,
					    o = e.get("snap");if (!o && !a) return !1;if ("auto" === i || null == i) {
						var r = this.animationThreshold;if (a && n.getBandWidth() > r) return !0;if (o) {
							var s = p.getAxisInfo(t).seriesDataCount,
							    l = n.getExtent();return Math.abs(l[0] - l[1]) / s > r;
						}return !1;
					}return i === !0;
				}, makeElOption: function makeElOption(t, e, i, n, a) {}, createPointerEl: function createPointerEl(t, e, i, n) {
					var a = e.pointer;if (a) {
						var o = f(t).pointerEl = new d[a.type](v(e.pointer));t.add(o);
					}
				}, createLabelEl: function createLabelEl(t, e, i, n) {
					if (e.label) {
						var a = f(t).labelEl = new d.Rect(v(e.label));t.add(a), r(a, n);
					}
				}, updatePointerEl: function updatePointerEl(t, e, i) {
					var n = f(t).pointerEl;n && (n.setStyle(e.pointer.style), i(n, { shape: e.pointer.shape }));
				}, updateLabelEl: function updateLabelEl(t, e, i, n) {
					var a = f(t).labelEl;a && (a.setStyle(e.label.style), i(a, { shape: e.label.shape, position: e.label.position }), r(a, n));
				}, _renderHandle: function _renderHandle(t) {
					if (!this._dragging && this.updateHandleTransform) {
						var e = this._axisPointerModel,
						    i = this._api.getZr(),
						    n = this._handle,
						    a = e.getModel("handle"),
						    o = e.get("status");if (!a.get("show") || !o || "hide" === o) return n && i.remove(n), void (this._handle = null);var r;this._handle || (r = !0, n = this._handle = l(a, { onmousemove: function onmousemove(t) {
								g.stop(t.event);
							}, onmousedown: y(this._onHandleDragMove, this, 0, 0), drift: y(this._onHandleDragMove, this), ondragend: y(this._onHandleDragEnd, this) }), i.add(n)), u(n, e, !1);var s = ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];n.setStyle(a.getItemStyle(null, s));var h = a.get("size");c.isArray(h) || (h = [h, h]), n.attr("scale", [h[0] / 2, h[1] / 2]), m.createOrUpdate(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, r);
					}
				}, _moveHandleToValue: function _moveHandleToValue(t, e) {
					a(this._axisPointerModel, !e && this._moveAnimation, this._handle, s(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
				}, _onHandleDragMove: function _onHandleDragMove(t, e) {
					var i = this._handle;if (i) {
						this._dragging = !0;var n = this.updateHandleTransform(s(i), [t, e], this._axisModel, this._axisPointerModel);this._payloadInfo = n, i.stopAnimation(), i.attr(s(n)), f(i).lastProp = null, this._doDispatchAxisPointer();
					}
				}, _doDispatchAxisPointer: function _doDispatchAxisPointer() {
					var t = this._handle;if (t) {
						var e = this._payloadInfo,
						    i = this._axisModel;this._api.dispatchAction({ type: "updateAxisPointer", x: e.cursorPoint[0], y: e.cursorPoint[1], tooltipOption: e.tooltipOption, axesInfo: [{ axisDim: i.axis.dim, axisIndex: i.componentIndex }] });
					}
				}, _onHandleDragEnd: function _onHandleDragEnd(t) {
					this._dragging = !1;var e = this._handle;if (e) {
						var i = this._axisPointerModel.get("value");this._moveHandleToValue(i), this._api.dispatchAction({ type: "hideTip" });
					}
				}, getHandleTransform: null, updateHandleTransform: null, clear: function clear(t) {
					this._lastValue = null, this._lastStatus = null;var e = t.getZr(),
					    i = this._group,
					    n = this._handle;e && i && (this._lastGraphicKey = null, i && e.remove(i), n && e.remove(n), this._group = null, this._handle = null, this._payloadInfo = null);
				}, doClear: function doClear() {}, buildLabel: function buildLabel(t, e, i) {
					return i = i || 0, { x: t[i], y: t[1 - i], width: e[i], height: e[1 - i] };
				} }, n.prototype.constructor = n, h.enableClassExtend(n), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				var i = {};return i[e.dim + "AxisIndex"] = e.index, t.getCartesian(i);
			}function a(t) {
				return "x" === t.dim ? 0 : 1;
			}var o = i(3),
			    r = i(119),
			    s = i(76),
			    l = i(75),
			    u = i(41),
			    c = r.extend({ makeElOption: function makeElOption(t, e, i, a, o) {
					var r = i.axis,
					    u = r.grid,
					    c = a.get("type"),
					    d = n(u, r).getOtherAxis(r).getGlobalExtent(),
					    f = r.toGlobalCoord(r.dataToCoord(e, !0));if (c && "none" !== c) {
						var p = s.buildElStyle(a),
						    g = h[c](r, f, d, p);g.style = p, t.graphicKey = g.type, t.pointer = g;
					}var m = l.layout(u.model, i);s.buildCartesianSingleLabelElOption(e, t, m, i, a, o);
				}, getHandleTransform: function getHandleTransform(t, e, i) {
					var n = l.layout(e.axis.grid.model, e, { labelInside: !1 });return n.labelMargin = i.get("handle.margin"), { position: s.getTransformedPosition(e.axis, t, n), rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0) };
				}, updateHandleTransform: function updateHandleTransform(t, e, i, a) {
					var o = i.axis,
					    r = o.grid,
					    s = o.getGlobalExtent(!0),
					    l = n(r, o).getOtherAxis(o).getGlobalExtent(),
					    u = "x" === o.dim ? 0 : 1,
					    c = t.position;c[u] += e[u], c[u] = Math.min(s[1], c[u]), c[u] = Math.max(s[0], c[u]);var h = (l[1] + l[0]) / 2,
					    d = [h, h];d[u] = c[u];var f = [{ verticalAlign: "middle" }, { align: "center" }];return { position: c, rotation: t.rotation, cursorPoint: d, tooltipOption: f[u] };
				} }),
			    h = { line: function line(t, e, i, n) {
					var r = s.makeLineShape([e, i[0]], [e, i[1]], a(t));return o.subPixelOptimizeLine({ shape: r, style: n }), { type: "Line", shape: r };
				}, shadow: function shadow(t, e, i, n) {
					var o = t.getBandWidth(),
					    r = i[1] - i[0];return { type: "Rect", shape: s.makeRectShape([e - o / 2, i[0]], [o, r], a(t)) };
				} };u.registerAxisPointerClass("CartesianAxisPointer", c), t.exports = c;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(5);t.exports = function (t, e) {
				var i,
				    o = [],
				    r = t.seriesIndex;if (null == r || !(i = e.getSeriesByIndex(r))) return { point: [] };var s = i.getData(),
				    l = a.queryDataIndex(s, t);if (null == l || n.isArray(l)) return { point: [] };var u = s.getItemGraphicEl(l),
				    c = i.coordinateSystem;if (i.getTooltipPosition) o = i.getTooltipPosition(l) || [];else if (c && c.dataToPoint) o = c.dataToPoint(s.getValues(n.map(c.dimensions, function (t) {
					return i.coordDimToDataDim(t)[0];
				}), l, !0)) || [];else if (u) {
					var h = u.getBoundingRect().clone();h.applyTransform(u.transform), o = [h.x + h.width / 2, h.y + h.height / 2];
				}return { point: o, el: u };
			};
		}, function (t, e, i) {
			function n(t, e) {
				function i(i, n) {
					t.on(i, function (i) {
						var o = s(e);h(c(t).records, function (t) {
							t && n(t, i, o.dispatchAction);
						}), a(o.pendings, e);
					});
				}c(t).initialized || (c(t).initialized = !0, i("click", u.curry(r, "click")), i("mousemove", u.curry(r, "mousemove")), i("globalout", o));
			}function a(t, e) {
				var i,
				    n = t.showTip.length,
				    a = t.hideTip.length;n ? i = t.showTip[n - 1] : a && (i = t.hideTip[a - 1]), i && (i.dispatchAction = null, e.dispatchAction(i));
			}function o(t, e, i) {
				t.handler("leave", null, i);
			}function r(t, e, i, n) {
				e.handler(t, i, n);
			}function s(t) {
				var e = { showTip: [], hideTip: [] },
				    i = function i(n) {
					var a = e[n.type];a ? a.push(n) : (n.dispatchAction = i, t.dispatchAction(n));
				};return { dispatchAction: i, pendings: e };
			}var l = i(9),
			    u = i(1),
			    c = i(5).makeGetter(),
			    h = u.each,
			    d = {};d.register = function (t, e, i) {
				if (!l.node) {
					var a = e.getZr();c(a).records || (c(a).records = {}), n(a, e);var o = c(a).records[t] || (c(a).records[t] = {});o.handler = i;
				}
			}, d.unregister = function (t, e) {
				if (!l.node) {
					var i = e.getZr(),
					    n = (c(i).records || {})[t];n && (c(i).records[t] = null);
				}
			}, t.exports = d;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(77),
			    o = i(2);o.registerAction("dataZoom", function (t, e) {
				var i = a.createLinkedNodesFinder(n.bind(e.eachComponent, e, "dataZoom"), a.eachAxisDim, function (t, e) {
					return t.get(e.axisIndex);
				}),
				    o = [];e.eachComponent({ mainType: "dataZoom", query: t }, function (t, e) {
					o.push.apply(o, i(t).nodes);
				}), n.each(o, function (e, i) {
					e.setRawRange({ start: t.start, end: t.end, startValue: t.startValue, endValue: t.endValue });
				});
			});
		}, function (t, e, i) {
			function n(t, e, i) {
				i.getAxisProxy(t.name, e).reset(i);
			}function a(t, e, i) {
				i.getAxisProxy(t.name, e).filterData(i);
			}var o = i(2);o.registerProcessor(function (t, e) {
				t.eachComponent("dataZoom", function (t) {
					t.eachTargetAxis(n), t.eachTargetAxis(a);
				}), t.eachComponent("dataZoom", function (t) {
					var e = t.findRepresentativeAxisProxy(),
					    i = e.getDataPercentWindow(),
					    n = e.getDataValueWindow();t.setRawRange({ start: i[0], end: i[1], startValue: n[0], endValue: n[1] }, !0);
				});
			});
		}, function (t, e, i) {
			function n(t) {
				var e = t[r];return e || (e = t[r] = [{}]), e;
			}var a = i(1),
			    o = a.each,
			    r = "\0_ec_hist_store",
			    s = { push: function push(t, e) {
					var i = n(t);o(e, function (e, n) {
						for (var a = i.length - 1; a >= 0; a--) {
							var o = i[a];if (o[n]) break;
						}if (a < 0) {
							var r = t.queryComponents({ mainType: "dataZoom", subType: "select", id: n })[0];if (r) {
								var s = r.getPercentRange();i[0][n] = { dataZoomId: n, start: s[0], end: s[1] };
							}
						}
					}), i.push(e);
				}, pop: function pop(t) {
					var e = n(t),
					    i = e[e.length - 1];e.length > 1 && e.pop();var a = {};return o(i, function (t, i) {
						for (var n = e.length - 1; n >= 0; n--) {
							var t = e[n][i];if (t) {
								a[i] = t;break;
							}
						}
					}), a;
				}, clear: function clear(t) {
					t[r] = null;
				}, count: function count(t) {
					return n(t).length;
				} };t.exports = s;
		}, function (t, e, i) {
			i(13).registerSubTypeDefaulter("dataZoom", function (t) {
				return "slider";
			});
		}, function (t, e, i) {
			function n(t) {
				V.call(this), this._zr = t, this.group = new G.Group(), this._brushType, this._brushOption, this._panels, this._track = [], this._dragging, this._covers = [], this._creatingCover, this._creatingPanel, this._enableGlobalPan, this._uid = "brushController_" + it++, this._handlers = {}, Z(nt, function (t, e) {
					this._handlers[e] = B.bind(t, this);
				}, this);
			}function a(t, e) {
				var i = t._zr;t._enableGlobalPan || H.take(i, J, t._uid), Z(t._handlers, function (t, e) {
					i.on(e, t);
				}), t._brushType = e.brushType, t._brushOption = B.merge(B.clone(et), e, !0);
			}function o(t) {
				var e = t._zr;H.release(e, J, t._uid), Z(t._handlers, function (t, i) {
					e.off(i, t);
				}), t._brushType = t._brushOption = null;
			}function r(t, e) {
				var i = at[e.brushType].createCover(t, e);return i.__brushOption = e, u(i, e), t.group.add(i), i;
			}function s(t, e) {
				var i = h(e);return i.endCreating && (i.endCreating(t, e), u(e, e.__brushOption)), e;
			}function l(t, e) {
				var i = e.__brushOption;h(e).updateCoverShape(t, e, i.range, i);
			}function u(t, e) {
				var i = e.z;null == i && (i = Y), t.traverse(function (t) {
					t.z = i, t.z2 = i;
				});
			}function c(t, e) {
				h(e).updateCommon(t, e), l(t, e);
			}function h(t) {
				return at[t.__brushOption.brushType];
			}function d(t, e, i) {
				var n = t._panels;if (!n) return !0;var a,
				    o = t._transform;return Z(n, function (t) {
					t.isTargetByCursor(e, i, o) && (a = t);
				}), a;
			}function f(t, e) {
				var i = t._panels;if (!i) return !0;var n = e.__brushOption.panelId;return null == n || i[n];
			}function p(t) {
				var e = t._covers,
				    i = e.length;return Z(e, function (e) {
					t.group.remove(e);
				}, t), e.length = 0, !!i;
			}function g(t, e) {
				var i = q(t._covers, function (t) {
					var e = t.__brushOption,
					    i = B.clone(e.range);return { brushType: e.brushType, panelId: e.panelId, range: i };
				});t.trigger("brush", i, { isEnd: !!e.isEnd, removeOnClick: !!e.removeOnClick });
			}function m(t) {
				var e = t._track;if (!e.length) return !1;var i = e[e.length - 1],
				    n = e[0],
				    a = i[0] - n[0],
				    o = i[1] - n[1],
				    r = X(a * a + o * o, .5);return r > $;
			}function v(t) {
				var e = t.length - 1;return e < 0 && (e = 0), [t[0], t[e]];
			}function y(t, e, i, n) {
				var a = new G.Group();return a.add(new G.Rect({ name: "main", style: w(i), silent: !0, draggable: !0, cursor: "move", drift: W(t, e, a, "nswe"), ondragend: W(g, e, { isEnd: !0 }) })), Z(n, function (i) {
					a.add(new G.Rect({ name: i, style: { opacity: 0 }, draggable: !0, silent: !0, invisible: !0, drift: W(t, e, a, i), ondragend: W(g, e, { isEnd: !0 }) }));
				}), a;
			}function x(t, e, i, n) {
				var a = n.brushStyle.lineWidth || 0,
				    o = U(a, K),
				    r = i[0][0],
				    s = i[1][0],
				    l = r - a / 2,
				    u = s - a / 2,
				    c = i[0][1],
				    h = i[1][1],
				    d = c - o + a / 2,
				    f = h - o + a / 2,
				    p = c - r,
				    g = h - s,
				    m = p + a,
				    v = g + a;b(t, e, "main", r, s, p, g), n.transformable && (b(t, e, "w", l, u, o, v), b(t, e, "e", d, u, o, v), b(t, e, "n", l, u, m, o), b(t, e, "s", l, f, m, o), b(t, e, "nw", l, u, o, o), b(t, e, "ne", d, u, o, o), b(t, e, "sw", l, f, o, o), b(t, e, "se", d, f, o, o));
			}function _(t, e) {
				var i = e.__brushOption,
				    n = i.transformable,
				    a = e.childAt(0);a.useStyle(w(i)), a.attr({ silent: !n, cursor: n ? "move" : "default" }), Z(["w", "e", "n", "s", "se", "sw", "ne", "nw"], function (i) {
					var a = e.childOfName(i),
					    o = I(t, i);a && a.attr({ silent: !n, invisible: !n, cursor: n ? tt[o] + "-resize" : null });
				});
			}function b(t, e, i, n, a, o, r) {
				var s = e.childOfName(i);s && s.setShape(D(L(t, e, [[n, a], [n + o, a + r]])));
			}function w(t) {
				return B.defaults({ strokeNoScale: !0 }, t.brushStyle);
			}function S(t, e, i, n) {
				var a = [j(t, i), j(e, n)],
				    o = [U(t, i), U(e, n)];return [[a[0], o[0]], [a[1], o[1]]];
			}function M(t) {
				return G.getTransform(t.group);
			}function I(t, e) {
				if (e.length > 1) {
					e = e.split("");var i = [I(t, e[0]), I(t, e[1])];return ("e" === i[0] || "w" === i[0]) && i.reverse(), i.join("");
				}var n = { w: "left", e: "right", n: "top", s: "bottom" },
				    a = { left: "w", right: "e", top: "n", bottom: "s" },
				    i = G.transformDirection(n[e], M(t));return a[i];
			}function T(t, e, i, n, a, o, r, s) {
				var l = n.__brushOption,
				    u = t(l.range),
				    h = C(i, o, r);Z(a.split(""), function (t) {
					var e = Q[t];u[e[0]][e[1]] += h[e[0]];
				}), l.range = e(S(u[0][0], u[1][0], u[0][1], u[1][1])), c(i, n), g(i, { isEnd: !1 });
			}function A(t, e, i, n, a) {
				var o = e.__brushOption.range,
				    r = C(t, i, n);Z(o, function (t) {
					t[0] += r[0], t[1] += r[1];
				}), c(t, e), g(t, { isEnd: !1 });
			}function C(t, e, i) {
				var n = t.group,
				    a = n.transformCoordToLocal(e, i),
				    o = n.transformCoordToLocal(0, 0);return [a[0] - o[0], a[1] - o[1]];
			}function L(t, e, i) {
				var n = f(t, e);return n && n !== !0 ? n.clipPath(i, t._transform) : B.clone(i);
			}function D(t) {
				var e = j(t[0][0], t[1][0]),
				    i = j(t[0][1], t[1][1]),
				    n = U(t[0][0], t[1][0]),
				    a = U(t[0][1], t[1][1]);return { x: e, y: i, width: n - e, height: a - i };
			}function P(t, e, i) {
				if (t._brushType) {
					var n = t._zr,
					    a = t._covers,
					    o = d(t, e, i);if (!t._dragging) for (var r = 0; r < a.length; r++) {
						var s = a[r].__brushOption;if (o && (o === !0 || s.panelId === o.panelId) && at[s.brushType].contain(a[r], i[0], i[1])) return;
					}o && n.setCursorStyle("crosshair");
				}
			}function k(t) {
				var e = t.event;e.preventDefault && e.preventDefault();
			}function O(t, e, i) {
				return t.childOfName("main").contain(e, i);
			}function z(t, e, i, n) {
				var a,
				    o = t._creatingCover,
				    u = t._creatingPanel,
				    c = t._brushOption;if (t._track.push(i.slice()), m(t) || o) {
					if (u && !o) {
						"single" === c.brushMode && p(t);var h = B.clone(c);h.brushType = E(h.brushType, u), h.panelId = u === !0 ? null : u.panelId, o = t._creatingCover = r(t, h), t._covers.push(o);
					}if (o) {
						var f = at[E(t._brushType, u)],
						    g = o.__brushOption;g.range = f.getCreatingRange(L(t, o, t._track)), n && (s(t, o), f.updateCommon(t, o)), l(t, o), a = { isEnd: n };
					}
				} else n && "single" === c.brushMode && c.removeOnClick && d(t, e, i) && p(t) && (a = { isEnd: n, removeOnClick: !0 });return a;
			}function E(t, e) {
				return "auto" === t ? e.defaultBrushType : t;
			}function R(t) {
				if (this._dragging) {
					k(t);var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY),
					    i = z(this, t, e, !0);this._dragging = !1, this._track = [], this._creatingCover = null, i && g(this, i);
				}
			}function N(t) {
				return { createCover: function createCover(e, i) {
						return y(W(T, function (e) {
							var i = [e, [0, 100]];return t && i.reverse(), i;
						}, function (e) {
							return e[t];
						}), e, i, [["w", "e"], ["n", "s"]][t]);
					}, getCreatingRange: function getCreatingRange(e) {
						var i = v(e),
						    n = j(i[0][t], i[1][t]),
						    a = U(i[0][t], i[1][t]);return [n, a];
					}, updateCoverShape: function updateCoverShape(e, i, n, a) {
						var o,
						    r = f(e, i);if (r !== !0 && r.getLinearBrushOtherExtent) o = r.getLinearBrushOtherExtent(t, e._transform);else {
							var s = e._zr;o = [0, [s.getWidth(), s.getHeight()][1 - t]];
						}var l = [n, o];t && l.reverse(), x(e, i, l, a);
					}, updateCommon: _, contain: O };
			}var V = i(23),
			    B = i(1),
			    G = i(3),
			    H = i(129),
			    F = i(48),
			    W = B.curry,
			    Z = B.each,
			    q = B.map,
			    j = Math.min,
			    U = Math.max,
			    X = Math.pow,
			    Y = 1e4,
			    $ = 6,
			    K = 6,
			    J = "globalPan",
			    Q = { w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1] },
			    tt = { w: "ew", e: "ew", n: "ns", s: "ns", ne: "nesw", sw: "nesw", nw: "nwse", se: "nwse" },
			    et = { brushStyle: { lineWidth: 2, stroke: "rgba(0,0,0,0.3)", fill: "rgba(0,0,0,0.1)" }, transformable: !0, brushMode: "single", removeOnClick: !1 },
			    it = 0;n.prototype = { constructor: n, enableBrush: function enableBrush(t) {
					return this._brushType && o(this), t.brushType && a(this, t), this;
				}, setPanels: function setPanels(t) {
					if (t && t.length) {
						var e = this._panels = {};B.each(t, function (t) {
							e[t.panelId] = B.clone(t);
						});
					} else this._panels = null;return this;
				}, mount: function mount(t) {
					t = t || {}, this._enableGlobalPan = t.enableGlobalPan;var e = this.group;return this._zr.add(e), e.attr({ position: t.position || [0, 0], rotation: t.rotation || 0, scale: t.scale || [1, 1] }), this._transform = e.getLocalTransform(), this;
				}, eachCover: function eachCover(t, e) {
					Z(this._covers, t, e);
				}, updateCovers: function updateCovers(t) {
					function e(t, e) {
						return (null != t.id ? t.id : o + e) + "-" + t.brushType;
					}function i(t, i) {
						return e(t.__brushOption, i);
					}function n(e, i) {
						var n = t[e];if (null != i && l[i] === d) u[e] = l[i];else {
							var a = u[e] = null != i ? (l[i].__brushOption = n, l[i]) : s(h, r(h, n));c(h, a);
						}
					}function a(t) {
						l[t] !== d && h.group.remove(l[t]);
					}t = B.map(t, function (t) {
						return B.merge(B.clone(et), t, !0);
					});var o = "\0-brush-index-",
					    l = this._covers,
					    u = this._covers = [],
					    h = this,
					    d = this._creatingCover;return new F(l, t, i, e).add(n).update(n).remove(a).execute(), this;
				}, unmount: function unmount() {
					return this.enableBrush(!1), p(this), this._zr.remove(this.group), this;
				}, dispose: function dispose() {
					this.unmount(), this.off();
				} }, B.mixin(n, V);var nt = { mousedown: function mousedown(t) {
					if (this._dragging) R.call(this, t);else if (!t.target || !t.target.draggable) {
						k(t);var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY);this._creatingCover = null;var i = this._creatingPanel = d(this, t, e);i && (this._dragging = !0, this._track = [e.slice()]);
					}
				}, mousemove: function mousemove(t) {
					var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY);if (P(this, t, e), this._dragging) {
						k(t);var i = z(this, t, e, !1);i && g(this, i);
					}
				}, mouseup: R },
			    at = { lineX: N(0), lineY: N(1), rect: { createCover: function createCover(t, e) {
						return y(W(T, function (t) {
							return t;
						}, function (t) {
							return t;
						}), t, e, ["w", "e", "n", "s", "se", "sw", "ne", "nw"]);
					}, getCreatingRange: function getCreatingRange(t) {
						var e = v(t);return S(e[1][0], e[1][1], e[0][0], e[0][1]);
					}, updateCoverShape: function updateCoverShape(t, e, i, n) {
						x(t, e, i, n);
					}, updateCommon: _, contain: O }, polygon: { createCover: function createCover(t, e) {
						var i = new G.Group();return i.add(new G.Polyline({ name: "main", style: w(e), silent: !0 })), i;
					}, getCreatingRange: function getCreatingRange(t) {
						return t;
					}, endCreating: function endCreating(t, e) {
						e.remove(e.childAt(0)), e.add(new G.Polygon({ name: "main", draggable: !0, drift: W(A, t, e), ondragend: W(g, t, { isEnd: !0 }) }));
					}, updateCoverShape: function updateCoverShape(t, e, i, n) {
						e.childAt(0).setShape({ points: L(t, e, i) });
					}, updateCommon: _, contain: O } };t.exports = n;
		}, function (t, e) {
			var i = {},
			    n = { axisPointer: 1, tooltip: 1, brush: 1 };i.onIrrelevantElement = function (t, e, i) {
				var a = e.getComponentByElement(t.topTarget),
				    o = a && a.coordinateSystem;return a && a !== i && !n[a.mainType] && o && o.model !== i;
			}, t.exports = i;
		}, function (t, e, i) {
			function n(t) {
				return t[a] || (t[a] = {});
			}var a = "\0_ec_interaction_mutex",
			    o = { take: function take(t, e, i) {
					var a = n(t);a[e] = i;
				}, release: function release(t, e, i) {
					var a = n(t),
					    o = a[e];o === i && (a[e] = null);
				}, isTaken: function isTaken(t, e) {
					return !!n(t)[e];
				} };i(2).registerAction({ type: "takeGlobalCursor", event: "globalCursorTaken", update: "update" }, function () {}), t.exports = o;
		}, function (t, e, i) {
			function n(t, e, i) {
				a.positionElement(t, e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }, e.get("padding"));
			}var a = i(12),
			    o = i(7),
			    r = i(3);t.exports = { layout: function layout(t, e, i) {
					var o = a.getLayoutRect(e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }, e.get("padding"));a.box(e.get("orient"), t, e.get("itemGap"), o.width, o.height), n(t, e, i);
				}, addBackground: function addBackground(t, e) {
					var i = o.normalizeCssArray(e.get("padding")),
					    n = t.getBoundingRect(),
					    a = e.getItemStyle(["color", "opacity"]);a.fill = e.get("backgroundColor");var s = new r.Rect({ shape: { x: n.x - i[3], y: n.y - i[0], width: n.width + i[1] + i[3], height: n.height + i[0] + i[2] }, style: a, silent: !0, z2: -1 });r.subPixelOptimizeRect(s), t.add(s);
				} };
		}, function (t, e, i) {
			var n = i(1),
			    a = i(33),
			    o = function o(t, e, i, n, _o2) {
				a.call(this, t, e, i), this.type = n || "value", this.position = _o2 || "bottom";
			};o.prototype = { constructor: o, index: 0, onZero: !1, model: null, isHorizontal: function isHorizontal() {
					var t = this.position;return "top" === t || "bottom" === t;
				}, getGlobalExtent: function getGlobalExtent(t) {
					var e = this.getExtent();return e[0] = this.toGlobalCoord(e[0]), e[1] = this.toGlobalCoord(e[1]), t && e[0] > e[1] && e.reverse(), e;
				}, getOtherAxis: function getOtherAxis() {
					this.grid.getOtherAxis();
				}, isLabelIgnored: function isLabelIgnored(t) {
					if ("category" === this.type) {
						var e = this.getLabelInterval();return "function" == typeof e && !e(t, this.scale.getLabel(t)) || t % (e + 1);
					}
				}, pointToData: function pointToData(t, e) {
					return this.coordToData(this.toLocalCoord(t["x" === this.dim ? 0 : 1]), e);
				}, toLocalCoord: null, toGlobalCoord: null }, n.inherits(o, a), t.exports = o;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return this._axes[t];
			}var a = i(1),
			    o = function o(t) {
				this._axes = {}, this._dimList = [], this.name = t || "";
			};o.prototype = { constructor: o, type: "cartesian", getAxis: function getAxis(t) {
					return this._axes[t];
				}, getAxes: function getAxes() {
					return a.map(this._dimList, n, this);
				}, getAxesByScale: function getAxesByScale(t) {
					return t = t.toLowerCase(), a.filter(this.getAxes(), function (e) {
						return e.scale.type === t;
					});
				}, addAxis: function addAxis(t) {
					var e = t.dim;this._axes[e] = t, this._dimList.push(e);
				}, dataToCoord: function dataToCoord(t) {
					return this._dataCoordConvert(t, "dataToCoord");
				}, coordToData: function coordToData(t) {
					return this._dataCoordConvert(t, "coordToData");
				}, _dataCoordConvert: function _dataCoordConvert(t, e) {
					for (var i = this._dimList, n = t instanceof Array ? [] : {}, a = 0; a < i.length; a++) {
						var o = i[a],
						    r = this._axes[o];n[o] = r[e](t[o]);
					}return n;
				} }, t.exports = o;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				o.call(this, t);
			}var a = i(1),
			    o = i(132);n.prototype = { constructor: n, type: "cartesian2d", dimensions: ["x", "y"], getBaseAxis: function getBaseAxis() {
					return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
				}, containPoint: function containPoint(t) {
					var e = this.getAxis("x"),
					    i = this.getAxis("y");return e.contain(e.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]));
				}, containData: function containData(t) {
					return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]);
				}, dataToPoints: function dataToPoints(t, e) {
					return t.mapArray(["x", "y"], function (t, e) {
						return this.dataToPoint([t, e]);
					}, e, this);
				}, dataToPoint: function dataToPoint(t, e) {
					var i = this.getAxis("x"),
					    n = this.getAxis("y");return [i.toGlobalCoord(i.dataToCoord(t[0], e)), n.toGlobalCoord(n.dataToCoord(t[1], e))];
				}, pointToData: function pointToData(t, e) {
					var i = this.getAxis("x"),
					    n = this.getAxis("y");return [i.coordToData(i.toLocalCoord(t[0]), e), n.coordToData(n.toLocalCoord(t[1]), e)];
				}, getOtherAxis: function getOtherAxis(t) {
					return this.getAxis("x" === t.dim ? "y" : "x");
				} }, a.inherits(n, o), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			i(60);var n = i(13);t.exports = n.extend({ type: "grid", dependencies: ["xAxis", "yAxis"], layoutMode: "box", coordinateSystem: null, defaultOption: { show: !1, zlevel: 0, z: 0, left: "10%", top: 60, right: "10%", bottom: 60, containLabel: !1, backgroundColor: "rgba(0,0,0,0)", borderWidth: 1, borderColor: "#ccc" } });
		}, function (t, e, i) {
			var n = i(28),
			    a = i(24),
			    o = i(18),
			    r = i(42),
			    s = i(10),
			    l = i(1);t.exports = { createList: function createList(t) {
					var e = t.get("data");return n(e, t, t.ecModel);
				}, completeDimensions: i(25), createSymbol: a.createSymbol, createScale: function createScale(t, e) {
					var i = e;e instanceof s || (i = new s(e), l.mixin(i, r));var n = o.createScaleByModel(i);return n.setExtent(t[0], t[1]), o.niceScaleExtent(n, i), n;
				}, mixinAxisModelCommonMethods: function mixinAxisModelCommonMethods(t) {
					l.mixin(t, r);
				} };
		}, function (t, e, i) {
			var n = i(3),
			    a = i(1),
			    o = Math.PI;t.exports = function (t, e) {
				e = e || {}, a.defaults(e, { text: "loading", color: "#c23531", textColor: "#000", maskColor: "rgba(255, 255, 255, 0.8)", zlevel: 0 });var i = new n.Rect({ style: { fill: e.maskColor }, zlevel: e.zlevel, z: 1e4 }),
				    r = new n.Arc({ shape: { startAngle: -o / 2, endAngle: -o / 2 + .1, r: 10 }, style: { stroke: e.color, lineCap: "round", lineWidth: 5 }, zlevel: e.zlevel, z: 10001 }),
				    s = new n.Rect({ style: { fill: "none", text: e.text, textPosition: "right", textDistance: 10, textFill: e.textColor }, zlevel: e.zlevel, z: 10001 });r.animateShape(!0).when(1e3, { endAngle: 3 * o / 2 }).start("circularInOut"), r.animateShape(!0).when(1e3, { startAngle: 3 * o / 2 }).delay(300).start("circularInOut");var l = new n.Group();return l.add(r), l.add(s), l.add(i), l.resize = function () {
					var e = t.getWidth() / 2,
					    n = t.getHeight() / 2;r.setShape({ cx: e, cy: n });var a = r.shape.r;s.setShape({ x: e - a, y: n - a, width: 2 * a, height: 2 * a }), i.setShape({ x: 0, y: 0, width: t.getWidth(), height: t.getHeight() });
				}, l.resize(), l;
			};
		}, function (t, e, i) {
			function n(t, e) {
				c.each(e, function (e, i) {
					x.hasClass(i) || ("object" == (typeof e === "undefined" ? "undefined" : _typeof(e)) ? t[i] = t[i] ? c.merge(t[i], e, !1) : c.clone(e) : null == t[i] && (t[i] = e));
				});
			}function a(t) {
				t = t, this.option = {}, this.option[b] = 1, this._componentsMap = c.createHashMap({ series: []
				}), this._seriesIndices = null, n(t, this._theme.option), c.merge(t, _, !1), this.mergeOption(t);
			}function o(t, e) {
				c.isArray(e) || (e = e ? [e] : []);var i = {};return f(e, function (e) {
					i[e] = (t.get(e) || []).slice();
				}), i;
			}function r(t, e, i) {
				var n = e.type ? e.type : i ? i.subType : x.determineSubType(t, e);return n;
			}function s(t) {
				return g(t, function (t) {
					return t.componentIndex;
				}) || [];
			}function l(t, e) {
				return e.hasOwnProperty("subType") ? p(t, function (t) {
					return t.subType === e.subType;
				}) : t;
			}function u(t) {}var c = i(1),
			    h = i(5),
			    d = i(10),
			    f = c.each,
			    p = c.filter,
			    g = c.map,
			    m = c.isArray,
			    v = c.indexOf,
			    y = c.isObject,
			    x = i(13),
			    _ = i(139),
			    b = "\0_ec_inner",
			    w = d.extend({ constructor: w, init: function init(t, e, i, n) {
					i = i || {}, this.option = null, this._theme = new d(i), this._optionManager = n;
				}, setOption: function setOption(t, e) {
					c.assert(!(b in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption(null);
				}, resetOption: function resetOption(t) {
					var e = !1,
					    i = this._optionManager;if (!t || "recreate" === t) {
						var n = i.mountOption("recreate" === t);this.option && "recreate" !== t ? (this.restoreData(), this.mergeOption(n)) : a.call(this, n), e = !0;
					}if ("timeline" !== t && "media" !== t || this.restoreData(), !t || "recreate" === t || "timeline" === t) {
						var o = i.getTimelineOption(this);o && (this.mergeOption(o), e = !0);
					}if (!t || "recreate" === t || "media" === t) {
						var r = i.getMediaOption(this, this._api);r.length && f(r, function (t) {
							this.mergeOption(t, e = !0);
						}, this);
					}return e;
				}, mergeOption: function mergeOption(t) {
					function e(e, a) {
						var l = h.normalizeToArray(t[e]),
						    u = h.mappingToExists(n.get(e), l);h.makeIdAndName(u), f(u, function (t, i) {
							var n = t.option;y(n) && (t.keyInfo.mainType = e, t.keyInfo.subType = r(e, n, t.exist));
						});var d = o(n, a);i[e] = [], n.set(e, []), f(u, function (t, a) {
							var o = t.exist,
							    r = t.option;if (c.assert(y(r) || o, "Empty component definition"), r) {
								var s = x.getClass(e, t.keyInfo.subType, !0);if (o && o instanceof s) o.name = t.keyInfo.name, o.mergeOption(r, this), o.optionUpdated(r, !1);else {
									var l = c.extend({ dependentModels: d, componentIndex: a }, t.keyInfo);o = new s(r, this, this, l), c.extend(o, l), o.init(r, this, this, l), o.optionUpdated(null, !0);
								}
							} else o.mergeOption({}, this), o.optionUpdated({}, !1);n.get(e)[a] = o, i[e][a] = o.option;
						}, this), "series" === e && (this._seriesIndices = s(n.get("series")));
					}var i = this.option,
					    n = this._componentsMap,
					    a = [];f(t, function (t, e) {
						null != t && (x.hasClass(e) ? a.push(e) : i[e] = null == i[e] ? c.clone(t) : c.merge(i[e], t, !0));
					}), x.topologicalTravel(a, x.getAllClassMainTypes(), e, this), this._seriesIndices = this._seriesIndices || [];
				}, getOption: function getOption() {
					var t = c.clone(this.option);return f(t, function (e, i) {
						if (x.hasClass(i)) {
							for (var e = h.normalizeToArray(e), n = e.length - 1; n >= 0; n--) {
								h.isIdInner(e[n]) && e.splice(n, 1);
							}t[i] = e;
						}
					}), delete t[b], t;
				}, getTheme: function getTheme() {
					return this._theme;
				}, getComponent: function getComponent(t, e) {
					var i = this._componentsMap.get(t);if (i) return i[e || 0];
				}, queryComponents: function queryComponents(t) {
					var e = t.mainType;if (!e) return [];var i = t.index,
					    n = t.id,
					    a = t.name,
					    o = this._componentsMap.get(e);if (!o || !o.length) return [];var r;if (null != i) m(i) || (i = [i]), r = p(g(i, function (t) {
						return o[t];
					}), function (t) {
						return !!t;
					});else if (null != n) {
						var s = m(n);r = p(o, function (t) {
							return s && v(n, t.id) >= 0 || !s && t.id === n;
						});
					} else if (null != a) {
						var u = m(a);r = p(o, function (t) {
							return u && v(a, t.name) >= 0 || !u && t.name === a;
						});
					} else r = o.slice();return l(r, t);
				}, findComponents: function findComponents(t) {
					function e(t) {
						var e = a + "Index",
						    i = a + "Id",
						    n = a + "Name";return !t || null == t[e] && null == t[i] && null == t[n] ? null : { mainType: a, index: t[e], id: t[i], name: t[n] };
					}function i(e) {
						return t.filter ? p(e, t.filter) : e;
					}var n = t.query,
					    a = t.mainType,
					    o = e(n),
					    r = o ? this.queryComponents(o) : this._componentsMap.get(a);return i(l(r, t));
				}, eachComponent: function eachComponent(t, e, i) {
					var n = this._componentsMap;if ("function" == typeof t) i = e, e = t, n.each(function (t, n) {
						f(t, function (t, a) {
							e.call(i, n, t, a);
						});
					});else if (c.isString(t)) f(n.get(t), e, i);else if (y(t)) {
						var a = this.findComponents(t);f(a, e, i);
					}
				}, getSeriesByName: function getSeriesByName(t) {
					var e = this._componentsMap.get("series");return p(e, function (e) {
						return e.name === t;
					});
				}, getSeriesByIndex: function getSeriesByIndex(t) {
					return this._componentsMap.get("series")[t];
				}, getSeriesByType: function getSeriesByType(t) {
					var e = this._componentsMap.get("series");return p(e, function (e) {
						return e.subType === t;
					});
				}, getSeries: function getSeries() {
					return this._componentsMap.get("series").slice();
				}, eachSeries: function eachSeries(t, e) {
					u(this), f(this._seriesIndices, function (i) {
						var n = this._componentsMap.get("series")[i];t.call(e, n, i);
					}, this);
				}, eachRawSeries: function eachRawSeries(t, e) {
					f(this._componentsMap.get("series"), t, e);
				}, eachSeriesByType: function eachSeriesByType(t, e, i) {
					u(this), f(this._seriesIndices, function (n) {
						var a = this._componentsMap.get("series")[n];a.subType === t && e.call(i, a, n);
					}, this);
				}, eachRawSeriesByType: function eachRawSeriesByType(t, e, i) {
					return f(this.getSeriesByType(t), e, i);
				}, isSeriesFiltered: function isSeriesFiltered(t) {
					return u(this), c.indexOf(this._seriesIndices, t.componentIndex) < 0;
				}, getCurrentSeriesIndices: function getCurrentSeriesIndices() {
					return (this._seriesIndices || []).slice();
				}, filterSeries: function filterSeries(t, e) {
					u(this);var i = p(this._componentsMap.get("series"), t, e);this._seriesIndices = s(i);
				}, restoreData: function restoreData() {
					var t = this._componentsMap;this._seriesIndices = s(t.get("series"));var e = [];t.each(function (t, i) {
						e.push(i);
					}), x.topologicalTravel(e, x.getAllClassMainTypes(), function (e, i) {
						f(t.get(e), function (t) {
							t.restoreData();
						});
					});
				} });c.mixin(w, i(62)), t.exports = w;
		}, function (t, e, i) {
			function n(t) {
				this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption;
			}function a(t, e, i) {
				var n,
				    a,
				    o = [],
				    r = [],
				    s = t.timeline;if (t.baseOption && (a = t.baseOption), (s || t.options) && (a = a || {}, o = (t.options || []).slice()), t.media) {
					a = a || {};var l = t.media;d(l, function (t) {
						t && t.option && (t.query ? r.push(t) : n || (n = t));
					});
				}return a || (a = t), a.timeline || (a.timeline = s), d([a].concat(o).concat(u.map(r, function (t) {
					return t.option;
				})), function (t) {
					d(e, function (e) {
						e(t, i);
					});
				}), { baseOption: a, timelineOptions: o, mediaDefault: n, mediaList: r };
			}function o(t, e, i) {
				var n = { width: e, height: i, aspectratio: e / i },
				    a = !0;return u.each(t, function (t, e) {
					var i = e.match(m);if (i && i[1] && i[2]) {
						var o = i[1],
						    s = i[2].toLowerCase();r(n[s], t, o) || (a = !1);
					}
				}), a;
			}function r(t, e, i) {
				return "min" === i ? t >= e : "max" === i ? t <= e : t === e;
			}function s(t, e) {
				return t.join(",") === e.join(",");
			}function l(t, e) {
				e = e || {}, d(e, function (e, i) {
					if (null != e) {
						var n = t[i];if (h.hasClass(i)) {
							e = c.normalizeToArray(e), n = c.normalizeToArray(n);var a = c.mappingToExists(n, e);t[i] = p(a, function (t) {
								return t.option && t.exist ? g(t.exist, t.option, !0) : t.exist || t.option;
							});
						} else t[i] = g(n, e, !0);
					}
				});
			}var u = i(1),
			    c = i(5),
			    h = i(13),
			    d = u.each,
			    f = u.clone,
			    p = u.map,
			    g = u.merge,
			    m = /^(min|max)?(.+)$/;n.prototype = { constructor: n, setOption: function setOption(t, e) {
					t = f(t, !0);var i = this._optionBackup,
					    n = a.call(this, t, e, !i);this._newBaseOption = n.baseOption, i ? (l(i.baseOption, n.baseOption), n.timelineOptions.length && (i.timelineOptions = n.timelineOptions), n.mediaList.length && (i.mediaList = n.mediaList), n.mediaDefault && (i.mediaDefault = n.mediaDefault)) : this._optionBackup = n;
				}, mountOption: function mountOption(t) {
					var e = this._optionBackup;return this._timelineOptions = p(e.timelineOptions, f), this._mediaList = p(e.mediaList, f), this._mediaDefault = f(e.mediaDefault), this._currentMediaIndices = [], f(t ? e.baseOption : this._newBaseOption);
				}, getTimelineOption: function getTimelineOption(t) {
					var e,
					    i = this._timelineOptions;if (i.length) {
						var n = t.getComponent("timeline");n && (e = f(i[n.getCurrentIndex()], !0));
					}return e;
				}, getMediaOption: function getMediaOption(t) {
					var e = this._api.getWidth(),
					    i = this._api.getHeight(),
					    n = this._mediaList,
					    a = this._mediaDefault,
					    r = [],
					    l = [];if (!n.length && !a) return l;for (var u = 0, c = n.length; u < c; u++) {
						o(n[u].query, e, i) && r.push(u);
					}return !r.length && a && (r = [-1]), r.length && !s(r, this._currentMediaIndices) && (l = p(r, function (t) {
						return f(t === -1 ? a.option : n[t].option);
					})), this._currentMediaIndices = r, l;
				} }, t.exports = n;
		}, function (t, e) {
			var i = "";"undefined" != typeof navigator && (i = navigator.platform || ""), t.exports = { color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"], textStyle: { fontFamily: i.match(/^Win/) ? "Microsoft YaHei" : "sans-serif", fontSize: 12, fontStyle: "normal", fontWeight: "normal" }, blendMode: null, animation: "auto", animationDuration: 1e3, animationDurationUpdate: 300, animationEasing: "exponentialOut", animationEasingUpdate: "cubicOut", animationThreshold: 2e3, progressiveThreshold: 3e3, progressive: 400, hoverLayerThreshold: 3e3, useUTC: !1 };
		}, function (t, e, i) {
			t.exports = { getAreaStyle: i(31)([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]]) };
		}, function (t, e) {
			t.exports = { getBoxLayoutParams: function getBoxLayoutParams() {
					return { left: this.get("left"), top: this.get("top"), right: this.get("right"), bottom: this.get("bottom"), width: this.get("width"), height: this.get("height") };
				} };
		}, function (t, e, i) {
			var n = i(31)([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["textPosition"], ["textAlign"]]);t.exports = { getItemStyle: function getItemStyle(t, e) {
					var i = n.call(this, t, e),
					    a = this.getBorderLineDash();return a && (i.lineDash = a), i;
				}, getBorderLineDash: function getBorderLineDash() {
					var t = this.get("borderType");return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1];
				} };
		}, function (t, e, i) {
			var n = i(31)([["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);t.exports = { getLineStyle: function getLineStyle(t) {
					var e = n.call(this, t),
					    i = this.getLineDash(e.lineWidth);return i && (e.lineDash = i), e;
				}, getLineDash: function getLineDash(t) {
					null == t && (t = 1);var e = this.get("type"),
					    i = Math.max(t, 2),
					    n = 4 * t;return "solid" === e || null == e ? null : "dashed" === e ? [n, n] : [i, i];
				} };
		}, function (t, e, i) {
			var n = i(16),
			    a = i(3);t.exports = { getTextColor: function getTextColor() {
					var t = this.ecModel;return this.getShallow("color") || t && t.get("textStyle.color");
				}, getFont: function getFont() {
					return a.getFont({ fontStyle: this.getShallow("fontStyle"), fontWeight: this.getShallow("fontWeight"), fontSize: this.getShallow("fontSize"), fontFamily: this.getShallow("fontFamily") }, this.ecModel);
				}, getTextRect: function getTextRect(t) {
					return n.getBoundingRect(t, this.getFont(), this.getShallow("align"), this.getShallow("baseline"));
				}, truncateText: function truncateText(t, e, i, a) {
					return n.truncateText(t, e, this.getFont(), i, a);
				} };
		}, function (t, e, i) {
			function n(t, e) {
				e = e.split(",");for (var i = t, n = 0; n < e.length && (i = i && i[e[n]], null != i); n++) {}return i;
			}function a(t, e, i, n) {
				e = e.split(",");for (var a, o = t, r = 0; r < e.length - 1; r++) {
					a = e[r], null == o[a] && (o[a] = {}), o = o[a];
				}(n || null == o[e[r]]) && (o[e[r]] = i);
			}function o(t) {
				h(l, function (e) {
					e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]]);
				});
			}var r = i(1),
			    s = i(146),
			    l = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]],
			    u = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"],
			    c = ["bar", "boxplot", "candlestick", "chord", "effectScatter", "funnel", "gauge", "lines", "graph", "heatmap", "line", "map", "parallel", "pie", "radar", "sankey", "scatter", "treemap"],
			    h = r.each;t.exports = function (t) {
				h(t.series, function (t) {
					if (r.isObject(t)) {
						var e = t.type;if (s(t), "pie" !== e && "gauge" !== e || null != t.clockWise && (t.clockwise = t.clockWise), "gauge" === e) {
							var i = n(t, "pointer.color");null != i && a(t, "itemStyle.normal.color", i);
						}for (var l = 0; l < c.length; l++) {
							if (c[l] === t.type) {
								o(t);break;
							}
						}
					}
				}), t.dataRange && (t.visualMap = t.dataRange), h(u, function (e) {
					var i = t[e];i && (r.isArray(i) || (i = [i]), h(i, function (t) {
						o(t);
					}));
				});
			};
		}, function (t, e, i) {
			function n(t) {
				var e = t && t.itemStyle;e && a.each(o, function (i) {
					var n = e.normal,
					    o = e.emphasis;n && n[i] && (t[i] = t[i] || {}, t[i].normal ? a.merge(t[i].normal, n[i]) : t[i].normal = n[i], n[i] = null), o && o[i] && (t[i] = t[i] || {}, t[i].emphasis ? a.merge(t[i].emphasis, o[i]) : t[i].emphasis = o[i], o[i] = null);
				});
			}var a = i(1),
			    o = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];t.exports = function (t) {
				if (t) {
					n(t), n(t.markPoint), n(t.markLine);var e = t.data;if (e) {
						for (var i = 0; i < e.length; i++) {
							n(e[i]);
						}var o = t.markPoint;if (o && o.data) for (var r = o.data, i = 0; i < r.length; i++) {
							n(r[i]);
						}var s = t.markLine;if (s && s.data) for (var l = s.data, i = 0; i < l.length; i++) {
							a.isArray(l[i]) ? (n(l[i][0]), n(l[i][1])) : n(l[i]);
						}
					}
				}
			};
		}, function (t, e) {
			var i = { average: function average(t) {
					for (var e = 0, i = 0, n = 0; n < t.length; n++) {
						isNaN(t[n]) || (e += t[n], i++);
					}return 0 === i ? NaN : e / i;
				}, sum: function sum(t) {
					for (var e = 0, i = 0; i < t.length; i++) {
						e += t[i] || 0;
					}return e;
				}, max: function max(t) {
					for (var e = -(1 / 0), i = 0; i < t.length; i++) {
						t[i] > e && (e = t[i]);
					}return e;
				}, min: function min(t) {
					for (var e = 1 / 0, i = 0; i < t.length; i++) {
						t[i] < e && (e = t[i]);
					}return e;
				}, nearest: function nearest(t) {
					return t[0];
				} },
			    n = function n(t, e) {
				return Math.round(t.length / 2);
			};t.exports = function (t, e, a) {
				e.eachSeriesByType(t, function (t) {
					var e = t.getData(),
					    a = t.get("sampling"),
					    o = t.coordinateSystem;if ("cartesian2d" === o.type && a) {
						var r = o.getBaseAxis(),
						    s = o.getOtherAxis(r),
						    l = r.getExtent(),
						    u = l[1] - l[0],
						    c = Math.round(e.count() / u);if (c > 1) {
							var h;"string" == typeof a ? h = i[a] : "function" == typeof a && (h = a), h && (e = e.downSample(s.dim, 1 / c, h, n), t.setData(e));
						}
					}
				}, this);
			};
		}, function (t, e, i) {
			function n(t, e) {
				return h(t, c(e));
			}var a = i(1),
			    o = i(34),
			    r = i(4),
			    s = i(43),
			    l = o.prototype,
			    u = s.prototype,
			    c = r.getPrecisionSafe,
			    h = r.round,
			    d = Math.floor,
			    f = Math.ceil,
			    p = Math.pow,
			    g = Math.log,
			    m = o.extend({ type: "log", base: 10, $constructor: function $constructor() {
					o.apply(this, arguments), this._originalScale = new s();
				}, getTicks: function getTicks() {
					var t = this._originalScale,
					    e = this._extent,
					    i = t.getExtent();return a.map(u.getTicks.call(this), function (a) {
						var o = r.round(p(this.base, a));return o = a === e[0] && t.__fixMin ? n(o, i[0]) : o, o = a === e[1] && t.__fixMax ? n(o, i[1]) : o;
					}, this);
				}, getLabel: u.getLabel, scale: function scale(t) {
					return t = l.scale.call(this, t), p(this.base, t);
				}, setExtent: function setExtent(t, e) {
					var i = this.base;t = g(t) / g(i), e = g(e) / g(i), u.setExtent.call(this, t, e);
				}, getExtent: function getExtent() {
					var t = this.base,
					    e = l.getExtent.call(this);e[0] = p(t, e[0]), e[1] = p(t, e[1]);var i = this._originalScale,
					    a = i.getExtent();return i.__fixMin && (e[0] = n(e[0], a[0])), i.__fixMax && (e[1] = n(e[1], a[1])), e;
				}, unionExtent: function unionExtent(t) {
					this._originalScale.unionExtent(t);var e = this.base;t[0] = g(t[0]) / g(e), t[1] = g(t[1]) / g(e), l.unionExtent.call(this, t);
				}, unionExtentFromData: function unionExtentFromData(t, e) {
					this.unionExtent(t.getDataExtent(e, !0, function (t) {
						return t > 0;
					}));
				}, niceTicks: function niceTicks(t) {
					t = t || 10;var e = this._extent,
					    i = e[1] - e[0];if (!(i === 1 / 0 || i <= 0)) {
						var n = r.quantity(i),
						    a = t / i * n;for (a <= .5 && (n *= 10); !isNaN(n) && Math.abs(n) < 1 && Math.abs(n) > 0;) {
							n *= 10;
						}var o = [r.round(f(e[0] / n) * n), r.round(d(e[1] / n) * n)];this._interval = n, this._niceExtent = o;
					}
				}, niceExtent: function niceExtent(t) {
					u.niceExtent.call(this, t);var e = this._originalScale;e.__fixMin = t.fixMin, e.__fixMax = t.fixMax;
				} });a.each(["contain", "normalize"], function (t) {
				m.prototype[t] = function (e) {
					return e = g(e) / g(this.base), l[t].call(this, e);
				};
			}), m.create = function () {
				return new m();
			}, t.exports = m;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(34),
			    o = a.prototype,
			    r = a.extend({ type: "ordinal", init: function init(t, e) {
					this._data = t, this._extent = e || [0, t.length - 1];
				}, parse: function parse(t) {
					return "string" == typeof t ? n.indexOf(this._data, t) : Math.round(t);
				}, contain: function contain(t) {
					return t = this.parse(t), o.contain.call(this, t) && null != this._data[t];
				}, normalize: function normalize(t) {
					return o.normalize.call(this, this.parse(t));
				}, scale: function scale(t) {
					return Math.round(o.scale.call(this, t));
				}, getTicks: function getTicks() {
					for (var t = [], e = this._extent, i = e[0]; i <= e[1];) {
						t.push(i), i++;
					}return t;
				}, getLabel: function getLabel(t) {
					return this._data[t];
				}, count: function count() {
					return this._extent[1] - this._extent[0] + 1;
				}, unionExtentFromData: function unionExtentFromData(t, e) {
					this.unionExtent(t.getDataExtent(e, !1));
				}, niceTicks: n.noop, niceExtent: n.noop });r.create = function () {
				return new r();
			}, t.exports = r;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(4),
			    o = i(7),
			    r = i(64),
			    s = i(43),
			    l = s.prototype,
			    u = Math.ceil,
			    c = Math.floor,
			    h = 1e3,
			    d = 60 * h,
			    f = 60 * d,
			    p = 24 * f,
			    g = function g(t, e, i, n) {
				for (; i < n;) {
					var a = i + n >>> 1;t[a][2] < e ? i = a + 1 : n = a;
				}return i;
			},
			    m = s.extend({ type: "time", getLabel: function getLabel(t) {
					var e = this._stepLvl,
					    i = new Date(t);return o.formatTime(e[0], i, this.getSetting("useUTC"));
				}, niceExtent: function niceExtent(t) {
					var e = this._extent;if (e[0] === e[1] && (e[0] -= p, e[1] += p), e[1] === -(1 / 0) && e[0] === 1 / 0) {
						var i = new Date();e[1] = new Date(i.getFullYear(), i.getMonth(), i.getDate()), e[0] = e[1] - p;
					}this.niceTicks(t.splitNumber);var n = this._interval;t.fixMin || (e[0] = a.round(c(e[0] / n) * n)), t.fixMax || (e[1] = a.round(u(e[1] / n) * n));
				}, niceTicks: function niceTicks(t) {
					var e = this.getSetting("useUTC") ? 0 : 60 * a.getTimezoneOffset() * 1e3;t = t || 10;var i = this._extent,
					    n = i[1] - i[0],
					    o = n / t,
					    s = v.length,
					    l = g(v, o, 0, s),
					    h = v[Math.min(l, s - 1)],
					    d = h[2];if ("year" === h[0]) {
						var f = n / d,
						    p = a.nice(f / t, !0);d *= p;
					}var m = [Math.round(u((i[0] - e) / d) * d + e), Math.round(c((i[1] - e) / d) * d + e)];r.fixExtent(m, i), this._stepLvl = h, this._interval = d, this._niceExtent = m;
				}, parse: function parse(t) {
					return +a.parseDate(t);
				} });n.each(["contain", "normalize"], function (t) {
				m.prototype[t] = function (e) {
					return l[t].call(this, this.parse(e));
				};
			});var v = [["hh:mm:ss", 1, h], ["hh:mm:ss", 5, 5 * h], ["hh:mm:ss", 10, 10 * h], ["hh:mm:ss", 15, 15 * h], ["hh:mm:ss", 30, 30 * h], ["hh:mm\nMM-dd", 1, d], ["hh:mm\nMM-dd", 5, 5 * d], ["hh:mm\nMM-dd", 10, 10 * d], ["hh:mm\nMM-dd", 15, 15 * d], ["hh:mm\nMM-dd", 30, 30 * d], ["hh:mm\nMM-dd", 1, f], ["hh:mm\nMM-dd", 2, 2 * f], ["hh:mm\nMM-dd", 6, 6 * f], ["hh:mm\nMM-dd", 12, 12 * f], ["MM-dd\nyyyy", 1, p], ["week", 7, 7 * p], ["month", 1, 31 * p], ["quarter", 3, 380 * p / 4], ["half-year", 6, 380 * p / 2], ["year", 1, 380 * p]];m.create = function (t) {
				return new m({ useUTC: t.ecModel.get("useUTC") });
			}, t.exports = m;
		}, function (t, e, i) {
			var n = i(39);t.exports = function (t) {
				function e(e) {
					var i = (e.visualColorAccessPath || "itemStyle.normal.color").split("."),
					    a = e.getData(),
					    o = e.get(i) || e.getColorFromPalette(e.get("name"));a.setVisual("color", o), t.isSeriesFiltered(e) || ("function" != typeof o || o instanceof n || a.each(function (t) {
						a.setItemVisual(t, "color", o(e.getDataParams(t)));
					}), a.each(function (t) {
						var e = a.getItemModel(t),
						    n = e.get(i, !0);null != n && a.setItemVisual(t, "color", n);
					}));
				}t.eachRawSeries(e);
			};
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				return { type: t, event: i, target: e.target, topTarget: e.topTarget, cancelBubble: !1, offsetX: i.zrX, offsetY: i.zrY, gestureEvent: i.gestureEvent, pinchX: i.pinchX, pinchY: i.pinchY, pinchScale: i.pinchScale, wheelDelta: i.zrDelta, zrByTouch: i.zrByTouch };
			}function a() {}function o(t, e, i) {
				if (t[t.rectHover ? "rectContain" : "contain"](e, i)) {
					for (var n, a = t; a;) {
						if (a.clipPath && !a.clipPath.contain(e, i)) return !1;a.silent && (n = !0), a = a.parent;
					}return !n || u;
				}return !1;
			}var r = i(1),
			    s = i(179),
			    l = i(23),
			    u = "silent";a.prototype.dispose = function () {};var c = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
			    h = function h(t, e, i, n) {
				l.call(this), this.storage = t, this.painter = e, this.painterRoot = n, i = i || new a(), this.proxy = i, i.handler = this, this._hovered = {}, this._lastTouchMoment, this._lastX, this._lastY, s.call(this), r.each(c, function (t) {
					i.on && i.on(t, this[t], this);
				}, this);
			};h.prototype = { constructor: h, mousemove: function mousemove(t) {
					var e = t.zrX,
					    i = t.zrY,
					    n = this._hovered,
					    a = this._hovered = this.findHover(e, i),
					    o = a.target,
					    r = n.target,
					    s = this.proxy;s.setCursor && s.setCursor(o ? o.cursor : "default"), r && o !== r && r.__zr && this.dispatchToElement(n, "mouseout", t), this.dispatchToElement(a, "mousemove", t), o && o !== r && this.dispatchToElement(a, "mouseover", t);
				}, mouseout: function mouseout(t) {
					this.dispatchToElement(this._hovered, "mouseout", t);var e,
					    i = t.toElement || t.relatedTarget;do {
						i = i && i.parentNode;
					} while (i && 9 != i.nodeType && !(e = i === this.painterRoot));!e && this.trigger("globalout", { event: t });
				}, resize: function resize(t) {
					this._hovered = {};
				}, dispatch: function dispatch(t, e) {
					var i = this[t];i && i.call(this, e);
				}, dispose: function dispose() {
					this.proxy.dispose(), this.storage = this.proxy = this.painter = null;
				}, setCursorStyle: function setCursorStyle(t) {
					var e = this.proxy;e.setCursor && e.setCursor(t);
				}, dispatchToElement: function dispatchToElement(t, e, i) {
					t = t || {};for (var a = "on" + e, o = n(e, t, i), r = t.target; r && (r[a] && (o.cancelBubble = r[a].call(r, o)), r.trigger(e, o), r = r.parent, !o.cancelBubble);) {}o.cancelBubble || (this.trigger(e, o), this.painter && this.painter.eachOtherLayer(function (t) {
						"function" == typeof t[a] && t[a].call(t, o), t.trigger && t.trigger(e, o);
					}));
				}, findHover: function findHover(t, e, i) {
					for (var n = this.storage.getDisplayList(), a = {}, r = n.length - 1; r >= 0; r--) {
						var s;if (n[r] !== i && !n[r].ignore && (s = o(n[r], t, e)) && (!a.topTarget && (a.topTarget = n[r]), s !== u)) {
							a.target = n[r];break;
						}
					}return a;
				} }, r.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function (t) {
				h.prototype[t] = function (e) {
					var i = this.findHover(e.zrX, e.zrY),
					    n = i.target;if ("mousedown" === t) this._downel = n, this._upel = n;else if ("mosueup" === t) this._upel = n;else if ("click" === t && this._downel !== this._upel) return;this.dispatchToElement(i, t, e);
				};
			}), r.mixin(h, l), r.mixin(h, s), t.exports = h;
		}, function (t, e, i) {
			function n() {
				return !1;
			}function a(t, e, i, n) {
				var a = document.createElement(e),
				    o = i.getWidth(),
				    r = i.getHeight(),
				    s = a.style;return s.position = "absolute", s.left = 0, s.top = 0, s.width = o + "px", s.height = r + "px", a.width = o * n, a.height = r * n, a.setAttribute("data-zr-dom-id", t), a;
			}var o = i(1),
			    r = i(35),
			    s = i(73),
			    l = i(72),
			    u = function u(t, e, i) {
				var s;i = i || r.devicePixelRatio, "string" == typeof t ? s = a(t, "canvas", e, i) : o.isObject(t) && (s = t, t = s.id), this.id = t, this.dom = s;var l = s.style;l && (s.onselectstart = n, l["-webkit-user-select"] = "none", l["user-select"] = "none", l["-webkit-touch-callout"] = "none", l["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", l.padding = 0, l.margin = 0, l["border-width"] = 0), this.domBack = null, this.ctxBack = null, this.painter = e, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = i;
			};u.prototype = { constructor: u, elCount: 0, __dirty: !0, initContext: function initContext() {
					this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
				}, createBackBuffer: function createBackBuffer() {
					var t = this.dpr;this.domBack = a("back-" + this.id, "canvas", this.painter, t), this.ctxBack = this.domBack.getContext("2d"), 1 != t && this.ctxBack.scale(t, t);
				}, resize: function resize(t, e) {
					var i = this.dpr,
					    n = this.dom,
					    a = n.style,
					    o = this.domBack;a.width = t + "px", a.height = e + "px", n.width = t * i, n.height = e * i, o && (o.width = t * i, o.height = e * i, 1 != i && this.ctxBack.scale(i, i));
				}, clear: function clear(t) {
					var e = this.dom,
					    i = this.ctx,
					    n = e.width,
					    a = e.height,
					    o = this.clearColor,
					    r = this.motionBlur && !t,
					    u = this.lastFrameAlpha,
					    c = this.dpr;if (r && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(e, 0, 0, n / c, a / c)), i.clearRect(0, 0, n, a), o) {
						var h;o.colorStops ? (h = o.__canvasGradient || s.getGradient(i, o, { x: 0, y: 0, width: n, height: a }), o.__canvasGradient = h) : o.image && (h = l.prototype.getCanvasPattern.call(o, i)), i.save(), i.fillStyle = h || o, i.fillRect(0, 0, n, a), i.restore();
					}if (r) {
						var d = this.domBack;i.save(), i.globalAlpha = u, i.drawImage(d, 0, 0, n, a), i.restore();
					}
				} }, t.exports = u;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return parseInt(t, 10);
			}function a(t) {
				return !!t && (!!t.__builtin__ || "function" == typeof t.resize && "function" == typeof t.refresh);
			}function o(t) {
				t.__unusedCount++;
			}function r(t) {
				1 == t.__unusedCount && t.clear();
			}function s(t, e, i) {
				return x.copy(t.getBoundingRect()), t.transform && x.applyTransform(t.transform), _.width = e, _.height = i, !x.intersect(_);
			}function l(t, e) {
				if (t == e) return !1;if (!t || !e || t.length !== e.length) return !0;for (var i = 0; i < t.length; i++) {
					if (t[i] !== e[i]) return !0;
				}
			}function u(t, e) {
				for (var i = 0; i < t.length; i++) {
					var n = t[i];n.setTransform(e), e.beginPath(), n.buildPath(e, n.shape), e.clip(), n.restoreTransform(e);
				}
			}function c(t, e) {
				var i = document.createElement("div");return i.style.cssText = ["position:relative", "overflow:hidden", "width:" + t + "px", "height:" + e + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";", i;
			}var h = i(35),
			    d = i(1),
			    f = i(52),
			    p = i(11),
			    g = i(51),
			    m = i(153),
			    v = i(68),
			    y = 5,
			    x = new p(0, 0, 0, 0),
			    _ = new p(0, 0, 0, 0),
			    b = function b(t, e, i) {
				var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();this._opts = i = d.extend({}, i || {}), this.dpr = i.devicePixelRatio || h.devicePixelRatio, this._singleCanvas = n, this.root = t;var a = t.style;a && (a["-webkit-tap-highlight-color"] = "transparent", a["-webkit-user-select"] = a["user-select"] = a["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e;var o = this._zlevelList = [],
				    r = this._layers = {};if (this._layerConfig = {}, n) {
					null != i.width && (t.width = i.width), null != i.height && (t.height = i.height);var s = t.width,
					    l = t.height;this._width = s, this._height = l;var u = new m(t, this, 1);u.initContext(), r[0] = u, o.push(0), this._domRoot = t;
				} else {
					this._width = this._getSize(0), this._height = this._getSize(1);var f = this._domRoot = c(this._width, this._height);t.appendChild(f);
				}this._progressiveLayers = [], this._hoverlayer, this._hoverElements = [];
			};b.prototype = { constructor: b, isSingleCanvas: function isSingleCanvas() {
					return this._singleCanvas;
				}, getViewportRoot: function getViewportRoot() {
					return this._domRoot;
				}, refresh: function refresh(t) {
					var e = this.storage.getDisplayList(!0),
					    i = this._zlevelList;this._paintList(e, t);for (var n = 0; n < i.length; n++) {
						var a = i[n],
						    o = this._layers[a];!o.__builtin__ && o.refresh && o.refresh();
					}return this.refreshHover(), this._progressiveLayers.length && this._startProgessive(), this;
				}, addHover: function addHover(t, e) {
					if (!t.__hoverMir) {
						var i = new t.constructor({ style: t.style, shape: t.shape });i.__from = t, t.__hoverMir = i, i.setStyle(e), this._hoverElements.push(i);
					}
				}, removeHover: function removeHover(t) {
					var e = t.__hoverMir,
					    i = this._hoverElements,
					    n = d.indexOf(i, e);n >= 0 && i.splice(n, 1), t.__hoverMir = null;
				}, clearHover: function clearHover(t) {
					for (var e = this._hoverElements, i = 0; i < e.length; i++) {
						var n = e[i].__from;n && (n.__hoverMir = null);
					}e.length = 0;
				}, refreshHover: function refreshHover() {
					var t = this._hoverElements,
					    e = t.length,
					    i = this._hoverlayer;if (i && i.clear(), e) {
						g(t, this.storage.displayableSortFunc), i || (i = this._hoverlayer = this.getLayer(1e5));var n = {};i.ctx.save();for (var a = 0; a < e;) {
							var o = t[a],
							    r = o.__from;r && r.__zr ? (a++, r.invisible || (o.transform = r.transform, o.invTransform = r.invTransform, o.__clipPaths = r.__clipPaths, this._doPaintEl(o, i, !0, n))) : (t.splice(a, 1), r.__hoverMir = null, e--);
						}i.ctx.restore();
					}
				}, _startProgessive: function _startProgessive() {
					function t() {
						i === e._progressiveToken && e.storage && (e._doPaintList(e.storage.getDisplayList()), e._furtherProgressive ? (e._progress++, v(t)) : e._progressiveToken = -1);
					}var e = this;if (e._furtherProgressive) {
						var i = e._progressiveToken = +new Date();e._progress++, v(t);
					}
				}, _clearProgressive: function _clearProgressive() {
					this._progressiveToken = -1, this._progress = 0, d.each(this._progressiveLayers, function (t) {
						t.__dirty && t.clear();
					});
				}, _paintList: function _paintList(t, e) {
					null == e && (e = !1), this._updateLayerStatus(t), this._clearProgressive(), this.eachBuiltinLayer(o), this._doPaintList(t, e), this.eachBuiltinLayer(r);
				}, _doPaintList: function _doPaintList(t, e) {
					function i(t) {
						var e = o.dpr || 1;o.save(), o.globalAlpha = 1, o.shadowBlur = 0, n.__dirty = !0, o.setTransform(1, 0, 0, 1, 0, 0), o.drawImage(t.dom, 0, 0, c * e, h * e), o.restore();
					}for (var n, a, o, r, s, l, u = 0, c = this._width, h = this._height, p = this._progress, g = 0, m = t.length; g < m; g++) {
						var v = t[g],
						    x = this._singleCanvas ? 0 : v.zlevel,
						    _ = v.__frame;if (_ < 0 && s && (i(s), s = null), a !== x && (o && o.restore(), r = {}, a = x, n = this.getLayer(a), n.__builtin__ || f("ZLevel " + a + " has been used by unkown layer " + n.id), o = n.ctx, o.save(), n.__unusedCount = 0, (n.__dirty || e) && n.clear()), n.__dirty || e) {
							if (_ >= 0) {
								if (!s) {
									if (s = this._progressiveLayers[Math.min(u++, y - 1)], s.ctx.save(), s.renderScope = {}, s && s.__progress > s.__maxProgress) {
										g = s.__nextIdxNotProg - 1;continue;
									}l = s.__progress, s.__dirty || (p = l), s.__progress = p + 1;
								}_ === p && this._doPaintEl(v, s, !0, s.renderScope);
							} else this._doPaintEl(v, n, e, r);v.__dirty = !1;
						}
					}s && i(s), o && o.restore(), this._furtherProgressive = !1, d.each(this._progressiveLayers, function (t) {
						t.__maxProgress >= t.__progress && (this._furtherProgressive = !0);
					}, this);
				}, _doPaintEl: function _doPaintEl(t, e, i, n) {
					var a = e.ctx,
					    o = t.transform;if ((e.__dirty || i) && !t.invisible && 0 !== t.style.opacity && (!o || o[0] || o[3]) && (!t.culling || !s(t, this._width, this._height))) {
						var r = t.__clipPaths;(n.prevClipLayer !== e || l(r, n.prevElClipPaths)) && (n.prevElClipPaths && (n.prevClipLayer.ctx.restore(), n.prevClipLayer = n.prevElClipPaths = null, n.prevEl = null), r && (a.save(), u(r, a), n.prevClipLayer = e, n.prevElClipPaths = r)), t.beforeBrush && t.beforeBrush(a), t.brush(a, n.prevEl || null), n.prevEl = t, t.afterBrush && t.afterBrush(a);
					}
				}, getLayer: function getLayer(t) {
					if (this._singleCanvas) return this._layers[0];var e = this._layers[t];return e || (e = new m("zr_" + t, this, this.dpr), e.__builtin__ = !0, this._layerConfig[t] && d.merge(e, this._layerConfig[t], !0), this.insertLayer(t, e), e.initContext()), e;
				}, insertLayer: function insertLayer(t, e) {
					var i = this._layers,
					    n = this._zlevelList,
					    o = n.length,
					    r = null,
					    s = -1,
					    l = this._domRoot;if (i[t]) return void f("ZLevel " + t + " has been used already");if (!a(e)) return void f("Layer of zlevel " + t + " is not valid");if (o > 0 && t > n[0]) {
						for (s = 0; s < o - 1 && !(n[s] < t && n[s + 1] > t); s++) {}r = i[n[s]];
					}if (n.splice(s + 1, 0, t), i[t] = e, !e.virtual) if (r) {
						var u = r.dom;u.nextSibling ? l.insertBefore(e.dom, u.nextSibling) : l.appendChild(e.dom);
					} else l.firstChild ? l.insertBefore(e.dom, l.firstChild) : l.appendChild(e.dom);
				}, eachLayer: function eachLayer(t, e) {
					var i,
					    n,
					    a = this._zlevelList;for (n = 0; n < a.length; n++) {
						i = a[n], t.call(e, this._layers[i], i);
					}
				}, eachBuiltinLayer: function eachBuiltinLayer(t, e) {
					var i,
					    n,
					    a,
					    o = this._zlevelList;for (a = 0; a < o.length; a++) {
						n = o[a], i = this._layers[n], i.__builtin__ && t.call(e, i, n);
					}
				}, eachOtherLayer: function eachOtherLayer(t, e) {
					var i,
					    n,
					    a,
					    o = this._zlevelList;for (a = 0; a < o.length; a++) {
						n = o[a], i = this._layers[n], i.__builtin__ || t.call(e, i, n);
					}
				}, getLayers: function getLayers() {
					return this._layers;
				}, _updateLayerStatus: function _updateLayerStatus(t) {
					var e = this._layers,
					    i = this._progressiveLayers,
					    n = {},
					    a = {};this.eachBuiltinLayer(function (t, e) {
						n[e] = t.elCount, t.elCount = 0, t.__dirty = !1;
					}), d.each(i, function (t, e) {
						a[e] = t.elCount, t.elCount = 0, t.__dirty = !1;
					});for (var o, r, s = 0, l = 0, u = 0, c = t.length; u < c; u++) {
						var h = t[u],
						    f = this._singleCanvas ? 0 : h.zlevel,
						    p = e[f],
						    g = h.progressive;if (p && (p.elCount++, p.__dirty = p.__dirty || h.__dirty), g >= 0) {
							r !== g && (r = g, l++);var v = h.__frame = l - 1;if (!o) {
								var x = Math.min(s, y - 1);o = i[x], o || (o = i[x] = new m("progressive", this, this.dpr), o.initContext()), o.__maxProgress = 0;
							}o.__dirty = o.__dirty || h.__dirty, o.elCount++, o.__maxProgress = Math.max(o.__maxProgress, v), o.__maxProgress >= o.__progress && (p.__dirty = !0);
						} else h.__frame = -1, o && (o.__nextIdxNotProg = u, s++, o = null);
					}o && (s++, o.__nextIdxNotProg = u), this.eachBuiltinLayer(function (t, e) {
						n[e] !== t.elCount && (t.__dirty = !0);
					}), i.length = Math.min(s, y), d.each(i, function (t, e) {
						a[e] !== t.elCount && (h.__dirty = !0), t.__dirty && (t.__progress = 0);
					});
				}, clear: function clear() {
					return this.eachBuiltinLayer(this._clearLayer), this;
				}, _clearLayer: function _clearLayer(t) {
					t.clear();
				}, configLayer: function configLayer(t, e) {
					if (e) {
						var i = this._layerConfig;i[t] ? d.merge(i[t], e, !0) : i[t] = e;var n = this._layers[t];n && d.merge(n, i[t], !0);
					}
				}, delLayer: function delLayer(t) {
					var e = this._layers,
					    i = this._zlevelList,
					    n = e[t];n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i.splice(d.indexOf(i, t), 1));
				}, resize: function resize(t, e) {
					var i = this._domRoot;i.style.display = "none";var n = this._opts;if (null != t && (n.width = t), null != e && (n.height = e), t = this._getSize(0), e = this._getSize(1), i.style.display = "", this._width != t || e != this._height) {
						i.style.width = t + "px", i.style.height = e + "px";for (var a in this._layers) {
							this._layers.hasOwnProperty(a) && this._layers[a].resize(t, e);
						}d.each(this._progressiveLayers, function (i) {
							i.resize(t, e);
						}), this.refresh(!0);
					}return this._width = t, this._height = e, this;
				}, clearLayer: function clearLayer(t) {
					var e = this._layers[t];e && e.clear();
				}, dispose: function dispose() {
					this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
				}, getRenderedCanvas: function getRenderedCanvas(t) {
					function e(t, e) {
						var n = r._zlevelList;null == t && (t = -(1 / 0));for (var a, o = 0; o < n.length; o++) {
							var s = n[o],
							    l = r._layers[s];if (!l.__builtin__ && s > t && s < e) {
								a = l;break;
							}
						}a && a.renderToCanvas && (i.ctx.save(), a.renderToCanvas(i.ctx), i.ctx.restore());
					}if (t = t || {}, this._singleCanvas) return this._layers[0].dom;var i = new m("image", this, t.pixelRatio || this.dpr);i.initContext(), i.clearColor = t.backgroundColor, i.clear();for (var n, a = this.storage.getDisplayList(!0), o = {}, r = this, s = 0; s < a.length; s++) {
						var l = a[s];l.zlevel !== n && (e(n, l.zlevel), n = l.zlevel), this._doPaintEl(l, i, !0, o);
					}return e(n, 1 / 0), i.dom;
				}, getWidth: function getWidth() {
					return this._width;
				}, getHeight: function getHeight() {
					return this._height;
				}, _getSize: function _getSize(t) {
					var e = this._opts,
					    i = ["width", "height"][t],
					    a = ["clientWidth", "clientHeight"][t],
					    o = ["paddingLeft", "paddingTop"][t],
					    r = ["paddingRight", "paddingBottom"][t];if (null != e[i] && "auto" !== e[i]) return parseFloat(e[i]);var s = this.root,
					    l = document.defaultView.getComputedStyle(s);return (s[a] || n(l[i]) || n(s.style[i])) - (n(l[o]) || 0) - (n(l[r]) || 0) | 0;
				}, pathToImage: function pathToImage(t, e) {
					e = e || this.dpr;var n = document.createElement("canvas"),
					    a = n.getContext("2d"),
					    o = t.getBoundingRect(),
					    r = t.style,
					    s = r.shadowBlur,
					    l = r.shadowOffsetX,
					    u = r.shadowOffsetY,
					    c = r.hasStroke() ? r.lineWidth : 0,
					    h = Math.max(c / 2, -l + s),
					    d = Math.max(c / 2, l + s),
					    f = Math.max(c / 2, -u + s),
					    p = Math.max(c / 2, u + s),
					    g = o.width + h + d,
					    m = o.height + f + p;n.width = g * e, n.height = m * e, a.scale(e, e), a.clearRect(0, 0, g, m), a.dpr = e;var v = { position: t.position, rotation: t.rotation, scale: t.scale };t.position = [h - o.x, f - o.y], t.rotation = 0, t.scale = [1, 1], t.updateTransform(), t && t.brush(a);var y = i(53),
					    x = new y({ style: { x: 0, y: 0, image: n } });return null != v.position && (x.position = t.position = v.position), null != v.rotation && (x.rotation = t.rotation = v.rotation), null != v.scale && (x.scale = t.scale = v.scale), x;
				} }, t.exports = b;
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel;
			}var a = i(1),
			    o = i(9),
			    r = i(36),
			    s = i(51),
			    l = function l() {
				this._roots = [], this._displayList = [], this._displayListLen = 0;
			};l.prototype = { constructor: l, traverse: function traverse(t, e) {
					for (var i = 0; i < this._roots.length; i++) {
						this._roots[i].traverse(t, e);
					}
				}, getDisplayList: function getDisplayList(t, e) {
					return e = e || !1, t && this.updateDisplayList(e), this._displayList;
				}, updateDisplayList: function updateDisplayList(t) {
					this._displayListLen = 0;for (var e = this._roots, i = this._displayList, a = 0, r = e.length; a < r; a++) {
						this._updateAndAddDisplayable(e[a], null, t);
					}i.length = this._displayListLen, o.canvasSupported && s(i, n);
				}, _updateAndAddDisplayable: function _updateAndAddDisplayable(t, e, i) {
					if (!t.ignore || i) {
						t.beforeUpdate(), t.__dirty && t.update(), t.afterUpdate();var n = t.clipPath;if (n) {
							e = e ? e.slice() : [];for (var a = n, o = t; a;) {
								a.parent = o, a.updateTransform(), e.push(a), o = a, a = a.clipPath;
							}
						}if (t.isGroup) {
							for (var r = t._children, s = 0; s < r.length; s++) {
								var l = r[s];t.__dirty && (l.__dirty = !0), this._updateAndAddDisplayable(l, e, i);
							}t.__dirty = !1;
						} else t.__clipPaths = e, this._displayList[this._displayListLen++] = t;
					}
				}, addRoot: function addRoot(t) {
					t.__storage !== this && (t instanceof r && t.addChildrenToStorage(this), this.addToStorage(t), this._roots.push(t));
				}, delRoot: function delRoot(t) {
					if (null == t) {
						for (var e = 0; e < this._roots.length; e++) {
							var i = this._roots[e];i instanceof r && i.delChildrenFromStorage(this);
						}return this._roots = [], this._displayList = [], void (this._displayListLen = 0);
					}if (t instanceof Array) for (var e = 0, n = t.length; e < n; e++) {
						this.delRoot(t[e]);
					} else {
						var o = a.indexOf(this._roots, t);o >= 0 && (this.delFromStorage(t), this._roots.splice(o, 1), t instanceof r && t.delChildrenFromStorage(this));
					}
				}, addToStorage: function addToStorage(t) {
					return t.__storage = this, t.dirty(!1), this;
				}, delFromStorage: function delFromStorage(t) {
					return t && (t.__storage = null), this;
				}, dispose: function dispose() {
					this._renderList = this._roots = null;
				}, displayableSortFunc: n }, t.exports = l;
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(21).Dispatcher,
			    o = i(68),
			    r = i(67),
			    s = function s(t) {
				t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function () {}, this._clips = [], this._running = !1, this._time, this._pausedTime, this._pauseStart, this._paused = !1, a.call(this);
			};s.prototype = { constructor: s, addClip: function addClip(t) {
					this._clips.push(t);
				}, addAnimator: function addAnimator(t) {
					t.animation = this;for (var e = t.getClips(), i = 0; i < e.length; i++) {
						this.addClip(e[i]);
					}
				}, removeClip: function removeClip(t) {
					var e = n.indexOf(this._clips, t);e >= 0 && this._clips.splice(e, 1);
				}, removeAnimator: function removeAnimator(t) {
					for (var e = t.getClips(), i = 0; i < e.length; i++) {
						this.removeClip(e[i]);
					}t.animation = null;
				}, _update: function _update() {
					for (var t = new Date().getTime() - this._pausedTime, e = t - this._time, i = this._clips, n = i.length, a = [], o = [], r = 0; r < n; r++) {
						var s = i[r],
						    l = s.step(t, e);l && (a.push(l), o.push(s));
					}for (var r = 0; r < n;) {
						i[r]._needsRemove ? (i[r] = i[n - 1], i.pop(), n--) : r++;
					}n = a.length;for (var r = 0; r < n; r++) {
						o[r].fire(a[r]);
					}this._time = t, this.onframe(e), this.trigger("frame", e), this.stage.update && this.stage.update();
				}, _startLoop: function _startLoop() {
					function t() {
						e._running && (o(t), !e._paused && e._update());
					}var e = this;this._running = !0, o(t);
				}, start: function start() {
					this._time = new Date().getTime(), this._pausedTime = 0, this._startLoop();
				}, stop: function stop() {
					this._running = !1;
				}, pause: function pause() {
					this._paused || (this._pauseStart = new Date().getTime(), this._paused = !0);
				}, resume: function resume() {
					this._paused && (this._pausedTime += new Date().getTime() - this._pauseStart, this._paused = !1);
				}, clear: function clear() {
					this._clips = [];
				}, animate: function animate(t, e) {
					e = e || {};var i = new r(t, e.loop, e.getter, e.setter);return this.addAnimator(i), i;
				} }, n.mixin(s, a), t.exports = s;
		}, function (t, e, i) {
			function n(t) {
				this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null != t.loop && t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart, this._pausedTime = 0, this._paused = !1;
			}var a = i(158);n.prototype = { constructor: n, step: function step(t, e) {
					if (this._initialized || (this._startTime = t + this._delay, this._initialized = !0), this._paused) return void (this._pausedTime += e);var i = (t - this._startTime - this._pausedTime) / this._life;if (!(i < 0)) {
						i = Math.min(i, 1);var n = this.easing,
						    o = "string" == typeof n ? a[n] : n,
						    r = "function" == typeof o ? o(i) : i;return this.fire("frame", r), 1 == i ? this.loop ? (this.restart(t), "restart") : (this._needsRemove = !0, "destroy") : null;
					}
				}, restart: function restart(t) {
					var e = (t - this._startTime - this._pausedTime) % this._life;this._startTime = t - e + this.gap, this._pausedTime = 0, this._needsRemove = !1;
				}, fire: function fire(t, e) {
					t = "on" + t, this[t] && this[t](this._target, e);
				}, pause: function pause() {
					this._paused = !0;
				}, resume: function resume() {
					this._paused = !1;
				} }, t.exports = n;
		}, function (t, e) {
			var i = { linear: function linear(t) {
					return t;
				}, quadraticIn: function quadraticIn(t) {
					return t * t;
				}, quadraticOut: function quadraticOut(t) {
					return t * (2 - t);
				}, quadraticInOut: function quadraticInOut(t) {
					return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1);
				}, cubicIn: function cubicIn(t) {
					return t * t * t;
				}, cubicOut: function cubicOut(t) {
					return --t * t * t + 1;
				}, cubicInOut: function cubicInOut(t) {
					return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2);
				}, quarticIn: function quarticIn(t) {
					return t * t * t * t;
				}, quarticOut: function quarticOut(t) {
					return 1 - --t * t * t * t;
				}, quarticInOut: function quarticInOut(t) {
					return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2);
				}, quinticIn: function quinticIn(t) {
					return t * t * t * t * t;
				}, quinticOut: function quinticOut(t) {
					return --t * t * t * t * t + 1;
				}, quinticInOut: function quinticInOut(t) {
					return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2);
				}, sinusoidalIn: function sinusoidalIn(t) {
					return 1 - Math.cos(t * Math.PI / 2);
				}, sinusoidalOut: function sinusoidalOut(t) {
					return Math.sin(t * Math.PI / 2);
				}, sinusoidalInOut: function sinusoidalInOut(t) {
					return .5 * (1 - Math.cos(Math.PI * t));
				}, exponentialIn: function exponentialIn(t) {
					return 0 === t ? 0 : Math.pow(1024, t - 1);
				}, exponentialOut: function exponentialOut(t) {
					return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
				}, exponentialInOut: function exponentialInOut(t) {
					return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2);
				}, circularIn: function circularIn(t) {
					return 1 - Math.sqrt(1 - t * t);
				}, circularOut: function circularOut(t) {
					return Math.sqrt(1 - --t * t);
				}, circularInOut: function circularInOut(t) {
					return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
				}, elasticIn: function elasticIn(t) {
					var e,
					    i = .1,
					    n = .4;return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n)));
				}, elasticOut: function elasticOut(t) {
					var e,
					    i = .1,
					    n = .4;return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / n) + 1);
				}, elasticInOut: function elasticInOut(t) {
					var e,
					    i = .1,
					    n = .4;return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * (i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n)) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n) * .5 + 1);
				}, backIn: function backIn(t) {
					var e = 1.70158;return t * t * ((e + 1) * t - e);
				}, backOut: function backOut(t) {
					var e = 1.70158;return --t * t * ((e + 1) * t + e) + 1;
				}, backInOut: function backInOut(t) {
					var e = 2.5949095;return (t *= 2) < 1 ? .5 * (t * t * ((e + 1) * t - e)) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2);
				}, bounceIn: function bounceIn(t) {
					return 1 - i.bounceOut(1 - t);
				}, bounceOut: function bounceOut(t) {
					return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
				}, bounceInOut: function bounceInOut(t) {
					return t < .5 ? .5 * i.bounceIn(2 * t) : .5 * i.bounceOut(2 * t - 1) + .5;
				} };t.exports = i;
		}, function (t, e, i) {
			var n = i(69).normalizeRadian,
			    a = 2 * Math.PI;t.exports = { containStroke: function containStroke(t, e, i, o, r, s, l, u, c) {
					if (0 === l) return !1;var h = l;u -= t, c -= e;var d = Math.sqrt(u * u + c * c);if (d - h > i || d + h < i) return !1;if (Math.abs(o - r) % a < 1e-4) return !0;if (s) {
						var f = o;o = n(r), r = n(f);
					} else o = n(o), r = n(r);o > r && (r += a);var p = Math.atan2(c, u);return p < 0 && (p += a), p >= o && p <= r || p + a >= o && p + a <= r;
				} };
		}, function (t, e, i) {
			var n = i(20);t.exports = { containStroke: function containStroke(t, e, i, a, o, r, s, l, u, c, h) {
					if (0 === u) return !1;var d = u;if (h > e + d && h > a + d && h > r + d && h > l + d || h < e - d && h < a - d && h < r - d && h < l - d || c > t + d && c > i + d && c > o + d && c > s + d || c < t - d && c < i - d && c < o - d && c < s - d) return !1;var f = n.cubicProjectPoint(t, e, i, a, o, r, s, l, c, h, null);return f <= d / 2;
				} };
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				return Math.abs(t - e) < x;
			}function a() {
				var t = b[0];b[0] = b[1], b[1] = t;
			}function o(t, e, i, n, o, r, s, l, u, c) {
				if (c > e && c > n && c > r && c > l || c < e && c < n && c < r && c < l) return 0;var h = g.cubicRootAt(e, n, r, l, c, _);if (0 === h) return 0;for (var d, f, p = 0, m = -1, v = 0; v < h; v++) {
					var y = _[v],
					    x = 0 === y || 1 === y ? .5 : 1,
					    w = g.cubicAt(t, i, o, s, y);w < u || (m < 0 && (m = g.cubicExtrema(e, n, r, l, b), b[1] < b[0] && m > 1 && a(), d = g.cubicAt(e, n, r, l, b[0]), m > 1 && (f = g.cubicAt(e, n, r, l, b[1]))), p += 2 == m ? y < b[0] ? d < e ? x : -x : y < b[1] ? f < d ? x : -x : l < f ? x : -x : y < b[0] ? d < e ? x : -x : l < d ? x : -x);
				}return p;
			}function r(t, e, i, n, a, o, r, s) {
				if (s > e && s > n && s > o || s < e && s < n && s < o) return 0;var l = g.quadraticRootAt(e, n, o, s, _);if (0 === l) return 0;var u = g.quadraticExtremum(e, n, o);if (u >= 0 && u <= 1) {
					for (var c = 0, h = g.quadraticAt(e, n, o, u), d = 0; d < l; d++) {
						var f = 0 === _[d] || 1 === _[d] ? .5 : 1,
						    p = g.quadraticAt(t, i, a, _[d]);p < r || (c += _[d] < u ? h < e ? f : -f : o < h ? f : -f);
					}return c;
				}var f = 0 === _[0] || 1 === _[0] ? .5 : 1,
				    p = g.quadraticAt(t, i, a, _[0]);return p < r ? 0 : o < e ? f : -f;
			}function s(t, e, i, n, a, o, r, s) {
				if (s -= e, s > i || s < -i) return 0;var l = Math.sqrt(i * i - s * s);_[0] = -l, _[1] = l;var u = Math.abs(n - a);if (u < 1e-4) return 0;if (u % y < 1e-4) {
					n = 0, a = y;var c = o ? 1 : -1;return r >= _[0] + t && r <= _[1] + t ? c : 0;
				}if (o) {
					var l = n;n = p(a), a = p(l);
				} else n = p(n), a = p(a);n > a && (a += y);for (var h = 0, d = 0; d < 2; d++) {
					var f = _[d];if (f + t > r) {
						var g = Math.atan2(s, f),
						    c = o ? 1 : -1;g < 0 && (g = y + g), (g >= n && g <= a || g + y >= n && g + y <= a) && (g > Math.PI / 2 && g < 1.5 * Math.PI && (c = -c), h += c);
					}
				}return h;
			}function l(t, e, i, a, l) {
				for (var c = 0, p = 0, g = 0, y = 0, x = 0, _ = 0; _ < t.length;) {
					var b = t[_++];switch (b === u.M && _ > 1 && (i || (c += m(p, g, y, x, a, l))), 1 == _ && (p = t[_], g = t[_ + 1], y = p, x = g), b) {case u.M:
							y = t[_++], x = t[_++], p = y, g = x;break;case u.L:
							if (i) {
								if (v(p, g, t[_], t[_ + 1], e, a, l)) return !0;
							} else c += m(p, g, t[_], t[_ + 1], a, l) || 0;p = t[_++], g = t[_++];break;case u.C:
							if (i) {
								if (h.containStroke(p, g, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], e, a, l)) return !0;
							} else c += o(p, g, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], a, l) || 0;p = t[_++], g = t[_++];break;case u.Q:
							if (i) {
								if (d.containStroke(p, g, t[_++], t[_++], t[_], t[_ + 1], e, a, l)) return !0;
							} else c += r(p, g, t[_++], t[_++], t[_], t[_ + 1], a, l) || 0;p = t[_++], g = t[_++];break;case u.A:
							var w = t[_++],
							    S = t[_++],
							    M = t[_++],
							    I = t[_++],
							    T = t[_++],
							    A = t[_++],
							    C = (t[_++], 1 - t[_++]),
							    L = Math.cos(T) * M + w,
							    D = Math.sin(T) * I + S;_ > 1 ? c += m(p, g, L, D, a, l) : (y = L, x = D);var P = (a - w) * I / M + w;if (i) {
								if (f.containStroke(w, S, I, T, T + A, C, e, P, l)) return !0;
							} else c += s(w, S, I, T, T + A, C, P, l);p = Math.cos(T + A) * M + w, g = Math.sin(T + A) * I + S;break;case u.R:
							y = p = t[_++], x = g = t[_++];var k = t[_++],
							    O = t[_++],
							    L = y + k,
							    D = x + O;if (i) {
								if (v(y, x, L, x, e, a, l) || v(L, x, L, D, e, a, l) || v(L, D, y, D, e, a, l) || v(y, D, y, x, e, a, l)) return !0;
							} else c += m(L, x, L, D, a, l), c += m(y, D, y, x, a, l);break;case u.Z:
							if (i) {
								if (v(p, g, y, x, e, a, l)) return !0;
							} else c += m(p, g, y, x, a, l);p = y, g = x;}
				}return i || n(g, x) || (c += m(p, g, y, x, a, l) || 0), 0 !== c;
			}var u = i(27).CMD,
			    c = i(97),
			    h = i(160),
			    d = i(98),
			    f = i(159),
			    p = i(69).normalizeRadian,
			    g = i(20),
			    m = i(99),
			    v = c.containStroke,
			    y = 2 * Math.PI,
			    x = 1e-4,
			    _ = [-1, -1, -1],
			    b = [-1, -1];t.exports = { contain: function contain(t, e, i) {
					return l(t, 0, !1, e, i);
				}, containStroke: function containStroke(t, e, i, n) {
					return l(t, e, !0, i, n);
				} };
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				var e = t[1][0] - t[0][0],
				    i = t[1][1] - t[0][1];return Math.sqrt(e * e + i * i);
			}function a(t) {
				return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2];
			}var o = i(21),
			    r = function r() {
				this._track = [];
			};r.prototype = { constructor: r, recognize: function recognize(t, e, i) {
					return this._doTrack(t, e, i), this._recognize(t);
				}, clear: function clear() {
					return this._track.length = 0, this;
				}, _doTrack: function _doTrack(t, e, i) {
					var n = t.touches;if (n) {
						for (var a = { points: [], touches: [], target: e, event: t }, r = 0, s = n.length; r < s; r++) {
							var l = n[r],
							    u = o.clientToLocal(i, l, {});a.points.push([u.zrX, u.zrY]), a.touches.push(l);
						}this._track.push(a);
					}
				}, _recognize: function _recognize(t) {
					for (var e in s) {
						if (s.hasOwnProperty(e)) {
							var i = s[e](this._track, t);if (i) return i;
						}
					}
				} };var s = { pinch: function pinch(t, e) {
					var i = t.length;if (i) {
						var o = (t[i - 1] || {}).points,
						    r = (t[i - 2] || {}).points || o;if (r && r.length > 1 && o && o.length > 1) {
							var s = n(o) / n(r);!isFinite(s) && (s = 1), e.pinchScale = s;var l = a(o);return e.pinchX = l[0], e.pinchY = l[1], { type: "pinch", target: t[0].target, event: e };
						}
					}
				} };t.exports = r;
		}, function (t, e, i) {
			function n(t) {
				return "mousewheel" === t && d.browser.firefox ? "DOMMouseScroll" : t;
			}function a(t, e, i) {
				var n = t._gestureMgr;"start" === i && n.clear();var a = n.recognize(e, t.handler.findHover(e.zrX, e.zrY, null).target, t.dom);if ("end" === i && n.clear(), a) {
					var o = a.type;e.gestureEvent = o, t.handler.dispatchToElement({ target: a.target }, o, a.event);
				}
			}function o(t) {
				t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(function () {
					t._touching = !1;
				}, 700);
			}function r(t) {
				var e = t.pointerType;return "pen" === e || "touch" === e;
			}function s(t) {
				function e(t, e) {
					return function () {
						if (!e._touching) return t.apply(e, arguments);
					};
				}c.each(x, function (e) {
					t._handlers[e] = c.bind(w[e], t);
				}), c.each(b, function (e) {
					t._handlers[e] = c.bind(w[e], t);
				}), c.each(y, function (i) {
					t._handlers[i] = e(w[i], t);
				});
			}function l(t) {
				function e(e, i) {
					c.each(e, function (e) {
						p(t, n(e), i._handlers[e]);
					}, i);
				}h.call(this), this.dom = t, this._touching = !1, this._touchTimer, this._gestureMgr = new f(), this._handlers = {}, s(this), d.pointerEventsSupported ? e(b, this) : (d.touchEventsSupported && e(x, this), e(y, this));
			}var u = i(21),
			    c = i(1),
			    h = i(23),
			    d = i(9),
			    f = i(162),
			    p = u.addEventListener,
			    g = u.removeEventListener,
			    m = u.normalizeEvent,
			    v = 300,
			    y = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
			    x = ["touchstart", "touchend", "touchmove"],
			    _ = { pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1 },
			    b = c.map(y, function (t) {
				var e = t.replace("mouse", "pointer");return _[e] ? e : t;
			}),
			    w = { mousemove: function mousemove(t) {
					t = m(this.dom, t), this.trigger("mousemove", t);
				}, mouseout: function mouseout(t) {
					t = m(this.dom, t);var e = t.toElement || t.relatedTarget;if (e != this.dom) for (; e && 9 != e.nodeType;) {
						if (e === this.dom) return;e = e.parentNode;
					}this.trigger("mouseout", t);
				}, touchstart: function touchstart(t) {
					t = m(this.dom, t), t.zrByTouch = !0, this._lastTouchMoment = new Date(), a(this, t, "start"), w.mousemove.call(this, t), w.mousedown.call(this, t), o(this);
				}, touchmove: function touchmove(t) {
					t = m(this.dom, t), t.zrByTouch = !0, a(this, t, "change"), w.mousemove.call(this, t), o(this);
				}, touchend: function touchend(t) {
					t = m(this.dom, t), t.zrByTouch = !0, a(this, t, "end"), w.mouseup.call(this, t), +new Date() - this._lastTouchMoment < v && w.click.call(this, t), o(this);
				}, pointerdown: function pointerdown(t) {
					w.mousedown.call(this, t);
				}, pointermove: function pointermove(t) {
					r(t) || w.mousemove.call(this, t);
				}, pointerup: function pointerup(t) {
					w.mouseup.call(this, t);
				}, pointerout: function pointerout(t) {
					r(t) || w.mouseout.call(this, t);
				} };c.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function (t) {
				w[t] = function (e) {
					e = m(this.dom, e), this.trigger(t, e);
				};
			});var S = l.prototype;S.dispose = function () {
				for (var t = y.concat(x), e = 0; e < t.length; e++) {
					var i = t[e];g(this.dom, n(i), this._handlers[i]);
				}
			}, S.setCursor = function (t) {
				this.dom.style.cursor = t || "default";
			}, c.mixin(l, h), t.exports = l;
		}, function (t, e, i) {
			var n = i(8);t.exports = n.extend({ type: "compound", shape: { paths: null }, _updatePathDirty: function _updatePathDirty() {
					for (var t = this.__dirtyPath, e = this.shape.paths, i = 0; i < e.length; i++) {
						t = t || e[i].__dirtyPath;
					}this.__dirtyPath = t, this.__dirty = this.__dirty || t;
				}, beforeBrush: function beforeBrush() {
					this._updatePathDirty();for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t.length; i++) {
						t[i].path || t[i].createPathProxy(), t[i].path.setScale(e[0], e[1]);
					}
				}, buildPath: function buildPath(t, e) {
					for (var i = e.paths || [], n = 0; n < i.length; n++) {
						i[n].buildPath(t, i[n].shape, !0);
					}
				}, afterBrush: function afterBrush() {
					for (var t = this.shape.paths, e = 0; e < t.length; e++) {
						t[e].__dirtyPath = !1;
					}
				}, getBoundingRect: function getBoundingRect() {
					return this._updatePathDirty(), n.prototype.getBoundingRect.call(this);
				} });
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(39),
			    o = function o(t, e, i, n, _o3) {
				this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == i ? .5 : i, this.type = "radial", this.global = _o3 || !1, a.call(this, n);
			};o.prototype = { constructor: o }, n.inherits(o, a), t.exports = o;
		}, function (t, e) {
			t.exports = { buildPath: function buildPath(t, e) {
					var i,
					    n,
					    a,
					    o,
					    r = e.x,
					    s = e.y,
					    l = e.width,
					    u = e.height,
					    c = e.r;l < 0 && (r += l, l = -l), u < 0 && (s += u, u = -u), "number" == typeof c ? i = n = a = o = c : c instanceof Array ? 1 === c.length ? i = n = a = o = c[0] : 2 === c.length ? (i = a = c[0], n = o = c[1]) : 3 === c.length ? (i = c[0], n = o = c[1], a = c[2]) : (i = c[0], n = c[1], a = c[2], o = c[3]) : i = n = a = o = 0;var h;i + n > l && (h = i + n, i *= l / h, n *= l / h), a + o > l && (h = a + o, a *= l / h, o *= l / h), n + a > u && (h = n + a, n *= u / h, a *= u / h), i + o > u && (h = i + o, i *= u / h, o *= u / h), t.moveTo(r + i, s), t.lineTo(r + l - n, s), 0 !== n && t.quadraticCurveTo(r + l, s, r + l, s + n), t.lineTo(r + l, s + u - a), 0 !== a && t.quadraticCurveTo(r + l, s + u, r + l - a, s + u), t.lineTo(r + o, s + u), 0 !== o && t.quadraticCurveTo(r, s + u, r, s + u - o), t.lineTo(r, s + i), 0 !== i && t.quadraticCurveTo(r, s, r + i, s);
				} };
		}, function (t, e, i) {
			var n = i(6),
			    a = n.min,
			    o = n.max,
			    r = n.scale,
			    s = n.distance,
			    l = n.add;t.exports = function (t, e, i, u) {
				var c,
				    h,
				    d,
				    f,
				    p = [],
				    g = [],
				    m = [],
				    v = [];if (u) {
					d = [1 / 0, 1 / 0], f = [-(1 / 0), -(1 / 0)];for (var y = 0, x = t.length; y < x; y++) {
						a(d, d, t[y]), o(f, f, t[y]);
					}a(d, d, u[0]), o(f, f, u[1]);
				}for (var y = 0, x = t.length; y < x; y++) {
					var _ = t[y];if (i) c = t[y ? y - 1 : x - 1], h = t[(y + 1) % x];else {
						if (0 === y || y === x - 1) {
							p.push(n.clone(t[y]));continue;
						}c = t[y - 1], h = t[y + 1];
					}n.sub(g, h, c), r(g, g, e);var b = s(_, c),
					    w = s(_, h),
					    S = b + w;0 !== S && (b /= S, w /= S), r(m, g, -b), r(v, g, w);var M = l([], _, m),
					    I = l([], _, v);u && (o(M, M, d), a(M, M, f), o(I, I, d), a(I, I, f)), p.push(M), p.push(I);
				}return i && p.push(p.shift()), p;
			};
		}, function (t, e, i) {
			function n(t, e, i, n, a, o, r) {
				var s = .5 * (i - t),
				    l = .5 * (n - e);return (2 * (e - i) + s + l) * r + (-3 * (e - i) - 2 * s - l) * o + s * a + e;
			}var a = i(6);t.exports = function (t, e) {
				for (var i = t.length, o = [], r = 0, s = 1; s < i; s++) {
					r += a.distance(t[s - 1], t[s]);
				}var l = r / 2;l = l < i ? i : l;for (var s = 0; s < l; s++) {
					var u,
					    c,
					    h,
					    d = s / (l - 1) * (e ? i : i - 1),
					    f = Math.floor(d),
					    p = d - f,
					    g = t[f % i];e ? (u = t[(f - 1 + i) % i], c = t[(f + 1) % i], h = t[(f + 2) % i]) : (u = t[0 === f ? f : f - 1], c = t[f > i - 2 ? i - 1 : f + 1], h = t[f > i - 3 ? i - 1 : f + 2]);var m = p * p,
					    v = p * m;o.push([n(u[0], g[0], c[0], h[0], p, m, v), n(u[1], g[1], c[1], h[1], p, m, v)]);
				}return o;
			};
		}, function (t, e, i) {
			t.exports = i(8).extend({ type: "arc", shape: { cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, style: { stroke: "#000", fill: null }, buildPath: function buildPath(t, e) {
					var i = e.cx,
					    n = e.cy,
					    a = Math.max(e.r, 0),
					    o = e.startAngle,
					    r = e.endAngle,
					    s = e.clockwise,
					    l = Math.cos(o),
					    u = Math.sin(o);t.moveTo(l * a + i, u * a + n), t.arc(i, n, a, o, r, !s);
				} });
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				var n = t.cpx2,
				    a = t.cpy2;return null === n || null === a ? [(i ? h : u)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? h : u)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? c : l)(t.x1, t.cpx1, t.x2, e), (i ? c : l)(t.y1, t.cpy1, t.y2, e)];
			}var a = i(20),
			    o = i(6),
			    r = a.quadraticSubdivide,
			    s = a.cubicSubdivide,
			    l = a.quadraticAt,
			    u = a.cubicAt,
			    c = a.quadraticDerivativeAt,
			    h = a.cubicDerivativeAt,
			    d = [];t.exports = i(8).extend({ type: "bezier-curve", shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1 }, style: { stroke: "#000", fill: null }, buildPath: function buildPath(t, e) {
					var i = e.x1,
					    n = e.y1,
					    a = e.x2,
					    o = e.y2,
					    l = e.cpx1,
					    u = e.cpy1,
					    c = e.cpx2,
					    h = e.cpy2,
					    f = e.percent;0 !== f && (t.moveTo(i, n), null == c || null == h ? (f < 1 && (r(i, l, a, f, d), l = d[1], a = d[2], r(n, u, o, f, d), u = d[1], o = d[2]), t.quadraticCurveTo(l, u, a, o)) : (f < 1 && (s(i, l, c, a, f, d), l = d[1], c = d[2], a = d[3], s(n, u, h, o, f, d), u = d[1], h = d[2], o = d[3]), t.bezierCurveTo(l, u, c, h, a, o)));
				}, pointAt: function pointAt(t) {
					return n(this.shape, t, !1);
				}, tangentAt: function tangentAt(t) {
					var e = n(this.shape, t, !0);return o.normalize(e, e);
				} });
		}, function (t, e, i) {
			"use strict";
			t.exports = i(8).extend({ type: "circle", shape: { cx: 0, cy: 0, r: 0 }, buildPath: function buildPath(t, e, i) {
					i && t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0);
				} });
		}, function (t, e, i) {
			t.exports = i(8).extend({ type: "line", shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1 }, style: { stroke: "#000", fill: null }, buildPath: function buildPath(t, e) {
					var i = e.x1,
					    n = e.y1,
					    a = e.x2,
					    o = e.y2,
					    r = e.percent;0 !== r && (t.moveTo(i, n), r < 1 && (a = i * (1 - r) + a * r, o = n * (1 - r) + o * r), t.lineTo(a, o));
				}, pointAt: function pointAt(t) {
					var e = this.shape;return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t];
				} });
		}, function (t, e, i) {
			var n = i(74);t.exports = i(8).extend({ type: "polygon", shape: { points: null, smooth: !1, smoothConstraint: null }, buildPath: function buildPath(t, e) {
					n.buildPath(t, e, !0);
				} });
		}, function (t, e, i) {
			var n = i(74);t.exports = i(8).extend({ type: "polyline", shape: { points: null, smooth: !1, smoothConstraint: null }, style: { stroke: "#000", fill: null }, buildPath: function buildPath(t, e) {
					n.buildPath(t, e, !1);
				} });
		}, function (t, e, i) {
			var n = i(166);t.exports = i(8).extend({ type: "rect", shape: { r: 0, x: 0, y: 0, width: 0, height: 0 }, buildPath: function buildPath(t, e) {
					var i = e.x,
					    a = e.y,
					    o = e.width,
					    r = e.height;e.r ? n.buildPath(t, e) : t.rect(i, a, o, r), t.closePath();
				} });
		}, function (t, e, i) {
			t.exports = i(8).extend({ type: "ring", shape: { cx: 0, cy: 0, r: 0, r0: 0 }, buildPath: function buildPath(t, e) {
					var i = e.cx,
					    n = e.cy,
					    a = 2 * Math.PI;t.moveTo(i + e.r, n), t.arc(i, n, e.r, 0, a, !1), t.moveTo(i + e.r0, n), t.arc(i, n, e.r0, 0, a, !0);
				} });
		}, function (t, e, i) {
			var n = i(9),
			    a = i(8),
			    o = [["shadowBlur", 0], ["shadowColor", "#000"], ["shadowOffsetX", 0], ["shadowOffsetY", 0]];t.exports = a.extend({ type: "sector", shape: { cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, brush: n.browser.ie && n.browser.version >= 11 ? function () {
					var t,
					    e = this.__clipPaths,
					    i = this.style;if (e) for (var n = 0; n < e.length; n++) {
						var r = e[n] && e[n].shape;if (r && r.startAngle === r.endAngle) {
							for (var s = 0; s < o.length; s++) {
								o[s][2] = i[o[s][0]], i[o[s][0]] = o[s][1];
							}t = !0;break;
						}
					}if (a.prototype.brush.apply(this, arguments), t) for (var s = 0; s < o.length; s++) {
						i[o[s][0]] = o[s][2];
					}
				} : a.prototype.brush, buildPath: function buildPath(t, e) {
					var i = e.cx,
					    n = e.cy,
					    a = Math.max(e.r0 || 0, 0),
					    o = Math.max(e.r, 0),
					    r = e.startAngle,
					    s = e.endAngle,
					    l = e.clockwise,
					    u = Math.cos(r),
					    c = Math.sin(r);t.moveTo(u * a + i, c * a + n), t.lineTo(u * o + i, c * o + n), t.arc(i, n, o, r, s, !l), t.lineTo(Math.cos(s) * a + i, Math.sin(s) * a + n), 0 !== a && t.arc(i, n, a, s, r, l), t.closePath();
				} });
		}, function (t, e, i) {
			"use strict";
			var n = i(67),
			    a = i(1),
			    o = a.isString,
			    r = a.isFunction,
			    s = a.isObject,
			    l = i(52),
			    u = function u() {
				this.animators = [];
			};u.prototype = { constructor: u, animate: function animate(t, e) {
					var i,
					    o = !1,
					    r = this,
					    s = this.__zr;if (t) {
						var u = t.split("."),
						    c = r;o = "shape" === u[0];for (var h = 0, d = u.length; h < d; h++) {
							c && (c = c[u[h]]);
						}c && (i = c);
					} else i = r;if (!i) return void l('Property "' + t + '" is not existed in element ' + r.id);var f = r.animators,
					    p = new n(i, e);return p.during(function (t) {
						r.dirty(o);
					}).done(function () {
						f.splice(a.indexOf(f, p), 1);
					}), f.push(p), s && s.animation.addAnimator(p), p;
				}, stopAnimation: function stopAnimation(t) {
					for (var e = this.animators, i = e.length, n = 0; n < i; n++) {
						e[n].stop(t);
					}return e.length = 0, this;
				}, animateTo: function animateTo(t, e, i, n, a) {
					function s() {
						u--, u || a && a();
					}o(i) ? (a = n, n = i, i = 0) : r(n) ? (a = n, n = "linear", i = 0) : r(i) ? (a = i, i = 0) : r(e) ? (a = e, e = 500) : e || (e = 500), this.stopAnimation(), this._animateToShallow("", this, t, e, i, n, a);var l = this.animators.slice(),
					    u = l.length;u || a && a();for (var c = 0; c < l.length; c++) {
						l[c].done(s).start(n);
					}
				}, _animateToShallow: function _animateToShallow(t, e, i, n, o) {
					var r = {},
					    l = 0;for (var u in i) {
						if (i.hasOwnProperty(u)) if (null != e[u]) s(i[u]) && !a.isArrayLike(i[u]) ? this._animateToShallow(t ? t + "." + u : u, e[u], i[u], n, o) : (r[u] = i[u], l++);else if (null != i[u]) if (t) {
							var c = {};c[t] = {}, c[t][u] = i[u], this.attr(c);
						} else this.attr(u, i[u]);
					}return l > 0 && this.animate(t, !1).when(null == n ? 500 : n, r).delay(o || 0), this;
				} }, t.exports = u;
		}, function (t, e) {
			function i() {
				this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this);
			}function n(t, e) {
				return { target: t, topTarget: e && e.topTarget };
			}i.prototype = { constructor: i, _dragStart: function _dragStart(t) {
					var e = t.target;e && e.draggable && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.dispatchToElement(n(e, t), "dragstart", t.event));
				}, _drag: function _drag(t) {
					var e = this._draggingTarget;if (e) {
						var i = t.offsetX,
						    a = t.offsetY,
						    o = i - this._x,
						    r = a - this._y;this._x = i, this._y = a, e.drift(o, r, t), this.dispatchToElement(n(e, t), "drag", t.event);var s = this.findHover(i, a, e).target,
						    l = this._dropTarget;this._dropTarget = s, e !== s && (l && s !== l && this.dispatchToElement(n(l, t), "dragleave", t.event), s && s !== l && this.dispatchToElement(n(s, t), "dragenter", t.event));
					}
				}, _dragEnd: function _dragEnd(t) {
					var e = this._draggingTarget;e && (e.dragging = !1), this.dispatchToElement(n(e, t), "dragend", t.event), this._dropTarget && this.dispatchToElement(n(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
				} }, t.exports = i;
		}, function (t, e, i) {
			function n(t, e, i, n, a, o, r, s, l, u, p) {
				var v = l * (f / 180),
				    y = d(v) * (t - i) / 2 + h(v) * (e - n) / 2,
				    x = -1 * h(v) * (t - i) / 2 + d(v) * (e - n) / 2,
				    _ = y * y / (r * r) + x * x / (s * s);_ > 1 && (r *= c(_), s *= c(_));var b = (a === o ? -1 : 1) * c((r * r * (s * s) - r * r * (x * x) - s * s * (y * y)) / (r * r * (x * x) + s * s * (y * y))) || 0,
				    w = b * r * x / s,
				    S = b * -s * y / r,
				    M = (t + i) / 2 + d(v) * w - h(v) * S,
				    I = (e + n) / 2 + h(v) * w + d(v) * S,
				    T = m([1, 0], [(y - w) / r, (x - S) / s]),
				    A = [(y - w) / r, (x - S) / s],
				    C = [(-1 * y - w) / r, (-1 * x - S) / s],
				    L = m(A, C);g(A, C) <= -1 && (L = f), g(A, C) >= 1 && (L = 0), 0 === o && L > 0 && (L -= 2 * f), 1 === o && L < 0 && (L += 2 * f), p.addData(u, M, I, r, s, T, L, v, o);
			}function a(t) {
				if (!t) return [];var e,
				    i = t.replace(/-/g, " -").replace(/  /g, " ").replace(/ /g, ",").replace(/,,/g, ",");for (e = 0; e < u.length; e++) {
					i = i.replace(new RegExp(u[e], "g"), "|" + u[e]);
				}var a,
				    o = i.split("|"),
				    r = 0,
				    l = 0,
				    c = new s(),
				    h = s.CMD;for (e = 1; e < o.length; e++) {
					var d,
					    f = o[e],
					    p = f.charAt(0),
					    g = 0,
					    m = f.slice(1).replace(/e,-/g, "e-").split(",");m.length > 0 && "" === m[0] && m.shift();for (var v = 0; v < m.length; v++) {
						m[v] = parseFloat(m[v]);
					}for (; g < m.length && !isNaN(m[g]) && !isNaN(m[0]);) {
						var y,
						    x,
						    _,
						    b,
						    w,
						    S,
						    M,
						    I = r,
						    T = l;switch (p) {case "l":
								r += m[g++], l += m[g++], d = h.L, c.addData(d, r, l);break;case "L":
								r = m[g++], l = m[g++], d = h.L, c.addData(d, r, l);break;case "m":
								r += m[g++], l += m[g++], d = h.M, c.addData(d, r, l), p = "l";break;case "M":
								r = m[g++], l = m[g++], d = h.M, c.addData(d, r, l), p = "L";break;case "h":
								r += m[g++], d = h.L, c.addData(d, r, l);break;case "H":
								r = m[g++], d = h.L, c.addData(d, r, l);break;case "v":
								l += m[g++], d = h.L, c.addData(d, r, l);break;case "V":
								l = m[g++], d = h.L, c.addData(d, r, l);break;case "C":
								d = h.C, c.addData(d, m[g++], m[g++], m[g++], m[g++], m[g++], m[g++]), r = m[g - 2], l = m[g - 1];break;case "c":
								d = h.C, c.addData(d, m[g++] + r, m[g++] + l, m[g++] + r, m[g++] + l, m[g++] + r, m[g++] + l), r += m[g - 2], l += m[g - 1];break;case "S":
								y = r, x = l;var A = c.len(),
								    C = c.data;a === h.C && (y += r - C[A - 4], x += l - C[A - 3]), d = h.C, I = m[g++], T = m[g++], r = m[g++], l = m[g++], c.addData(d, y, x, I, T, r, l);break;case "s":
								y = r, x = l;var A = c.len(),
								    C = c.data;a === h.C && (y += r - C[A - 4], x += l - C[A - 3]), d = h.C, I = r + m[g++], T = l + m[g++], r += m[g++], l += m[g++], c.addData(d, y, x, I, T, r, l);break;case "Q":
								I = m[g++], T = m[g++], r = m[g++], l = m[g++], d = h.Q, c.addData(d, I, T, r, l);break;case "q":
								I = m[g++] + r, T = m[g++] + l, r += m[g++], l += m[g++], d = h.Q, c.addData(d, I, T, r, l);break;case "T":
								y = r, x = l;var A = c.len(),
								    C = c.data;a === h.Q && (y += r - C[A - 4], x += l - C[A - 3]), r = m[g++], l = m[g++], d = h.Q, c.addData(d, y, x, r, l);break;case "t":
								y = r, x = l;var A = c.len(),
								    C = c.data;a === h.Q && (y += r - C[A - 4], x += l - C[A - 3]), r += m[g++], l += m[g++], d = h.Q, c.addData(d, y, x, r, l);break;case "A":
								_ = m[g++], b = m[g++], w = m[g++], S = m[g++], M = m[g++], I = r, T = l, r = m[g++], l = m[g++], d = h.A, n(I, T, r, l, S, M, _, b, w, d, c);break;case "a":
								_ = m[g++], b = m[g++], w = m[g++], S = m[g++], M = m[g++], I = r, T = l, r += m[g++], l += m[g++], d = h.A, n(I, T, r, l, S, M, _, b, w, d, c);}
					}"z" !== p && "Z" !== p || (d = h.Z, c.addData(d)), a = d;
				}return c.toStatic(), c;
			}function o(t, e) {
				var i = a(t);return e = e || {}, e.buildPath = function (t) {
					if (t.setData) {
						t.setData(i.data);var e = t.getContext();e && t.rebuildPath(e);
					} else {
						var e = t;i.rebuildPath(e);
					}
				}, e.applyTransform = function (t) {
					l(i, t), this.dirty(!0);
				}, e;
			}var r = i(8),
			    s = i(27),
			    l = i(181),
			    u = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"],
			    c = Math.sqrt,
			    h = Math.sin,
			    d = Math.cos,
			    f = Math.PI,
			    p = function p(t) {
				return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
			},
			    g = function g(t, e) {
				return (t[0] * e[0] + t[1] * e[1]) / (p(t) * p(e));
			},
			    m = function m(t, e) {
				return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(g(t, e));
			};t.exports = { createFromString: function createFromString(t, e) {
					return new r(o(t, e));
				}, extendFromString: function extendFromString(t, e) {
					return r.extend(o(t, e));
				}, mergePath: function mergePath(t, e) {
					for (var i = [], n = t.length, a = 0; a < n; a++) {
						var o = t[a];o.path || o.createPathProxy(), o.__dirtyPath && o.buildPath(o.path, o.shape, !0), i.push(o.path);
					}var s = new r(e);return s.createPathProxy(), s.buildPath = function (t) {
						t.appendPath(i);var e = t.getContext();e && t.rebuildPath(e);
					}, s;
				} };
		}, function (t, e, i) {
			function n(t, e) {
				var i,
				    n,
				    o,
				    c,
				    h,
				    d,
				    f = t.data,
				    p = a.M,
				    g = a.C,
				    m = a.L,
				    v = a.R,
				    y = a.A,
				    x = a.Q;for (o = 0, c = 0; o < f.length;) {
					switch (i = f[o++], c = o, n = 0, i) {case p:
							n = 1;break;case m:
							n = 1;break;case g:
							n = 3;break;case x:
							n = 2;break;case y:
							var _ = e[4],
							    b = e[5],
							    w = l(e[0] * e[0] + e[1] * e[1]),
							    S = l(e[2] * e[2] + e[3] * e[3]),
							    M = u(-e[1] / S, e[0] / w);f[o] *= w, f[o++] += _, f[o] *= S, f[o++] += b, f[o++] *= w, f[o++] *= S, f[o++] += M, f[o++] += M, o += 2, c = o;break;case v:
							d[0] = f[o++], d[1] = f[o++], r(d, d, e), f[c++] = d[0], f[c++] = d[1], d[0] += f[o++], d[1] += f[o++], r(d, d, e), f[c++] = d[0], f[c++] = d[1];}for (h = 0; h < n; h++) {
						var d = s[h];d[0] = f[o++], d[1] = f[o++], r(d, d, e), f[c++] = d[0], f[c++] = d[1];
					}
				}
			}var a = i(27).CMD,
			    o = i(6),
			    r = o.applyTransform,
			    s = [[], [], []],
			    l = Math.sqrt,
			    u = Math.atan2;t.exports = n;
		}, function (t, e, i) {
			if (!i(9).canvasSupported) {
				var n,
				    a = "urn:schemas-microsoft-com:vml",
				    o = window,
				    r = o.document,
				    s = !1;try {
					!r.namespaces.zrvml && r.namespaces.add("zrvml", a), n = function n(t) {
						return r.createElement("<zrvml:" + t + ' class="zrvml">');
					};
				} catch (l) {
					n = function n(t) {
						return r.createElement("<" + t + ' xmlns="' + a + '" class="zrvml">');
					};
				}var u = function u() {
					if (!s) {
						s = !0;var t = r.styleSheets;t.length < 31 ? r.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)");
					}
				};t.exports = { doc: r, initVML: u, createNode: n };
			}
		}, function (t, e, i) {
			"use strict";
			var n = i(14),
			    a = i(25),
			    o = i(313),
			    r = i(1),
			    s = { _baseAxisDim: null, getInitialData: function getInitialData(t, e) {
					var i,
					    o,
					    s = e.getComponent("xAxis", this.get("xAxisIndex")),
					    l = e.getComponent("yAxis", this.get("yAxisIndex")),
					    u = s.get("type"),
					    c = l.get("type");"category" === u ? (t.layout = "horizontal", i = s.getCategories(), o = !0) : "category" === c ? (t.layout = "vertical", i = l.getCategories(), o = !0) : t.layout = t.layout || "horizontal";var h = ["x", "y"],
					    d = "horizontal" === t.layout ? 0 : 1,
					    f = this._baseAxisDim = h[d],
					    p = h[1 - d],
					    g = t.data;o && r.each(g, function (t, e) {
						r.isArray(t) && t.unshift(e);
					});var m = [{ name: f, otherDims: { tooltip: !1 }, dimsDef: ["base"] }, { name: p, dimsDef: this.defaultValueDimensions.slice() }];m = a(m, g, { encodeDef: this.get("encode"), dimsDef: this.get("dimensions") });var v = new n(m, this);return v.initData(g, i ? i.slice() : null), v;
				}, getBaseAxis: function getBaseAxis() {
					var t = this._baseAxisDim;return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis;
				} },
			    l = { init: function init() {
					var t = this._whiskerBoxDraw = new o(this.getStyleUpdater());this.group.add(t.group);
				}, render: function render(t, e, i) {
					this._whiskerBoxDraw.updateData(t.getData());
				}, remove: function remove(t) {
					this._whiskerBoxDraw.remove();
				} };t.exports = { seriesModelMixin: s, viewMixin: l };
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = this._targetInfoList = [],
				    a = {},
				    r = o(e, t);p(_, function (t, e) {
					(!i || !i.include || g(i.include, e) >= 0) && t(r, n, a);
				});
			}function a(t) {
				return t[0] > t[1] && t.reverse(), t;
			}function o(t, e) {
				return d.parseFinder(t, e, { includeMainTypes: y });
			}function r(t, e, i, n) {
				var o = i.getAxis(["x", "y"][t]),
				    r = a(c.map([0, 1], function (t) {
					return e ? o.coordToData(o.toLocalCoord(n[t])) : o.toGlobalCoord(o.dataToCoord(n[t]));
				})),
				    s = [];return s[t] = r, s[1 - t] = [NaN, NaN], { values: r, xyMinMax: s };
			}function s(t, e, i, n) {
				return [e[0] - n[t] * i[0], e[1] - n[t] * i[1]];
			}function l(t, e) {
				var i = u(t),
				    n = u(e),
				    a = [i[0] / n[0], i[1] / n[1]];return isNaN(a[0]) && (a[0] = 1), isNaN(a[1]) && (a[1] = 1), a;
			}function u(t) {
				return t ? [t[0][1] - t[0][0], t[1][1] - t[1][0]] : [NaN, NaN];
			}var c = i(1),
			    h = i(3),
			    d = i(5),
			    f = i(185),
			    p = c.each,
			    g = c.indexOf,
			    m = c.curry,
			    v = ["dataToPoint", "pointToData"],
			    y = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"],
			    x = n.prototype;x.setOutputRanges = function (t, e) {
				this.matchOutputRanges(t, e, function (t, e, i) {
					if ((t.coordRanges || (t.coordRanges = [])).push(e), !t.coordRange) {
						t.coordRange = e;var n = S[t.brushType](0, i, e);t.__rangeOffset = { offset: M[t.brushType](n.values, t.range, [1, 1]), xyMinMax: n.xyMinMax };
					}
				});
			}, x.matchOutputRanges = function (t, e, i) {
				p(t, function (t) {
					var n = this.findTargetInfo(t, e);n && n !== !0 && c.each(n.coordSyses, function (n) {
						var a = S[t.brushType](1, n, t.range);i(t, a.values, n, e);
					});
				}, this);
			}, x.setInputRanges = function (t, e) {
				p(t, function (t) {
					var i = this.findTargetInfo(t, e);if (t.range = t.range || [], i && i !== !0) {
						t.panelId = i.panelId;var n = S[t.brushType](0, i.coordSys, t.coordRange),
						    a = t.__rangeOffset;t.range = a ? M[t.brushType](n.values, a.offset, l(n.xyMinMax, a.xyMinMax)) : n.values;
					}
				}, this);
			}, x.makePanelOpts = function (t, e) {
				return c.map(this._targetInfoList, function (i) {
					var n = i.getPanelRect();return { panelId: i.panelId, defaultBrushType: e && e(i), clipPath: f.makeRectPanelClipPath(n), isTargetByCursor: f.makeRectIsTargetByCursor(n, t, i.coordSysModel), getLinearBrushOtherExtent: f.makeLinearBrushOtherExtent(n) };
				});
			}, x.controlSeries = function (t, e, i) {
				var n = this.findTargetInfo(t, i);return n === !0 || n && g(n.coordSyses, e.coordinateSystem) >= 0;
			}, x.findTargetInfo = function (t, e) {
				for (var i = this._targetInfoList, n = o(e, t), a = 0; a < i.length; a++) {
					var r = i[a],
					    s = t.panelId;if (s) {
						if (r.panelId === s) return r;
					} else for (var a = 0; a < b.length; a++) {
						if (b[a](n, r)) return r;
					}
				}return !0;
			};var _ = { grid: function grid(t, e) {
					var i = t.xAxisModels,
					    n = t.yAxisModels,
					    a = t.gridModels,
					    o = c.createHashMap(),
					    r = {},
					    s = {};(i || n || a) && (p(i, function (t) {
						var e = t.axis.grid.model;o.set(e.id, e), r[e.id] = !0;
					}), p(n, function (t) {
						var e = t.axis.grid.model;o.set(e.id, e), s[e.id] = !0;
					}), p(a, function (t) {
						o.set(t.id, t), r[t.id] = !0, s[t.id] = !0;
					}), o.each(function (t) {
						var a = t.coordinateSystem,
						    o = [];p(a.getCartesians(), function (t, e) {
							(g(i, t.getAxis("x").model) >= 0 || g(n, t.getAxis("y").model) >= 0) && o.push(t);
						}), e.push({ panelId: "grid--" + t.id, gridModel: t, coordSysModel: t, coordSys: o[0], coordSyses: o, getPanelRect: w.grid, xAxisDeclared: r[t.id], yAxisDeclared: s[t.id] });
					}));
				}, geo: function geo(t, e) {
					p(t.geoModels, function (t) {
						var i = t.coordinateSystem;e.push({ panelId: "geo--" + t.id, geoModel: t, coordSysModel: t, coordSys: i, coordSyses: [i], getPanelRect: w.geo });
					});
				} },
			    b = [function (t, e) {
				var i = t.xAxisModel,
				    n = t.yAxisModel,
				    a = t.gridModel;return !a && i && (a = i.axis.grid.model), !a && n && (a = n.axis.grid.model), a && a === e.gridModel;
			}, function (t, e) {
				var i = t.geoModel;return i && i === e.geoModel;
			}],
			    w = { grid: function grid() {
					return this.coordSys.grid.getRect().clone();
				}, geo: function geo() {
					var t = this.coordSys,
					    e = t.getBoundingRect().clone();return e.applyTransform(h.getTransform(t)), e;
				} },
			    S = { lineX: m(r, 0), lineY: m(r, 1), rect: function rect(t, e, i) {
					var n = e[v[t]]([i[0][0], i[1][0]]),
					    o = e[v[t]]([i[0][1], i[1][1]]),
					    r = [a([n[0], o[0]]), a([n[1], o[1]])];return { values: r, xyMinMax: r };
				},
				polygon: function polygon(t, e, i) {
					var n = [[1 / 0, -(1 / 0)], [1 / 0, -(1 / 0)]],
					    a = c.map(i, function (i) {
						var a = e[v[t]](i);return n[0][0] = Math.min(n[0][0], a[0]), n[1][0] = Math.min(n[1][0], a[1]), n[0][1] = Math.max(n[0][1], a[0]), n[1][1] = Math.max(n[1][1], a[1]), a;
					});return { values: a, xyMinMax: n };
				} },
			    M = { lineX: m(s, 0), lineY: m(s, 1), rect: function rect(t, e, i) {
					return [[t[0][0] - i[0] * e[0][0], t[0][1] - i[0] * e[0][1]], [t[1][0] - i[1] * e[1][0], t[1][1] - i[1] * e[1][1]]];
				}, polygon: function polygon(t, e, i) {
					return c.map(t, function (t, n) {
						return [t[0] - i[0] * e[n][0], t[1] - i[1] * e[n][1]];
					});
				} };t.exports = n;
		}, function (t, e, i) {
			function n(t) {
				return o.create(t);
			}var a = i(128),
			    o = i(11),
			    r = i(3),
			    s = {};s.makeRectPanelClipPath = function (t) {
				return t = n(t), function (e, i) {
					return r.clipPointsByRect(e, t);
				};
			}, s.makeLinearBrushOtherExtent = function (t, e) {
				return t = n(t), function (i) {
					var n = null != e ? e : i,
					    a = n ? t.width : t.height,
					    o = n ? t.x : t.y;return [o, o + (a || 0)];
				};
			}, s.makeRectIsTargetByCursor = function (t, e, i) {
				return t = n(t), function (n, o, r) {
					return t.contain(o[0], o[1]) && !a.onIrrelevantElement(n, e, i);
				};
			}, t.exports = s;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t.get("boundingCoords");if (null != i) {
					var n = i[0],
					    a = i[1];isNaN(n[0]) || isNaN(n[1]) || isNaN(a[0]) || isNaN(a[1]) || this.setBoundingRect(n[0], n[1], a[0] - n[0], a[1] - n[1]);
				}var o,
				    s = this.getBoundingRect(),
				    u = t.get("layoutCenter"),
				    c = t.get("layoutSize"),
				    h = e.getWidth(),
				    d = e.getHeight(),
				    f = t.get("aspectScale") || .75,
				    p = s.width / s.height * f,
				    g = !1;u && c && (u = [l.parsePercent(u[0], h), l.parsePercent(u[1], d)], c = l.parsePercent(c, Math.min(h, d)), isNaN(u[0]) || isNaN(u[1]) || isNaN(c) || (g = !0));var m;if (g) {
					var m = {};p > 1 ? (m.width = c, m.height = c / p) : (m.height = c, m.width = c * p), m.y = u[1] - m.height / 2, m.x = u[0] - m.width / 2;
				} else o = t.getBoxLayoutParams(), o.aspect = p, m = r.getLayoutRect(o, { width: h, height: d });this.setViewRect(m.x, m.y, m.width, m.height), this.setCenter(t.get("center")), this.setZoom(t.get("zoom"));
			}function a(t, e) {
				s.each(e.get("geoCoord"), function (e, i) {
					t.addGeoCoord(i, e);
				});
			}var o = i(398),
			    r = i(12),
			    s = i(1),
			    l = i(4),
			    u = {},
			    c = { dimensions: o.prototype.dimensions, create: function create(t, e) {
					var i = [];t.eachComponent("geo", function (t, r) {
						var s = t.get("map"),
						    l = u[s],
						    c = new o(s + r, s, l && l.geoJson, l && l.specialAreas, t.get("nameMap"));c.zoomLimit = t.get("scaleLimit"), i.push(c), a(c, t), t.coordinateSystem = c, c.model = t, c.resize = n, c.resize(t, e);
					}), t.eachSeries(function (t) {
						var e = t.get("coordinateSystem");if ("geo" === e) {
							var n = t.get("geoIndex") || 0;t.coordinateSystem = i[n];
						}
					});var r = {};return t.eachSeriesByType("map", function (t) {
						if (!t.getHostGeoModel()) {
							var e = t.getMapType();r[e] = r[e] || [], r[e].push(t);
						}
					}), s.each(r, function (t, r) {
						var l = u[r],
						    c = s.map(t, function (t) {
							return t.get("nameMap");
						}),
						    h = new o(r, r, l && l.geoJson, l && l.specialAreas, s.mergeAll(c));h.zoomLimit = s.retrieve.apply(null, s.map(t, function (t) {
							return t.get("scaleLimit");
						})), i.push(h), h.resize = n, h.resize(t[0], e), s.each(t, function (t) {
							t.coordinateSystem = h, a(h, t);
						});
					}), i;
				}, registerMap: function registerMap(t, e, i) {
					e.geoJson && !e.features && (i = e.specialAreas, e = e.geoJson), "string" == typeof e && (e = "undefined" != typeof JSON && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")()), u[t] = { geoJson: e, specialAreas: i };
				}, getMap: function getMap(t) {
					return u[t];
				}, getFilledRegions: function getFilledRegions(t, e) {
					var i = (t || []).slice(),
					    n = c.getMap(e),
					    a = n && n.geoJson;if (!a) return t;for (var o = s.createHashMap(), r = a.features, l = 0; l < i.length; l++) {
						o.set(i[l].name, i[l]);
					}for (var l = 0; l < r.length; l++) {
						var u = r[l].properties.name;o.get(u) || i.push({ name: u });
					}return i;
				} },
			    h = i(2);h.registerMap = c.registerMap, h.getMap = c.getMap, h.parseGeoJSON = i(262), h.loadMap = function () {}, h.registerCoordinateSystem("geo", c), t.exports = c;
		}, function (t, e, i) {
			function n(t) {
				if (t) for (var e in t) {
					if (t.hasOwnProperty(e)) return !0;
				}
			}var a = i(1),
			    o = i(83),
			    r = a.each,
			    s = { createVisualMappings: function createVisualMappings(t, e, i) {
					function n() {
						var t = function t() {};t.prototype.__hidden = t.prototype;var e = new t();return e;
					}var s = {};return r(e, function (e) {
						var l = s[e] = n();r(t[e], function (t, n) {
							if (o.isValidType(n)) {
								var r = { type: n, visual: t };i && i(r, e), l[n] = new o(r), "opacity" === n && (r = a.clone(r), r.type = "colorAlpha", l.__hidden.__alphaForOpacity = new o(r));
							}
						});
					}), s;
				}, replaceVisualOption: function replaceVisualOption(t, e, i) {
					var o;a.each(i, function (t) {
						e.hasOwnProperty(t) && n(e[t]) && (o = !0);
					}), o && a.each(i, function (i) {
						e.hasOwnProperty(i) && n(e[i]) ? t[i] = a.clone(e[i]) : delete t[i];
					});
				}, applyVisual: function applyVisual(t, e, i, n, r, s) {
					function l(t) {
						return i.getItemVisual(d, t);
					}function u(t, e) {
						i.setItemVisual(d, t, e);
					}function c(t, a) {
						d = null == s ? t : a;var o = i.getRawDataItem(d);if (!o || o.visualMap !== !1) for (var c = n.call(r, t), f = e[c], p = h[c], g = 0, m = p.length; g < m; g++) {
							var v = p[g];f[v] && f[v].applyVisual(t, l, u);
						}
					}var h = {};a.each(t, function (t) {
						var i = o.prepareVisualTypes(e[t]);h[t] = i;
					});var d;null == s ? i.each(c, !0) : i.each([s], c, !0);
				} };t.exports = s;
		}, function (t, e) {
			function i() {
				throw new Error("setTimeout has not been defined");
			}function n() {
				throw new Error("clearTimeout has not been defined");
			}function a(t) {
				if (c === setTimeout) return setTimeout(t, 0);if ((c === i || !c) && setTimeout) return c = setTimeout, setTimeout(t, 0);try {
					return c(t, 0);
				} catch (e) {
					try {
						return c.call(null, t, 0);
					} catch (e) {
						return c.call(this, t, 0);
					}
				}
			}function o(t) {
				if (h === clearTimeout) return clearTimeout(t);if ((h === n || !h) && clearTimeout) return h = clearTimeout, clearTimeout(t);try {
					return h(t);
				} catch (e) {
					try {
						return h.call(null, t);
					} catch (e) {
						return h.call(this, t);
					}
				}
			}function r() {
				g && f && (g = !1, f.length ? p = f.concat(p) : m = -1, p.length && s());
			}function s() {
				if (!g) {
					var t = a(r);g = !0;for (var e = p.length; e;) {
						for (f = p, p = []; ++m < e;) {
							f && f[m].run();
						}m = -1, e = p.length;
					}f = null, g = !1, o(t);
				}
			}function l(t, e) {
				this.fun = t, this.array = e;
			}function u() {}var c,
			    h,
			    d = t.exports = {};!function () {
				try {
					c = "function" == typeof setTimeout ? setTimeout : i;
				} catch (t) {
					c = i;
				}try {
					h = "function" == typeof clearTimeout ? clearTimeout : n;
				} catch (t) {
					h = n;
				}
			}();var f,
			    p = [],
			    g = !1,
			    m = -1;d.nextTick = function (t) {
				var e = new Array(arguments.length - 1);if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) {
					e[i - 1] = arguments[i];
				}p.push(new l(t, e)), 1 !== p.length || g || a(s);
			}, l.prototype.run = function () {
				this.fun.apply(null, this.array);
			}, d.title = "browser", d.browser = !0, d.env = {}, d.argv = [], d.version = "", d.versions = {}, d.on = u, d.addListener = u, d.once = u, d.off = u, d.removeListener = u, d.removeAllListeners = u, d.emit = u, d.binding = function (t) {
				throw new Error("process.binding is not supported");
			}, d.cwd = function () {
				return "/";
			}, d.chdir = function (t) {
				throw new Error("process.chdir is not supported");
			}, d.umask = function () {
				return 0;
			};
		}, function (t, e, i) {
			function n() {
				this.group = new a.Group(), this._symbolEl = new r({});
			}var a = i(3),
			    o = i(24),
			    r = a.extendShape({ shape: { points: null, sizes: null }, symbolProxy: null, buildPath: function buildPath(t, e) {
					for (var i = e.points, n = e.sizes, a = this.symbolProxy, o = a.shape, r = 0; r < i.length; r++) {
						var s = i[r],
						    l = n[r];l[0] < 4 ? t.rect(s[0] - l[0] / 2, s[1] - l[1] / 2, l[0], l[1]) : (o.x = s[0] - l[0] / 2, o.y = s[1] - l[1] / 2, o.width = l[0], o.height = l[1], a.buildPath(t, o, !0));
					}
				}, findDataIndex: function findDataIndex(t, e) {
					for (var i = this.shape, n = i.points, a = i.sizes, o = n.length - 1; o >= 0; o--) {
						var r = n[o],
						    s = a[o],
						    l = r[0] - s[0] / 2,
						    u = r[1] - s[1] / 2;if (t >= l && e >= u && t <= l + s[0] && e <= u + s[1]) return o;
					}return -1;
				} }),
			    s = n.prototype;s.updateData = function (t) {
				this.group.removeAll();var e = this._symbolEl,
				    i = t.hostModel;e.setShape({ points: t.mapArray(t.getItemLayout), sizes: t.mapArray(function (e) {
						var i = t.getItemVisual(e, "symbolSize");return i instanceof Array || (i = [i, i]), i;
					}) }), e.symbolProxy = o.createSymbol(t.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor, e.useStyle(i.getModel("itemStyle.normal").getItemStyle(["color"]));var n = t.getVisual("color");n && e.setColor(n), e.seriesIndex = i.seriesIndex, e.on("mousemove", function (t) {
					e.dataIndex = null;var i = e.findDataIndex(t.offsetX, t.offsetY);i > 0 && (e.dataIndex = i);
				}), this.group.add(e);
			}, s.updateLayout = function (t) {
				var e = t.getData();this._symbolEl.setShape({ points: e.mapArray(e.getItemLayout) });
			}, s.remove = function () {
				this.group.removeAll();
			}, t.exports = n;
		}, function (t, e, i) {
			function n(t) {
				return isNaN(+t.cpx1) || isNaN(+t.cpy1);
			}var a = i(3),
			    o = i(6),
			    r = a.Line.prototype,
			    s = a.BezierCurve.prototype;t.exports = a.extendShape({ type: "ec-line", style: { stroke: "#000", fill: null }, shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1, cpx1: null, cpy1: null }, buildPath: function buildPath(t, e) {
					(n(e) ? r : s).buildPath(t, e);
				}, pointAt: function pointAt(t) {
					return n(this.shape) ? r.pointAt.call(this, t) : s.pointAt.call(this, t);
				}, tangentAt: function tangentAt(t) {
					var e = this.shape,
					    i = n(e) ? [e.x2 - e.x1, e.y2 - e.y1] : s.tangentAt.call(this, t);return o.normalize(i, i);
				} });
		}, function (t, e, i) {
			var n = i(1),
			    a = i(2);i(192), i(193), a.registerVisual(n.curry(i(50), "scatter", "circle", null)), a.registerLayout(n.curry(i(61), "scatter")), i(32);
		}, function (t, e, i) {
			"use strict";
			var n = i(28),
			    a = i(17);t.exports = a.extend({ type: "series.scatter", dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"], getInitialData: function getInitialData(t, e) {
					return n(t.data, this, e);
				}, brushSelector: "point", defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, symbolSize: 10, large: !1, largeThreshold: 2e3, itemStyle: { normal: { opacity: .8 } } } });
		}, function (t, e, i) {
			var n = i(44),
			    a = i(189);i(2).extendChartView({ type: "scatter", init: function init() {
					this._normalSymbolDraw = new n(), this._largeSymbolDraw = new a();
				}, render: function render(t, e, i) {
					var n = t.getData(),
					    a = this._largeSymbolDraw,
					    o = this._normalSymbolDraw,
					    r = this.group,
					    s = t.get("large") && n.count() > t.get("largeThreshold") ? a : o;this._symbolDraw = s, s.updateData(n), r.add(s.group), r.remove(s === a ? o.group : a.group);
				}, updateLayout: function updateLayout(t) {
					this._symbolDraw.updateLayout(t);
				}, remove: function remove(t, e) {
					this._symbolDraw && this._symbolDraw.remove(e, !0);
				}, dispose: function dispose() {} });
		}, function (t, e, i) {
			var n = i(2),
			    a = n.extendComponentModel({ type: "axisPointer", coordSysAxesInfo: null, defaultOption: { show: "auto", triggerOn: null, zlevel: 0, z: 50, type: "line", snap: !1, triggerTooltip: !0, value: null, status: null, link: [], animation: null, animationDurationUpdate: 200, lineStyle: { color: "#aaa", width: 1, type: "solid" }, shadowStyle: { color: "rgba(150,150,150,0.3)" }, label: { show: !0, formatter: null, precision: "auto", margin: 3, textStyle: { color: "#fff" }, padding: [5, 7, 5, 7], backgroundColor: "auto", borderColor: null, borderWidth: 0, shadowBlur: 3, shadowColor: "#aaa" }, handle: { show: !1, icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z", size: 45, margin: 50, color: "#333", shadowBlur: 3, shadowColor: "#aaa", shadowOffsetX: 0, shadowOffsetY: 2, throttle: 40 } } });t.exports = a;
		}, function (t, e, i) {
			var n = i(122),
			    a = i(2).extendComponentView({ type: "axisPointer", render: function render(t, e, i) {
					var a = e.getComponent("tooltip"),
					    o = t.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";n.register("axisPointer", i, function (t, e, i) {
						"none" !== o && ("leave" === t || o.indexOf(t) >= 0) && i({ type: "updateAxisPointer", currTrigger: t, x: e && e.offsetX, y: e && e.offsetY });
					});
				}, remove: function remove(t, e) {
					n.disopse(e.getZr(), "axisPointer"), a.superApply(this._model, "remove", arguments);
				}, dispose: function dispose(t, e) {
					n.unregister("axisPointer", e), a.superApply(this._model, "dispose", arguments);
				} });
		}, function (t, e, i) {
			function n(t, e, i, n, o, p, g, m) {
				n = n || {}, f(i) && (i = v({ seriesIndex: n.seriesIndex, dataIndex: n.dataIndex }, p).point);var _ = f(i),
				    b = n.axesInfo,
				    w = t.axesInfo,
				    S = "leave" === e || f(i),
				    M = {},
				    I = {},
				    T = { list: [], map: {} },
				    A = { showPointer: x(r, I), showTooltip: x(s, T) };y(t.coordSysMap, function (e, n) {
					var o = _ || e.containPoint(i);y(t.coordSysAxesInfo[n], function (t, e) {
						var n = t.axis,
						    r = h(b, t);if (!S && o && (!b || r)) {
							var s = r && r.value;null != s || _ || (s = n.pointToData(i)), null != s && a(t, s, A, !1, M);
						}
					});
				});var C = {};return y(w, function (t, e) {
					var i = t.linkGroup;i && !I[e] && y(i.axesInfo, function (e, n) {
						var a = I[n];if (e !== t && a) {
							var o = a.value;i.mapper && (o = t.axis.scale.parse(i.mapper(o, d(e), d(t)))), C[t.key] = o;
						}
					});
				}), y(C, function (t, e) {
					a(w[e], t, A, !0, M);
				}), l(I, w, M), u(T, i, m, o), c(w, o, g), M;
			}function a(t, e, i, n, a) {
				var r = t.axis;if (!r.scale.isBlank() && r.containData(e)) {
					if (!t.involveSeries) return void i.showPointer(t, e);var s = o(e, t),
					    l = s.payloadBatch,
					    u = s.snapToValue;l[0] && null == a.seriesIndex && p.extend(a, l[0]), !n && t.snap && r.containData(u) && null != u && (e = u), i.showPointer(t, e, l, a), i.showTooltip(t, s, u);
				}
			}function o(t, e) {
				var i = e.axis,
				    n = i.dim,
				    a = t,
				    o = [],
				    r = Number.MAX_VALUE,
				    s = -1;return y(e.seriesModels, function (e, l) {
					var u,
					    c,
					    h = e.coordDimToDataDim(n);if (e.getAxisTooltipData) {
						var d = e.getAxisTooltipData(h, t, i);c = d.dataIndices, u = d.nestestValue;
					} else {
						if (c = e.getData().indicesOfNearest(h[0], t, !1, "category" === i.type ? .5 : null), !c.length) return;u = e.getData().get(h[0], c[0]);
					}if (null != u && isFinite(u)) {
						var f = t - u,
						    p = Math.abs(f);p <= r && ((p < r || f >= 0 && s < 0) && (r = p, s = f, a = u, o.length = 0), y(c, function (t) {
							o.push({ seriesIndex: e.seriesIndex, dataIndexInside: t, dataIndex: e.getData().getRawIndex(t) });
						}));
					}
				}), { payloadBatch: o, snapToValue: a };
			}function r(t, e, i, n) {
				t[e.key] = { value: i, payloadBatch: n };
			}function s(t, e, i, n) {
				var a = i.payloadBatch,
				    o = e.axis,
				    r = o.model,
				    s = e.axisPointerModel;if (e.triggerTooltip && a.length) {
					var l = e.coordSys.model,
					    u = m.makeKey(l),
					    c = t.map[u];c || (c = t.map[u] = { coordSysId: l.id, coordSysIndex: l.componentIndex, coordSysType: l.type, coordSysMainType: l.mainType, dataByAxis: [] }, t.list.push(c)), c.dataByAxis.push({ axisDim: o.dim, axisIndex: r.componentIndex, axisType: r.type, axisId: r.id, value: n, valueLabelOpt: { precision: s.get("label.precision"), formatter: s.get("label.formatter") }, seriesDataIndices: a.slice() });
				}
			}function l(t, e, i) {
				var n = i.axesInfo = [];y(e, function (e, i) {
					var a = e.axisPointerModel.option,
					    o = t[i];o ? (!e.useHandle && (a.status = "show"), a.value = o.value, a.seriesDataIndices = (o.payloadBatch || []).slice()) : !e.useHandle && (a.status = "hide"), "show" === a.status && n.push({ axisDim: e.axis.dim, axisIndex: e.axis.model.componentIndex, value: a.value });
				});
			}function u(t, e, i, n) {
				if (f(e) || !t.list.length) return void n({ type: "hideTip" });var a = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};n({ type: "showTip", escapeConnect: !0, x: e[0], y: e[1], tooltipOption: i, dataIndexInside: a.dataIndexInside, dataIndex: a.dataIndex, seriesIndex: a.seriesIndex, dataByCoordSys: t.list });
			}function c(t, e, i) {
				var n = i.getZr(),
				    a = "axisPointerLastHighlights",
				    o = _(n)[a] || {},
				    r = _(n)[a] = {};y(t, function (t, e) {
					var i = t.axisPointerModel.option;"show" === i.status && y(i.seriesDataIndices, function (t) {
						var e = t.seriesIndex + " | " + t.dataIndex;r[e] = t;
					});
				});var s = [],
				    l = [];p.each(o, function (t, e) {
					!r[e] && l.push(t);
				}), p.each(r, function (t, e) {
					!o[e] && s.push(t);
				}), l.length && i.dispatchAction({ type: "downplay", escapeConnect: !0, batch: l }), s.length && i.dispatchAction({ type: "highlight", escapeConnect: !0, batch: s });
			}function h(t, e) {
				for (var i = 0; i < (t || []).length; i++) {
					var n = t[i];if (e.axis.dim === n.axisDim && e.axis.model.componentIndex === n.axisIndex) return n;
				}
			}function d(t) {
				var e = t.axis.model,
				    i = {},
				    n = i.axisDim = t.axis.dim;return i.axisIndex = i[n + "AxisIndex"] = e.componentIndex, i.axisName = i[n + "AxisName"] = e.name, i.axisId = i[n + "AxisId"] = e.id, i;
			}function f(t) {
				return !t || null == t[0] || isNaN(t[0]) || null == t[1] || isNaN(t[1]);
			}var p = i(1),
			    g = i(5),
			    m = i(45),
			    v = i(121),
			    y = p.each,
			    x = p.curry,
			    _ = g.makeGetter();t.exports = n;
		}, function (t, e, i) {
			i(126), i(46), i(47), i(203), i(204), i(199), i(200), i(124), i(123);
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = [1 / 0, -(1 / 0)];return c(i, function (t) {
					var i = t.getData();i && c(t.coordDimToDataDim(e), function (t) {
						var e = i.getDataExtent(t);e[0] < n[0] && (n[0] = e[0]), e[1] > n[1] && (n[1] = e[1]);
					});
				}), n[1] < n[0] && (n = [NaN, NaN]), a(t, n), n;
			}function a(t, e) {
				var i = t.getAxisModel(),
				    n = i.getMin(!0),
				    a = "category" === i.get("type"),
				    o = a && (i.get("data") || []).length;null != n && "dataMin" !== n ? e[0] = n : a && (e[0] = o > 0 ? 0 : NaN);var r = i.getMax(!0);return null != r && "dataMax" !== r ? e[1] = r : a && (e[1] = o > 0 ? o - 1 : NaN), i.get("scale", !0) || (e[0] > 0 && (e[0] = 0), e[1] < 0 && (e[1] = 0)), e;
			}function o(t, e) {
				var i = t.getAxisModel(),
				    n = t._percentWindow,
				    a = t._valueWindow;if (n) {
					var o = l.getPixelPrecision(a, [0, 500]),
					    r = e || 0 === n[0] && 100 === n[1];i.setRange(r ? null : +a[0].toFixed(o), r ? null : +a[1].toFixed(o));
				}
			}function r(t) {
				var e = t._minMaxSpan = {},
				    i = t._dataZoomModel;c(["min", "max"], function (n) {
					e[n + "Span"] = i.get(n + "Span");var a = i.get(n + "ValueSpan");null != a && (e[n + "ValueSpan"] = a, a = t.getAxisModel().axis.scale.parse(a), null != a && (e[n + "Span"] = l.linearMap(a, t._dataExtent, [0, 100], !0)));
				});
			}var s = i(1),
			    l = i(4),
			    u = i(77),
			    c = s.each,
			    h = l.asc,
			    d = function d(t, e, i, n) {
				this._dimName = t, this._axisIndex = e, this._valueWindow, this._percentWindow, this._dataExtent, this._minMaxSpan, this.ecModel = n, this._dataZoomModel = i;
			};d.prototype = { constructor: d, hostedBy: function hostedBy(t) {
					return this._dataZoomModel === t;
				}, getDataValueWindow: function getDataValueWindow() {
					return this._valueWindow.slice();
				}, getDataPercentWindow: function getDataPercentWindow() {
					return this._percentWindow.slice();
				}, getTargetSeriesModels: function getTargetSeriesModels() {
					var t = [],
					    e = this.ecModel;return e.eachSeries(function (i) {
						if (u.isCoordSupported(i.get("coordinateSystem"))) {
							var n = this._dimName,
							    a = e.queryComponents({ mainType: n + "Axis", index: i.get(n + "AxisIndex"), id: i.get(n + "AxisId") })[0];this._axisIndex === (a && a.componentIndex) && t.push(i);
						}
					}, this), t;
				}, getAxisModel: function getAxisModel() {
					return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
				}, getOtherAxisModel: function getOtherAxisModel() {
					var t,
					    e,
					    i = this._dimName,
					    n = this.ecModel,
					    a = this.getAxisModel(),
					    o = "x" === i || "y" === i;o ? (e = "gridIndex", t = "x" === i ? "y" : "x") : (e = "polarIndex", t = "angle" === i ? "radius" : "angle");var r;return n.eachComponent(t + "Axis", function (t) {
						(t.get(e) || 0) === (a.get(e) || 0) && (r = t);
					}), r;
				}, getMinMaxSpan: function getMinMaxSpan() {
					return s.clone(this._minMaxSpan);
				}, calculateDataWindow: function calculateDataWindow(t) {
					var e = this._dataExtent,
					    i = this.getAxisModel(),
					    n = i.axis.scale,
					    a = this._dataZoomModel.getRangePropMode(),
					    o = [0, 100],
					    r = [t.start, t.end],
					    s = [];return c(["startValue", "endValue"], function (e) {
						s.push(null != t[e] ? n.parse(t[e]) : null);
					}), c([0, 1], function (t) {
						var i = s[t],
						    u = r[t];"percent" === a[t] ? (null == u && (u = o[t]), i = n.parse(l.linearMap(u, o, e, !0))) : u = l.linearMap(i, e, o, !0), s[t] = i, r[t] = u;
					}), { valueWindow: h(s), percentWindow: h(r) };
				}, reset: function reset(t) {
					if (t === this._dataZoomModel) {
						this._dataExtent = n(this, this._dimName, this.getTargetSeriesModels());var e = this.calculateDataWindow(t.option);this._valueWindow = e.valueWindow, this._percentWindow = e.percentWindow, r(this), o(this);
					}
				}, restore: function restore(t) {
					t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, o(this, !0));
				}, filterData: function filterData(t) {
					function e(t) {
						return t >= o[0] && t <= o[1];
					}if (t === this._dataZoomModel) {
						var i = this._dimName,
						    n = this.getTargetSeriesModels(),
						    a = t.get("filterMode"),
						    o = this._valueWindow;if ("none" !== a) {
							var r = this.getOtherAxisModel();t.get("$fromToolbox") && r && "category" === r.get("type") && (a = "empty"), c(n, function (t) {
								var n = t.getData(),
								    r = t.coordDimToDataDim(i);"weakFilter" === a ? n && n.filterSelf(function (t) {
									for (var e, i, a, s = 0; s < r.length; s++) {
										var l = n.get(r[s], t),
										    u = !isNaN(l),
										    c = l < o[0],
										    h = l > o[1];if (u && !c && !h) return !0;u && (a = !0), c && (e = !0), h && (i = !0);
									}return a && e && i;
								}) : n && c(r, function (i) {
									"empty" === a ? t.setData(n.map(i, function (t) {
										return e(t) ? t : NaN;
									})) : n.filterSelf(i, e);
								});
							});
						}
					}
				} }, t.exports = d;
		}, function (t, e, i) {
			t.exports = i(46).extend({ type: "dataZoom.inside", defaultOption: { disabled: !1, zoomLock: !1, zoomOnMouseWheel: !0, moveOnMouseMove: !0, preventDefaultMouseMove: !0 } });
		}, function (t, e, i) {
			var n = i(47),
			    a = i(1),
			    o = i(56),
			    r = i(205),
			    s = a.bind,
			    l = n.extend({ type: "dataZoom.inside", init: function init(t, e) {
					this._range;
				}, render: function render(t, e, i, n) {
					l.superApply(this, "render", arguments), r.shouldRecordRange(n, t.id) && (this._range = t.getPercentRange()), a.each(this.getTargetCoordInfo(), function (e, n) {
						var o = a.map(e, function (t) {
							return r.generateCoordId(t.model);
						});a.each(e, function (e) {
							var a = e.model,
							    l = t.option;r.register(i, { coordId: r.generateCoordId(a), allCoordIds: o, containsPoint: function containsPoint(t, e, i) {
									return a.coordinateSystem.containPoint([e, i]);
								}, dataZoomId: t.id, throttleRate: t.get("throttle", !0), panGetRange: s(this._onPan, this, e, n), zoomGetRange: s(this._onZoom, this, e, n), zoomLock: l.zoomLock, disabled: l.disabled, roamControllerOpt: { zoomOnMouseWheel: l.zoomOnMouseWheel, moveOnMouseMove: l.moveOnMouseMove, preventDefaultMouseMove: l.preventDefaultMouseMove } });
						}, this);
					}, this);
				}, dispose: function dispose() {
					r.unregister(this.api, this.dataZoomModel.id), l.superApply(this, "dispose", arguments), this._range = null;
				}, _onPan: function _onPan(t, e, i, n, a, r, s, l, c) {
					var h = this._range.slice(),
					    d = t.axisModels[0];if (d) {
						var f = u[e]([r, s], [l, c], d, i, t),
						    p = f.signal * (h[1] - h[0]) * f.pixel / f.pixelLength;return o(p, h, [0, 100], "all"), this._range = h;
					}
				}, _onZoom: function _onZoom(t, e, i, n, a, r) {
					var s = this._range.slice(),
					    l = t.axisModels[0];if (l) {
						var c = u[e](null, [a, r], l, i, t),
						    h = (c.pixel - c.pixelStart) / c.pixelLength * (s[1] - s[0]) + s[0];n = Math.max(1 / n, 0), s[0] = (s[0] - h) * n + h, s[1] = (s[1] - h) * n + h;var d = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();return o(0, s, [0, 100], 0, d.minSpan, d.maxSpan), this._range = s;
					}
				} }),
			    u = { grid: function grid(t, e, i, n, a) {
					var o = i.axis,
					    r = {},
					    s = a.model.coordinateSystem.getRect();return t = t || [0, 0], "x" === o.dim ? (r.pixel = e[0] - t[0], r.pixelLength = s.width, r.pixelStart = s.x, r.signal = o.inverse ? 1 : -1) : (r.pixel = e[1] - t[1], r.pixelLength = s.height, r.pixelStart = s.y, r.signal = o.inverse ? -1 : 1), r;
				}, polar: function polar(t, e, i, n, a) {
					var o = i.axis,
					    r = {},
					    s = a.model.coordinateSystem,
					    l = s.getRadiusAxis().getExtent(),
					    u = s.getAngleAxis().getExtent();return t = t ? s.pointToCoord(t) : [0, 0], e = s.pointToCoord(e), "radiusAxis" === i.mainType ? (r.pixel = e[0] - t[0], r.pixelLength = l[1] - l[0], r.pixelStart = l[0], r.signal = o.inverse ? 1 : -1) : (r.pixel = e[1] - t[1], r.pixelLength = u[1] - u[0], r.pixelStart = u[0], r.signal = o.inverse ? -1 : 1), r;
				}, singleAxis: function singleAxis(t, e, i, n, a) {
					var o = i.axis,
					    r = a.model.coordinateSystem.getRect(),
					    s = {};return t = t || [0, 0], "horizontal" === o.orient ? (s.pixel = e[0] - t[0], s.pixelLength = r.width, s.pixelStart = r.x, s.signal = o.inverse ? 1 : -1) : (s.pixel = e[1] - t[1], s.pixelLength = r.height, s.pixelStart = r.y, s.signal = o.inverse ? -1 : 1), s;
				} };t.exports = l;
		}, function (t, e, i) {
			var n = i(46);t.exports = n.extend({ type: "dataZoom.select" });
		}, function (t, e, i) {
			t.exports = i(47).extend({ type: "dataZoom.select" });
		}, function (t, e, i) {
			var n = i(46),
			    a = n.extend({ type: "dataZoom.slider", layoutMode: "box", defaultOption: { show: !0, right: "ph", top: "ph", width: "ph", height: "ph", left: null, bottom: null, backgroundColor: "rgba(47,69,84,0)", dataBackground: { lineStyle: { color: "#2f4554", width: .5, opacity: .3 }, areaStyle: { color: "rgba(47,69,84,0.3)", opacity: .3 } }, borderColor: "#ddd", fillerColor: "rgba(167,183,204,0.4)", handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z", handleSize: "100%", handleStyle: { color: "#a7b7cc" }, labelPrecision: null, labelFormatter: null, showDetail: !0, showDataShadow: "auto", realtime: !0, zoomLock: !1, textStyle: { color: "#333" } } });t.exports = a;
		}, function (t, e, i) {
			function n(t) {
				var e = { x: "y", y: "x", radius: "angle", angle: "radius" };return e[t];
			}var a = i(1),
			    o = i(3),
			    r = i(37),
			    s = i(47),
			    l = o.Rect,
			    u = i(4),
			    c = u.linearMap,
			    h = i(12),
			    d = i(56),
			    f = i(21),
			    p = u.asc,
			    g = a.bind,
			    m = a.each,
			    v = 7,
			    y = 1,
			    x = 30,
			    _ = "horizontal",
			    b = "vertical",
			    w = 5,
			    S = ["line", "bar", "candlestick", "scatter"],
			    M = s.extend({ type: "dataZoom.slider", init: function init(t, e) {
					this._displayables = {}, this._orient, this._range, this._handleEnds, this._size, this._handleWidth, this._handleHeight, this._location, this._dragging, this._dataShadowInfo, this.api = e;
				}, render: function render(t, e, i, n) {
					return M.superApply(this, "render", arguments), r.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"), this._orient = t.get("orient"), this.dataZoomModel.get("show") === !1 ? void this.group.removeAll() : (n && "dataZoom" === n.type && n.from === this.uid || this._buildView(), void this._updateView());
				}, remove: function remove() {
					M.superApply(this, "remove", arguments), r.clear(this, "_dispatchZoomAction");
				}, dispose: function dispose() {
					M.superApply(this, "dispose", arguments), r.clear(this, "_dispatchZoomAction");
				}, _buildView: function _buildView() {
					var t = this.group;t.removeAll(), this._resetLocation(), this._resetInterval();var e = this._displayables.barGroup = new o.Group();this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(e), this._positionGroup();
				}, _resetLocation: function _resetLocation() {
					var t = this.dataZoomModel,
					    e = this.api,
					    i = this._findCoordRect(),
					    n = { width: e.getWidth(), height: e.getHeight() },
					    o = this._orient === _ ? { right: n.width - i.x - i.width, top: n.height - x - v, width: i.width, height: x } : { right: v, top: i.y, width: x, height: i.height },
					    r = h.getLayoutParams(t.option);a.each(["right", "top", "width", "height"], function (t) {
						"ph" === r[t] && (r[t] = o[t]);
					});var s = h.getLayoutRect(r, n, t.padding);this._location = { x: s.x, y: s.y }, this._size = [s.width, s.height], this._orient === b && this._size.reverse();
				}, _positionGroup: function _positionGroup() {
					var t = this.group,
					    e = this._location,
					    i = this._orient,
					    n = this.dataZoomModel.getFirstTargetAxisModel(),
					    a = n && n.get("inverse"),
					    o = this._displayables.barGroup,
					    r = (this._dataShadowInfo || {}).otherAxisInverse;o.attr(i !== _ || a ? i === _ && a ? { scale: r ? [-1, 1] : [-1, -1] } : i !== b || a ? { scale: r ? [-1, -1] : [-1, 1], rotation: Math.PI / 2 } : { scale: r ? [1, -1] : [1, 1], rotation: Math.PI / 2 } : { scale: r ? [1, 1] : [1, -1] });var s = t.getBoundingRect([o]);t.attr("position", [e.x - s.x, e.y - s.y]);
				}, _getViewExtent: function _getViewExtent() {
					return [0, this._size[0]];
				}, _renderBackground: function _renderBackground() {
					var t = this.dataZoomModel,
					    e = this._size,
					    i = this._displayables.barGroup;i.add(new l({ silent: !0, shape: { x: 0, y: 0, width: e[0], height: e[1] }, style: { fill: t.get("backgroundColor") }, z2: -40 })), i.add(new l({ shape: { x: 0, y: 0, width: e[0], height: e[1] }, style: { fill: "transparent" }, z2: 0, onclick: a.bind(this._onClickPanelClick, this) }));
				}, _renderDataShadow: function _renderDataShadow() {
					var t = this._dataShadowInfo = this._prepareDataShadowInfo();if (t) {
						var e = this._size,
						    i = t.series,
						    n = i.getRawData(),
						    r = i.getShadowDim ? i.getShadowDim() : t.otherDim;if (null != r) {
							var s = n.getDataExtent(r),
							    l = .3 * (s[1] - s[0]);s = [s[0] - l, s[1] + l];var u,
							    h = [0, e[1]],
							    d = [0, e[0]],
							    f = [[e[0], 0], [0, 0]],
							    p = [],
							    g = d[1] / (n.count() - 1),
							    m = 0,
							    v = Math.round(n.count() / e[0]);n.each([r], function (t, e) {
								if (v > 0 && e % v) return void (m += g);var i = null == t || isNaN(t) || "" === t,
								    n = i ? 0 : c(t, s, h, !0);i && !u && e ? (f.push([f[f.length - 1][0], 0]), p.push([p[p.length - 1][0], 0])) : !i && u && (f.push([m, 0]), p.push([m, 0])), f.push([m, n]), p.push([m, n]), m += g, u = i;
							});var y = this.dataZoomModel;this._displayables.barGroup.add(new o.Polygon({ shape: { points: f }, style: a.defaults({ fill: y.get("dataBackgroundColor") }, y.getModel("dataBackground.areaStyle").getAreaStyle()), silent: !0, z2: -20 })), this._displayables.barGroup.add(new o.Polyline({ shape: { points: p }, style: y.getModel("dataBackground.lineStyle").getLineStyle(), silent: !0, z2: -19 }));
						}
					}
				}, _prepareDataShadowInfo: function _prepareDataShadowInfo() {
					var t = this.dataZoomModel,
					    e = t.get("showDataShadow");if (e !== !1) {
						var i,
						    o = this.ecModel;return t.eachTargetAxis(function (r, s) {
							var l = t.getAxisProxy(r.name, s).getTargetSeriesModels();a.each(l, function (t) {
								if (!(i || e !== !0 && a.indexOf(S, t.get("type")) < 0)) {
									var l,
									    u = o.getComponent(r.axis, s).axis,
									    c = n(r.name),
									    h = t.coordinateSystem;null != c && h.getOtherAxis && (l = h.getOtherAxis(u).inverse), i = { thisAxis: u, series: t, thisDim: r.name, otherDim: c, otherAxisInverse: l };
								}
							}, this);
						}, this), i;
					}
				}, _renderHandle: function _renderHandle() {
					var t = this._displayables,
					    e = t.handles = [],
					    i = t.handleLabels = [],
					    n = this._displayables.barGroup,
					    a = this._size,
					    r = this.dataZoomModel;n.add(t.filler = new l({ draggable: !0, cursor: "move", drift: g(this._onDragMove, this, "all"), onmousemove: function onmousemove(t) {
							f.stop(t.event);
						}, ondragstart: g(this._showDataInfo, this, !0), ondragend: g(this._onDragEnd, this), onmouseover: g(this._showDataInfo, this, !0), onmouseout: g(this._showDataInfo, this, !1), style: { fill: r.get("fillerColor"), textPosition: "inside" } })), n.add(new l(o.subPixelOptimizeRect({ silent: !0, shape: { x: 0, y: 0, width: a[0], height: a[1] }, style: { stroke: r.get("dataBackgroundColor") || r.get("borderColor"), lineWidth: y, fill: "rgba(0,0,0,0)" } })));var s = r.get("handleIcon");m([0, 1], function (t) {
						var a = { style: { strokeNoScale: !0 }, rectHover: !0, cursor: "vertical" === this._orient ? "ns-resize" : "ew-resize", draggable: !0, drift: g(this._onDragMove, this, t), onmousemove: function onmousemove(t) {
								f.stop(t.event);
							}, ondragend: g(this._onDragEnd, this), onmouseover: g(this._showDataInfo, this, !0), onmouseout: g(this._showDataInfo, this, !1) },
						    l = { x: -1, y: 0, width: 2, height: 2 },
						    c = 0 === s.indexOf("image://") ? (l.image = s.slice(8), a.style = l, new o.Image(a)) : o.makePath(s.replace("path://", ""), a, l, "center"),
						    h = c.getBoundingRect();this._handleHeight = u.parsePercent(r.get("handleSize"), this._size[1]), this._handleWidth = h.width / h.height * this._handleHeight, c.setStyle(r.getModel("handleStyle").getItemStyle());var d = r.get("handleColor");null != d && (c.style.fill = d), n.add(e[t] = c);var p = r.textStyleModel;this.group.add(i[t] = new o.Text({ silent: !0, invisible: !0, style: { x: 0, y: 0, text: "", textVerticalAlign: "middle", textAlign: "center", fill: p.getTextColor(), textFont: p.getFont() }, z2: 10 }));
					}, this);
				}, _resetInterval: function _resetInterval() {
					var t = this._range = this.dataZoomModel.getPercentRange(),
					    e = this._getViewExtent();this._handleEnds = [c(t[0], [0, 100], e, !0), c(t[1], [0, 100], e, !0)];
				}, _updateInterval: function _updateInterval(t, e) {
					var i = this.dataZoomModel,
					    n = this._handleEnds,
					    a = this._getViewExtent(),
					    o = i.findRepresentativeAxisProxy().getMinMaxSpan(),
					    r = [0, 100];d(e, n, a, i.get("zoomLock") ? "all" : t, null != o.minSpan ? c(o.minSpan, r, a, !0) : null, null != o.maxSpan ? c(o.maxSpan, r, a, !0) : null), this._range = p([c(n[0], a, r, !0), c(n[1], a, r, !0)]);
				}, _updateView: function _updateView(t) {
					var e = this._displayables,
					    i = this._handleEnds,
					    n = p(i.slice()),
					    a = this._size;m([0, 1], function (t) {
						var n = e.handles[t],
						    o = this._handleHeight;n.attr({ scale: [o / 2, o / 2], position: [i[t], a[1] / 2 - o / 2] });
					}, this), e.filler.setShape({ x: n[0], y: 0, width: n[1] - n[0], height: a[1] }), this._updateDataInfo(t);
				}, _updateDataInfo: function _updateDataInfo(t) {
					function e(t) {
						var e = o.getTransform(n.handles[t].parent, this.group),
						    i = o.transformDirection(0 === t ? "right" : "left", e),
						    l = this._handleWidth / 2 + w,
						    u = o.applyTransform([d[t] + (0 === t ? -l : l), this._size[1] / 2], e);a[t].setStyle({ x: u[0], y: u[1], textVerticalAlign: r === _ ? "middle" : i, textAlign: r === _ ? i : "center", text: s[t] });
					}var i = this.dataZoomModel,
					    n = this._displayables,
					    a = n.handleLabels,
					    r = this._orient,
					    s = ["", ""];if (i.get("showDetail")) {
						var l = i.findRepresentativeAxisProxy();if (l) {
							var u = l.getAxisModel().axis,
							    c = this._range,
							    h = t ? l.calculateDataWindow({ start: c[0], end: c[1] }).valueWindow : l.getDataValueWindow();s = [this._formatLabel(h[0], u), this._formatLabel(h[1], u)];
						}
					}var d = p(this._handleEnds.slice());e.call(this, 0), e.call(this, 1);
				}, _formatLabel: function _formatLabel(t, e) {
					var i = this.dataZoomModel,
					    n = i.get("labelFormatter"),
					    o = i.get("labelPrecision");null != o && "auto" !== o || (o = e.getPixelPrecision());var r = null == t || isNaN(t) ? "" : "category" === e.type || "time" === e.type ? e.scale.getLabel(Math.round(t)) : t.toFixed(Math.min(o, 20));return a.isFunction(n) ? n(t, r) : a.isString(n) ? n.replace("{value}", r) : r;
				}, _showDataInfo: function _showDataInfo(t) {
					t = this._dragging || t;var e = this._displayables.handleLabels;e[0].attr("invisible", !t), e[1].attr("invisible", !t);
				}, _onDragMove: function _onDragMove(t, e, i) {
					this._dragging = !0;var n = this._displayables.barGroup.getLocalTransform(),
					    a = o.applyTransform([e, i], n, !0);this._updateInterval(t, a[0]);var r = this.dataZoomModel.get("realtime");this._updateView(!r), r && r && this._dispatchZoomAction();
				}, _onDragEnd: function _onDragEnd() {
					this._dragging = !1, this._showDataInfo(!1), this._dispatchZoomAction();
				}, _onClickPanelClick: function _onClickPanelClick(t) {
					var e = this._size,
					    i = this._displayables.barGroup.transformCoordToLocal(t.offsetX, t.offsetY);if (!(i[0] < 0 || i[0] > e[0] || i[1] < 0 || i[1] > e[1])) {
						var n = this._handleEnds,
						    a = (n[0] + n[1]) / 2;this._updateInterval("all", i[0] - a), this._updateView(), this._dispatchZoomAction();
					}
				}, _dispatchZoomAction: function _dispatchZoomAction() {
					var t = this._range;this.api.dispatchAction({ type: "dataZoom", from: this.uid, dataZoomId: this.dataZoomModel.id, start: t[0], end: t[1] });
				}, _findCoordRect: function _findCoordRect() {
					var t;if (m(this.getTargetCoordInfo(), function (e) {
						if (!t && e.length) {
							var i = e[0].model.coordinateSystem;t = i.getRect && i.getRect();
						}
					}), !t) {
						var e = this.api.getWidth(),
						    i = this.api.getHeight();t = { x: .2 * e, y: .2 * i, width: .6 * e, height: .6 * i };
					}return t;
				} });t.exports = M;
		}, function (t, e, i) {
			function n(t) {
				var e = t.getZr();return e[p] || (e[p] = {});
			}function a(t, e) {
				var i = new h(t.getZr());return i.on("pan", f(r, e)), i.on("zoom", f(s, e)), i;
			}function o(t) {
				c.each(t, function (e, i) {
					e.count || (e.controller.dispose(), delete t[i]);
				});
			}function r(t, e, i, n, a, o, r) {
				l(t, function (s) {
					return s.panGetRange(t.controller, e, i, n, a, o, r);
				});
			}function s(t, e, i, n) {
				l(t, function (a) {
					return a.zoomGetRange(t.controller, e, i, n);
				});
			}function l(t, e) {
				var i = [];c.each(t.dataZoomInfos, function (t) {
					var n = e(t);n && i.push({ dataZoomId: t.dataZoomId, start: n[0], end: n[1] });
				}), t.dispatchAction(i);
			}function u(t, e) {
				t.dispatchAction({ type: "dataZoom", batch: e });
			}var c = i(1),
			    h = i(95),
			    d = i(37),
			    f = c.curry,
			    p = "\0_ec_dataZoom_roams",
			    g = { register: function register(t, e) {
					var i = n(t),
					    r = e.dataZoomId,
					    s = e.coordId;c.each(i, function (t, i) {
						var n = t.dataZoomInfos;n[r] && c.indexOf(e.allCoordIds, s) < 0 && (delete n[r], t.count--);
					}), o(i);var l = i[s];l || (l = i[s] = { coordId: s, dataZoomInfos: {}, count: 0 }, l.controller = a(t, l), l.dispatchAction = c.curry(u, t)), l.controller.enable(!e.disabled && (!e.zoomLock || "move"), e.roamControllerOpt), l.controller.setPointerChecker(e.containsPoint), d.createOrUpdate(l, "dispatchAction", e.throttleRate, "fixRate"), !l.dataZoomInfos[r] && l.count++, l.dataZoomInfos[r] = e;
				}, unregister: function unregister(t, e) {
					var i = n(t);c.each(i, function (t) {
						t.controller.dispose();var i = t.dataZoomInfos;i[e] && (delete i[e], t.count--);
					}), o(i);
				}, shouldRecordRange: function shouldRecordRange(t, e) {
					if (t && "dataZoom" === t.type && t.batch) for (var i = 0, n = t.batch.length; i < n; i++) {
						if (t.batch[i].dataZoomId === e) return !1;
					}return !0;
				}, generateCoordId: function generateCoordId(t) {
					return t.type + "\0_" + t.id;
				} };t.exports = g;
		}, function (t, e, i) {
			i(126), i(46), i(47), i(201), i(202), i(124), i(123);
		}, function (t, e, i) {
			function n(t, e, i, n) {
				var a = i.type,
				    o = f[a.charAt(0).toUpperCase() + a.slice(1)],
				    r = new o(i);e.add(r), n.set(t, r), r.__ecGraphicId = t;
			}function a(t, e) {
				var i = t && t.parent;i && ("group" === t.type && t.traverse(function (t) {
					a(t, e);
				}), e.removeKey(t.__ecGraphicId), i.remove(t));
			}function o(t) {
				return t = h.extend({}, t), h.each(["id", "parentId", "$action", "hv", "bounding"].concat(p.LOCATION_PARAMS), function (e) {
					delete t[e];
				}), t;
			}function r(t, e) {
				var i;return h.each(e, function (e) {
					null != t[e] && "auto" !== t[e] && (i = !0);
				}), i;
			}function s(t, e) {
				var i = t.exist;if (e.id = t.keyInfo.id, !e.type && i && (e.type = i.type), null == e.parentId) {
					var n = e.parentOption;n ? e.parentId = n.id : i && (e.parentId = i.parentId);
				}e.parentOption = null;
			}function l(t, e, i) {
				var n = h.extend({}, i),
				    a = t[e],
				    o = i.$action || "merge";if ("merge" === o) {
					if (a) {
						h.merge(a, n, !0), p.mergeLayoutParam(a, n, { ignoreSize: !0 }), p.copyLayoutParams(i, a);
					} else t[e] = n;
				} else "replace" === o ? t[e] = n : "remove" === o && a && (t[e] = null);
			}function u(t, e) {
				t && (t.hv = e.hv = [r(e, ["left", "right"]), r(e, ["top", "bottom"])], "group" === t.type && (null == t.width && (t.width = e.width = 0), null == t.height && (t.height = e.height = 0)));
			}var c = i(2),
			    h = i(1),
			    d = i(5),
			    f = i(3),
			    p = i(12);c.registerPreprocessor(function (t) {
				var e = t.graphic;h.isArray(e) ? e[0] && e[0].elements ? t.graphic = [t.graphic[0]] : t.graphic = [{ elements: e }] : e && !e.elements && (t.graphic = [{ elements: [e] }]);
			});var g = c.extendComponentModel({ type: "graphic", defaultOption: { elements: [], parentId: null }, _elOptionsToUpdate: null, mergeOption: function mergeOption(t) {
					var e = this.option.elements;this.option.elements = null, g.superApply(this, "mergeOption", arguments), this.option.elements = e;
				}, optionUpdated: function optionUpdated(t, e) {
					var i = this.option,
					    n = (e ? i : t).elements,
					    a = i.elements = e ? [] : i.elements,
					    o = [];this._flatten(n, o);var r = d.mappingToExists(a, o);d.makeIdAndName(r);var c = this._elOptionsToUpdate = [];h.each(r, function (t, e) {
						var i = t.option;i && (c.push(i), s(t, i), l(a, e, i), u(a[e], i));
					}, this);for (var f = a.length - 1; f >= 0; f--) {
						null == a[f] ? a.splice(f, 1) : delete a[f].$action;
					}
				}, _flatten: function _flatten(t, e, i) {
					h.each(t, function (t) {
						if (t) {
							i && (t.parentOption = i), e.push(t);var n = t.children;"group" === t.type && n && this._flatten(n, e, t), delete t.children;
						}
					}, this);
				}, useElOptionsToUpdate: function useElOptionsToUpdate() {
					var t = this._elOptionsToUpdate;return this._elOptionsToUpdate = null, t;
				} });c.extendComponentView({ type: "graphic", init: function init(t, e) {
					this._elMap = h.createHashMap(), this._lastGraphicModel;
				}, render: function render(t, e, i) {
					t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t, i), this._relocate(t, i);
				}, _updateElements: function _updateElements(t, e) {
					var i = t.useElOptionsToUpdate();if (i) {
						var r = this._elMap,
						    s = this.group;h.each(i, function (t) {
							var e = t.$action,
							    i = t.id,
							    l = r.get(i),
							    u = t.parentId,
							    c = null != u ? r.get(u) : s;t.hv && t.hv[1] && "text" === t.type && (t.style = h.defaults({ textBaseline: "middle" }, t.style), t.style.textVerticalAlign = null);var d = o(t);e && "merge" !== e ? "replace" === e ? (a(l, r), n(i, c, d, r)) : "remove" === e && a(l, r) : l ? l.attr(d) : n(i, c, d, r);var f = r.get(i);f && (f.__ecGraphicWidth = t.width, f.__ecGraphicHeight = t.height);
						});
					}
				}, _relocate: function _relocate(t, e) {
					for (var i = t.option.elements, n = this.group, a = this._elMap, o = i.length - 1; o >= 0; o--) {
						var r = i[o],
						    s = a.get(r.id);if (s) {
							var l = s.parent,
							    u = l === n ? { width: e.getWidth(), height: e.getHeight() } : { width: l.__ecGraphicWidth || 0, height: l.__ecGraphicHeight || 0 };p.positionElement(s, r, u, null, { hv: r.hv, boundingMode: r.bounding });
						}
					}
				}, _clear: function _clear() {
					var t = this._elMap;t.each(function (e) {
						a(e, t);
					}), this._elMap = h.createHashMap();
				}, dispose: function dispose() {
					this._clear();
				} });
		}, function (t, e, i) {
			i(32), i(120), i(55);
		}, function (t, e, i) {
			i(210), i(212), i(211);var n = i(2);n.registerProcessor(i(213));
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(10),
			    o = i(2).extendComponentModel({ type: "legend", dependencies: ["series"], layoutMode: { type: "box", ignoreSize: !0 }, init: function init(t, e, i) {
					this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {};
				}, mergeOption: function mergeOption(t) {
					o.superCall(this, "mergeOption", t);
				}, optionUpdated: function optionUpdated() {
					this._updateData(this.ecModel);var t = this._data;if (t[0] && "single" === this.get("selectedMode")) {
						for (var e = !1, i = 0; i < t.length; i++) {
							var n = t[i].get("name");if (this.isSelected(n)) {
								this.select(n), e = !0;break;
							}
						}!e && this.select(t[0].get("name"));
					}
				}, _updateData: function _updateData(t) {
					var e = n.map(this.get("data") || [], function (t) {
						return "string" != typeof t && "number" != typeof t || (t = { name: t }), new a(t, this, this.ecModel);
					}, this);this._data = e;var i = n.map(t.getSeries(), function (t) {
						return t.name;
					});t.eachSeries(function (t) {
						if (t.legendDataProvider) {
							var e = t.legendDataProvider();i = i.concat(e.mapArray(e.getName));
						}
					}), this._availableNames = i;
				}, getData: function getData() {
					return this._data;
				}, select: function select(t) {
					var e = this.option.selected,
					    i = this.get("selectedMode");if ("single" === i) {
						var a = this._data;n.each(a, function (t) {
							e[t.get("name")] = !1;
						});
					}e[t] = !0;
				}, unSelect: function unSelect(t) {
					"single" !== this.get("selectedMode") && (this.option.selected[t] = !1);
				}, toggleSelected: function toggleSelected(t) {
					var e = this.option.selected;e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t);
				}, isSelected: function isSelected(t) {
					var e = this.option.selected;return !(e.hasOwnProperty(t) && !e[t]) && n.indexOf(this._availableNames, t) >= 0;
				}, defaultOption: { zlevel: 0, z: 4, show: !0, orient: "horizontal", left: "center", top: "top", align: "auto", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, itemWidth: 25, itemHeight: 14, inactiveColor: "#ccc", textStyle: { color: "#333" }, selectedMode: !0, tooltip: { show: !1 } } });t.exports = o;
		}, function (t, e, i) {
			function n(t, e) {
				e.dispatchAction({ type: "legendToggleSelect", name: t });
			}function a(t, e, i) {
				var n = i.getZr().storage.getDisplayList()[0];n && n.useHoverLayer || t.get("legendHoverLink") && i.dispatchAction({ type: "highlight", seriesName: t.name, name: e });
			}function o(t, e, i) {
				var n = i.getZr().storage.getDisplayList()[0];n && n.useHoverLayer || t.get("legendHoverLink") && i.dispatchAction({ type: "downplay", seriesName: t.name, name: e });
			}var r = i(1),
			    s = i(24),
			    l = i(3),
			    u = i(130),
			    c = r.curry;t.exports = i(2).extendComponentView({ type: "legend", init: function init() {
					this._symbolTypeStore = {};
				}, render: function render(t, e, i) {
					var s = this.group;if (s.removeAll(), t.get("show")) {
						var h = t.get("selectedMode"),
						    d = t.get("align");"auto" === d && (d = "right" === t.get("left") && "vertical" === t.get("orient") ? "right" : "left");var f = r.createHashMap();r.each(t.getData(), function (r) {
							var u = r.get("name");if ("" === u || "\n" === u) return void s.add(new l.Group({ newline: !0 }));var p = e.getSeriesByName(u)[0];if (!f.get(u)) if (p) {
								var g = p.getData(),
								    m = g.getVisual("color");"function" == typeof m && (m = m(p.getDataParams(0)));var v = g.getVisual("legendSymbol") || "roundRect",
								    y = g.getVisual("symbol"),
								    x = this._createItem(u, r, t, v, y, d, m, h);x.on("click", c(n, u, i)).on("mouseover", c(a, p, null, i)).on("mouseout", c(o, p, null, i)), f.set(u, !0);
							} else e.eachRawSeries(function (e) {
								if (!f.get(u) && e.legendDataProvider) {
									var s = e.legendDataProvider(),
									    l = s.indexOfName(u);if (l < 0) return;var p = s.getItemVisual(l, "color"),
									    g = "roundRect",
									    m = this._createItem(u, r, t, g, null, d, p, h);m.on("click", c(n, u, i)).on("mouseover", c(a, e, u, i)).on("mouseout", c(o, e, u, i)), f.set(u, !0);
								}
							}, this);
						}, this), u.layout(s, t, i), u.addBackground(s, t);
					}
				}, _createItem: function _createItem(t, e, i, n, a, o, u, c) {
					var h = i.get("itemWidth"),
					    d = i.get("itemHeight"),
					    f = i.get("inactiveColor"),
					    p = i.isSelected(t),
					    g = new l.Group(),
					    m = e.getModel("textStyle"),
					    v = e.get("icon"),
					    y = e.getModel("tooltip"),
					    x = y.parentModel;if (n = v || n, g.add(s.createSymbol(n, 0, 0, h, d, p ? u : f)), !v && a && (a !== n || "none" == a)) {
						var _ = .8 * d;"none" === a && (a = "circle"), g.add(s.createSymbol(a, (h - _) / 2, (d - _) / 2, _, _, p ? u : f));
					}var b = "left" === o ? h + 5 : -5,
					    w = o,
					    S = i.get("formatter"),
					    M = t;"string" == typeof S && S ? M = S.replace("{name}", null != t ? t : "") : "function" == typeof S && (M = S(t));var I = new l.Text({ style: { text: M, x: b, y: d / 2, fill: p ? m.getTextColor() : f, textFont: m.getFont(), textAlign: w, textVerticalAlign: "middle" } });g.add(I);var T = new l.Rect({ shape: g.getBoundingRect(), invisible: !0, tooltip: y.get("show") ? r.extend({ content: t, formatter: x.get("formatter", !0) || function () {
								return t;
							}, formatterParams: { componentType: "legend", legendIndex: i.componentIndex, name: t, $vars: ["name"] } }, y.option) : null });return g.add(T), g.eachChild(function (t) {
						t.silent = !0;
					}), T.silent = !c, this.group.add(g), l.setHoverStyle(g), g;
				} });
		}, function (t, e, i) {
			function n(t, e, i) {
				var n,
				    a = {},
				    r = "toggleSelected" === t;return i.eachComponent("legend", function (i) {
					r && null != n ? i[n ? "select" : "unSelect"](e.name) : (i[t](e.name), n = i.isSelected(e.name));var s = i.getData();o.each(s, function (t) {
						var e = t.get("name");if ("\n" !== e && "" !== e) {
							var n = i.isSelected(e);a.hasOwnProperty(e) ? a[e] = a[e] && n : a[e] = n;
						}
					});
				}), { name: e.name, selected: a };
			}var a = i(2),
			    o = i(1);a.registerAction("legendToggleSelect", "legendselectchanged", o.curry(n, "toggleSelected")), a.registerAction("legendSelect", "legendselected", o.curry(n, "select")), a.registerAction("legendUnSelect", "legendunselected", o.curry(n, "unSelect"));
		}, function (t, e) {
			t.exports = function (t) {
				var e = t.findComponents({ mainType: "legend" });e && e.length && t.filterSeries(function (t) {
					for (var i = 0; i < e.length; i++) {
						if (!e[i].isSelected(t.name)) return !1;
					}return !0;
				});
			};
		}, function (t, e, i) {
			i(217), i(218), i(2).registerPreprocessor(function (t) {
				t.markArea = t.markArea || {};
			});
		}, function (t, e, i) {
			i(219), i(220), i(2).registerPreprocessor(function (t) {
				t.markLine = t.markLine || {};
			});
		}, function (t, e, i) {
			i(221), i(222), i(2).registerPreprocessor(function (t) {
				t.markPoint = t.markPoint || {};
			});
		}, function (t, e, i) {
			t.exports = i(79).extend({ type: "markArea", defaultOption: { zlevel: 0, z: 1, tooltip: { trigger: "item" }, animation: !1, label: { normal: { show: !0, position: "top" }, emphasis: { show: !0, position: "top" } }, itemStyle: { normal: { borderWidth: 0 } } } });
		}, function (t, e, i) {
			function n(t) {
				return !isNaN(t) && !isFinite(t);
			}function a(t, e, i, a) {
				var o = 1 - t;return n(e[o]) && n(i[o]);
			}function o(t, e) {
				var i = e.coord[0],
				    n = e.coord[1];return !("cartesian2d" !== t.type || !i || !n || !a(1, i, n, t) && !a(0, i, n, t)) || f.dataFilter(t, { coord: i, x: e.x0, y: e.y0 }) || f.dataFilter(t, { coord: n, x: e.x1, y: e.y1 });
			}function r(t, e, i, a, o) {
				var r,
				    s = a.coordinateSystem,
				    l = t.getItemModel(e),
				    u = c.parsePercent(l.get(i[0]), o.getWidth()),
				    h = c.parsePercent(l.get(i[1]), o.getHeight());if (isNaN(u) || isNaN(h)) {
					if (a.getMarkerPosition) r = a.getMarkerPosition(t.getValues(i, e));else {
						var d = t.get(i[0], e),
						    f = t.get(i[1], e);r = s.dataToPoint([d, f], !0);
					}if ("cartesian2d" === s.type) {
						var p = s.getAxis("x"),
						    g = s.getAxis("y"),
						    d = t.get(i[0], e),
						    f = t.get(i[1], e);n(d) ? r[0] = p.toGlobalCoord(p.getExtent()["x0" === i[0] ? 0 : 1]) : n(f) && (r[1] = g.toGlobalCoord(g.getExtent()["y0" === i[1] ? 0 : 1]));
					}isNaN(u) || (r[0] = u), isNaN(h) || (r[1] = h);
				} else r = [u, h];return r;
			}function s(t, e, i) {
				var n,
				    a,
				    r = ["x0", "y0", "x1", "y1"];t ? (n = l.map(t && t.dimensions, function (t) {
					var i = e.getData().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};return i.name = t, i;
				}), a = new u(l.map(r, function (t, e) {
					return { name: t, type: n[e % 2].type };
				}), i)) : (n = [{ name: "value", type: "float" }], a = new u(n, i));var s = l.map(i.get("data"), l.curry(p, e, t, i));t && (s = l.filter(s, l.curry(o, t)));var c = t ? function (t, e, i, n) {
					return t.coord[Math.floor(n / 2)][n % 2];
				} : function (t) {
					return t.value;
				};return a.initData(s, null, c), a.hasItemOption = !0, a;
			}var l = i(1),
			    u = i(14),
			    c = i(4),
			    h = i(3),
			    d = i(22),
			    f = i(81),
			    p = function p(t, e, i, n) {
				var a = f.dataTransform(t, n[0]),
				    o = f.dataTransform(t, n[1]),
				    r = l.retrieve,
				    s = a.coord,
				    u = o.coord;s[0] = r(s[0], -(1 / 0)), s[1] = r(s[1], -(1 / 0)), u[0] = r(u[0], 1 / 0), u[1] = r(u[1], 1 / 0);var c = l.mergeAll([{}, a, o]);return c.coord = [a.coord, o.coord], c.x0 = a.x, c.y0 = a.y, c.x1 = o.x, c.y1 = o.y, c;
			},
			    g = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];i(80).extend({ type: "markArea", updateLayout: function updateLayout(t, e, i) {
					e.eachSeries(function (t) {
						var e = t.markAreaModel;if (e) {
							var n = e.getData();n.each(function (e) {
								var a = l.map(g, function (a) {
									return r(n, e, a, t, i);
								});n.setItemLayout(e, a);var o = n.getItemGraphicEl(e);o.setShape("points", a);
							});
						}
					}, this);
				}, renderSeries: function renderSeries(t, e, i, n) {
					var a = t.coordinateSystem,
					    o = t.name,
					    u = t.getData(),
					    c = this.markerGroupMap,
					    f = c.get(o) || c.set(o, { group: new h.Group() });this.group.add(f.group), f.__keep = !0;var p = s(a, t, e);e.setData(p), p.each(function (e) {
						p.setItemLayout(e, l.map(g, function (i) {
							return r(p, e, i, t, n);
						})), p.setItemVisual(e, { color: u.getVisual("color") });
					}), p.diff(f.__data).add(function (t) {
						var e = new h.Polygon({ shape: { points: p.getItemLayout(t) } });p.setItemGraphicEl(t, e), f.group.add(e);
					}).update(function (t, i) {
						var n = f.__data.getItemGraphicEl(i);h.updateProps(n, { shape: { points: p.getItemLayout(t) } }, e, t), f.group.add(n), p.setItemGraphicEl(t, n);
					}).remove(function (t) {
						var e = f.__data.getItemGraphicEl(t);f.group.remove(e);
					}).execute(), p.eachItemGraphicEl(function (t, i) {
						var n = p.getItemModel(i),
						    a = n.getModel("label.normal"),
						    o = n.getModel("label.emphasis"),
						    r = p.getItemVisual(i, "color");t.useStyle(l.defaults(n.getModel("itemStyle.normal").getItemStyle(), { fill: d.modifyAlpha(r, .4), stroke: r })), t.hoverStyle = n.getModel("itemStyle.normal").getItemStyle();var s = p.getName(i) || "",
						    u = r || t.style.fill;a.getShallow("show") ? (h.setText(t.style, a, u), t.style.text = l.retrieve(e.getFormattedLabel(i, "normal"), s)) : t.style.text = "", o.getShallow("show") ? (h.setText(t.hoverStyle, o, u), t.hoverStyle.text = l.retrieve(e.getFormattedLabel(i, "emphasis"), s)) : t.hoverStyle.text = "", h.setHoverStyle(t, {}), t.dataModel = e;
					}), f.__data = p, f.group.silent = e.get("silent") || t.get("silent");
				} });
		}, function (t, e, i) {
			t.exports = i(79).extend({ type: "markLine", defaultOption: { zlevel: 0, z: 5, symbol: ["circle", "arrow"], symbolSize: [8, 16], precision: 2, tooltip: { trigger: "item" }, label: { normal: { show: !0, position: "end" }, emphasis: { show: !0 } }, lineStyle: { normal: { type: "dashed" }, emphasis: { width: 3 } }, animationEasing: "linear" } });
		}, function (t, e, i) {
			function n(t) {
				return !isNaN(t) && !isFinite(t);
			}function a(t, e, i, a) {
				var o = 1 - t,
				    r = a.dimensions[t];return n(e[o]) && n(i[o]) && e[t] === i[t] && a.getAxis(r).containData(e[t]);
			}function o(t, e) {
				if ("cartesian2d" === t.type) {
					var i = e[0].coord,
					    n = e[1].coord;if (i && n && (a(1, i, n, t) || a(0, i, n, t))) return !0;
				}return h.dataFilter(t, e[0]) && h.dataFilter(t, e[1]);
			}function r(t, e, i, a, o) {
				var r,
				    s = a.coordinateSystem,
				    l = t.getItemModel(e),
				    u = c.parsePercent(l.get("x"), o.getWidth()),
				    h = c.parsePercent(l.get("y"), o.getHeight());if (isNaN(u) || isNaN(h)) {
					if (a.getMarkerPosition) r = a.getMarkerPosition(t.getValues(t.dimensions, e));else {
						var d = s.dimensions,
						    f = t.get(d[0], e),
						    p = t.get(d[1], e);r = s.dataToPoint([f, p]);
					}if ("cartesian2d" === s.type) {
						var g = s.getAxis("x"),
						    m = s.getAxis("y"),
						    d = s.dimensions;n(t.get(d[0], e)) ? r[0] = g.toGlobalCoord(g.getExtent()[i ? 0 : 1]) : n(t.get(d[1], e)) && (r[1] = m.toGlobalCoord(m.getExtent()[i ? 0 : 1]));
					}isNaN(u) || (r[0] = u), isNaN(h) || (r[1] = h);
				} else r = [u, h];t.setItemLayout(e, r);
			}function s(t, e, i) {
				var n;n = t ? l.map(t && t.dimensions, function (t) {
					var i = e.getData().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};return i.name = t, i;
				}) : [{ name: "value", type: "float" }];var a = new u(n, i),
				    r = new u(n, i),
				    s = new u([], i),
				    c = l.map(i.get("data"), l.curry(f, e, t, i));t && (c = l.filter(c, l.curry(o, t)));var d = t ? h.dimValueGetter : function (t) {
					return t.value;
				};return a.initData(l.map(c, function (t) {
					return t[0];
				}), null, d), r.initData(l.map(c, function (t) {
					return t[1];
				}), null, d), s.initData(l.map(c, function (t) {
					return t[2];
				})), s.hasItemOption = !0, { from: a, to: r, line: s };
			}var l = i(1),
			    u = i(14),
			    c = i(4),
			    h = i(81),
			    d = i(107),
			    f = function f(t, e, i, n) {
				var a = t.getData(),
				    o = n.type;if (!l.isArray(n) && ("min" === o || "max" === o || "average" === o || null != n.xAxis || null != n.yAxis)) {
					var r, s, u;if (null != n.yAxis || null != n.xAxis) s = null != n.yAxis ? "y" : "x", r = e.getAxis(s), u = l.retrieve(n.yAxis, n.xAxis);else {
						var c = h.getAxisInfo(n, a, e, t);s = c.valueDataDim, r = c.valueAxis, u = h.numCalculate(a, s, o);
					}var d = "x" === s ? 0 : 1,
					    f = 1 - d,
					    p = l.clone(n),
					    g = {};p.type = null, p.coord = [], g.coord = [], p.coord[f] = -(1 / 0), g.coord[f] = 1 / 0;var m = i.get("precision");m >= 0 && "number" == typeof u && (u = +u.toFixed(m)), p.coord[d] = g.coord[d] = u, n = [p, g, { type: o, valueIndex: n.valueIndex, value: u }];
				}return n = [h.dataTransform(t, n[0]), h.dataTransform(t, n[1]), l.extend({}, n[2])], n[2].type = n[2].type || "", l.merge(n[2], n[0]), l.merge(n[2], n[1]), n;
			};i(80).extend({ type: "markLine", updateLayout: function updateLayout(t, e, i) {
					e.eachSeries(function (t) {
						var e = t.markLineModel;if (e) {
							var n = e.getData(),
							    a = e.__from,
							    o = e.__to;a.each(function (e) {
								r(a, e, !0, t, i), r(o, e, !1, t, i);
							}), n.each(function (t) {
								n.setItemLayout(t, [a.getItemLayout(t), o.getItemLayout(t)]);
							}), this.markerGroupMap.get(t.name).updateLayout();
						}
					}, this);
				}, renderSeries: function renderSeries(t, e, i, n) {
					function a(e, i, a) {
						var o = e.getItemModel(i);r(e, i, a, t, n), e.setItemVisual(i, { symbolSize: o.get("symbolSize") || x[a ? 0 : 1], symbol: o.get("symbol", !0) || y[a ? 0 : 1], color: o.get("itemStyle.normal.color") || c.getVisual("color") });
					}var o = t.coordinateSystem,
					    u = t.name,
					    c = t.getData(),
					    h = this.markerGroupMap,
					    f = h.get(u) || h.set(u, new d());this.group.add(f.group);var p = s(o, t, e),
					    g = p.from,
					    m = p.to,
					    v = p.line;e.__from = g, e.__to = m, e.setData(v);var y = e.get("symbol"),
					    x = e.get("symbolSize");l.isArray(y) || (y = [y, y]), "number" == typeof x && (x = [x, x]), p.from.each(function (t) {
						a(g, t, !0), a(m, t, !1);
					}), v.each(function (t) {
						var e = v.getItemModel(t).get("lineStyle.normal.color");v.setItemVisual(t, { color: e || g.getItemVisual(t, "color") }), v.setItemLayout(t, [g.getItemLayout(t), m.getItemLayout(t)]), v.setItemVisual(t, { fromSymbolSize: g.getItemVisual(t, "symbolSize"), fromSymbol: g.getItemVisual(t, "symbol"), toSymbolSize: m.getItemVisual(t, "symbolSize"), toSymbol: m.getItemVisual(t, "symbol") });
					}), f.updateData(v), p.line.eachItemGraphicEl(function (t, i) {
						t.traverse(function (t) {
							t.dataModel = e;
						});
					}), f.__keep = !0, f.group.silent = e.get("silent") || t.get("silent");
				} });
		}, function (t, e, i) {
			t.exports = i(79).extend({ type: "markPoint", defaultOption: { zlevel: 0, z: 5, symbol: "pin", symbolSize: 50, tooltip: { trigger: "item" }, label: { normal: { show: !0, position: "inside" }, emphasis: { show: !0 } }, itemStyle: { normal: { borderWidth: 2 } } } });
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = e.coordinateSystem;t.each(function (a) {
					var o,
					    r = t.getItemModel(a),
					    l = s.parsePercent(r.get("x"), i.getWidth()),
					    u = s.parsePercent(r.get("y"), i.getHeight());if (isNaN(l) || isNaN(u)) {
						if (e.getMarkerPosition) o = e.getMarkerPosition(t.getValues(t.dimensions, a));else if (n) {
							var c = t.get(n.dimensions[0], a),
							    h = t.get(n.dimensions[1], a);o = n.dataToPoint([c, h]);
						}
					} else o = [l, u];isNaN(l) || (o[0] = l), isNaN(u) || (o[1] = u), t.setItemLayout(a, o);
				});
			}function a(t, e, i) {
				var n;n = t ? r.map(t && t.dimensions, function (t) {
					var i = e.getData().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};return i.name = t, i;
				}) : [{ name: "value", type: "float" }];var a = new l(n, i),
				    o = r.map(i.get("data"), r.curry(u.dataTransform, e));return t && (o = r.filter(o, r.curry(u.dataFilter, t))), a.initData(o, null, t ? u.dimValueGetter : function (t) {
					return t.value;
				}), a;
			}var o = i(44),
			    r = i(1),
			    s = i(4),
			    l = i(14),
			    u = i(81);i(80).extend({ type: "markPoint", updateLayout: function updateLayout(t, e, i) {
					e.eachSeries(function (t) {
						var e = t.markPointModel;e && (n(e.getData(), t, i), this.markerGroupMap.get(t.name).updateLayout(e));
					}, this);
				}, renderSeries: function renderSeries(t, e, i, r) {
					var s = t.coordinateSystem,
					    l = t.name,
					    u = t.getData(),
					    c = this.markerGroupMap,
					    h = c.get(l) || c.set(l, new o()),
					    d = a(s, t, e);e.setData(d), n(e.getData(), t, r), d.each(function (t) {
						var i = d.getItemModel(t),
						    n = i.getShallow("symbolSize");"function" == typeof n && (n = n(e.getRawValue(t), e.getDataParams(t))), d.setItemVisual(t, { symbolSize: n, color: i.get("itemStyle.normal.color") || u.getVisual("color"), symbol: i.getShallow("symbol") });
					}), h.updateData(d), this.group.add(h.group), d.eachItemGraphicEl(function (t) {
						t.traverse(function (t) {
							t.dataModel = e;
						});
					}), h.__keep = !0, h.group.silent = e.get("silent") || t.get("silent");
				} });
		}, function (t, e, i) {
			"use strict";
			var n = i(2),
			    a = i(3),
			    o = i(12);n.extendComponentModel({ type: "title", layoutMode: { type: "box", ignoreSize: !0 }, defaultOption: { zlevel: 0, z: 6, show: !0, text: "", target: "blank", subtext: "", subtarget: "blank", left: 0, top: 0, backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, textStyle: { fontSize: 18, fontWeight: "bolder", color: "#333" }, subtextStyle: { color: "#aaa" } } }), n.extendComponentView({ type: "title", render: function render(t, e, i) {
					if (this.group.removeAll(), t.get("show")) {
						var n = this.group,
						    r = t.getModel("textStyle"),
						    s = t.getModel("subtextStyle"),
						    l = t.get("textAlign"),
						    u = t.get("textBaseline"),
						    c = new a.Text({ style: { text: t.get("text"), textFont: r.getFont(), fill: r.getTextColor() }, z2: 10 }),
						    h = c.getBoundingRect(),
						    d = t.get("subtext"),
						    f = new a.Text({ style: { text: d, textFont: s.getFont(), fill: s.getTextColor(), y: h.height + t.get("itemGap"), textBaseline: "top" }, z2: 10 }),
						    p = t.get("link"),
						    g = t.get("sublink");c.silent = !p, f.silent = !g, p && c.on("click", function () {
							window.open(p, "_" + t.get("target"));
						}), g && f.on("click", function () {
							window.open(g, "_" + t.get("subtarget"));
						}), n.add(c), d && n.add(f);var m = n.getBoundingRect(),
						    v = t.getBoxLayoutParams();v.width = m.width, v.height = m.height;var y = o.getLayoutRect(v, { width: i.getWidth(), height: i.getHeight() }, t.get("padding"));l || (l = t.get("left") || t.get("right"), "middle" === l && (l = "center"), "right" === l ? y.x += y.width : "center" === l && (y.x += y.width / 2)), u || (u = t.get("top") || t.get("bottom"), "center" === u && (u = "middle"), "bottom" === u ? y.y += y.height : "middle" === u && (y.y += y.height / 2), u = u || "top"), n.attr("position", [y.x, y.y]);var x = { textAlign: l, textVerticalAlign: u };c.setStyle(x), f.setStyle(x), m = n.getBoundingRect();var _ = y.margin,
						    b = t.getItemStyle(["color", "opacity"]);b.fill = t.get("backgroundColor");var w = new a.Rect({ shape: { x: m.x - _[3], y: m.y - _[0], width: m.width + _[1] + _[3], height: m.height + _[0] + _[2] }, style: b, silent: !0 });a.subPixelOptimizeRect(w), n.add(w);
					}
				} });
		}, function (t, e, i) {
			i(225), i(226), i(231), i(229), i(227), i(228), i(230);
		}, function (t, e, i) {
			var n = i(29),
			    a = i(1),
			    o = i(2).extendComponentModel({ type: "toolbox", layoutMode: { type: "box", ignoreSize: !0 }, mergeDefaultAndTheme: function mergeDefaultAndTheme(t) {
					o.superApply(this, "mergeDefaultAndTheme", arguments), a.each(this.option.feature, function (t, e) {
						var i = n.get(e);i && a.merge(t, i.defaultOption);
					});
				}, defaultOption: { show: !0, z: 6, zlevel: 0, orient: "horizontal", left: "right", top: "top", backgroundColor: "transparent", borderColor: "#ccc", borderWidth: 0, padding: 5, itemSize: 15, itemGap: 8, showTitle: !0, iconStyle: { normal: { borderColor: "#666", color: "none" }, emphasis: { borderColor: "#3E98C5" } } } });t.exports = o;
		}, function (t, e, i) {
			(function (e) {
				function n(t) {
					return 0 === t.indexOf("my");
				}var a = i(29),
				    o = i(1),
				    r = i(3),
				    s = i(10),
				    l = i(48),
				    u = i(130),
				    c = i(16);t.exports = i(2).extendComponentView({ type: "toolbox", render: function render(t, e, i, h) {
						function d(o, r) {
							var l,
							    u = y[o],
							    c = y[r],
							    d = m[u],
							    p = new s(d, t, t.ecModel);if (u && !c) {
								if (n(u)) l = { model: p, onclick: p.option.onclick, featureName: u };else {
									var g = a.get(u);if (!g) return;l = new g(p, e, i);
								}v[u] = l;
							} else {
								if (l = v[c], !l) return;l.model = p, l.ecModel = e, l.api = i;
							}return !u && c ? void (l.dispose && l.dispose(e, i)) : !p.get("show") || l.unusable ? void (l.remove && l.remove(e, i)) : (f(p, l, u), p.setIconStatus = function (t, e) {
								var i = this.option,
								    n = this.iconPaths;i.iconStatus = i.iconStatus || {}, i.iconStatus[t] = e, n[t] && n[t].trigger(e);
							}, void (l.render && l.render(p, e, i, h)));
						}function f(n, a, s) {
							var l = n.getModel("iconStyle"),
							    u = a.getIcons ? a.getIcons() : n.get("icon"),
							    c = n.get("title") || {};if ("string" == typeof u) {
								var h = u,
								    d = c;u = {}, c = {}, u[s] = h, c[s] = d;
							}var f = n.iconPaths = {};o.each(u, function (s, u) {
								var h = l.getModel("normal").getItemStyle(),
								    d = l.getModel("emphasis").getItemStyle(),
								    m = { x: -g / 2, y: -g / 2, width: g, height: g },
								    v = 0 === s.indexOf("image://") ? (m.image = s.slice(8), new r.Image({ style: m })) : r.makePath(s.replace("path://", ""), { style: h, hoverStyle: d, rectHover: !0 }, m, "center");r.setHoverStyle(v), t.get("showTitle") && (v.__title = c[u], v.on("mouseover", function () {
									var t = l.getModel("emphasis").getItemStyle();v.setStyle({ text: c[u], textPosition: t.textPosition || "bottom", textFill: t.fill || t.stroke || "#000", textAlign: t.textAlign || "center" });
								}).on("mouseout", function () {
									v.setStyle({ textFill: null });
								})), v.trigger(n.get("iconStatus." + u) || "normal"), p.add(v), v.on("click", o.bind(a.onclick, a, e, i, u)), f[u] = v;
							});
						}var p = this.group;if (p.removeAll(), t.get("show")) {
							var g = +t.get("itemSize"),
							    m = t.get("feature") || {},
							    v = this._features || (this._features = {}),
							    y = [];o.each(m, function (t, e) {
								y.push(e);
							}), new l(this._featureNames || [], y).add(d).update(d).remove(o.curry(d, null)).execute(), this._featureNames = y, u.layout(p, t, i), u.addBackground(p, t), p.eachChild(function (t) {
								var e = t.__title,
								    n = t.hoverStyle;if (n && e) {
									var a = c.getBoundingRect(e, n.font),
									    o = t.position[0] + p.position[0],
									    r = t.position[1] + p.position[1] + g,
									    s = !1;r + a.height > i.getHeight() && (n.textPosition = "top", s = !0);var l = s ? -5 - a.height : g + 8;o + a.width / 2 > i.getWidth() ? (n.textPosition = ["100%", l], n.textAlign = "right") : o - a.width / 2 < 0 && (n.textPosition = [0, l], n.textAlign = "left");
								}
							});
						}
					}, updateView: function updateView(t, e, i, n) {
						o.each(this._features, function (t) {
							t.updateView && t.updateView(t.model, e, i, n);
						});
					}, updateLayout: function updateLayout(t, e, i, n) {
						o.each(this._features, function (t) {
							t.updateLayout && t.updateLayout(t.model, e, i, n);
						});
					}, remove: function remove(t, e) {
						o.each(this._features, function (i) {
							i.remove && i.remove(t, e);
						}), this.group.removeAll();
					}, dispose: function dispose(t, e) {
						o.each(this._features, function (i) {
							i.dispose && i.dispose(t, e);
						});
					} });
			}).call(e, i(188));
		}, function (t, e, i) {
			function n(t) {
				var e = {},
				    i = [],
				    n = [];return t.eachRawSeries(function (t) {
					var a = t.coordinateSystem;if (!a || "cartesian2d" !== a.type && "polar" !== a.type) i.push(t);else {
						var o = a.getBaseAxis();if ("category" === o.type) {
							var r = o.dim + "_" + o.index;e[r] || (e[r] = { categoryAxis: o, valueAxis: a.getOtherAxis(o), series: [] }, n.push({ axisDim: o.dim, axisIndex: o.index })), e[r].series.push(t);
						} else i.push(t);
					}
				}), { seriesGroupByCategoryAxis: e, other: i, meta: n };
			}function a(t) {
				var e = [];return p.each(t, function (t, i) {
					var n = t.categoryAxis,
					    a = t.valueAxis,
					    o = a.dim,
					    r = [" "].concat(p.map(t.series, function (t) {
						return t.name;
					})),
					    s = [n.model.getCategories()];p.each(t.series, function (t) {
						s.push(t.getRawData().mapArray(o, function (t) {
							return t;
						}));
					});for (var l = [r.join(v)], u = 0; u < s[0].length; u++) {
						for (var c = [], h = 0; h < s.length; h++) {
							c.push(s[h][u]);
						}l.push(c.join(v));
					}e.push(l.join("\n"));
				}), e.join("\n\n" + m + "\n\n");
			}function o(t) {
				return p.map(t, function (t) {
					var e = t.getRawData(),
					    i = [t.name],
					    n = [];return e.each(e.dimensions, function () {
						for (var t = arguments.length, a = arguments[t - 1], o = e.getName(a), r = 0; r < t - 1; r++) {
							n[r] = arguments[r];
						}i.push((o ? o + v : "") + n.join(v));
					}), i.join("\n");
				}).join("\n\n" + m + "\n\n");
			}function r(t) {
				var e = n(t);return { value: p.filter([a(e.seriesGroupByCategoryAxis), o(e.other)], function (t) {
						return t.replace(/[\n\t\s]/g, "");
					}).join("\n\n" + m + "\n\n"), meta: e.meta };
			}function s(t) {
				return t.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
			}function l(t) {
				var e = t.slice(0, t.indexOf("\n"));if (e.indexOf(v) >= 0) return !0;
			}function u(t) {
				for (var e = t.split(/\n+/g), i = s(e.shift()).split(y), n = [], a = p.map(i, function (t) {
					return { name: t, data: [] };
				}), o = 0; o < e.length; o++) {
					var r = s(e[o]).split(y);n.push(r.shift());for (var l = 0; l < r.length; l++) {
						a[l] && (a[l].data[o] = r[l]);
					}
				}return { series: a, categories: n };
			}function c(t) {
				for (var e = t.split(/\n+/g), i = s(e.shift()), n = [], a = 0; a < e.length; a++) {
					var o,
					    r = s(e[a]).split(y),
					    l = "",
					    u = !1;isNaN(r[0]) ? (u = !0, l = r[0], r = r.slice(1), n[a] = { name: l, value: [] }, o = n[a].value) : o = n[a] = [];for (var c = 0; c < r.length; c++) {
						o.push(+r[c]);
					}1 === o.length && (u ? n[a].value = o[0] : n[a] = o[0]);
				}return { name: i, data: n };
			}function h(t, e) {
				var i = t.split(new RegExp("\n*" + m + "\n*", "g")),
				    n = { series: [] };return p.each(i, function (t, i) {
					if (l(t)) {
						var a = u(t),
						    o = e[i],
						    r = o.axisDim + "Axis";o && (n[r] = n[r] || [], n[r][o.axisIndex] = { data: a.categories }, n.series = n.series.concat(a.series));
					} else {
						var a = c(t);n.series.push(a);
					}
				}), n;
			}function d(t) {
				this._dom = null, this.model = t;
			}function f(t, e) {
				return p.map(t, function (t, i) {
					var n = e && e[i];return p.isObject(n) && !p.isArray(n) ? (p.isObject(t) && !p.isArray(t) && (t = t.value), p.defaults({ value: t }, n)) : t;
				});
			}var p = i(1),
			    g = i(21),
			    m = new Array(60).join("-"),
			    v = "\t",
			    y = new RegExp("[" + v + "]+", "g");d.defaultOption = { show: !0, readOnly: !1, optionToContent: null, contentToOption: null, icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28", title: "", lang: ["", "", ""], backgroundColor: "#fff", textColor: "#000", textareaColor: "#fff", textareaBorderColor: "#333", buttonColor: "#c23531", buttonTextColor: "#fff" }, d.prototype.onclick = function (t, e) {
				function i() {
					n.removeChild(o), M._dom = null;
				}var n = e.getDom(),
				    a = this.model;this._dom && n.removeChild(this._dom);var o = document.createElement("div");o.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;", o.style.backgroundColor = a.get("backgroundColor") || "#fff";var s = document.createElement("h4"),
				    l = a.get("lang") || [];s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin: 10px 20px;", s.style.color = a.get("textColor");var u = document.createElement("div"),
				    c = document.createElement("textarea");u.style.cssText = "display:block;width:100%;overflow:auto;";var d = a.get("optionToContent"),
				    f = a.get("contentToOption"),
				    m = r(t);if ("function" == typeof d) {
					var y = d(e.getOption());"string" == typeof y ? u.innerHTML = y : p.isDom(y) && u.appendChild(y);
				} else u.appendChild(c), c.readOnly = a.get("readOnly"), c.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;", c.style.color = a.get("textColor"), c.style.borderColor = a.get("textareaBorderColor"), c.style.backgroundColor = a.get("textareaColor"), c.value = m.value;var x = m.meta,
				    _ = document.createElement("div");_.style.cssText = "position:absolute;bottom:0;left:0;right:0;";var b = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px",
				    w = document.createElement("div"),
				    S = document.createElement("div");b += ";background-color:" + a.get("buttonColor"), b += ";color:" + a.get("buttonTextColor");var M = this;g.addEventListener(w, "click", i), g.addEventListener(S, "click", function () {
					var t;try {
						t = "function" == typeof f ? f(u, e.getOption()) : h(c.value, x);
					} catch (n) {
						throw i(), new Error("Data view format error " + n);
					}t && e.dispatchAction({ type: "changeDataView", newOption: t }), i();
				}), w.innerHTML = l[1], S.innerHTML = l[2], S.style.cssText = b, w.style.cssText = b, !a.get("readOnly") && _.appendChild(S), _.appendChild(w), g.addEventListener(c, "keydown", function (t) {
					if (9 === (t.keyCode || t.which)) {
						var e = this.value,
						    i = this.selectionStart,
						    n = this.selectionEnd;this.value = e.substring(0, i) + v + e.substring(n), this.selectionStart = this.selectionEnd = i + 1, g.stop(t);
					}
				}), o.appendChild(s), o.appendChild(u), o.appendChild(_), u.style.height = n.clientHeight - 80 + "px", n.appendChild(o), this._dom = o;
			}, d.prototype.remove = function (t, e) {
				this._dom && e.getDom().removeChild(this._dom);
			}, d.prototype.dispose = function (t, e) {
				this.remove(t, e);
			}, i(29).register("dataView", d), i(2).registerAction({ type: "changeDataView", event: "dataViewChanged", update: "prepareAndUpdate" }, function (t, e) {
				var i = [];p.each(t.newOption.series, function (t) {
					var n = e.getSeriesByName(t.name)[0];if (n) {
						var a = n.get("data");i.push({ name: t.name, data: f(t.data, a) });
					} else i.push(p.extend({ type: "scatter" }, t));
				}), e.mergeOption(p.defaults({ series: i }, t.newOption));
			}), t.exports = d;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				(this._brushController = new l(i.getZr())).on("brush", s.bind(this._onBrush, this)).mount(), this._isZoomActive;
			}function a(t) {
				var e = {};return s.each(["xAxisIndex", "yAxisIndex"], function (i) {
					e[i] = t[i], null == e[i] && (e[i] = "all"), (e[i] === !1 || "none" === e[i]) && (e[i] = []);
				}), e;
			}function o(t, e) {
				t.setIconStatus("back", c.count(e) > 1 ? "emphasis" : "normal");
			}function r(t, e, i, n, o) {
				var r = i._isZoomActive;n && "takeGlobalCursor" === n.type && (r = "dataZoomSelect" === n.key && n.dataZoomSelectActive), i._isZoomActive = r, t.setIconStatus("zoom", r ? "emphasis" : "normal");var s = new u(a(t.option), e, { include: ["grid"] });i._brushController.setPanels(s.makePanelOpts(o, function (t) {
					return t.xAxisDeclared && !t.yAxisDeclared ? "lineX" : !t.xAxisDeclared && t.yAxisDeclared ? "lineY" : "rect";
				})).enableBrush(!!r && { brushType: "auto", brushStyle: { lineWidth: 0, fill: "rgba(0,0,0,0.2)" } });
			}var s = i(1),
			    l = i(127),
			    u = i(184),
			    c = i(125),
			    h = i(56),
			    d = s.each;i(206);var f = "\0_ec_\0toolbox-dataZoom_";n.defaultOption = { show: !0, icon: { zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1", back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26" }, title: { zoom: "", back: "" } };var p = n.prototype;p.render = function (t, e, i, n) {
				this.model = t, this.ecModel = e, this.api = i, r(t, e, this, n, i), o(t, e);
			}, p.onclick = function (t, e, i) {
				g[i].call(this);
			}, p.remove = function (t, e) {
				this._brushController.unmount();
			}, p.dispose = function (t, e) {
				this._brushController.dispose();
			};var g = { zoom: function zoom() {
					var t = !this._isZoomActive;this.api.dispatchAction({ type: "takeGlobalCursor", key: "dataZoomSelect", dataZoomSelectActive: t });
				}, back: function back() {
					this._dispatchZoomAction(c.pop(this.ecModel));
				} };p._onBrush = function (t, e) {
				function i(t, e, i) {
					var a = e.getAxis(t),
					    s = a.model,
					    l = n(t, s, r),
					    u = l.findRepresentativeAxisProxy(s).getMinMaxSpan();null == u.minValueSpan && null == u.maxValueSpan || (i = h(0, i.slice(), a.scale.getExtent(), 0, u.minValueSpan, u.maxValueSpan)), l && (o[l.id] = { dataZoomId: l.id, startValue: i[0], endValue: i[1] });
				}function n(t, e, i) {
					var n;return i.eachComponent({ mainType: "dataZoom", subType: "select" }, function (i) {
						var a = i.getAxisModel(t, e.componentIndex);a && (n = i);
					}), n;
				}if (e.isEnd && t.length) {
					var o = {},
					    r = this.ecModel;this._brushController.updateCovers([]);var s = new u(a(this.model.option), r, { include: ["grid"] });s.matchOutputRanges(t, r, function (t, e, n) {
						if ("cartesian2d" === n.type) {
							var a = t.brushType;"rect" === a ? (i("x", n, e[0]), i("y", n, e[1])) : i({ lineX: "x", lineY: "y" }[a], n, e);
						}
					}), c.push(r, o), this._dispatchZoomAction(o);
				}
			}, p._dispatchZoomAction = function (t) {
				var e = [];d(t, function (t, i) {
					e.push(s.clone(t));
				}), e.length && this.api.dispatchAction({ type: "dataZoom", from: this.uid, batch: e });
			}, i(29).register("dataZoom", n), i(2).registerPreprocessor(function (t) {
				function e(t, e) {
					if (e) {
						var a = t + "Index",
						    o = e[a];null == o || "all" == o || s.isArray(o) || (o = o === !1 || "none" === o ? [] : [o]), i(t, function (e, i) {
							if (null == o || "all" == o || s.indexOf(o, i) !== -1) {
								var r = { type: "select", $fromToolbox: !0, id: f + t + i };r[a] = i, n.push(r);
							}
						});
					}
				}function i(e, i) {
					var n = t[e];s.isArray(n) || (n = n ? [n] : []), d(n, i);
				}if (t) {
					var n = t.dataZoom || (t.dataZoom = []);s.isArray(n) || (t.dataZoom = n = [n]);var a = t.toolbox;if (a && (s.isArray(a) && (a = a[0]), a && a.feature)) {
						var o = a.feature.dataZoom;e("xAxis", o), e("yAxis", o);
					}
				}
			}), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				this.model = t;
			}var a = i(1);n.defaultOption = { show: !0, type: [], icon: { line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4", bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7", stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z", tiled: "M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z" }, title: { line: "", bar: "", stack: "", tiled: "" }, option: {}, seriesIndex: {} };var o = n.prototype;o.getIcons = function () {
				var t = this.model,
				    e = t.get("icon"),
				    i = {};return a.each(t.get("type"), function (t) {
					e[t] && (i[t] = e[t]);
				}), i;
			};var r = { line: function line(t, e, i, n) {
					if ("bar" === t) return a.merge({ id: e, type: "line", data: i.get("data"), stack: i.get("stack"), markPoint: i.get("markPoint"), markLine: i.get("markLine") }, n.get("option.line") || {}, !0);
				}, bar: function bar(t, e, i, n) {
					if ("line" === t) return a.merge({ id: e, type: "bar", data: i.get("data"), stack: i.get("stack"), markPoint: i.get("markPoint"), markLine: i.get("markLine") }, n.get("option.bar") || {}, !0);
				}, stack: function stack(t, e, i, n) {
					if ("line" === t || "bar" === t) return a.merge({ id: e, stack: "__ec_magicType_stack__" }, n.get("option.stack") || {}, !0);
				}, tiled: function tiled(t, e, i, n) {
					if ("line" === t || "bar" === t) return a.merge({ id: e, stack: "" }, n.get("option.tiled") || {}, !0);
				} },
			    s = [["line", "bar"], ["stack", "tiled"]];o.onclick = function (t, e, i) {
				var n = this.model,
				    o = n.get("seriesIndex." + i);if (r[i]) {
					var l = { series: [] },
					    u = function u(e) {
						var o = e.subType,
						    s = e.id,
						    u = r[i](o, s, e, n);u && (a.defaults(u, e.option), l.series.push(u));var c = e.coordinateSystem;if (c && "cartesian2d" === c.type && ("line" === i || "bar" === i)) {
							var h = c.getAxesByScale("ordinal")[0];if (h) {
								var d = h.dim,
								    f = d + "Axis",
								    p = t.queryComponents({ mainType: f, index: e.get(name + "Index"), id: e.get(name + "Id") })[0],
								    g = p.componentIndex;l[f] = l[f] || [];for (var m = 0; m <= g; m++) {
									l[f][g] = l[f][g] || {};
								}l[f][g].boundaryGap = "bar" === i;
							}
						}
					};a.each(s, function (t) {
						a.indexOf(t, i) >= 0 && a.each(t, function (t) {
							n.setIconStatus(t, "normal");
						});
					}), n.setIconStatus(i, "emphasis"), t.eachComponent({ mainType: "series", query: null == o ? null : { seriesIndex: o } }, u), e.dispatchAction({ type: "changeMagicType", currentType: i, newOption: l });
				}
			};var l = i(2);l.registerAction({ type: "changeMagicType", event: "magicTypeChanged", update: "prepareAndUpdate" }, function (t, e) {
				e.mergeOption(t.newOption);
			}), i(29).register("magicType", n), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				this.model = t;
			}var a = i(125);n.defaultOption = { show: !0, icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5", title: "" };var o = n.prototype;o.onclick = function (t, e, i) {
				a.clear(t), e.dispatchAction({ type: "restore", from: this.uid });
			}, i(29).register("restore", n), i(2).registerAction({ type: "restore", event: "restore", update: "prepareAndUpdate" }, function (t, e) {
				e.resetOption("recreate");
			}), t.exports = n;
		}, function (t, e, i) {
			function n(t) {
				this.model = t;
			}var a = i(9);n.defaultOption = { show: !0, icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0", title: "", type: "png", name: "", excludeComponents: ["toolbox"], pixelRatio: 1, lang: [""] }, n.prototype.unusable = !a.canvasSupported;var o = n.prototype;o.onclick = function (t, e) {
				var i = this.model,
				    n = i.get("name") || t.get("title.0.text") || "echarts",
				    o = document.createElement("a"),
				    r = i.get("type", !0) || "png";o.download = n + "." + r, o.target = "_blank";var s = e.getConnectedDataURL({ type: r, backgroundColor: i.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff", excludeComponents: i.get("excludeComponents"), pixelRatio: i.get("pixelRatio") });if (o.href = s, "function" != typeof MouseEvent || a.browser.ie || a.browser.edge) {
					var l = i.get("lang"),
					    u = '<body style="margin:0;"><img src="' + s + '" style="max-width:100%;" title="' + (l && l[0] || "") + '" /></body>',
					    c = window.open();c.document.write(u);
				} else {
					var h = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !1 });o.dispatchEvent(h);
				}
			}, i(29).register("saveAsImage", n), t.exports = n;
		}, function (t, e, i) {
			i(55), i(234), i(235), i(2).registerAction({ type: "showTip", event: "showTip", update: "tooltip:manuallyShowTip" }, function () {}), i(2).registerAction({ type: "hideTip", event: "hideTip", update: "tooltip:manuallyHideTip" }, function () {});
		}, function (t, e, i) {
			function n(t) {
				var e = "cubic-bezier(0.23, 1, 0.32, 1)",
				    i = "left " + t + "s " + e + ",top " + t + "s " + e;return s.map(p, function (t) {
					return t + "transition:" + i;
				}).join(";");
			}function a(t) {
				var e = [],
				    i = t.get("fontSize"),
				    n = t.getTextColor();return n && e.push("color:" + n), e.push("font:" + t.getFont()), i && e.push("line-height:" + Math.round(3 * i / 2) + "px"), h(["decoration", "align"], function (i) {
					var n = t.get(i);n && e.push("text-" + i + ":" + n);
				}), e.join(";");
			}function o(t) {
				var e = [],
				    i = t.get("transitionDuration"),
				    o = t.get("backgroundColor"),
				    r = t.getModel("textStyle"),
				    s = t.get("padding");return i && e.push(n(i)), o && (f.canvasSupported ? e.push("background-Color:" + o) : (e.push("background-Color:#" + l.toHex(o)), e.push("filter:alpha(opacity=70)"))), h(["width", "color", "radius"], function (i) {
					var n = "border-" + i,
					    a = d(n),
					    o = t.get(a);null != o && e.push(n + ":" + o + ("color" === i ? "" : "px"));
				}), e.push(a(r)), null != s && e.push("padding:" + c.normalizeCssArray(s).join("px ") + "px"), e.join(";") + ";";
			}function r(t, e) {
				var i = document.createElement("div"),
				    n = this._zr = e.getZr();this.el = i, this._x = e.getWidth() / 2, this._y = e.getHeight() / 2, t.appendChild(i), this._container = t, this._show = !1, this._hideTimeout;var a = this;i.onmouseenter = function () {
					a._enterable && (clearTimeout(a._hideTimeout), a._show = !0), a._inContent = !0;
				}, i.onmousemove = function (e) {
					if (e = e || window.event, !a._enterable) {
						var i = n.handler;u.normalizeEvent(t, e, !0), i.dispatch("mousemove", e);
					}
				}, i.onmouseleave = function () {
					a._enterable && a._show && a.hideLater(a._hideDelay), a._inContent = !1;
				};
			}var s = i(1),
			    l = i(22),
			    u = i(21),
			    c = i(7),
			    h = s.each,
			    d = c.toCamelCase,
			    f = i(9),
			    p = ["", "-webkit-", "-moz-", "-o-"],
			    g = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";r.prototype = { constructor: r, _enterable: !0, update: function update() {
					var t = this._container,
					    e = t.currentStyle || document.defaultView.getComputedStyle(t),
					    i = t.style;"absolute" !== i.position && "absolute" !== e.position && (i.position = "relative");
				}, show: function show(t) {
					clearTimeout(this._hideTimeout);var e = this.el;e.style.cssText = g + o(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""), e.style.display = e.innerHTML ? "block" : "none", this._show = !0;
				}, setContent: function setContent(t) {
					this.el.innerHTML = null == t ? "" : t;
				}, setEnterable: function setEnterable(t) {
					this._enterable = t;
				}, getSize: function getSize() {
					var t = this.el;return [t.clientWidth, t.clientHeight];
				}, moveTo: function moveTo(t, e) {
					var i,
					    n = this._zr;n && n.painter && (i = n.painter.getViewportRoot()) && (t += i.offsetLeft || 0, e += i.offsetTop || 0);var a = this.el.style;a.left = t + "px", a.top = e + "px", this._x = t, this._y = e;
				}, hide: function hide() {
					this.el.style.display = "none", this._show = !1;
				}, hideLater: function hideLater(t) {
					!this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(s.bind(this.hide, this), t)) : this.hide());
				}, isShow: function isShow() {
					return this._show;
				} }, t.exports = r;
		}, function (t, e, i) {
			i(2).extendComponentModel({ type: "tooltip", dependencies: ["axisPointer"], defaultOption: { zlevel: 0, z: 8, show: !0, showContent: !0, trigger: "item", triggerOn: "mousemove|click", alwaysShowContent: !1, displayMode: "single", confine: !1, showDelay: 0, hideDelay: 100, transitionDuration: .4, enterable: !1, backgroundColor: "rgba(50,50,50,0.7)", borderColor: "#333", borderRadius: 4, borderWidth: 0, padding: 5, extraCssText: "", axisPointer: { type: "line", axis: "auto", animation: "auto", animationDurationUpdate: 200, animationEasingUpdate: "exponentialOut", crossStyle: { color: "#999", width: 1, type: "dashed", textStyle: {} } }, textStyle: { color: "#fff", fontSize: 14 } } });
		}, function (t, e, i) {
			function n(t) {
				for (var e = t.pop(); t.length;) {
					var i = t.pop();i && (i instanceof v && (i = i.get("tooltip", !0)), "string" == typeof i && (i = { formatter: i }), e = new v(i, e, e.ecModel));
				}return e;
			}function a(t, e) {
				return t.dispatchAction || c.bind(e.dispatchAction, e);
			}function o(t, e, i, n, a, o, r) {
				var s = i.clientWidth,
				    l = i.clientHeight;return null != o && (t + s + o > n ? t -= s + o : t += o), null != r && (e + l + r > a ? e -= l + r : e += r), [t, e];
			}function r(t, e, i, n, a) {
				var o = i.clientWidth,
				    r = i.clientHeight;return t = Math.min(t + o, n) - o, e = Math.min(e + r, a) - r, t = Math.max(t, 0), e = Math.max(e, 0), [t, e];
			}function s(t, e, i) {
				var n = i[0],
				    a = i[1],
				    o = 5,
				    r = 0,
				    s = 0,
				    l = e.width,
				    u = e.height;switch (t) {case "inside":
						r = e.x + l / 2 - n / 2, s = e.y + u / 2 - a / 2;break;case "top":
						r = e.x + l / 2 - n / 2, s = e.y - a - o;break;case "bottom":
						r = e.x + l / 2 - n / 2, s = e.y + u + o;break;case "left":
						r = e.x - n - o, s = e.y + u / 2 - a / 2;break;case "right":
						r = e.x + l + o, s = e.y + u / 2 - a / 2;}return [r, s];
			}function l(t) {
				return "center" === t || "middle" === t;
			}var u = i(233),
			    c = i(1),
			    h = i(7),
			    d = i(4),
			    f = i(3),
			    p = i(121),
			    g = i(12),
			    m = i(9),
			    v = i(10),
			    y = i(122),
			    x = i(18),
			    _ = i(76),
			    b = c.bind,
			    w = c.each,
			    S = d.parsePercent,
			    M = new f.Rect({ shape: { x: -1, y: -1, width: 2, height: 2 } });i(2).extendComponentView({ type: "tooltip", init: function init(t, e) {
					if (!m.node) {
						var i = new u(e.getDom(), e);this._tooltipContent = i;
					}
				}, render: function render(t, e, i) {
					if (!m.node) {
						this.group.removeAll(), this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastDataByCoordSys = null, this._alwaysShowContent = t.get("alwaysShowContent");var n = this._tooltipContent;n.update(), n.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow();
					}
				}, _initGlobalListener: function _initGlobalListener() {
					var t = this._tooltipModel,
					    e = t.get("triggerOn");y.register("itemTooltip", this._api, b(function (t, i, n) {
						"none" !== e && (e.indexOf(t) >= 0 ? this._tryShow(i, n) : "leave" === t && this._hide(n));
					}, this));
				}, _keepShow: function _keepShow() {
					var t = this._tooltipModel,
					    e = this._ecModel,
					    i = this._api;if (null != this._lastX && null != this._lastY && "none" !== t.get("triggerOn")) {
						var n = this;clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function () {
							n.manuallyShowTip(t, e, i, { x: n._lastX, y: n._lastY });
						});
					}
				}, manuallyShowTip: function manuallyShowTip(t, e, i, n) {
					if (n.from !== this.uid && !m.node) {
						var o = a(n, i);this._ticket = "";var r = n.dataByCoordSys;if (n.tooltip && null != n.x && null != n.y) {
							var s = M;s.position = [n.x, n.y], s.update(), s.tooltip = n.tooltip, this._tryShow({ offsetX: n.x, offsetY: n.y, target: s }, o);
						} else if (r) this._tryShow({ offsetX: n.x, offsetY: n.y, position: n.position, event: {}, dataByCoordSys: n.dataByCoordSys, tooltipOption: n.tooltipOption }, o);else if (null != n.seriesIndex) {
							if (this._manuallyAxisShowTip(t, e, i, n)) return;var l = p(n, e),
							    u = l.point[0],
							    c = l.point[1];null != u && null != c && this._tryShow({ offsetX: u, offsetY: c, position: n.position, target: l.el, event: {} }, o);
						} else null != n.x && null != n.y && (i.dispatchAction({ type: "updateAxisPointer", x: n.x, y: n.y }), this._tryShow({ offsetX: n.x, offsetY: n.y, position: n.position, target: i.getZr().findHover(n.x, n.y).target, event: {} }, o));
					}
				}, manuallyHideTip: function manuallyHideTip(t, e, i, n) {
					var o = this._tooltipContent;this._alwaysShowContent || o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = null, n.from !== this.uid && this._hide(a(n, i));
				}, _manuallyAxisShowTip: function _manuallyAxisShowTip(t, e, i, a) {
					var o = a.seriesIndex,
					    r = a.dataIndex,
					    s = e.getComponent("axisPointer").coordSysAxesInfo;if (null != o && null != r && null != s) {
						var l = e.getSeriesByIndex(o);if (l) {
							var u = l.getData(),
							    t = n([u.getItemModel(r), l, (l.coordinateSystem || {}).model, t]);if ("axis" === t.get("trigger")) return i.dispatchAction({ type: "updateAxisPointer", seriesIndex: o, dataIndex: r }), !0;
						}
					}
				}, _tryShow: function _tryShow(t, e) {
					var i = t.target,
					    n = this._tooltipModel;if (n) {
						this._lastX = t.offsetX, this._lastY = t.offsetY;var a = t.dataByCoordSys;a && a.length ? this._showAxisTooltip(a, t) : i && null != i.dataIndex ? (this._lastDataByCoordSys = null, this._showSeriesItemTooltip(t, i, e)) : i && i.tooltip ? (this._lastDataByCoordSys = null, this._showComponentItemTooltip(t, i, e)) : (this._lastDataByCoordSys = null, this._hide(e));
					}
				}, _showOrMove: function _showOrMove(t, e) {
					var i = t.get("showDelay");e = c.bind(e, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(e, i) : e();
				}, _showAxisTooltip: function _showAxisTooltip(t, e) {
					var i = this._ecModel,
					    a = this._tooltipModel,
					    o = [e.offsetX, e.offsetY],
					    r = [],
					    s = [],
					    l = n([e.tooltipOption, a]);w(t, function (t) {
						w(t.dataByAxis, function (t) {
							var e = i.getComponent(t.axisDim + "Axis", t.axisIndex),
							    n = t.value,
							    a = [];if (e && null != n) {
								var o = _.getValueLabel(n, e.axis, i, t.seriesDataIndices, t.valueLabelOpt);c.each(t.seriesDataIndices, function (r) {
									var l = i.getSeriesByIndex(r.seriesIndex),
									    u = r.dataIndexInside,
									    c = l && l.getDataParams(u);c.axisDim = t.axisDim, c.axisIndex = t.axisIndex, c.axisType = t.axisType, c.axisId = t.axisId, c.axisValue = x.getAxisRawValue(e.axis, n), c.axisValueLabel = o, c && (s.push(c), a.push(l.formatTooltip(u, !0)));
								});var l = o;r.push((l ? h.encodeHTML(l) + "<br />" : "") + a.join("<br />"));
							}
						});
					}, this), r.reverse(), r = r.join("<br /><br />");var u = e.position;this._showOrMove(l, function () {
						this._updateContentNotChangedOnAxis(t) ? this._updatePosition(l, u, o[0], o[1], this._tooltipContent, s) : this._showTooltipContent(l, r, s, Math.random(), o[0], o[1], u);
					});
				}, _showSeriesItemTooltip: function _showSeriesItemTooltip(t, e, i) {
					var a = this._ecModel,
					    o = e.seriesIndex,
					    r = a.getSeriesByIndex(o),
					    s = e.dataModel || r,
					    l = e.dataIndex,
					    u = e.dataType,
					    c = s.getData(),
					    h = n([c.getItemModel(l), s, r && (r.coordinateSystem || {}).model, this._tooltipModel]),
					    d = h.get("trigger");if (null == d || "item" === d) {
						var f = s.getDataParams(l, u),
						    p = s.formatTooltip(l, !1, u),
						    g = "item_" + s.name + "_" + l;this._showOrMove(h, function () {
							this._showTooltipContent(h, p, f, g, t.offsetX, t.offsetY, t.position, t.target);
						}), i({ type: "showTip", dataIndexInside: l, dataIndex: c.getRawIndex(l), seriesIndex: o, from: this.uid });
					}
				}, _showComponentItemTooltip: function _showComponentItemTooltip(t, e, i) {
					var n = e.tooltip;if ("string" == typeof n) {
						var a = n;n = { content: a, formatter: a };
					}var o = new v(n, this._tooltipModel, this._ecModel),
					    r = o.get("content"),
					    s = Math.random();this._showOrMove(o, function () {
						this._showTooltipContent(o, r, o.get("formatterParams") || {}, s, t.offsetX, t.offsetY, t.position, e);
					}), i({ type: "showTip", from: this.uid });
				}, _showTooltipContent: function _showTooltipContent(t, e, i, n, a, o, r, s) {
					if (this._ticket = "", t.get("showContent") && t.get("show")) {
						var l = this._tooltipContent,
						    u = t.get("formatter");r = r || t.get("position");var c = e;if (u && "string" == typeof u) c = h.formatTpl(u, i, !0);else if ("function" == typeof u) {
							var d = b(function (e, n) {
								e === this._ticket && (l.setContent(n), this._updatePosition(t, r, a, o, l, i, s));
							}, this);this._ticket = n, c = u(i, n, d);
						}l.setContent(c), l.show(t), this._updatePosition(t, r, a, o, l, i, s);
					}
				}, _updatePosition: function _updatePosition(t, e, i, n, a, u, h) {
					var d = this._api.getWidth(),
					    f = this._api.getHeight();e = e || t.get("position");var p = a.getSize(),
					    m = t.get("align"),
					    v = t.get("verticalAlign"),
					    y = h && h.getBoundingRect().clone();if (h && y.applyTransform(h.transform), "function" == typeof e && (e = e([i, n], u, a.el, y, { viewSize: [d, f], contentSize: p.slice() })), c.isArray(e)) i = S(e[0], d), n = S(e[1], f);else if (c.isObject(e)) {
						e.width = p[0], e.height = p[1];var x = g.getLayoutRect(e, { width: d, height: f });i = x.x, n = x.y, m = null, v = null;
					} else if ("string" == typeof e && h) {
						var _ = s(e, y, p);i = _[0], n = _[1];
					} else {
						var _ = o(i, n, a.el, d, f, m ? null : 20, v ? null : 20);i = _[0], n = _[1];
					}if (m && (i -= l(m) ? p[0] / 2 : "right" === m ? p[0] : 0), v && (n -= l(v) ? p[1] / 2 : "bottom" === v ? p[1] : 0), t.get("confine")) {
						var _ = r(i, n, a.el, d, f);i = _[0], n = _[1];
					}a.moveTo(i, n);
				}, _updateContentNotChangedOnAxis: function _updateContentNotChangedOnAxis(t) {
					var e = this._lastDataByCoordSys,
					    i = !!e && e.length === t.length;return i && w(e, function (e, n) {
						var a = e.dataByAxis || {},
						    o = t[n] || {},
						    r = o.dataByAxis || [];i &= a.length === r.length, i && w(a, function (t, e) {
							var n = r[e] || {},
							    a = t.seriesDataIndices || [],
							    o = n.seriesDataIndices || [];i &= t.value === n.value && t.axisType === n.axisType && t.axisId === n.axisId && a.length === o.length, i && w(a, function (t, e) {
								var n = o[e];i &= t.seriesIndex === n.seriesIndex && t.dataIndex === n.dataIndex;
							});
						});
					}), this._lastDataByCoordSys = t, !!i;
				}, _hide: function _hide(t) {
					this._lastDataByCoordSys = null, t({ type: "hideTip", from: this.uid });
				}, dispose: function dispose(t, e) {
					m.node || (this._tooltipContent.hide(), y.unregister("itemTooltip", e));
				} });
		}, function (t, e, i) {
			function n(t, e) {
				var i = t.get("center"),
				    n = t.get("radius"),
				    a = e.getWidth(),
				    o = e.getHeight(),
				    r = s.parsePercent;this.cx = r(i[0], a), this.cy = r(i[1], o);var l = this.getRadiusAxis(),
				    u = Math.min(a, o) / 2;l.setExtent(0, r(n, u));
			}function a(t, e) {
				var i = this,
				    n = i.getAngleAxis(),
				    a = i.getRadiusAxis();if (n.scale.setExtent(1 / 0, -(1 / 0)), a.scale.setExtent(1 / 0, -(1 / 0)), t.eachSeries(function (t) {
					if (t.coordinateSystem === i) {
						var e = t.getData();a.scale.unionExtentFromData(e, "radius"), n.scale.unionExtentFromData(e, "angle");
					}
				}), u(n.scale, n.model), u(a.scale, a.model), "category" === n.type && !n.onBand) {
					var o = n.getExtent(),
					    r = 360 / n.scale.count();n.inverse ? o[1] += r : o[1] -= r, n.setExtent(o[0], o[1]);
				}
			}function o(t, e) {
				if (t.type = e.get("type"), t.scale = l.createScaleByModel(e), t.onBand = e.get("boundaryGap") && "category" === t.type, "angleAxis" === e.mainType) {
					var i = e.get("startAngle");t.inverse = e.get("inverse") ^ e.get("clockwise"), t.setExtent(i, i + (t.inverse ? -360 : 360));
				}e.axis = t, t.model = e;
			}var r = i(411),
			    s = i(4),
			    l = (i(1), i(18)),
			    u = l.niceScaleExtent;i(412);var c = { dimensions: r.prototype.dimensions, create: function create(t, e) {
					var i = [];return t.eachComponent("polar", function (t, s) {
						var l = new r(s);l.resize = n, l.update = a;var u = l.getRadiusAxis(),
						    c = l.getAngleAxis(),
						    h = t.findAxisModel("radiusAxis"),
						    d = t.findAxisModel("angleAxis");o(u, h), o(c, d), l.resize(t, e), i.push(l), t.coordinateSystem = l, l.model = t;
					}), t.eachSeries(function (e) {
						if ("polar" === e.get("coordinateSystem")) {
							var i = t.queryComponents({ mainType: "polar", index: e.get("polarIndex"), id: e.get("polarId") })[0];e.coordinateSystem = i.coordinateSystem;
						}
					}), i;
				} };i(26).register("polar", c);
		}, function (t, e, i) {
			function n(t) {
				return parseInt(t, 10);
			}function a(t, e) {
				s.initVML(), this.root = t, this.storage = e;var i = document.createElement("div"),
				    n = document.createElement("div");i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", n.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(i), this._vmlRoot = n, this._vmlViewport = i, this.resize();var a = e.delFromStorage,
				    o = e.addToStorage;e.delFromStorage = function (t) {
					a.call(e, t), t && t.onRemove && t.onRemove(n);
				}, e.addToStorage = function (t) {
					t.onAdd && t.onAdd(n), o.call(e, t);
				}, this._firstPaint = !0;
			}function o(t) {
				return function () {
					r('In IE8.0 VML mode painter not support method "' + t + '"');
				};
			}var r = i(52),
			    s = i(182);a.prototype = { constructor: a, getViewportRoot: function getViewportRoot() {
					return this._vmlViewport;
				}, refresh: function refresh() {
					var t = this.storage.getDisplayList(!0, !0);this._paintList(t);
				}, _paintList: function _paintList(t) {
					for (var e = this._vmlRoot, i = 0; i < t.length; i++) {
						var n = t[i];n.invisible || n.ignore ? (n.__alreadyNotVisible || n.onRemove(e), n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e), n.__alreadyNotVisible = !1, n.__dirty && (n.beforeBrush && n.beforeBrush(), (n.brushVML || n.brush).call(n, e), n.afterBrush && n.afterBrush())), n.__dirty = !1;
					}this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1);
				}, resize: function resize(t, e) {
					var t = null == t ? this._getWidth() : t,
					    e = null == e ? this._getHeight() : e;if (this._width != t || this._height != e) {
						this._width = t, this._height = e;var i = this._vmlViewport.style;i.width = t + "px", i.height = e + "px";
					}
				}, dispose: function dispose() {
					this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this.storage = null;
				}, getWidth: function getWidth() {
					return this._width;
				}, getHeight: function getHeight() {
					return this._height;
				}, clear: function clear() {
					this._vmlViewport && this.root.removeChild(this._vmlViewport);
				}, _getWidth: function _getWidth() {
					var t = this.root,
					    e = t.currentStyle;return (t.clientWidth || n(e.width)) - n(e.paddingLeft) - n(e.paddingRight) | 0;
				}, _getHeight: function _getHeight() {
					var t = this.root,
					    e = t.currentStyle;return (t.clientHeight || n(e.height)) - n(e.paddingTop) - n(e.paddingBottom) | 0;
				} };for (var l = ["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], u = 0; u < l.length; u++) {
				var c = l[u];a.prototype[c] = o(c);
			}t.exports = a;
		}, function (t, e, i) {
			if (!i(9).canvasSupported) {
				var n = i(6),
				    a = i(11),
				    o = i(27).CMD,
				    r = i(22),
				    s = i(16),
				    l = i(87),
				    u = i(38),
				    c = i(53),
				    h = i(86),
				    d = i(8),
				    f = i(27),
				    p = i(39),
				    g = i(182),
				    m = Math.round,
				    v = Math.sqrt,
				    y = Math.abs,
				    x = Math.cos,
				    _ = Math.sin,
				    b = Math.max,
				    w = n.applyTransform,
				    S = ",",
				    M = "progid:DXImageTransform.Microsoft",
				    I = 21600,
				    T = I / 2,
				    A = 1e5,
				    C = 1e3,
				    L = function L(t) {
					t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = I + "," + I, t.coordorigin = "0,0";
				},
				    D = function D(t) {
					return String(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
				},
				    P = function P(t, e, i) {
					return "rgb(" + [t, e, i].join(",") + ")";
				},
				    k = function k(t, e) {
					e && t && e.parentNode !== t && t.appendChild(e);
				},
				    O = function O(t, e) {
					e && t && e.parentNode === t && t.removeChild(e);
				},
				    z = function z(t, e, i) {
					return (parseFloat(t) || 0) * A + (parseFloat(e) || 0) * C + i;
				},
				    E = function E(t, e) {
					return "string" == typeof t ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t;
				},
				    R = function R(t, e, i) {
					var n = r.parse(e);i = +i, isNaN(i) && (i = 1), n && (t.color = P(n[0], n[1], n[2]), t.opacity = i * n[3]);
				},
				    N = function N(t) {
					var e = r.parse(t);return [P(e[0], e[1], e[2]), e[3]];
				},
				    V = function V(t, e, i) {
					var n = e.fill;if (null != n) if (n instanceof p) {
						var a,
						    o = 0,
						    r = [0, 0],
						    s = 0,
						    l = 1,
						    u = i.getBoundingRect(),
						    c = u.width,
						    h = u.height;if ("linear" === n.type) {
							a = "gradient";var d = i.transform,
							    f = [n.x * c, n.y * h],
							    g = [n.x2 * c, n.y2 * h];d && (w(f, f, d), w(g, g, d));var m = g[0] - f[0],
							    v = g[1] - f[1];o = 180 * Math.atan2(m, v) / Math.PI, o < 0 && (o += 360), o < 1e-6 && (o = 0);
						} else {
							a = "gradientradial";var f = [n.x * c, n.y * h],
							    d = i.transform,
							    y = i.scale,
							    x = c,
							    _ = h;r = [(f[0] - u.x) / x, (f[1] - u.y) / _], d && w(f, f, d), x /= y[0] * I, _ /= y[1] * I;var S = b(x, _);s = 0 / S, l = 2 * n.r / S - s;
						}var M = n.colorStops.slice();M.sort(function (t, e) {
							return t.offset - e.offset;
						});for (var T = M.length, A = [], C = [], L = 0; L < T; L++) {
							var D = M[L],
							    P = N(D.color);C.push(D.offset * l + s + " " + P[0]), 0 !== L && L !== T - 1 || A.push(P);
						}if (T >= 2) {
							var k = A[0][0],
							    O = A[1][0],
							    z = A[0][1] * e.opacity,
							    E = A[1][1] * e.opacity;t.type = a, t.method = "none", t.focus = "100%", t.angle = o, t.color = k, t.color2 = O, t.colors = C.join(","), t.opacity = E, t.opacity2 = z;
						}"radial" === a && (t.focusposition = r.join(","));
					} else R(t, n, e.opacity);
				},
				    B = function B(t, e) {
					null != e.lineDash && (t.dashstyle = e.lineDash.join(" ")), null == e.stroke || e.stroke instanceof p || R(t, e.stroke, e.opacity);
				},
				    G = function G(t, e, i, n) {
					var a = "fill" == e,
					    o = t.getElementsByTagName(e)[0];null != i[e] && "none" !== i[e] && (a || !a && i.lineWidth) ? (t[a ? "filled" : "stroked"] = "true", i[e] instanceof p && O(t, o), o || (o = g.createNode(e)), a ? V(o, i, n) : B(o, i), k(t, o)) : (t[a ? "filled" : "stroked"] = "false", O(t, o));
				},
				    H = [[], [], []],
				    F = function F(t, e) {
					var i,
					    n,
					    a,
					    r,
					    s,
					    l,
					    u = o.M,
					    c = o.C,
					    h = o.L,
					    d = o.A,
					    f = o.Q,
					    p = [];for (r = 0; r < t.length;) {
						switch (a = t[r++], n = "", i = 0, a) {case u:
								n = " m ", i = 1, s = t[r++], l = t[r++], H[0][0] = s, H[0][1] = l;break;case h:
								n = " l ", i = 1, s = t[r++], l = t[r++], H[0][0] = s, H[0][1] = l;break;case f:case c:
								n = " c ", i = 3;var g,
								    y,
								    b = t[r++],
								    M = t[r++],
								    A = t[r++],
								    C = t[r++];a === f ? (g = A, y = C, A = (A + 2 * b) / 3, C = (C + 2 * M) / 3, b = (s + 2 * b) / 3, M = (l + 2 * M) / 3) : (g = t[r++], y = t[r++]), H[0][0] = b, H[0][1] = M, H[1][0] = A, H[1][1] = C, H[2][0] = g, H[2][1] = y, s = g, l = y;break;case d:
								var L = 0,
								    D = 0,
								    P = 1,
								    k = 1,
								    O = 0;e && (L = e[4], D = e[5], P = v(e[0] * e[0] + e[1] * e[1]), k = v(e[2] * e[2] + e[3] * e[3]), O = Math.atan2(-e[1] / k, e[0] / P));var z = t[r++],
								    E = t[r++],
								    R = t[r++],
								    N = t[r++],
								    V = t[r++] + O,
								    B = t[r++] + V + O;r++;var G = t[r++],
								    F = z + x(V) * R,
								    W = E + _(V) * N,
								    b = z + x(B) * R,
								    M = E + _(B) * N,
								    Z = G ? " wa " : " at ";Math.abs(F - b) < 1e-4 && (Math.abs(B - V) > .01 ? G && (F += 270 / I) : Math.abs(W - E) < 1e-4 ? G && F < z || !G && F > z ? M -= 270 / I : M += 270 / I : G && W < E || !G && W > E ? b += 270 / I : b -= 270 / I), p.push(Z, m(((z - R) * P + L) * I - T), S, m(((E - N) * k + D) * I - T), S, m(((z + R) * P + L) * I - T), S, m(((E + N) * k + D) * I - T), S, m((F * P + L) * I - T), S, m((W * k + D) * I - T), S, m((b * P + L) * I - T), S, m((M * k + D) * I - T)), s = b, l = M;break;case o.R:
								var q = H[0],
								    j = H[1];q[0] = t[r++], q[1] = t[r++], j[0] = q[0] + t[r++], j[1] = q[1] + t[r++], e && (w(q, q, e), w(j, j, e)), q[0] = m(q[0] * I - T), j[0] = m(j[0] * I - T), q[1] = m(q[1] * I - T), j[1] = m(j[1] * I - T), p.push(" m ", q[0], S, q[1], " l ", j[0], S, q[1], " l ", j[0], S, j[1], " l ", q[0], S, j[1]);break;case o.Z:
								p.push(" x ");}if (i > 0) {
							p.push(n);for (var U = 0; U < i; U++) {
								var X = H[U];e && w(X, X, e), p.push(m(X[0] * I - T), S, m(X[1] * I - T), U < i - 1 ? S : "");
							}
						}
					}return p.join("");
				};d.prototype.brushVML = function (t) {
					var e = this.style,
					    i = this._vmlEl;i || (i = g.createNode("shape"), L(i), this._vmlEl = i), G(i, "fill", e, this), G(i, "stroke", e, this);var n = this.transform,
					    a = null != n,
					    o = i.getElementsByTagName("stroke")[0];if (o) {
						var r = e.lineWidth;if (a && !e.strokeNoScale) {
							var s = n[0] * n[3] - n[1] * n[2];r *= v(y(s));
						}o.weight = r + "px";
					}var l = this.path || (this.path = new f());this.__dirtyPath && (l.beginPath(), this.buildPath(l, this.shape), l.toStatic(), this.__dirtyPath = !1), i.path = F(l.data, this.transform), i.style.zIndex = z(this.zlevel, this.z, this.z2), k(t, i), null != e.text ? this.drawRectText(t, this.getBoundingRect()) : this.removeRectText(t);
				}, d.prototype.onRemove = function (t) {
					O(t, this._vmlEl), this.removeRectText(t);
				}, d.prototype.onAdd = function (t) {
					k(t, this._vmlEl), this.appendRectText(t);
				};var W = function W(t) {
					return "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && t.tagName && "IMG" === t.tagName.toUpperCase();
				};c.prototype.brushVML = function (t) {
					var e,
					    i,
					    n = this.style,
					    a = n.image;if (W(a)) {
						var o = a.src;if (o === this._imageSrc) e = this._imageWidth, i = this._imageHeight;else {
							var r = a.runtimeStyle,
							    s = r.width,
							    l = r.height;r.width = "auto", r.height = "auto", e = a.width, i = a.height, r.width = s, r.height = l, this._imageSrc = o, this._imageWidth = e, this._imageHeight = i;
						}a = o;
					} else a === this._imageSrc && (e = this._imageWidth, i = this._imageHeight);if (a) {
						var u = n.x || 0,
						    c = n.y || 0,
						    h = n.width,
						    d = n.height,
						    f = n.sWidth,
						    p = n.sHeight,
						    y = n.sx || 0,
						    x = n.sy || 0,
						    _ = f && p,
						    I = this._vmlEl;I || (I = g.doc.createElement("div"), L(I), this._vmlEl = I);var T,
						    A = I.style,
						    C = !1,
						    D = 1,
						    P = 1;if (this.transform && (T = this.transform, D = v(T[0] * T[0] + T[1] * T[1]), P = v(T[2] * T[2] + T[3] * T[3]), C = T[1] || T[2]), C) {
							var O = [u, c],
							    E = [u + h, c],
							    R = [u, c + d],
							    N = [u + h, c + d];w(O, O, T), w(E, E, T), w(R, R, T), w(N, N, T);var V = b(O[0], E[0], R[0], N[0]),
							    B = b(O[1], E[1], R[1], N[1]),
							    G = [];G.push("M11=", T[0] / D, S, "M12=", T[2] / P, S, "M21=", T[1] / D, S, "M22=", T[3] / P, S, "Dx=", m(u * D + T[4]), S, "Dy=", m(c * P + T[5])), A.padding = "0 " + m(V) + "px " + m(B) + "px 0", A.filter = M + ".Matrix(" + G.join("") + ", SizingMethod=clip)";
						} else T && (u = u * D + T[4], c = c * P + T[5]), A.filter = "", A.left = m(u) + "px", A.top = m(c) + "px";var H = this._imageEl,
						    F = this._cropEl;H || (H = g.doc.createElement("div"), this._imageEl = H);var Z = H.style;if (_) {
							if (e && i) Z.width = m(D * e * h / f) + "px", Z.height = m(P * i * d / p) + "px";else {
								var q = new Image(),
								    j = this;q.onload = function () {
									q.onload = null, e = q.width, i = q.height, Z.width = m(D * e * h / f) + "px", Z.height = m(P * i * d / p) + "px", j._imageWidth = e, j._imageHeight = i, j._imageSrc = a;
								}, q.src = a;
							}F || (F = g.doc.createElement("div"), F.style.overflow = "hidden", this._cropEl = F);var U = F.style;U.width = m((h + y * h / f) * D), U.height = m((d + x * d / p) * P), U.filter = M + ".Matrix(Dx=" + -y * h / f * D + ",Dy=" + -x * d / p * P + ")", F.parentNode || I.appendChild(F), H.parentNode != F && F.appendChild(H);
						} else Z.width = m(D * h) + "px", Z.height = m(P * d) + "px", I.appendChild(H), F && F.parentNode && (I.removeChild(F), this._cropEl = null);var X = "",
						    Y = n.opacity;Y < 1 && (X += ".Alpha(opacity=" + m(100 * Y) + ") "), X += M + ".AlphaImageLoader(src=" + a + ", SizingMethod=scale)", Z.filter = X, I.style.zIndex = z(this.zlevel, this.z, this.z2), k(t, I), null != n.text && this.drawRectText(t, this.getBoundingRect());
					}
				}, c.prototype.onRemove = function (t) {
					O(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t);
				}, c.prototype.onAdd = function (t) {
					k(t, this._vmlEl), this.appendRectText(t);
				};var Z,
				    q = "normal",
				    j = {},
				    U = 0,
				    X = 100,
				    Y = document.createElement("div"),
				    $ = function $(t) {
					var e = j[t];if (!e) {
						U > X && (U = 0, j = {});var i,
						    n = Y.style;try {
							n.font = t, i = n.fontFamily.split(",")[0];
						} catch (a) {}e = { style: n.fontStyle || q, variant: n.fontVariant || q, weight: n.fontWeight || q, size: 0 | parseFloat(n.fontSize || 12), family: i || "Microsoft YaHei" }, j[t] = e, U++;
					}return e;
				};s.measureText = function (t, e) {
					var i = g.doc;Z || (Z = i.createElement("div"), Z.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", g.doc.body.appendChild(Z));try {
						Z.style.font = e;
					} catch (n) {}return Z.innerHTML = "", Z.appendChild(i.createTextNode(t)), { width: Z.offsetWidth };
				};for (var K = new a(), J = function J(t, e, i, n) {
					var a = this.style,
					    o = a.text;if (null != o && (o += ""), o) {
						var r,
						    l,
						    u = a.textAlign,
						    c = $(a.textFont),
						    h = c.style + " " + c.variant + " " + c.weight + " " + c.size + 'px "' + c.family + '"',
						    d = a.textBaseline,
						    f = a.textVerticalAlign;i = i || s.getBoundingRect(o, h, u, d);var p = this.transform;if (p && !n && (K.copy(e), K.applyTransform(p), e = K), n) r = e.x, l = e.y;else {
							var v = a.textPosition,
							    y = a.textDistance;if (v instanceof Array) r = e.x + E(v[0], e.width), l = e.y + E(v[1], e.height), u = u || "left", d = d || "top";else {
								var x = s.adjustTextPositionOnRect(v, e, i, y);r = x.x, l = x.y, u = u || x.textAlign, d = d || x.textBaseline;
							}
						}if (f) {
							switch (f) {case "middle":
									l -= i.height / 2;break;case "bottom":
									l -= i.height;}d = "top";
						}var _ = c.size;switch (d) {case "hanging":case "top":
								l += _ / 1.75;break;case "middle":
								break;default:
								l -= _ / 2.25;}switch (u) {case "left":
								break;case "center":
								r -= i.width / 2;break;case "right":
								r -= i.width;}var b,
						    M,
						    I,
						    T = g.createNode,
						    A = this._textVmlEl;A ? (I = A.firstChild, b = I.nextSibling, M = b.nextSibling) : (A = T("line"), b = T("path"), M = T("textpath"), I = T("skew"), M.style["v-text-align"] = "left", L(A), b.textpathok = !0, M.on = !0, A.from = "0 0", A.to = "1000 0.05", k(A, I), k(A, b), k(A, M), this._textVmlEl = A);var C = [r, l],
						    P = A.style;p && n ? (w(C, C, p), I.on = !0, I.matrix = p[0].toFixed(3) + S + p[2].toFixed(3) + S + p[1].toFixed(3) + S + p[3].toFixed(3) + ",0,0", I.offset = (m(C[0]) || 0) + "," + (m(C[1]) || 0), I.origin = "0 0", P.left = "0px", P.top = "0px") : (I.on = !1, P.left = m(r) + "px", P.top = m(l) + "px"), M.string = D(o);try {
							M.style.font = h;
						} catch (O) {}G(A, "fill", { fill: n ? a.fill : a.textFill, opacity: a.opacity }, this), G(A, "stroke", { stroke: n ? a.stroke : a.textStroke, opacity: a.opacity, lineDash: a.lineDash }, this), A.style.zIndex = z(this.zlevel, this.z, this.z2), k(t, A);
					}
				}, Q = function Q(t) {
					O(t, this._textVmlEl), this._textVmlEl = null;
				}, tt = function tt(t) {
					k(t, this._textVmlEl);
				}, et = [l, u, c, d, h], it = 0; it < et.length; it++) {
					var nt = et[it].prototype;nt.drawRectText = J, nt.removeRectText = Q, nt.appendRectText = tt;
				}h.prototype.brushVML = function (t) {
					var e = this.style;null != e.text ? this.drawRectText(t, { x: e.x || 0, y: e.y || 0, width: 0, height: 0 }, this.getBoundingRect(), !0) : this.removeRectText(t);
				}, h.prototype.onRemove = function (t) {
					this.removeRectText(t);
				}, h.prototype.onAdd = function (t) {
					this.appendRectText(t);
				};
			}
		}, function (t, e, i) {
			i(238), i(88).registerPainter("vml", i(237));
		}, function (t, e, i) {
			var n = i(1),
			    a = i(241),
			    o = i(2);o.registerAction({ type: "geoRoam", event: "geoRoam", update: "updateLayout" }, function (t, e) {
				var i = t.componentType || "series";e.eachComponent({ mainType: i, query: t }, function (e) {
					var o = e.coordinateSystem;if ("geo" === o.type) {
						var r = a.updateCenterAndZoom(o, t, e.get("scaleLimit"));e.setCenter && e.setCenter(r.center), e.setZoom && e.setZoom(r.zoom), "series" === i && n.each(e.seriesGroup, function (t) {
							t.setCenter(r.center), t.setZoom(r.zoom);
						});
					}
				});
			});
		}, function (t, e) {
			var i = {};i.updateCenterAndZoom = function (t, e, i) {
				var n = t.getZoom(),
				    a = t.getCenter(),
				    o = e.zoom,
				    r = t.dataToPoint(a);if (null != e.dx && null != e.dy) {
					r[0] -= e.dx, r[1] -= e.dy;var a = t.pointToData(r);t.setCenter(a);
				}if (null != o) {
					if (i) {
						var s = i.min || 0,
						    l = i.max || 1 / 0;o = Math.max(Math.min(n * o, l), s) / n;
					}t.scale[0] *= o, t.scale[1] *= o;var u = t.position,
					    c = (e.originX - u[0]) * (o - 1),
					    h = (e.originY - u[1]) * (o - 1);u[0] -= c, u[1] -= h, t.updateTransform();var a = t.pointToData(r);t.setCenter(a), t.setZoom(o * n);
				}return { center: t.getCenter(), zoom: t.getZoom() };
			}, t.exports = i;
		}, function (t, e, i) {
			var n = i(6);t.exports = function (t) {
				var e = t.coordinateSystem;if (!e || "view" === e.type) {
					var i = e.getBoundingRect(),
					    a = t.getData(),
					    o = a.graph,
					    r = 0,
					    s = a.getSum("value"),
					    l = 2 * Math.PI / (s || a.count()),
					    u = i.width / 2 + i.x,
					    c = i.height / 2 + i.y,
					    h = Math.min(i.width, i.height) / 2;o.eachNode(function (t) {
						var e = t.getValue("value");r += l * (s ? e : 1) / 2, t.setLayout([h * Math.cos(r) + u, h * Math.sin(r) + c]), r += l * (s ? e : 1) / 2;
					}), a.setLayout({ cx: u, cy: c }), o.eachEdge(function (t) {
						var e,
						    i = t.getModel().get("lineStyle.normal.curveness") || 0,
						    a = n.clone(t.node1.getLayout()),
						    o = n.clone(t.node2.getLayout()),
						    r = (a[0] + o[0]) / 2,
						    s = (a[1] + o[1]) / 2;+i && (i *= 3, e = [u * i + r * (1 - i), c * i + s * (1 - i)]), t.setLayout([a, o, e]);
					});
				}
			};
		}, function (t, e, i) {
			var n = i(6);t.exports = function (t) {
				t.eachEdge(function (t) {
					var e = t.getModel().get("lineStyle.normal.curveness") || 0,
					    i = n.clone(t.node1.getLayout()),
					    a = n.clone(t.node2.getLayout()),
					    o = [i, a];+e && o.push([(i[0] + a[0]) / 2 - (i[1] - a[1]) * e, (i[1] + a[1]) / 2 - (a[0] - i[0]) * e]), t.setLayout(o);
				});
			};
		}, function (t, e, i) {
			var n = i(243);t.exports = function (t) {
				var e = t.coordinateSystem;if (!e || "view" === e.type) {
					var i = t.getGraph();i.eachNode(function (t) {
						var e = t.getModel();t.setLayout([+e.get("x"), +e.get("y")]);
					}), n(i);
				}
			};
		}, function (t, e, i) {
			function n(t, e, i) {
				a.Group.call(this), this.add(this.createLine(t, e, i)), this._updateEffectSymbol(t, e);
			}var a = i(3),
			    o = i(106),
			    r = i(1),
			    s = i(24),
			    l = i(6),
			    u = i(20),
			    c = n.prototype;c.createLine = function (t, e, i) {
				return new o(t, e, i);
			}, c._updateEffectSymbol = function (t, e) {
				var i = t.getItemModel(e),
				    n = i.getModel("effect"),
				    a = n.get("symbolSize"),
				    o = n.get("symbol");r.isArray(a) || (a = [a, a]);var l = n.get("color") || t.getItemVisual(e, "color"),
				    u = this.childAt(1);this._symbolType !== o && (this.remove(u), u = s.createSymbol(o, -.5, -.5, 1, 1, l), u.z2 = 100, u.culling = !0, this.add(u)), u && (u.setStyle("shadowColor", l), u.setStyle(n.getItemStyle(["color"])), u.attr("scale", a), u.setColor(l), u.attr("scale", a), this._symbolType = o, this._updateEffectAnimation(t, n, e));
			}, c._updateEffectAnimation = function (t, e, i) {
				var n = this.childAt(1);if (n) {
					var a = this,
					    o = t.getItemLayout(i),
					    s = 1e3 * e.get("period"),
					    l = e.get("loop"),
					    u = e.get("constantSpeed"),
					    c = r.retrieve(e.get("delay"), function (e) {
						return e / t.count() * s / 3;
					}),
					    h = "function" == typeof c;if (n.ignore = !0, this.updateAnimationPoints(n, o), u > 0 && (s = this.getLineLength(n) / u * 1e3), s !== this._period || l !== this._loop) {
						n.stopAnimation();var d = c;h && (d = c(i)), n.__t > 0 && (d = -s * n.__t), n.__t = 0;var f = n.animate("", l).when(s, { __t: 1 }).delay(d).during(function () {
							a.updateSymbolPosition(n);
						});l || f.done(function () {
							a.remove(n);
						}), f.start();
					}this._period = s, this._loop = l;
				}
			}, c.getLineLength = function (t) {
				return l.dist(t.__p1, t.__cp1) + l.dist(t.__cp1, t.__p2);
			}, c.updateAnimationPoints = function (t, e) {
				t.__p1 = e[0], t.__p2 = e[1], t.__cp1 = e[2] || [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2];
			}, c.updateData = function (t, e, i) {
				this.childAt(0).updateData(t, e, i), this._updateEffectSymbol(t, e);
			}, c.updateSymbolPosition = function (t) {
				var e = t.__p1,
				    i = t.__p2,
				    n = t.__cp1,
				    a = t.__t,
				    o = t.position,
				    r = u.quadraticAt,
				    s = u.quadraticDerivativeAt;o[0] = r(e[0], n[0], i[0], a), o[1] = r(e[1], n[1], i[1], a);var l = s(e[0], n[0], i[0], a),
				    c = s(e[1], n[1], i[1], a);t.rotation = -Math.atan2(c, l) - Math.PI / 2, t.ignore = !1;
			}, c.updateLayout = function (t, e) {
				this.childAt(0).updateLayout(t, e);var i = t.getItemModel(e).getModel("effect");this._updateEffectAnimation(t, i, e);
			}, r.inherits(n, a.Group), t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i) {
				a.Group.call(this), this._createPolyline(t, e, i);
			}var a = i(3),
			    o = i(1),
			    r = n.prototype;r._createPolyline = function (t, e, i) {
				var n = t.getItemLayout(e),
				    o = new a.Polyline({ shape: { points: n } });this.add(o), this._updateCommonStl(t, e, i);
			}, r.updateData = function (t, e, i) {
				var n = t.hostModel,
				    o = this.childAt(0),
				    r = { shape: { points: t.getItemLayout(e) } };a.updateProps(o, r, n, e), this._updateCommonStl(t, e, i);
			}, r._updateCommonStl = function (t, e, i) {
				var n = this.childAt(0),
				    r = t.getItemModel(e),
				    s = t.getItemVisual(e, "color"),
				    l = i && i.lineStyle,
				    u = i && i.hoverLineStyle;i && !t.hasItemOption || (l = r.getModel("lineStyle.normal").getLineStyle(), u = r.getModel("lineStyle.emphasis").getLineStyle()), n.useStyle(o.defaults({ strokeNoScale: !0, fill: "none", stroke: s }, l)), n.hoverStyle = u, a.setHoverStyle(this);
			}, r.updateLayout = function (t, e) {
				var i = this.childAt(0);i.setShape("points", t.getItemLayout(e));
			}, o.inherits(n, a.Group), t.exports = n;
		}, function (t, e, i) {
			var n = i(14),
			    a = i(423),
			    o = i(264),
			    r = i(25),
			    s = i(26),
			    l = i(1),
			    u = i(28);t.exports = function (t, e, i, c, h) {
				for (var d = new a(c), f = 0; f < t.length; f++) {
					d.addNode(l.retrieve(t[f].id, t[f].name, f), f);
				}for (var p = [], g = [], m = 0, f = 0; f < e.length; f++) {
					var v = e[f],
					    y = v.source,
					    x = v.target;d.addEdge(y, x, m) && (g.push(v), p.push(l.retrieve(v.id, y + " > " + x)), m++);
				}var _,
				    b = i.get("coordinateSystem");if ("cartesian2d" === b || "polar" === b) _ = u(t, i, i.ecModel);else {
					var w = s.get(b),
					    S = r((w && "view" !== w.type ? w.dimensions || [] : []).concat(["value"]), t);_ = new n(S, i), _.initData(t);
				}var M = new n(["value"], i);return M.initData(g, p), h && h(_, M), o({ mainData: _, struct: d, structAttr: "graph", datas: { node: _, edge: M }, datasAttr: { node: "data", edge: "edgeData" } }), d.update(), d;
			};
		}, function (t, e, i) {
			var n = i(1),
			    a = {};a.layout = function (t, e) {
				e = e || {};var i = t.coordinateSystem,
				    a = t.axis,
				    o = {},
				    r = a.position,
				    s = a.orient,
				    l = i.getRect(),
				    u = [l.x, l.x + l.width, l.y, l.y + l.height],
				    c = { horizontal: { top: u[2], bottom: u[3] }, vertical: { left: u[0], right: u[1] } };o.position = ["vertical" === s ? c.vertical[r] : u[0], "horizontal" === s ? c.horizontal[r] : u[3]];var h = { horizontal: 0, vertical: 1 };o.rotation = Math.PI / 2 * h[s];var d = { top: -1, bottom: 1, right: 1, left: -1 };o.labelDirection = o.tickDirection = o.nameDirection = d[r], t.get("axisTick.inside") && (o.tickDirection = -o.tickDirection), n.retrieve(e.labelInside, t.get("axisLabel.inside")) && (o.labelDirection = -o.labelDirection);var f = e.rotate;return null == f && (f = t.get("axisLabel.rotate")), o.labelRotation = "top" === r ? -f : f, o.labelInterval = a.getLabelInterval(), o.z2 = 1, o;
			}, t.exports = a;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t.getItemStyle(),
				    n = t.get("areaColor");return null != n && (i.fill = n), i;
			}function a(t, e, i, n, a) {
				i.off("click"), i.off("mousedown"), e.get("selectedMode") && (i.on("mousedown", function () {
					t._mouseDownFlag = !0;
				}), i.on("click", function (r) {
					if (t._mouseDownFlag) {
						t._mouseDownFlag = !1;for (var s = r.target; !s.__regions;) {
							s = s.parent;
						}if (s) {
							var l = { type: ("geo" === e.mainType ? "geo" : "map") + "ToggleSelect", batch: h.map(s.__regions, function (t) {
									return { name: t.name, from: a.uid };
								}) };l[e.mainType + "Id"] = e.id, n.dispatchAction(l), o(e, i);
						}
					}
				}));
			}function o(t, e) {
				e.eachChild(function (e) {
					h.each(e.__regions, function (i) {
						e.trigger(t.isSelected(i.name) ? "emphasis" : "normal");
					});
				});
			}function r(t, e) {
				var i = new c.Group();this._controller = new s(t.getZr()), this._controllerHost = { target: e ? i : null }, this.group = i, this._updateGroup = e, this._mouseDownFlag;
			}var s = i(95),
			    l = i(250),
			    u = i(128),
			    c = i(3),
			    h = i(1);r.prototype = { constructor: r, draw: function draw(t, e, i, r, s) {
					var l = "geo" === t.mainType,
					    u = t.getData && t.getData();l && e.eachComponent({ mainType: "series", subType: "map" }, function (e) {
						u || e.getHostGeoModel() !== t || (u = e.getData());
					});var d = t.coordinateSystem,
					    f = this.group,
					    p = d.scale,
					    g = { position: d.position, scale: p };!f.childAt(0) || s ? f.attr(g) : c.updateProps(f, g, t), f.removeAll();var m = ["itemStyle", "normal"],
					    v = ["itemStyle", "emphasis"],
					    y = ["label", "normal"],
					    x = ["label", "emphasis"],
					    _ = h.createHashMap();h.each(d.regions, function (e) {
						var i = _.get(e.name) || _.set(e.name, new c.Group()),
						    a = new c.CompoundPath({ shape: { paths: [] } });i.add(a);var o,
						    r = t.getRegionModel(e.name) || t,
						    s = r.getModel(m),
						    d = r.getModel(v),
						    g = n(s, p),
						    b = n(d, p),
						    w = r.getModel(y),
						    S = r.getModel(x);if (u) {
							o = u.indexOfName(e.name);var M = u.getItemVisual(o, "color", !0);M && (g.fill = M);
						}var I = w.getModel("textStyle"),
						    T = S.getModel("textStyle");h.each(e.geometries, function (t) {
							if ("polygon" === t.type) {
								a.shape.paths.push(new c.Polygon({ shape: { points: t.exterior } }));for (var e = 0; e < (t.interiors ? t.interiors.length : 0); e++) {
									a.shape.paths.push(new c.Polygon({ shape: { points: t.interiors[e] } }));
								}
							}
						}), a.setStyle(g), a.style.strokeNoScale = !0, a.culling = !0;var A = w.get("show"),
						    C = S.get("show"),
						    L = u && isNaN(u.get("value", o)),
						    D = u && u.getItemLayout(o);if (l || L && (A || C) || D && D.showLabel) {
							var P = u ? o : e.name,
							    k = t.getFormattedLabel(P, "normal"),
							    O = t.getFormattedLabel(P, "emphasis"),
							    z = new c.Text({ style: { text: A ? k || e.name : "", fill: I.getTextColor(), textFont: I.getFont(), textAlign: "center", textVerticalAlign: "middle" }, hoverStyle: { text: C ? O || e.name : "", fill: T.getTextColor(), textFont: T.getFont() }, position: e.center.slice(), scale: [1 / p[0], 1 / p[1]], z2: 10, silent: !0 });i.add(z);
						}if (u) u.setItemGraphicEl(o, i);else {
							var r = t.getRegionModel(e.name);a.eventData = { componentType: "geo", geoIndex: t.componentIndex, name: e.name, region: r && r.option || {} };
						}var E = i.__regions || (i.__regions = []);E.push(e), c.setHoverStyle(i, b, { hoverSilentOnTouch: !!t.get("selectedMode") }), f.add(i);
					}), this._updateController(t, e, i), a(this, t, f, i, r), o(t, f);
				}, remove: function remove() {
					this.group.removeAll(), this._controller.dispose(), this._controllerHost = {};
				}, _updateController: function _updateController(t, e, i) {
					function n() {
						var e = { type: "geoRoam", componentType: s };return e[s + "Id"] = t.id, e;
					}var a = t.coordinateSystem,
					    o = this._controller,
					    r = this._controllerHost;r.zoomLimit = t.get("scaleLimit"), r.zoom = a.getZoom(), o.enable(t.get("roam") || !1);var s = t.mainType;o.off("pan").on("pan", function (t, e) {
						this._mouseDownFlag = !1, l.updateViewOnPan(r, t, e), i.dispatchAction(h.extend(n(), { dx: t, dy: e }));
					}, this), o.off("zoom").on("zoom", function (t, e, a) {
						if (this._mouseDownFlag = !1, l.updateViewOnZoom(r, t, e, a), i.dispatchAction(h.extend(n(), { zoom: t, originX: e, originY: a })), this._updateGroup) {
							var o = this.group,
							    s = o.scale;o.traverse(function (t) {
								"text" === t.type && t.attr("scale", [1 / s[0], 1 / s[1]]);
							});
						}
					}, this), o.setPointerChecker(function (e, n, o) {
						return a.getViewRectAfterRoam().contain(n, o) && !u.onIrrelevantElement(e, i, t);
					});
				} }, t.exports = r;
		}, function (t, e) {
			var i = {};i.updateViewOnPan = function (t, e, i) {
				var n = t.target,
				    a = n.position;a[0] += e, a[1] += i, n.dirty();
			}, i.updateViewOnZoom = function (t, e, i, n) {
				var a = t.target,
				    o = t.zoomLimit,
				    r = a.position,
				    s = a.scale,
				    l = t.zoom = t.zoom || 1;if (l *= e, o) {
					var u = o.min || 0,
					    c = o.max || 1 / 0;l = Math.max(Math.min(c, l), u);
				}var h = l / t.zoom;t.zoom = l, r[0] -= (i - r[0]) * (h - 1), r[1] -= (n - r[1]) * (h - 1), s[0] *= h, s[1] *= h, a.dirty();
			}, t.exports = i;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t._model;return i.get("axisExpandable") && i.get("axisExpandTriggerOn") === e;
			}i(263), i(407), i(372);var a = i(2),
			    o = i(1),
			    r = i(37),
			    s = 5;a.extendComponentView({ type: "parallel", render: function render(t, e, i) {
					this._model = t, this._api = i, this._handlers || (this._handlers = {}, o.each(l, function (t, e) {
						i.getZr().on(e, this._handlers[e] = o.bind(t, this));
					}, this)), r.createOrUpdate(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate");
				}, dispose: function dispose(t, e) {
					o.each(this._handlers, function (t, i) {
						e.getZr().off(i, t);
					}), this._handlers = null;
				}, _throttledDispatchExpand: function _throttledDispatchExpand(t) {
					this._dispatchExpand(t);
				}, _dispatchExpand: function _dispatchExpand(t) {
					t && this._api.dispatchAction(o.extend({ type: "parallelAxisExpand" }, t));
				} });var l = { mousedown: function mousedown(t) {
					n(this, "click") && (this._mouseDownPoint = [t.offsetX, t.offsetY]);
				}, mouseup: function mouseup(t) {
					var e = this._mouseDownPoint;if (n(this, "click") && e) {
						var i = [t.offsetX, t.offsetY],
						    a = Math.pow(e[0] - i[0], 2) + Math.pow(e[1] - i[1], 2);if (a > s) return;var o = this._model.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]);"none" !== o.behavior && this._dispatchExpand({ axisExpandWindow: o.axisExpandWindow });
					}this._mouseDownPoint = null;
				}, mousemove: function mousemove(t) {
					if (!this._mouseDownPoint && n(this, "mousemove")) {
						var e = this._model,
						    i = e.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]),
						    a = i.behavior;"jump" === a && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand("none" === a ? null : { axisExpandWindow: i.axisExpandWindow, animation: "jump" === a && null });
					}
				} };a.registerPreprocessor(i(408));
		}, function (t, e, i) {
			i(422), i(357), i(418), i(55), i(360);var n = i(2);n.extendComponentView({ type: "single" });
		}, function (t, e, i) {
			var n = i(2),
			    a = i(1),
			    o = i(9),
			    r = i(266),
			    s = i(83),
			    l = i(187),
			    u = s.mapVisual,
			    c = i(5),
			    h = s.eachVisual,
			    d = i(4),
			    f = a.isArray,
			    p = a.each,
			    g = d.asc,
			    m = d.linearMap,
			    v = a.noop,
			    y = ["#f6efa6", "#d88273", "#bf444c"],
			    x = n.extendComponentModel({ type: "visualMap", dependencies: ["series"], stateList: ["inRange", "outOfRange"], replacableOptionKeys: ["inRange", "outOfRange", "target", "controller", "color"], dataBound: [-(1 / 0), 1 / 0], layoutMode: { type: "box", ignoreSize: !0 }, defaultOption: { show: !0, zlevel: 0, z: 4, seriesIndex: null, min: 0, max: 200, dimension: null, inRange: null, outOfRange: null, left: 0, right: null, top: null, bottom: 0, itemWidth: null, itemHeight: null, inverse: !1, orient: "vertical", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", contentColor: "#5793f3", inactiveColor: "#aaa", borderWidth: 0, padding: 5, textGap: 10, precision: 0, color: null, formatter: null, text: null, textStyle: { color: "#333" } }, init: function init(t, e, i) {
					this._dataExtent, this.targetVisuals = {}, this.controllerVisuals = {}, this.textStyleModel, this.itemSize, this.mergeDefaultAndTheme(t, i);
				}, optionUpdated: function optionUpdated(t, e) {
					var i = this.option;o.canvasSupported || (i.realtime = !1), !e && l.replaceVisualOption(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
				}, resetVisual: function resetVisual(t) {
					var e = this.stateList;t = a.bind(t, this), this.controllerVisuals = l.createVisualMappings(this.option.controller, e, t), this.targetVisuals = l.createVisualMappings(this.option.target, e, t);
				}, resetTargetSeries: function resetTargetSeries() {
					var t = this.option,
					    e = null == t.seriesIndex;t.seriesIndex = e ? [] : c.normalizeToArray(t.seriesIndex), e && this.ecModel.eachSeries(function (e, i) {
						t.seriesIndex.push(i);
					});
				}, eachTargetSeries: function eachTargetSeries(t, e) {
					a.each(this.option.seriesIndex, function (i) {
						t.call(e, this.ecModel.getSeriesByIndex(i));
					}, this);
				}, isTargetSeries: function isTargetSeries(t) {
					var e = !1;return this.eachTargetSeries(function (i) {
						i === t && (e = !0);
					}), e;
				}, formatValueText: function formatValueText(t, e, i) {
					function n(t) {
						return t === u[0] ? "min" : t === u[1] ? "max" : (+t).toFixed(l);
					}var o,
					    r,
					    s = this.option,
					    l = s.precision,
					    u = this.dataBound,
					    c = s.formatter;return i = i || ["<", ">"], a.isArray(t) && (t = t.slice(), o = !0), r = e ? t : o ? [n(t[0]), n(t[1])] : n(t), a.isString(c) ? c.replace("{value}", o ? r[0] : r).replace("{value2}", o ? r[1] : r) : a.isFunction(c) ? o ? c(t[0], t[1]) : c(t) : o ? t[0] === u[0] ? i[0] + " " + r[1] : t[1] === u[1] ? i[1] + " " + r[0] : r[0] + " - " + r[1] : r;
				}, resetExtent: function resetExtent() {
					var t = this.option,
					    e = g([t.min, t.max]);this._dataExtent = e;
				}, getDataDimension: function getDataDimension(t) {
					var e = this.option.dimension;return null != e ? e : t.dimensions.length - 1;
				}, getExtent: function getExtent() {
					return this._dataExtent.slice();
				}, completeVisualOption: function completeVisualOption() {
					function t(t) {
						f(n.color) && !t.inRange && (t.inRange = { color: n.color.slice().reverse() }), t.inRange = t.inRange || { color: y }, p(this.stateList, function (e) {
							var i = t[e];if (a.isString(i)) {
								var n = r.get(i, "active", d);n ? (t[e] = {}, t[e][i] = n) : delete t[e];
							}
						}, this);
					}function e(t, e, i) {
						var n = t[e],
						    a = t[i];n && !a && (a = t[i] = {}, p(n, function (t, e) {
							if (s.isValidType(e)) {
								var i = r.get(e, "inactive", d);null != i && (a[e] = i, "color" !== e || a.hasOwnProperty("opacity") || a.hasOwnProperty("colorAlpha") || (a.opacity = [0, 0]));
							}
						}));
					}function i(t) {
						var e = (t.inRange || {}).symbol || (t.outOfRange || {}).symbol,
						    i = (t.inRange || {}).symbolSize || (t.outOfRange || {}).symbolSize,
						    n = this.get("inactiveColor");p(this.stateList, function (o) {
							var r = this.itemSize,
							    s = t[o];s || (s = t[o] = { color: d ? n : [n] }), null == s.symbol && (s.symbol = e && a.clone(e) || (d ? "roundRect" : ["roundRect"])), null == s.symbolSize && (s.symbolSize = i && a.clone(i) || (d ? r[0] : [r[0], r[0]])), s.symbol = u(s.symbol, function (t) {
								return "none" === t || "square" === t ? "roundRect" : t;
							});var l = s.symbolSize;if (null != l) {
								var c = -(1 / 0);h(l, function (t) {
									t > c && (c = t);
								}), s.symbolSize = u(l, function (t) {
									return m(t, [0, c], [0, r[0]], !0);
								});
							}
						}, this);
					}var n = this.option,
					    o = { inRange: n.inRange, outOfRange: n.outOfRange },
					    l = n.target || (n.target = {}),
					    c = n.controller || (n.controller = {});a.merge(l, o), a.merge(c, o);var d = this.isCategory();t.call(this, l), t.call(this, c), e.call(this, l, "inRange", "outOfRange"), i.call(this, c);
				}, resetItemSize: function resetItemSize() {
					this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
				}, isCategory: function isCategory() {
					return !!this.option.categories;
				}, setSelected: v, getValueState: v, getVisualMeta: v });t.exports = x;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(3),
			    o = i(7),
			    r = i(12),
			    s = i(2),
			    l = i(83);t.exports = s.extendComponentView({ type: "visualMap", autoPositionValues: { left: 1, right: 1, top: 1, bottom: 1 }, init: function init(t, e) {
					this.ecModel = t, this.api = e, this.visualMapModel;
				}, render: function render(t, e, i, n) {
					return this.visualMapModel = t, t.get("show") === !1 ? void this.group.removeAll() : void this.doRender.apply(this, arguments);
				}, renderBackground: function renderBackground(t) {
					var e = this.visualMapModel,
					    i = o.normalizeCssArray(e.get("padding") || 0),
					    n = t.getBoundingRect();t.add(new a.Rect({ z2: -1, silent: !0, shape: { x: n.x - i[3], y: n.y - i[0], width: n.width + i[3] + i[1], height: n.height + i[0] + i[2] }, style: { fill: e.get("backgroundColor"), stroke: e.get("borderColor"), lineWidth: e.get("borderWidth") } }));
				}, getControllerVisual: function getControllerVisual(t, e, i) {
					function a(t) {
						return u[t];
					}function o(t, e) {
						u[t] = e;
					}i = i || {};var r = i.forceState,
					    s = this.visualMapModel,
					    u = {};if ("symbol" === e && (u.symbol = s.get("itemSymbol")), "color" === e) {
						var c = s.get("contentColor");u.color = c;
					}var h = s.controllerVisuals[r || s.getValueState(t)],
					    d = l.prepareVisualTypes(h);return n.each(d, function (n) {
						var r = h[n];i.convertOpacityToAlpha && "opacity" === n && (n = "colorAlpha", r = h.__alphaForOpacity), l.dependsOn(n, e) && r && r.applyVisual(t, a, o);
					}), u[e];
				}, positionGroup: function positionGroup(t) {
					var e = this.visualMapModel,
					    i = this.api;r.positionElement(t, e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() });
				}, doRender: n.noop });
		}, function (t, e, i) {
			var n = i(1),
			    a = i(12),
			    o = { getItemAlign: function getItemAlign(t, e, i) {
					var n = t.option,
					    o = n.align;if (null != o && "auto" !== o) return o;for (var r = { width: e.getWidth(), height: e.getHeight() }, s = "horizontal" === n.orient ? 1 : 0, l = [["left", "right", "width"], ["top", "bottom", "height"]], u = l[s], c = [0, null, 10], h = {}, d = 0; d < 3; d++) {
						h[l[1 - s][d]] = c[d], h[u[d]] = 2 === d ? i[0] : n[u[d]];
					}var f = [["x", "width", 3], ["y", "height", 0]][s],
					    p = a.getLayoutRect(h, r, n.padding);return u[(p.margin[f[2]] || 0) + p[f[0]] + .5 * p[f[1]] < .5 * r[f[1]] ? 0 : 1];
				}, convertDataIndex: function convertDataIndex(t) {
					return n.each(t || [], function (e) {
						null != t.dataIndex && (t.dataIndexInside = t.dataIndex, t.dataIndex = null);
					}), t;
				} };t.exports = o;
		}, function (t, e, i) {
			function n(t, e) {
				return t && t.hasOwnProperty && t.hasOwnProperty(e);
			}var a = i(1),
			    o = a.each;t.exports = function (t) {
				var e = t && t.visualMap;a.isArray(e) || (e = e ? [e] : []), o(e, function (t) {
					if (t) {
						n(t, "splitList") && !n(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);var e = t.pieces;e && a.isArray(e) && o(e, function (t) {
							a.isObject(t) && (n(t, "start") && !n(t, "min") && (t.min = t.start), n(t, "end") && !n(t, "max") && (t.max = t.end));
						});
					}
				});
			};
		}, function (t, e, i) {
			i(13).registerSubTypeDefaulter("visualMap", function (t) {
				return t.categories || (t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) && !t.calculable ? "piecewise" : "continuous";
			});
		}, function (t, e, i) {
			function n(t, e) {
				t.eachTargetSeries(function (e) {
					var i = e.getData();s.applyVisual(t.stateList, t.targetVisuals, i, t.getValueState, t, t.getDataDimension(i));
				});
			}function a(t) {
				t.eachSeries(function (e) {
					var i = e.getData(),
					    n = [];t.eachComponent("visualMap", function (t) {
						if (t.isTargetSeries(e)) {
							var a = t.getVisualMeta(u.bind(o, null, e, t)) || { stops: [], outerColors: [] };a.dimension = t.getDataDimension(i), n.push(a);
						}
					}), e.getData().setVisual("visualMeta", n);
				});
			}function o(t, e, i, n) {
				function a(t) {
					return u[t];
				}function o(t, e) {
					u[t] = e;
				}for (var r = e.targetVisuals[n], s = l.prepareVisualTypes(r), u = { color: t.getData().getVisual("color") }, c = 0, h = s.length; c < h; c++) {
					var d = s[c],
					    f = r["opacity" === d ? "__alphaForOpacity" : d];f && f.applyVisual(i, a, o);
				}return u.color;
			}var r = i(2),
			    s = i(187),
			    l = i(83),
			    u = i(1);r.registerVisual(r.PRIORITY.VISUAL.COMPONENT, function (t) {
				t.eachComponent("visualMap", function (e) {
					n(e, t);
				}), a(t);
			});
		}, function (t, e, i) {
			var n = i(2),
			    a = { type: "selectDataRange", event: "dataRangeSelected", update: "update" };n.registerAction(a, function (t, e) {
				e.eachComponent({ mainType: "visualMap", query: t }, function (e) {
					e.setSelected(t.selected);
				});
			});
		}, function (t, e, i) {
			function n() {
				l.call(this);
			}function a(t) {
				this.name = t, this.zoomLimit, l.call(this), this._roamTransform = new n(), this._viewTransform = new n(), this._center, this._zoom;
			}function o(t, e, i, n) {
				var a = i.seriesModel,
				    o = a ? a.coordinateSystem : null;return o === this ? o[t](n) : null;
			}var r = i(6),
			    s = i(19),
			    l = i(58),
			    u = i(1),
			    c = i(11),
			    h = r.applyTransform;u.mixin(n, l), a.prototype = { constructor: a, type: "view", dimensions: ["x", "y"], setBoundingRect: function setBoundingRect(t, e, i, n) {
					return this._rect = new c(t, e, i, n), this._rect;
				}, getBoundingRect: function getBoundingRect() {
					return this._rect;
				}, setViewRect: function setViewRect(t, e, i, n) {
					this.transformTo(t, e, i, n), this._viewRect = new c(t, e, i, n);
				}, transformTo: function transformTo(t, e, i, n) {
					var a = this.getBoundingRect(),
					    o = this._viewTransform;o.transform = a.calculateTransform(new c(t, e, i, n)), o.decomposeTransform(), this._updateTransform();
				}, setCenter: function setCenter(t) {
					t && (this._center = t, this._updateCenterAndZoom());
				}, setZoom: function setZoom(t) {
					t = t || 1;var e = this.zoomLimit;e && (null != e.max && (t = Math.min(e.max, t)), null != e.min && (t = Math.max(e.min, t))), this._zoom = t, this._updateCenterAndZoom();
				}, getDefaultCenter: function getDefaultCenter() {
					var t = this.getBoundingRect(),
					    e = t.x + t.width / 2,
					    i = t.y + t.height / 2;return [e, i];
				}, getCenter: function getCenter() {
					return this._center || this.getDefaultCenter();
				}, getZoom: function getZoom() {
					return this._zoom || 1;
				}, getRoamTransform: function getRoamTransform() {
					return this._roamTransform;
				}, _updateCenterAndZoom: function _updateCenterAndZoom() {
					var t = this._viewTransform.getLocalTransform(),
					    e = this._roamTransform,
					    i = this.getDefaultCenter(),
					    n = this.getCenter(),
					    a = this.getZoom();n = r.applyTransform([], n, t), i = r.applyTransform([], i, t), e.origin = n, e.position = [i[0] - n[0], i[1] - n[1]], e.scale = [a, a], this._updateTransform();
				}, _updateTransform: function _updateTransform() {
					var t = this._roamTransform,
					    e = this._viewTransform;e.parent = t, t.updateTransform(), e.updateTransform(), e.transform && s.copy(this.transform || (this.transform = []), e.transform), this.transform ? (this.invTransform = this.invTransform || [], s.invert(this.invTransform, this.transform)) : this.invTransform = null, this.decomposeTransform();
				}, getViewRect: function getViewRect() {
					return this._viewRect;
				}, getViewRectAfterRoam: function getViewRectAfterRoam() {
					var t = this.getBoundingRect().clone();return t.applyTransform(this.transform), t;
				}, dataToPoint: function dataToPoint(t) {
					var e = this.transform;return e ? h([], t, e) : [t[0], t[1]];
				}, pointToData: function pointToData(t) {
					var e = this.invTransform;return e ? h([], t, e) : [t[0], t[1]];
				}, convertToPixel: u.curry(o, "dataToPoint"), convertFromPixel: u.curry(o, "pointToData"), containPoint: function containPoint(t) {
					return this.getViewRectAfterRoam().contain(t[0], t[1]);
				} }, u.mixin(a, l), t.exports = a;
		}, function (t, e, i) {
			function n(t, e, i) {
				if (this.name = t, this.geometries = e, i) i = [i[0], i[1]];else {
					var n = this.getBoundingRect();i = [n.x + n.width / 2, n.y + n.height / 2];
				}this.center = i;
			}var a = i(267),
			    o = i(11),
			    r = i(85),
			    s = i(6);n.prototype = { constructor: n, properties: null, getBoundingRect: function getBoundingRect() {
					var t = this._rect;if (t) return t;for (var e = Number.MAX_VALUE, i = [e, e], n = [-e, -e], a = [], l = [], u = this.geometries, c = 0; c < u.length; c++) {
						if ("polygon" === u[c].type) {
							var h = u[c].exterior;r.fromPoints(h, a, l), s.min(i, i, a), s.max(n, n, l);
						}
					}return 0 === c && (i[0] = i[1] = n[0] = n[1] = 0), this._rect = new o(i[0], i[1], n[0] - i[0], n[1] - i[1]);
				}, contain: function contain(t) {
					var e = this.getBoundingRect(),
					    i = this.geometries;if (!e.contain(t[0], t[1])) return !1;t: for (var n = 0, o = i.length; n < o; n++) {
						if ("polygon" === i[n].type) {
							var r = i[n].exterior,
							    s = i[n].interiors;if (a.contain(r, t[0], t[1])) {
								for (var l = 0; l < (s ? s.length : 0); l++) {
									if (a.contain(s[l])) continue t;
								}return !0;
							}
						}
					}return !1;
				}, transformTo: function transformTo(t, e, i, n) {
					var a = this.getBoundingRect(),
					    r = a.width / a.height;i ? n || (n = i / r) : i = r * n;for (var l = new o(t, e, i, n), u = a.calculateTransform(l), c = this.geometries, h = 0; h < c.length; h++) {
						if ("polygon" === c[h].type) {
							for (var d = c[h].exterior, f = c[h].interiors, p = 0; p < d.length; p++) {
								s.applyTransform(d[p], d[p], u);
							}for (var g = 0; g < (f ? f.length : 0); g++) {
								for (var p = 0; p < f[g].length; p++) {
									s.applyTransform(f[g][p], f[g][p], u);
								}
							}
						}
					}a = this._rect, a.copy(l), this.center = [a.x + a.width / 2, a.y + a.height / 2];
				} }, t.exports = n;
		}, function (t, e, i) {
			function n(t) {
				if (!t.UTF8Encoding) return t;var e = t.UTF8Scale;null == e && (e = 1024);for (var i = t.features, n = 0; n < i.length; n++) {
					for (var o = i[n], r = o.geometry, s = r.coordinates, l = r.encodeOffsets, u = 0; u < s.length; u++) {
						var c = s[u];if ("Polygon" === r.type) s[u] = a(c, l[u], e);else if ("MultiPolygon" === r.type) for (var h = 0; h < c.length; h++) {
							var d = c[h];c[h] = a(d, l[u][h], e);
						}
					}
				}return t.UTF8Encoding = !1, t;
			}function a(t, e, i) {
				for (var n = [], a = e[0], o = e[1], r = 0; r < t.length; r += 2) {
					var s = t.charCodeAt(r) - 64,
					    l = t.charCodeAt(r + 1) - 64;s = s >> 1 ^ -(1 & s), l = l >> 1 ^ -(1 & l), s += a, l += o, a = s, o = l, n.push([s / i, l / i]);
				}return n;
			}var o = i(1),
			    r = i(261);t.exports = function (t) {
				return n(t), o.map(o.filter(t.features, function (t) {
					return t.geometry && t.properties && t.geometry.coordinates.length > 0;
				}), function (t) {
					var e = t.properties,
					    i = t.geometry,
					    n = i.coordinates,
					    a = [];"Polygon" === i.type && a.push({ type: "polygon", exterior: n[0], interiors: n.slice(1) }), "MultiPolygon" === i.type && o.each(n, function (t) {
						t[0] && a.push({ type: "polygon", exterior: t[0], interiors: t.slice(1) });
					});var s = new r(e.name, a, e.cp);return s.properties = e, s;
				});
			};
		}, function (t, e, i) {
			function n(t, e) {
				var i = [];return t.eachComponent("parallel", function (n, o) {
					var r = new a(n, t, e);r.name = "parallel_" + o, r.resize(n, e), n.coordinateSystem = r, r.model = n, i.push(r);
				}), t.eachSeries(function (e) {
					if ("parallel" === e.get("coordinateSystem")) {
						var i = t.queryComponents({ mainType: "parallel", index: e.get("parallelIndex"), id: e.get("parallelId") })[0];e.coordinateSystem = i.coordinateSystem;
					}
				}), i;
			}var a = i(405);i(26).register("parallel", { create: n });
		}, function (t, e, i) {
			function n(t) {
				var e = t.mainData,
				    i = t.datas;i || (i = { main: e }, t.datasAttr = { main: "data" }), t.datas = t.mainData = null, u(e, i, t), d(i, function (i) {
					d(e.TRANSFERABLE_METHODS, function (e) {
						i.wrapMethod(e, h.curry(a, t));
					});
				}), e.wrapMethod("cloneShallow", h.curry(r, t)), d(e.CHANGABLE_METHODS, function (i) {
					e.wrapMethod(i, h.curry(o, t));
				}), h.assert(i[e.dataType] === e);
			}function a(t, e) {
				if (l(this)) {
					var i = h.extend({}, this[f]);i[this.dataType] = e, u(e, i, t);
				} else c(e, this.dataType, this[p], t);return e;
			}function o(t, e) {
				return t.struct && t.struct.update(this), e;
			}function r(t, e) {
				return d(e[f], function (i, n) {
					i !== e && c(i.cloneShallow(), n, e, t);
				}), e;
			}function s(t) {
				var e = this[p];return null == t || null == e ? e : e[f][t];
			}function l(t) {
				return t[p] === t;
			}function u(t, e, i) {
				t[f] = {}, d(e, function (e, n) {
					c(e, n, t, i);
				});
			}function c(t, e, i, n) {
				i[f][e] = t, t[p] = i, t.dataType = e, n.struct && (t[n.structAttr] = n.struct, n.struct[n.datasAttr[e]] = t), t.getLinkedData = s;
			}var h = i(1),
			    d = h.each,
			    f = "\0__link_datas",
			    p = "\0__link_mainData";t.exports = n;
		}, function (t, e, i) {
			function n() {
				function t(e, n) {
					if (n >= i.length) return e;for (var o = -1, r = e.length, s = i[n++], l = {}, u = {}; ++o < r;) {
						var c = s(e[o]),
						    h = u[c];h ? h.push(e[o]) : u[c] = [e[o]];
					}return a.each(u, function (e, i) {
						l[i] = t(e, n);
					}), l;
				}function e(t, o) {
					if (o >= i.length) return t;var r = [],
					    s = n[o++];return a.each(t, function (t, i) {
						r.push({ key: i, values: e(t, o) });
					}), s ? r.sort(function (t, e) {
						return s(t.key, e.key);
					}) : r;
				}var i = [],
				    n = [];return { key: function key(t) {
						return i.push(t), this;
					}, sortKeys: function sortKeys(t) {
						return n[i.length - 1] = t, this;
					}, entries: function entries(i) {
						return e(t(i, 0), 0);
					} };
			}var a = i(1);t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = { get: function get(t, e, i) {
					var a = n.clone((o[t] || {})[e]);return i && n.isArray(a) ? a[a.length - 1] : a;
				} },
			    o = { color: { active: ["#006edd", "#e0ffff"], inactive: ["rgba(0,0,0,0)"] }, colorHue: { active: [0, 360], inactive: [0, 0] }, colorSaturation: { active: [.3, 1], inactive: [0, 0] }, colorLightness: { active: [.9, .5], inactive: [0, 0] }, colorAlpha: { active: [.3, 1], inactive: [0, 0] }, opacity: { active: [.3, 1], inactive: [0, 0] }, symbol: { active: ["circle", "roundRect", "diamond"], inactive: ["none"] }, symbolSize: { active: [10, 50], inactive: [0, 0] } };t.exports = a;
		}, function (t, e, i) {
			function n(t, e) {
				return Math.abs(t - e) < r;
			}function a(t, e, i) {
				var a = 0,
				    r = t[0];if (!r) return !1;for (var s = 1; s < t.length; s++) {
					var l = t[s];a += o(r[0], r[1], l[0], l[1], e, i), r = l;
				}var u = t[0];return n(r[0], u[0]) && n(r[1], u[1]) || (a += o(r[0], r[1], u[0], u[1], e, i)), 0 !== a;
			}var o = i(99),
			    r = 1e-8;t.exports = { contain: a };
		}, function (t, e, i) {
			var n = i(90).extend({ type: "series.pictorialBar", dependencies: ["grid"], defaultOption: { symbol: "circle", symbolSize: null, symbolRotate: null, symbolPosition: null, symbolOffset: null, symbolMargin: null, symbolRepeat: !1, symbolRepeatDirection: "end", symbolClip: !1, symbolBoundingData: null, symbolPatternSize: 400, barGap: "-100%", progressive: 0, hoverAnimation: !1 }, getInitialData: function getInitialData(t) {
					return t.stack = null, n.superApply(this, "getInitialData", arguments);
				} });t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i, n) {
				var l = t.getItemLayout(e),
				    u = i.get("symbolRepeat"),
				    c = i.get("symbolClip"),
				    h = i.get("symbolPosition") || "start",
				    d = i.get("symbolRotate"),
				    f = (d || 0) * Math.PI / 180 || 0,
				    p = i.get("symbolPatternSize") || 2,
				    g = i.isAnimationEnabled(),
				    m = { dataIndex: e, layout: l, itemModel: i, symbolType: t.getItemVisual(e, "symbol") || "circle", color: t.getItemVisual(e, "color"), symbolClip: c, symbolRepeat: u, symbolRepeatDirection: i.get("symbolRepeatDirection"), symbolPatternSize: p, rotation: f, animationModel: g ? i : null, hoverAnimation: g && i.get("hoverAnimation"), z2: i.getShallow("z", !0) || 0 };a(i, u, l, n, m), o(t, e, l, u, c, m.boundingLength, m.pxSign, p, n, m), r(i, m.symbolScale, f, n, m);var v = m.symbolSize,
				    y = i.get("symbolOffset");return I.isArray(y) && (y = [D(y[0], v[0]), D(y[1], v[1])]), s(i, v, l, u, c, y, h, m.valueLineWidth, m.boundingLength, m.repeatCutLength, n, m), m;
			}function a(t, e, i, n, a) {
				var o = n.valueDim,
				    r = t.get("symbolBoundingData"),
				    s = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()),
				    l = s.toGlobalCoord(s.dataToCoord(0)),
				    u = a.boundingLength = null != r ? s.toGlobalCoord(s.dataToCoord(s.scale.parse(r))) - l : e ? n.coordSysExtent[o.index][1 - +(i[o.wh] <= 0)] - l : i[o.wh];e && (a.repeatCutLength = i[o.wh]), a.pxSign = u > 0 ? 1 : u < 0 ? -1 : 0;
			}function o(t, e, i, n, a, o, r, s, l, u) {
				var c = l.valueDim,
				    h = l.categoryDim,
				    d = Math.abs(i[h.wh]),
				    f = t.getItemVisual(e, "symbolSize");I.isArray(f) ? f = f.slice() : (null == f && (f = "100%"), f = [f, f]), f[h.index] = D(f[h.index], d), f[c.index] = D(f[c.index], n ? d : Math.abs(o)), u.symbolSize = f;var p = u.symbolScale = [f[0] / s, f[1] / s];p[c.index] *= (l.isHorizontal ? -1 : 1) * r;
			}function r(t, e, i, n, a) {
				var o = t.get(P) || 0;o && (O.attr({ scale: e.slice(), rotation: i }), O.updateTransform(), o /= O.getLineScale(), o *= e[n.valueDim.index]), a.valueLineWidth = o;
			}function s(t, e, i, n, a, o, r, s, l, u, c, h) {
				var d = c.categoryDim,
				    f = c.valueDim,
				    p = h.pxSign,
				    g = Math.max(e[f.index] + s, 0),
				    m = g;if (n) {
					var v = Math.abs(l),
					    y = I.retrieve(t.get("symbolMargin"), "15%") + "",
					    x = !1;y.lastIndexOf("!") === y.length - 1 && (x = !0, y = y.slice(0, y.length - 1)), y = D(y, e[f.index]);var _ = Math.max(g + 2 * y, 0),
					    b = x ? 0 : 2 * y,
					    w = C.isNumeric(n),
					    S = w ? n : M((v + b) / _),
					    T = v - S * g;y = T / 2 / (x ? S : S - 1), _ = g + 2 * y, b = x ? 0 : 2 * y, w || "fixed" === n || (S = u ? M((Math.abs(u) + b) / _) : 0), m = S * _ - b, h.repeatTimes = S, h.symbolMargin = y;
				}var A = p * (m / 2),
				    L = h.pathPosition = [];L[d.index] = i[d.wh] / 2, L[f.index] = "start" === r ? A : "end" === r ? l - A : l / 2, o && (L[0] += o[0], L[1] += o[1]);var P = h.bundlePosition = [];P[d.index] = i[d.xy], P[f.index] = i[f.xy];var k = h.barRectShape = I.extend({}, i);k[f.wh] = p * Math.max(Math.abs(i[f.wh]), Math.abs(L[f.index] + A)), k[d.wh] = i[d.wh];var O = h.clipShape = {};O[d.xy] = -i[d.xy], O[d.wh] = c.ecSize[d.wh], O[f.xy] = 0, O[f.wh] = i[f.wh];
			}function l(t) {
				var e = t.symbolPatternSize,
				    i = A.createSymbol(t.symbolType, -e / 2, -e / 2, e, e, t.color);return i.attr({ culling: !0 }), "image" !== i.type && i.setStyle({ strokeNoScale: !0 }), i;
			}function u(t, e, i, n) {
				function a(t) {
					var e = h.slice(),
					    n = i.pxSign,
					    a = t;return ("start" === i.symbolRepeatDirection ? n > 0 : n < 0) && (a = f - 1 - t), e[d.index] = g * (a - f / 2 + .5) + h[d.index], { position: e, scale: i.symbolScale.slice(), rotation: i.rotation };
				}function o() {
					b(t, function (t) {
						t.trigger("emphasis");
					});
				}function r() {
					b(t, function (t) {
						t.trigger("normal");
					});
				}var s = t.__pictorialBundle,
				    u = i.symbolSize,
				    c = i.valueLineWidth,
				    h = i.pathPosition,
				    d = e.valueDim,
				    f = i.repeatTimes || 0,
				    p = 0,
				    g = u[e.valueDim.index] + c + 2 * i.symbolMargin;for (b(t, function (t) {
					t.__pictorialAnimationIndex = p, t.__pictorialRepeatTimes = f, p < f ? w(t, null, a(p), i, n) : w(t, null, { scale: [0, 0] }, i, n, function () {
						s.remove(t);
					}), m(t, i), p++;
				}); p < f; p++) {
					var v = l(i);v.__pictorialAnimationIndex = p, v.__pictorialRepeatTimes = f, s.add(v);var y = a(p, !0);w(v, { position: y.position, scale: [0, 0] }, { scale: y.scale, rotation: y.rotation }, i, n), v.on("mouseover", o).on("mouseout", r), m(v, i);
				}
			}function c(t, e, i, n) {
				function a() {
					this.trigger("emphasis");
				}function o() {
					this.trigger("normal");
				}var r = t.__pictorialBundle,
				    s = t.__pictorialMainPath;s ? w(s, null, { position: i.pathPosition.slice(), scale: i.symbolScale.slice(), rotation: i.rotation }, i, n) : (s = t.__pictorialMainPath = l(i), r.add(s), w(s, { position: i.pathPosition.slice(), scale: [0, 0], rotation: i.rotation }, { scale: i.symbolScale.slice() }, i, n), s.on("mouseover", a).on("mouseout", o)), m(s, i);
			}function h(t, e, i) {
				var n = I.extend({}, e.barRectShape),
				    a = t.__pictorialBarRect;a ? w(a, null, { shape: n }, e, i) : (a = t.__pictorialBarRect = new T.Rect({ z2: 2, shape: n, silent: !0, style: { stroke: "transparent", fill: "transparent", lineWidth: 0 } }), t.add(a));
			}function d(t, e, i, n) {
				if (i.symbolClip) {
					var a = t.__pictorialClipPath,
					    o = I.extend({}, i.clipShape),
					    r = e.valueDim,
					    s = i.animationModel,
					    l = i.dataIndex;if (a) T.updateProps(a, { shape: o }, s, l);else {
						o[r.wh] = 0, a = new T.Rect({ shape: o }), t.__pictorialBundle.setClipPath(a), t.__pictorialClipPath = a;var u = {};u[r.wh] = i.clipShape[r.wh], T[n ? "updateProps" : "initProps"](a, { shape: u }, s, l);
					}
				}
			}function f(t, e) {
				var i = t.getItemModel(e);return i.getAnimationDelayParams = p, i.isAnimationEnabled = g, i;
			}function p(t) {
				return { index: t.__pictorialAnimationIndex, count: t.__pictorialRepeatTimes };
			}function g() {
				return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
			}function m(t, e) {
				t.off("emphasis").off("normal");var i = e.symbolScale.slice();e.hoverAnimation && t.on("emphasis", function () {
					this.animateTo({ scale: [1.1 * i[0], 1.1 * i[1]] }, 400, "elasticOut");
				}).on("normal", function () {
					this.animateTo({ scale: i.slice() }, 400, "elasticOut");
				});
			}function v(t, e, i, n) {
				var a = new T.Group(),
				    o = new T.Group();return a.add(o), a.__pictorialBundle = o, o.attr("position", i.bundlePosition.slice()), i.symbolRepeat ? u(a, e, i) : c(a, e, i), h(a, i, n), d(a, e, i, n), a.__pictorialShapeStr = _(t, i), a.__pictorialSymbolMeta = i, a;
			}function y(t, e, i) {
				var n = i.animationModel,
				    a = i.dataIndex,
				    o = t.__pictorialBundle;T.updateProps(o, { position: i.bundlePosition.slice() }, n, a), i.symbolRepeat ? u(t, e, i, !0) : c(t, e, i, !0), h(t, i, !0), d(t, e, i, !0);
			}function x(t, e, i, n) {
				var a = n.__pictorialBarRect;a && (a.style.text = "");
				var o = [];b(n, function (t) {
					o.push(t);
				}), n.__pictorialMainPath && o.push(n.__pictorialMainPath), n.__pictorialClipPath && (i = null), I.each(o, function (t) {
					T.updateProps(t, { scale: [0, 0] }, i, e, function () {
						n.parent && n.parent.remove(n);
					});
				}), t.setItemGraphicEl(e, null);
			}function _(t, e) {
				return [t.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":");
			}function b(t, e, i) {
				I.each(t.__pictorialBundle.children(), function (n) {
					n !== t.__pictorialBarRect && e.call(i, n);
				});
			}function w(t, e, i, n, a, o) {
				e && t.attr(e), n.symbolClip && !a ? i && t.attr(i) : i && T[a ? "updateProps" : "initProps"](t, i, n.animationModel, n.dataIndex, o);
			}function S(t, e, i) {
				var n = i.color,
				    a = i.dataIndex,
				    o = i.itemModel,
				    r = o.getModel("itemStyle.normal").getItemStyle(["color"]),
				    s = o.getModel("itemStyle.emphasis").getItemStyle();b(t, function (t) {
					t.setColor(n), t.setStyle(I.defaults({ fill: n, opacity: i.opacity }, r)), T.setHoverStyle(t, s), t.z2 = i.z2;
				});var l = {},
				    u = e.valueDim.posDesc[+(i.boundingLength > 0)],
				    c = t.__pictorialBarRect;L.setLabel(c.style, l, o, n, e.seriesModel, a, u), T.setHoverStyle(c, l);
			}function M(t) {
				var e = Math.round(t);return Math.abs(t - e) < 1e-4 ? e : Math.ceil(t);
			}var I = i(1),
			    T = i(3),
			    A = i(24),
			    C = i(4),
			    L = i(91),
			    D = C.parsePercent,
			    P = ["itemStyle", "normal", "borderWidth"],
			    k = [{ xy: "x", wh: "width", index: 0, posDesc: ["left", "right"] }, { xy: "y", wh: "height", index: 1, posDesc: ["top", "bottom"] }],
			    O = new T.Circle(),
			    z = i(2).extendChartView({ type: "pictorialBar", render: function render(t, e, i) {
					var a = this.group,
					    o = t.getData(),
					    r = this._data,
					    s = t.coordinateSystem,
					    l = s.getBaseAxis(),
					    u = !!l.isHorizontal(),
					    c = s.grid.getRect(),
					    h = { ecSize: { width: i.getWidth(), height: i.getHeight() }, seriesModel: t, coordSys: s, coordSysExtent: [[c.x, c.x + c.width], [c.y, c.y + c.height]], isHorizontal: u, valueDim: k[+u], categoryDim: k[1 - u] };return o.diff(r).add(function (t) {
						if (o.hasValue(t)) {
							var e = f(o, t),
							    i = n(o, t, e, h),
							    r = v(o, h, i);o.setItemGraphicEl(t, r), a.add(r), S(r, h, i);
						}
					}).update(function (t, e) {
						var i = r.getItemGraphicEl(e);if (!o.hasValue(t)) return void a.remove(i);var s = f(o, t),
						    l = n(o, t, s, h),
						    u = _(o, l);i && u !== i.__pictorialShapeStr && (a.remove(i), o.setItemGraphicEl(t, null), i = null), i ? y(i, h, l) : i = v(o, h, l, !0), o.setItemGraphicEl(t, i), i.__pictorialSymbolMeta = l, a.add(i), S(i, h, l);
					}).remove(function (t) {
						var e = r.getItemGraphicEl(t);e && x(r, t, e.__pictorialSymbolMeta.animationModel, e);
					}).execute(), this._data = o, this.group;
				}, dispose: I.noop, remove: function remove(t, e) {
					var i = this.group,
					    n = this._data;t.get("animation") ? n && n.eachItemGraphicEl(function (e) {
						x(n, e.dataIndex, t, e);
					}) : i.removeAll();
				} });t.exports = z;
		}, function (t, e, i) {
			var n = i(2);i(271), i(272), n.registerVisual(i(274)), n.registerLayout(i(273));
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(17),
			    o = i(183),
			    r = a.extend({ type: "series.boxplot", dependencies: ["xAxis", "yAxis", "grid"], defaultValueDimensions: ["min", "Q1", "median", "Q3", "max"], dimensions: null, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, hoverAnimation: !0, layout: null, boxWidth: [7, 50], itemStyle: { normal: { color: "#fff", borderWidth: 1 }, emphasis: { borderWidth: 2, shadowBlur: 5, shadowOffsetX: 2, shadowOffsetY: 2, shadowColor: "rgba(0,0,0,0.4)" } }, animationEasing: "elasticOut", animationDuration: 800 } });n.mixin(r, o.seriesModelMixin, !0), t.exports = r;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				var n = e.getItemModel(i),
				    a = n.getModel(u),
				    o = e.getItemVisual(i, "color"),
				    s = a.getItemStyle(["borderColor"]),
				    l = t.childAt(t.whiskerIndex);l.style.set(s), l.style.stroke = o, l.dirty();var h = t.childAt(t.bodyIndex);h.style.set(s), h.style.stroke = o, h.dirty();var d = n.getModel(c).getItemStyle();r.setHoverStyle(t, d);
			}var a = i(1),
			    o = i(30),
			    r = i(3),
			    s = i(183),
			    l = o.extend({ type: "boxplot", getStyleUpdater: function getStyleUpdater() {
					return n;
				}, dispose: a.noop });a.mixin(l, s.viewMixin, !0);var u = ["itemStyle", "normal"],
			    c = ["itemStyle", "emphasis"];t.exports = l;
		}, function (t, e, i) {
			function n(t) {
				var e = [],
				    i = [];return t.eachSeriesByType("boxplot", function (t) {
					var n = t.getBaseAxis(),
					    a = r.indexOf(i, n);a < 0 && (a = i.length, i[a] = n, e[a] = { axis: n, seriesModels: [] }), e[a].seriesModels.push(t);
				}), e;
			}function a(t) {
				var e,
				    i,
				    n = t.axis,
				    a = t.seriesModels,
				    o = a.length,
				    s = t.boxWidthList = [],
				    c = t.boxOffsetList = [],
				    h = [];if ("category" === n.type) i = n.getBandWidth();else {
					var d = 0;u(a, function (t) {
						d = Math.max(d, t.getData().count());
					}), e = n.getExtent(), Math.abs(e[1] - e[0]) / d;
				}u(a, function (t) {
					var e = t.get("boxWidth");r.isArray(e) || (e = [e, e]), h.push([l(e[0], i) || 0, l(e[1], i) || 0]);
				});var f = .8 * i - 2,
				    p = f / o * .3,
				    g = (f - p * (o - 1)) / o,
				    m = g / 2 - f / 2;u(a, function (t, e) {
					c.push(m), m += p + g, s.push(Math.min(Math.max(g, h[e][0]), h[e][1]));
				});
			}function o(t, e, i) {
				var n,
				    a = t.coordinateSystem,
				    o = t.getData(),
				    s = i / 2,
				    l = t.get("layout"),
				    u = "horizontal" === l ? 0 : 1,
				    c = 1 - u,
				    h = ["x", "y"],
				    d = [];r.each(o.dimensions, function (t) {
					var e = o.getDimensionInfo(t),
					    i = e.coordDim;i === h[c] ? d.push(t) : i === h[u] && (n = t);
				}), null == n || d.length < 5 || o.each([n].concat(d), function () {
					function t(t) {
						var i = [];i[u] = h, i[c] = t;var n;return isNaN(h) || isNaN(t) ? n = [NaN, NaN] : (n = a.dataToPoint(i), n[u] += e), n;
					}function i(t, e) {
						var i = t.slice(),
						    n = t.slice();i[u] += s, n[u] -= s, e ? y.push(i, n) : y.push(n, i);
					}function n(t) {
						var e = [t.slice(), t.slice()];e[0][u] -= s, e[1][u] += s, v.push(e);
					}var r = arguments,
					    h = r[0],
					    f = r[d.length + 1],
					    p = t(r[3]),
					    g = t(r[1]),
					    m = t(r[5]),
					    v = [[g, t(r[2])], [m, t(r[4])]];n(g), n(m), n(p);var y = [];i(v[0][1], 0), i(v[1][1], 1), o.setItemLayout(f, { chartLayout: l, initBaseline: p[c], median: p, bodyEnds: y, whiskerEnds: v });
				});
			}var r = i(1),
			    s = i(4),
			    l = s.parsePercent,
			    u = r.each;t.exports = function (t) {
				var e = n(t);u(e, function (t) {
					var e = t.seriesModels;e.length && (a(t), u(e, function (e, i) {
						o(e, t.boxOffsetList[i], t.boxWidthList[i]);
					}));
				});
			};
		}, function (t, e) {
			var i = ["itemStyle", "normal", "borderColor"];t.exports = function (t, e) {
				var n = t.get("color");t.eachRawSeriesByType("boxplot", function (e) {
					var a = n[e.seriesIndex % n.length],
					    o = e.getData();o.setVisual({ legendSymbol: "roundRect", color: e.get(i) || a }), t.isSeriesFiltered(e) || o.each(function (t) {
						var e = o.getItemModel(t);o.setItemVisual(t, { color: e.get(i, !0) });
					});
				});
			};
		}, function (t, e, i) {
			var n = i(2);i(276), i(277), n.registerPreprocessor(i(280)), n.registerVisual(i(279)), n.registerLayout(i(278));
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(17),
			    o = i(183),
			    r = a.extend({ type: "series.candlestick", dependencies: ["xAxis", "yAxis", "grid"], defaultValueDimensions: ["open", "close", "lowest", "highest"], dimensions: null, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, hoverAnimation: !0, layout: null, itemStyle: { normal: { color: "#c23531", color0: "#314656", borderWidth: 1, borderColor: "#c23531", borderColor0: "#314656" }, emphasis: { borderWidth: 2 } }, barMaxWidth: null, barMinWidth: null, barWidth: null, animationUpdate: !1, animationEasing: "linear", animationDuration: 300 }, getShadowDim: function getShadowDim() {
					return "open";
				}, brushSelector: function brushSelector(t, e, i) {
					var n = e.getItemLayout(t);return i.rect(n.brushRect);
				} });n.mixin(r, o.seriesModelMixin, !0), t.exports = r;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				var n = e.getItemModel(i),
				    a = n.getModel(u),
				    o = e.getItemVisual(i, "color"),
				    s = e.getItemVisual(i, "borderColor") || o,
				    l = a.getItemStyle(["color", "color0", "borderColor", "borderColor0"]),
				    h = t.childAt(t.whiskerIndex);h.useStyle(l), h.style.stroke = s;var d = t.childAt(t.bodyIndex);d.useStyle(l), d.style.fill = o, d.style.stroke = s;var f = n.getModel(c).getItemStyle();r.setHoverStyle(t, f);
			}var a = i(1),
			    o = i(30),
			    r = i(3),
			    s = i(183),
			    l = o.extend({ type: "candlestick", getStyleUpdater: function getStyleUpdater() {
					return n;
				}, dispose: a.noop });a.mixin(l, s.viewMixin, !0);var u = ["itemStyle", "normal"],
			    c = ["itemStyle", "emphasis"];t.exports = l;
		}, function (t, e, i) {
			function n(t, e) {
				var i,
				    n = t.getBaseAxis(),
				    a = "category" === n.type ? n.getBandWidth() : (i = n.getExtent(), Math.abs(i[1] - i[0]) / e.count()),
				    s = r(o(t.get("barMaxWidth"), a), a),
				    l = r(o(t.get("barMinWidth"), 1), a),
				    u = t.get("barWidth");return null != u ? r(u, a) : Math.max(Math.min(a / 2, s), l);
			}var a = i(1),
			    o = i(1).retrieve,
			    r = i(4).parsePercent;t.exports = function (t) {
				t.eachSeriesByType("candlestick", function (t) {
					var e,
					    i = t.coordinateSystem,
					    o = t.getData(),
					    r = n(t, o),
					    s = t.get("layout"),
					    l = "horizontal" === s ? 0 : 1,
					    u = 1 - l,
					    c = ["x", "y"],
					    h = [];a.each(o.dimensions, function (t) {
						var i = o.getDimensionInfo(t),
						    n = i.coordDim;n === c[u] ? h.push(t) : n === c[l] && (e = t);
					}), null == e || h.length < 4 || o.each([e].concat(h), function () {
						function t(t) {
							var e = [];return e[l] = c, e[u] = t, isNaN(c) || isNaN(t) ? [NaN, NaN] : i.dataToPoint(e);
						}function e(t, e) {
							var i = t.slice(),
							    n = t.slice();i[l] += r / 2, n[l] -= r / 2, e ? M.push(i, n) : M.push(n, i);
						}function n() {
							var e = t(Math.min(f, p, g, m)),
							    i = t(Math.max(f, p, g, m));return e[l] -= r / 2, i[l] -= r / 2, { x: e[0], y: e[1], width: u ? r : i[0] - e[0], height: u ? i[1] - e[1] : r };
						}var a = arguments,
						    c = a[0],
						    d = a[h.length + 1],
						    f = a[1],
						    p = a[2],
						    g = a[3],
						    m = a[4],
						    v = Math.min(f, p),
						    y = Math.max(f, p),
						    x = t(v),
						    _ = t(y),
						    b = t(g),
						    w = t(m),
						    S = [[w, _], [b, x]],
						    M = [];e(_, 0), e(x, 1), o.setItemLayout(d, { chartLayout: s, sign: f > p ? -1 : f < p ? 1 : 0, initBaseline: f > p ? _[u] : x[u], bodyEnds: M, whiskerEnds: S, brushRect: n() });
					}, !0);
				});
			};
		}, function (t, e) {
			var i = ["itemStyle", "normal", "borderColor"],
			    n = ["itemStyle", "normal", "borderColor0"],
			    a = ["itemStyle", "normal", "color"],
			    o = ["itemStyle", "normal", "color0"];t.exports = function (t, e) {
				t.eachRawSeriesByType("candlestick", function (e) {
					var r = e.getData();r.setVisual({ legendSymbol: "roundRect" }), t.isSeriesFiltered(e) || r.each(function (t) {
						var e = r.getItemModel(t),
						    s = r.getItemLayout(t).sign;r.setItemVisual(t, { color: e.get(s > 0 ? a : o), borderColor: e.get(s > 0 ? i : n) });
					});
				});
			};
		}, function (t, e, i) {
			var n = i(1);t.exports = function (t) {
				t && n.isArray(t.series) && n.each(t.series, function (t) {
					n.isObject(t) && "k" === t.type && (t.type = "candlestick");
				});
			};
		}, function (t, e, i) {
			function n(t) {
				var e,
				    i = t.type;if ("path" === i) {
					var n = t.shape;e = d.makePath(n.pathData, null, { x: n.x || 0, y: n.y || 0, width: n.width || 0, height: n.height || 0 }, "center"), e.__customPathData = t.pathData;
				} else if ("image" === i) e = new d.Image({}), e.__customImagePath = t.style.image;else if ("text" === i) e = new d.Text({}), e.__customText = t.style.text;else {
					var a = d[i.charAt(0).toUpperCase() + i.slice(1)];e = new a();
				}return e.__customGraphicType = i, e;
			}function a(t, e, i, n, a, r) {
				var s = {},
				    l = i.style || {};if (i.shape && (s.shape = h.clone(i.shape)), i.position && (s.position = i.position.slice()), i.scale && (s.scale = i.scale.slice()), i.origin && (s.origin = i.origin.slice()), i.rotation && (s.rotation = i.rotation), "image" === t.type && i.style) {
					var u = s.style = {};h.each(["x", "y", "width", "height"], function (e) {
						o(e, u, l, t.style, r);
					});
				}if ("text" === t.type && i.style) {
					var u = s.style = {};h.each(["x", "y"], function (e) {
						o(e, u, l, t.style, r);
					});
				}if ("group" !== t.type && (t.useStyle(l), r)) {
					t.style.opacity = 0;var c = l.opacity;null == c && (c = 1), d.initProps(t, { style: { opacity: c } }, n, e);
				}r ? t.attr(s) : d.updateProps(t, s, n, e), t.attr({ z2: i.z2 || 0, silent: i.silent }), t.styleEmphasis !== !1 && d.setHoverStyle(t, t.styleEmphasis);
			}function o(t, e, i, n, a) {
				null == i[t] || a || (e[t] = i[t], i[t] = n[t]);
			}function r(t, e, i, n) {
				function a(t) {
					null == t && (t = w), O && (S = e.getItemModel(t), M = S.getModel(y), I = S.getModel(x), T = f.findLabelValueDim(e), A = e.getItemVisual(t, "color"), O = !1);
				}function o(t, i) {
					return null == i && (i = w), e.get(e.getDimension(t || 0), i);
				}function r(i, n) {
					null == n && (n = w), a(n);var o = S.getModel(m).getItemStyle();null != A && (o.fill = A);var r = e.getItemVisual(n, "opacity");return null != r && (o.opacity = r), f.setTextToStyle(e, n, T, o, t, M, A), i && h.extend(o, i), o;
				}function l(i, n) {
					null == n && (n = w), a(n);var o = S.getModel(v).getItemStyle();return f.setTextToStyle(e, n, T, o, t, I, A), i && h.extend(o, i), o;
				}function u(t, i) {
					return null == i && (i = w), e.getItemVisual(i, t);
				}function c(t) {
					if (L.getBaseAxis) {
						var e = L.getBaseAxis();return g.getLayoutOnAxis(h.defaults({ axis: e }, t), n);
					}
				}function p() {
					return i.getCurrentSeriesIndices();
				}function b(t) {
					return d.getFont(t, i);
				}var w,
				    S,
				    M,
				    I,
				    T,
				    A,
				    C = t.get("renderItem"),
				    L = t.coordinateSystem,
				    D = _[L.type](L),
				    P = h.defaults({ getWidth: n.getWidth, getHeight: n.getHeight, getZr: n.getZr, getDevicePixelRatio: n.getDevicePixelRatio, value: o, style: r, styleEmphasis: l, visual: u, barLayout: c, currentSeriesIndices: p, font: b }, D.api),
				    k = { context: {}, seriesId: t.id, seriesName: t.name, seriesIndex: t.seriesIndex, coordSys: D.coordSys, dataInsideLength: e.count(), encode: s(t.getData()) },
				    O = !0;return function (t) {
					return w = t, O = !0, C && C(h.defaults({ dataIndexInside: t, dataIndex: e.getRawIndex(t) }, k), P) || {};
				};
			}function s(t) {
				var e = {};return h.each(t.dimensions, function (i, n) {
					var a = t.getDimensionInfo(i);if (!a.isExtraCoord) {
						var o = a.coordDim,
						    r = e[o] = e[o] || [];r[a.coordDimIndex] = n;
					}
				}), e;
			}function l(t, e, i, n, a, o) {
				t = u(t, e, i, n, a, o), t && o.setItemGraphicEl(e, t);
			}function u(t, e, i, o, r, s) {
				var l = i.type;if (!t || l === t.__customGraphicType || "path" === l && i.pathData === t.__customPathData || "image" === l && i.style.image === t.__customImagePath || "text" === l && i.style.text === t.__customText || (r.remove(t), t = null), null != l) {
					var c = !t;return !t && (t = n(i)), a(t, e, i, o, s, c), "group" === l && h.each(i.children, function (i, n) {
						u(t.childAt(n), e, i, o, t, s);
					}), r.add(t), t;
				}
			}var c = i(2),
			    h = i(1),
			    d = i(3),
			    f = i(92),
			    p = i(28),
			    g = i(82),
			    m = ["itemStyle", "normal"],
			    v = ["itemStyle", "emphasis"],
			    y = ["label", "normal"],
			    x = ["label", "emphasis"],
			    _ = { cartesian2d: i(397), geo: i(403), singleAxis: i(421), polar: i(414), calendar: i(396) };c.extendSeriesModel({ type: "series.custom", dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"], defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: !0 }, getInitialData: function getInitialData(t, e) {
					return p(t.data, this, e);
				} }), c.extendChartView({ type: "custom", _data: null, render: function render(t, e, i) {
					var n = this._data,
					    a = t.getData(),
					    o = this.group,
					    s = r(t, a, e, i);a.diff(n).add(function (e) {
						a.hasValue(e) && l(null, e, s(e), t, o, a);
					}).update(function (e, i) {
						var r = n.getItemGraphicEl(i);a.hasValue(e) ? l(r, e, s(e), t, o, a) : r && o.remove(r);
					}).remove(function (t) {
						var e = n.getItemGraphicEl(t);e && o.remove(e);
					}).execute(), this._data = a;
				} });
		}, function (t, e, i) {
			var n = i(1),
			    a = i(2);i(283), i(284), a.registerVisual(n.curry(i(50), "effectScatter", "circle", null)), a.registerLayout(n.curry(i(61), "effectScatter"));
		}, function (t, e, i) {
			"use strict";
			var n = i(28),
			    a = i(17);t.exports = a.extend({ type: "series.effectScatter", dependencies: ["grid", "polar"], getInitialData: function getInitialData(t, e) {
					var i = n(t.data, this, e);return i;
				}, brushSelector: "point", defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: !0, effectType: "ripple", progressive: 0, showEffectOn: "render", rippleEffect: { period: 4, scale: 2.5, brushType: "fill" }, symbolSize: 10 } });
		}, function (t, e, i) {
			var n = i(44),
			    a = i(311);i(2).extendChartView({ type: "effectScatter", init: function init() {
					this._symbolDraw = new n(a);
				}, render: function render(t, e, i) {
					var n = t.getData(),
					    a = this._symbolDraw;a.updateData(n), this.group.add(a.group);
				}, updateLayout: function updateLayout() {
					this._symbolDraw.updateLayout();
				}, remove: function remove(t, e) {
					this._symbolDraw && this._symbolDraw.remove(e);
				}, dispose: function dispose() {} });
		}, function (t, e, i) {
			var n = i(1),
			    a = i(2);i(286), i(287), a.registerVisual(n.curry(i(84), "funnel")), a.registerLayout(i(288)), a.registerProcessor(n.curry(i(63), "funnel"));
		}, function (t, e, i) {
			"use strict";
			var n = i(14),
			    a = i(5),
			    o = i(25),
			    r = i(2).extendSeriesModel({ type: "series.funnel", init: function init(t) {
					r.superApply(this, "init", arguments), this.legendDataProvider = function () {
						return this.getRawData();
					}, this._defaultLabelLine(t);
				}, getInitialData: function getInitialData(t, e) {
					var i = o(["value"], t.data),
					    a = new n(i, this);return a.initData(t.data), a;
				}, _defaultLabelLine: function _defaultLabelLine(t) {
					a.defaultEmphasis(t.labelLine, ["show"]);var e = t.labelLine.normal,
					    i = t.labelLine.emphasis;e.show = e.show && t.label.normal.show, i.show = i.show && t.label.emphasis.show;
				}, getDataParams: function getDataParams(t) {
					var e = this.getData(),
					    i = r.superCall(this, "getDataParams", t),
					    n = e.getSum("value");return i.percent = n ? +(e.get("value", t) / n * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
				}, defaultOption: { zlevel: 0, z: 2, legendHoverLink: !0, left: 80, top: 60, right: 80, bottom: 60, minSize: "0%", maxSize: "100%", sort: "descending", gap: 0, funnelAlign: "center", label: { normal: { show: !0, position: "outer" }, emphasis: { show: !0 } }, labelLine: { normal: { show: !0, length: 20, lineStyle: { width: 1, type: "solid" } }, emphasis: {} }, itemStyle: { normal: { borderColor: "#fff", borderWidth: 1 }, emphasis: {} } } });t.exports = r;
		}, function (t, e, i) {
			function n(t, e) {
				function i() {
					r.ignore = r.hoverIgnore, s.ignore = s.hoverIgnore;
				}function n() {
					r.ignore = r.normalIgnore, s.ignore = s.normalIgnore;
				}o.Group.call(this);var a = new o.Polygon(),
				    r = new o.Polyline(),
				    s = new o.Text();this.add(a), this.add(r), this.add(s), this.updateData(t, e, !0), this.on("emphasis", i).on("normal", n).on("mouseover", i).on("mouseout", n);
			}function a(t, e, i, n) {
				var a = n.getModel("textStyle"),
				    o = n.get("position"),
				    s = "inside" === o || "inner" === o || "center" === o;return { fill: a.getTextColor() || (s ? "#fff" : t.getItemVisual(e, "color")), textFont: a.getFont(), text: r.retrieve(t.hostModel.getFormattedLabel(e, i), t.getName(e)) };
			}var o = i(3),
			    r = i(1),
			    s = n.prototype,
			    l = ["itemStyle", "normal", "opacity"];s.updateData = function (t, e, i) {
				var n = this.childAt(0),
				    a = t.hostModel,
				    s = t.getItemModel(e),
				    u = t.getItemLayout(e),
				    c = t.getItemModel(e).get(l);c = null == c ? 1 : c, n.useStyle({}), i ? (n.setShape({ points: u.points }), n.setStyle({ opacity: 0 }), o.initProps(n, { style: { opacity: c } }, a, e)) : o.updateProps(n, { style: { opacity: c }, shape: { points: u.points } }, a, e);var h = s.getModel("itemStyle"),
				    d = t.getItemVisual(e, "color");n.setStyle(r.defaults({ lineJoin: "round", fill: d }, h.getModel("normal").getItemStyle(["opacity"]))), n.hoverStyle = h.getModel("emphasis").getItemStyle(), this._updateLabel(t, e), o.setHoverStyle(this);
			}, s._updateLabel = function (t, e) {
				var i = this.childAt(1),
				    n = this.childAt(2),
				    r = t.hostModel,
				    s = t.getItemModel(e),
				    l = t.getItemLayout(e),
				    u = l.label,
				    c = t.getItemVisual(e, "color");o.updateProps(i, { shape: { points: u.linePoints || u.linePoints } }, r, e), o.updateProps(n, { style: { x: u.x, y: u.y } }, r, e), n.attr({ style: { textAlign: u.textAlign, textVerticalAlign: u.verticalAlign, textFont: u.font }, rotation: u.rotation, origin: [u.x, u.y], z2: 10 });var h = s.getModel("label.normal"),
				    d = s.getModel("label.emphasis"),
				    f = s.getModel("labelLine.normal"),
				    p = s.getModel("labelLine.emphasis");n.setStyle(a(t, e, "normal", h)), n.ignore = n.normalIgnore = !h.get("show"), n.hoverIgnore = !d.get("show"), i.ignore = i.normalIgnore = !f.get("show"), i.hoverIgnore = !p.get("show"), i.setStyle({ stroke: c }), i.setStyle(f.getModel("lineStyle").getLineStyle()), n.hoverStyle = a(t, e, "emphasis", d), i.hoverStyle = p.getModel("lineStyle").getLineStyle();
			}, r.inherits(n, o.Group);var u = i(30).extend({ type: "funnel", render: function render(t, e, i) {
					var a = t.getData(),
					    o = this._data,
					    r = this.group;a.diff(o).add(function (t) {
						var e = new n(a, t);a.setItemGraphicEl(t, e), r.add(e);
					}).update(function (t, e) {
						var i = o.getItemGraphicEl(e);i.updateData(a, t), r.add(i), a.setItemGraphicEl(t, i);
					}).remove(function (t) {
						var e = o.getItemGraphicEl(t);r.remove(e);
					}).execute(), this._data = a;
				}, remove: function remove() {
					this.group.removeAll(), this._data = null;
				}, dispose: function dispose() {} });t.exports = u;
		}, function (t, e, i) {
			function n(t, e) {
				return r.getLayoutRect(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() });
			}function a(t, e) {
				for (var i = t.mapArray("value", function (t) {
					return t;
				}), n = [], a = "ascending" === e, o = 0, r = t.count(); o < r; o++) {
					n[o] = o;
				}return "function" == typeof e ? n.sort(e) : "none" !== e && n.sort(function (t, e) {
					return a ? i[t] - i[e] : i[e] - i[t];
				}), n;
			}function o(t) {
				t.each(function (e) {
					var i,
					    n,
					    a,
					    o,
					    r = t.getItemModel(e),
					    s = r.getModel("label.normal"),
					    l = s.get("position"),
					    u = r.getModel("labelLine.normal"),
					    c = t.getItemLayout(e),
					    h = c.points,
					    d = "inner" === l || "inside" === l || "center" === l;if (d) n = (h[0][0] + h[1][0] + h[2][0] + h[3][0]) / 4, a = (h[0][1] + h[1][1] + h[2][1] + h[3][1]) / 4, i = "center", o = [[n, a], [n, a]];else {
						var f,
						    p,
						    g,
						    m = u.get("length");"left" === l ? (f = (h[3][0] + h[0][0]) / 2, p = (h[3][1] + h[0][1]) / 2, g = f - m, n = g - 5, i = "right") : (f = (h[1][0] + h[2][0]) / 2, p = (h[1][1] + h[2][1]) / 2, g = f + m, n = g + 5, i = "left");var v = p;o = [[f, p], [g, v]], a = v;
					}c.label = { linePoints: o, x: n, y: a, verticalAlign: "middle", textAlign: i, inside: d };
				});
			}var r = i(12),
			    s = i(4),
			    l = s.parsePercent;t.exports = function (t, e, i) {
				t.eachSeriesByType("funnel", function (t) {
					var i = t.getData(),
					    r = t.get("sort"),
					    u = n(t, e),
					    c = a(i, r),
					    h = [l(t.get("minSize"), u.width), l(t.get("maxSize"), u.width)],
					    d = i.getDataExtent("value"),
					    f = t.get("min"),
					    p = t.get("max");null == f && (f = Math.min(d[0], 0)), null == p && (p = d[1]);var g = t.get("funnelAlign"),
					    m = t.get("gap"),
					    v = (u.height - m * (i.count() - 1)) / i.count(),
					    y = u.y,
					    x = function x(t, e) {
						var n,
						    a = i.get("value", t) || 0,
						    o = s.linearMap(a, [f, p], h, !0);switch (g) {case "left":
								n = u.x;break;case "center":
								n = u.x + (u.width - o) / 2;break;case "right":
								n = u.x + u.width - o;}return [[n, e], [n + o, e]];
					};"ascending" === r && (v = -v, m = -m, y += u.height, c = c.reverse());for (var _ = 0; _ < c.length; _++) {
						var b = c[_],
						    w = c[_ + 1],
						    S = x(b, y),
						    M = x(w, y + v);y += v + m, i.setItemLayout(b, { points: S.concat(M.slice().reverse()) });
					}o(i);
				});
			};
		}, function (t, e, i) {
			i(290), i(291);
		}, function (t, e, i) {
			var n = i(14),
			    a = i(17),
			    o = i(1),
			    r = a.extend({ type: "series.gauge", getInitialData: function getInitialData(t, e) {
					var i = new n(["value"], this),
					    a = t.data || [];return o.isArray(a) || (a = [a]), i.initData(a), i;
				}, defaultOption: { zlevel: 0, z: 2, center: ["50%", "50%"], legendHoverLink: !0, radius: "75%", startAngle: 225, endAngle: -45, clockwise: !0, min: 0, max: 100, splitNumber: 10, axisLine: { show: !0, lineStyle: { color: [[.2, "#91c7ae"], [.8, "#63869e"], [1, "#c23531"]], width: 30 } }, splitLine: { show: !0, length: 30, lineStyle: { color: "#eee", width: 2, type: "solid" } }, axisTick: { show: !0, splitNumber: 5, length: 8, lineStyle: { color: "#eee", width: 1, type: "solid" } }, axisLabel: { show: !0, distance: 5, textStyle: { color: "auto" } }, pointer: { show: !0, length: "80%", width: 8 }, itemStyle: { normal: { color: "auto" } }, title: { show: !0, offsetCenter: [0, "-40%"], textStyle: { color: "#333", fontSize: 15 } }, detail: { show: !0, backgroundColor: "rgba(0,0,0,0)", borderWidth: 0, borderColor: "#ccc", width: 100, height: 40, offsetCenter: [0, "40%"], textStyle: { color: "auto", fontSize: 30 } } } });t.exports = r;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t.get("center"),
				    n = e.getWidth(),
				    a = e.getHeight(),
				    o = Math.min(n, a),
				    r = l(i[0], e.getWidth()),
				    s = l(i[1], e.getHeight()),
				    u = l(t.get("radius"), o / 2);return { cx: r, cy: s, r: u };
			}function a(t, e) {
				return e && ("string" == typeof e ? t = e.replace("{value}", null != t ? t : "") : "function" == typeof e && (t = e(t))), t;
			}var o = i(292),
			    r = i(3),
			    s = i(4),
			    l = s.parsePercent,
			    u = 2 * Math.PI,
			    c = i(30).extend({ type: "gauge", render: function render(t, e, i) {
					this.group.removeAll();var a = t.get("axisLine.lineStyle.color"),
					    o = n(t, i);this._renderMain(t, e, i, a, o);
				}, dispose: function dispose() {}, _renderMain: function _renderMain(t, e, i, n, a) {
					for (var o = this.group, s = t.getModel("axisLine"), l = s.getModel("lineStyle"), c = t.get("clockwise"), h = -t.get("startAngle") / 180 * Math.PI, d = -t.get("endAngle") / 180 * Math.PI, f = (d - h) % u, p = h, g = l.get("width"), m = 0; m < n.length; m++) {
						var v = Math.min(Math.max(n[m][0], 0), 1),
						    d = h + f * v,
						    y = new r.Sector({ shape: { startAngle: p, endAngle: d, cx: a.cx, cy: a.cy, clockwise: c, r0: a.r - g, r: a.r }, silent: !0 });y.setStyle({ fill: n[m][1] }), y.setStyle(l.getLineStyle(["color", "borderWidth", "borderColor"])), o.add(y), p = d;
					}var x = function x(t) {
						if (t <= 0) return n[0][1];for (var e = 0; e < n.length; e++) {
							if (n[e][0] >= t && (0 === e ? 0 : n[e - 1][0]) < t) return n[e][1];
						}return n[e - 1][1];
					};if (!c) {
						var _ = h;h = d, d = _;
					}this._renderTicks(t, e, i, x, a, h, d, c), this._renderPointer(t, e, i, x, a, h, d, c), this._renderTitle(t, e, i, x, a), this._renderDetail(t, e, i, x, a);
				}, _renderTicks: function _renderTicks(t, e, i, n, o, u, c, h) {
					for (var d = this.group, f = o.cx, p = o.cy, g = o.r, m = +t.get("min"), v = +t.get("max"), y = t.getModel("splitLine"), x = t.getModel("axisTick"), _ = t.getModel("axisLabel"), b = t.get("splitNumber"), w = x.get("splitNumber"), S = l(y.get("length"), g), M = l(x.get("length"), g), I = u, T = (c - u) / b, A = T / w, C = y.getModel("lineStyle").getLineStyle(), L = x.getModel("lineStyle").getLineStyle(), D = _.getModel("textStyle"), P = 0; P <= b; P++) {
						var k = Math.cos(I),
						    O = Math.sin(I);if (y.get("show")) {
							var z = new r.Line({ shape: { x1: k * g + f, y1: O * g + p, x2: k * (g - S) + f, y2: O * (g - S) + p }, style: C, silent: !0 });"auto" === C.stroke && z.setStyle({ stroke: n(P / b) }), d.add(z);
						}if (_.get("show")) {
							var E = a(s.round(P / b * (v - m) + m), _.get("formatter")),
							    R = _.get("distance"),
							    N = new r.Text({ style: { text: E, x: k * (g - S - R) + f, y: O * (g - S - R) + p, fill: D.getTextColor(), textFont: D.getFont(), textVerticalAlign: O < -.4 ? "top" : O > .4 ? "bottom" : "middle", textAlign: k < -.4 ? "left" : k > .4 ? "right" : "center" }, silent: !0 });"auto" === N.style.fill && N.setStyle({ fill: n(P / b) }), d.add(N);
						}if (x.get("show") && P !== b) {
							for (var V = 0; V <= w; V++) {
								var k = Math.cos(I),
								    O = Math.sin(I),
								    B = new r.Line({ shape: { x1: k * g + f, y1: O * g + p, x2: k * (g - M) + f, y2: O * (g - M) + p }, silent: !0, style: L });"auto" === L.stroke && B.setStyle({ stroke: n((P + V / w) / b) }), d.add(B), I += A;
							}I -= A;
						} else I += T;
					}
				}, _renderPointer: function _renderPointer(t, e, i, n, a, u, c, h) {
					var d = this.group,
					    f = this._data;if (!t.get("pointer.show")) return void (f && f.eachItemGraphicEl(function (t) {
						d.remove(t);
					}));var p = [+t.get("min"), +t.get("max")],
					    g = [u, c],
					    m = t.getData();m.diff(f).add(function (e) {
						var i = new o({ shape: { angle: u } });r.initProps(i, { shape: { angle: s.linearMap(m.get("value", e), p, g, !0) } }, t), d.add(i), m.setItemGraphicEl(e, i);
					}).update(function (e, i) {
						var n = f.getItemGraphicEl(i);r.updateProps(n, { shape: { angle: s.linearMap(m.get("value", e), p, g, !0) } }, t), d.add(n), m.setItemGraphicEl(e, n);
					}).remove(function (t) {
						var e = f.getItemGraphicEl(t);d.remove(e);
					}).execute(), m.eachItemGraphicEl(function (t, e) {
						var i = m.getItemModel(e),
						    o = i.getModel("pointer");t.setShape({ x: a.cx, y: a.cy, width: l(o.get("width"), a.r), r: l(o.get("length"), a.r) }), t.useStyle(i.getModel("itemStyle.normal").getItemStyle()), "auto" === t.style.fill && t.setStyle("fill", n(s.linearMap(m.get("value", e), p, [0, 1], !0))), r.setHoverStyle(t, i.getModel("itemStyle.emphasis").getItemStyle());
					}), this._data = m;
				}, _renderTitle: function _renderTitle(t, e, i, n, a) {
					var o = t.getModel("title");if (o.get("show")) {
						var u = o.getModel("textStyle"),
						    c = o.get("offsetCenter"),
						    h = a.cx + l(c[0], a.r),
						    d = a.cy + l(c[1], a.r),
						    f = new r.Text({ style: { x: h, y: d, text: t.getData().getName(0), fill: u.getTextColor(), textFont: u.getFont(), textAlign: "center", textVerticalAlign: "middle" } });if ("auto" === f.style.fill) {
							var p = +t.get("min"),
							    g = +t.get("max"),
							    m = t.getData().get("value", 0);f.setStyle("fill", n(s.linearMap(m, [p, g], [0, 1], !0)));
						}this.group.add(f);
					}
				}, _renderDetail: function _renderDetail(t, e, i, n, o) {
					var u = t.getModel("detail"),
					    c = +t.get("min"),
					    h = +t.get("max");if (u.get("show")) {
						var d = u.getModel("textStyle"),
						    f = u.get("offsetCenter"),
						    p = o.cx + l(f[0], o.r),
						    g = o.cy + l(f[1], o.r),
						    m = l(u.get("width"), o.r),
						    v = l(u.get("height"), o.r),
						    y = t.getData().get("value", 0),
						    x = new r.Rect({ shape: { x: p - m / 2, y: g - v / 2, width: m, height: v }, style: { text: a(y, u.get("formatter")), fill: u.get("backgroundColor"), textFill: d.getTextColor(), textFont: d.getFont() } });"auto" === x.style.textFill && x.setStyle("textFill", n(s.linearMap(y, [c, h], [0, 1], !0))), x.setStyle(u.getItemStyle(["color"])), this.group.add(x);
					}
				} });t.exports = c;
		}, function (t, e, i) {
			t.exports = i(8).extend({ type: "echartsGaugePointer", shape: { angle: 0, width: 10, r: 10, x: 0, y: 0 }, buildPath: function buildPath(t, e) {
					var i = Math.cos,
					    n = Math.sin,
					    a = e.r,
					    o = e.width,
					    r = e.angle,
					    s = e.x - i(r) * o * (o >= a / 3 ? 1 : 2),
					    l = e.y - n(r) * o * (o >= a / 3 ? 1 : 2);r = e.angle - Math.PI / 2, t.moveTo(s, l), t.lineTo(e.x + i(r) * o, e.y + n(r) * o), t.lineTo(e.x + i(e.angle) * a, e.y + n(e.angle) * a), t.lineTo(e.x - i(r) * o, e.y - n(r) * o), t.lineTo(s, l);
				} });
		}, function (t, e, i) {
			var n = i(2),
			    a = i(1);i(294), i(295), i(304), n.registerProcessor(i(297)), n.registerVisual(a.curry(i(50), "graph", "circle", null)), n.registerVisual(i(298)), n.registerVisual(i(301)), n.registerLayout(i(305)), n.registerLayout(i(299)), n.registerLayout(i(303)), n.registerCoordinateSystem("graphView", { create: i(300) });
		}, function (t, e, i) {
			"use strict";
			var n = i(14),
			    a = i(1),
			    o = i(5),
			    r = i(10),
			    s = i(7),
			    l = i(247),
			    u = i(2).extendSeriesModel({ type: "series.graph", init: function init(t) {
					u.superApply(this, "init", arguments), this.legendDataProvider = function () {
						return this._categoriesData;
					}, this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
				}, mergeOption: function mergeOption(t) {
					u.superApply(this, "mergeOption", arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
				}, mergeDefaultAndTheme: function mergeDefaultAndTheme(t) {
					u.superApply(this, "mergeDefaultAndTheme", arguments), o.defaultEmphasis(t.edgeLabel, o.LABEL_OPTIONS);
				}, getInitialData: function getInitialData(t, e) {
					function i(t, i) {
						function n(t) {
							return t = this.parsePath(t), t && "label" === t[0] ? s : this.parentModel;
						}t.wrapMethod("getItemModel", function (t) {
							var e = o._categoriesModels,
							    i = t.getShallow("category"),
							    n = e[i];return n && (n.parentModel = t.parentModel, t.parentModel = n), t;
						});var a = o.getModel("edgeLabel"),
						    s = new r({ label: a.option }, a.parentModel, e);i.wrapMethod("getItemModel", function (t) {
							return t.customizeGetParent(n), t;
						});
					}var n = t.edges || t.links || [],
					    a = t.data || t.nodes || [],
					    o = this;if (a && n) return l(a, n, this, !0, i).data;
				}, getGraph: function getGraph() {
					return this.getData().graph;
				}, getEdgeData: function getEdgeData() {
					return this.getGraph().edgeData;
				}, getCategoriesData: function getCategoriesData() {
					return this._categoriesData;
				}, formatTooltip: function formatTooltip(t, e, i) {
					if ("edge" === i) {
						var n = this.getData(),
						    a = this.getDataParams(t, i),
						    o = n.graph.getEdgeByIndex(t),
						    r = n.getName(o.node1.dataIndex),
						    l = n.getName(o.node2.dataIndex),
						    c = [];return null != r && c.push(r), null != l && c.push(l), c = s.encodeHTML(c.join(" > ")), a.value && (c += " : " + s.encodeHTML(a.value)), c;
					}return u.superApply(this, "formatTooltip", arguments);
				}, _updateCategoriesData: function _updateCategoriesData() {
					var t = a.map(this.option.categories || [], function (t) {
						return null != t.value ? t : a.extend({ value: 0 }, t);
					}),
					    e = new n(["value"], this);e.initData(t), this._categoriesData = e, this._categoriesModels = e.mapArray(function (t) {
						return e.getItemModel(t, !0);
					});
				}, setZoom: function setZoom(t) {
					this.option.zoom = t;
				}, setCenter: function setCenter(t) {
					this.option.center = t;
				}, isAnimationEnabled: function isAnimationEnabled() {
					return u.superCall(this, "isAnimationEnabled") && !("force" === this.get("layout") && this.get("force.layoutAnimation"));
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "view", legendHoverLink: !0, hoverAnimation: !0, layout: null, focusNodeAdjacency: !1, circular: { rotateLabel: !1 }, force: { initLayout: null, repulsion: [0, 50], gravity: .1, edgeLength: 30, layoutAnimation: !0 }, left: "center", top: "center", symbol: "circle", symbolSize: 10, edgeSymbol: ["none", "none"], edgeSymbolSize: 10, edgeLabel: { normal: { position: "middle" }, emphasis: {} }, draggable: !1, roam: !1, center: null, zoom: 1, nodeScaleRatio: .6, label: { normal: { show: !1, formatter: "{b}" }, emphasis: { show: !0 } }, itemStyle: { normal: {}, emphasis: {} }, lineStyle: { normal: { color: "#aaa", width: 1, curveness: 0, opacity: .5 }, emphasis: {} } } });t.exports = u;
		}, function (t, e, i) {
			function n(t, e) {
				return t.getVisual("opacity") || t.getModel().get(e);
			}var a = i(44),
			    o = i(107),
			    r = i(95),
			    s = i(250),
			    l = i(128),
			    u = i(3),
			    c = i(296),
			    h = i(1),
			    d = ["itemStyle", "normal", "opacity"],
			    f = ["lineStyle", "normal", "opacity"];i(2).extendChartView({ type: "graph", init: function init(t, e) {
					var i = new a(),
					    n = new o(),
					    s = this.group;this._controller = new r(e.getZr()), this._controllerHost = { target: s }, s.add(i.group), s.add(n.group), this._symbolDraw = i, this._lineDraw = n, this._firstRender = !0;
				}, render: function render(t, e, i) {
					var n = t.coordinateSystem;this._model = t, this._nodeScaleRatio = t.get("nodeScaleRatio");var a = this._symbolDraw,
					    o = this._lineDraw,
					    r = this.group;if ("view" === n.type) {
						var s = { position: n.position, scale: n.scale };this._firstRender ? r.attr(s) : u.updateProps(r, s, t);
					}c(t.getGraph(), this._getNodeGlobalScale(t));var l = t.getData();a.updateData(l);var h = t.getEdgeData();o.updateData(h), this._updateNodeAndLinkScale(), this._updateController(t, e, i), clearTimeout(this._layoutTimeout);var d = t.forceLayout,
					    f = t.get("force.layoutAnimation");d && this._startForceLayoutIteration(d, f), l.eachItemGraphicEl(function (e, n) {
						var a = l.getItemModel(n);e.off("drag").off("dragend");var o = l.getItemModel(n).get("draggable");o && e.on("drag", function () {
							d && (d.warmUp(), !this._layouting && this._startForceLayoutIteration(d, f), d.setFixed(n), l.setItemLayout(n, e.position));
						}, this).on("dragend", function () {
							d && d.setUnfixed(n);
						}, this), e.setDraggable(o && d), e.off("mouseover", e.__focusNodeAdjacency), e.off("mouseout", e.__unfocusNodeAdjacency), a.get("focusNodeAdjacency") && (e.on("mouseover", e.__focusNodeAdjacency = function () {
							i.dispatchAction({ type: "focusNodeAdjacency", seriesId: t.id, dataIndex: e.dataIndex });
						}), e.on("mouseout", e.__unfocusNodeAdjacency = function () {
							i.dispatchAction({ type: "unfocusNodeAdjacency", seriesId: t.id });
						}));
					}, this);var p = "circular" === t.get("layout") && t.get("circular.rotateLabel"),
					    g = l.getLayout("cx"),
					    m = l.getLayout("cy");l.eachItemGraphicEl(function (t, e) {
						var i = t.getSymbolPath();if (p) {
							var n = l.getItemLayout(e),
							    a = Math.atan2(n[1] - m, n[0] - g);a < 0 && (a = 2 * Math.PI + a);var o = n[0] < g;o && (a -= Math.PI);var r = o ? "left" : "right";i.setStyle({ textRotation: a, textPosition: r }), i.hoverStyle && (i.hoverStyle.textPosition = r);
						} else i.setStyle({ textRotation: 0 });
					}), this._firstRender = !1;
				}, dispose: function dispose() {
					this._controller && this._controller.dispose(), this._controllerHost = {};
				}, focusNodeAdjacency: function focusNodeAdjacency(t, e, i, a) {
					function o(t, e) {
						var i = n(t, e),
						    a = t.getGraphicEl();null == i && (i = 1), a.traverse(function (t) {
							t.trigger("normal"), "group" !== t.type && t.setStyle("opacity", .1 * i);
						});
					}function r(t, e) {
						var i = n(t, e),
						    a = t.getGraphicEl();a.traverse(function (t) {
							t.trigger("emphasis"), "group" !== t.type && t.setStyle("opacity", i);
						});
					}var s = this._model.getData(),
					    l = a.dataIndex,
					    u = s.getItemGraphicEl(l);if (u) {
						var c = s.graph,
						    p = u.dataType;if (null !== l && "edge" !== p) {
							c.eachNode(function (t) {
								o(t, d);
							}), c.eachEdge(function (t) {
								o(t, f);
							});var g = c.getNodeByIndex(l);r(g, d), h.each(g.edges, function (t) {
								t.dataIndex < 0 || (r(t, f), r(t.node1, d), r(t.node2, d));
							});
						}
					}
				}, unfocusNodeAdjacency: function unfocusNodeAdjacency(t, e, i, a) {
					var o = this._model.getData().graph;o.eachNode(function (t) {
						var e = n(t, d);t.getGraphicEl().traverse(function (t) {
							t.trigger("normal"), "group" !== t.type && t.setStyle("opacity", e);
						});
					}), o.eachEdge(function (t) {
						var e = n(t, f);t.getGraphicEl().traverse(function (t) {
							t.trigger("normal"), "group" !== t.type && t.setStyle("opacity", e);
						});
					});
				}, _startForceLayoutIteration: function _startForceLayoutIteration(t, e) {
					var i = this;!function n() {
						t.step(function (t) {
							i.updateLayout(i._model), (i._layouting = !t) && (e ? i._layoutTimeout = setTimeout(n, 16) : n());
						});
					}();
				}, _updateController: function _updateController(t, e, i) {
					var n = this._controller,
					    a = this._controllerHost,
					    o = this.group;return n.setPointerChecker(function (e, n, a) {
						var r = o.getBoundingRect();return r.applyTransform(o.transform), r.contain(n, a) && !l.onIrrelevantElement(e, i, t);
					}), "view" !== t.coordinateSystem.type ? void n.disable() : (n.enable(t.get("roam")), a.zoomLimit = t.get("scaleLimit"), a.zoom = t.coordinateSystem.getZoom(), void n.off("pan").off("zoom").on("pan", function (e, n) {
						s.updateViewOnPan(a, e, n), i.dispatchAction({ seriesId: t.id, type: "graphRoam", dx: e, dy: n });
					}).on("zoom", function (e, n, o) {
						s.updateViewOnZoom(a, e, n, o), i.dispatchAction({ seriesId: t.id, type: "graphRoam", zoom: e, originX: n, originY: o }), this._updateNodeAndLinkScale(), c(t.getGraph(), this._getNodeGlobalScale(t)), this._lineDraw.updateLayout();
					}, this));
				}, _updateNodeAndLinkScale: function _updateNodeAndLinkScale() {
					var t = this._model,
					    e = t.getData(),
					    i = this._getNodeGlobalScale(t),
					    n = [i, i];e.eachItemGraphicEl(function (t, e) {
						t.attr("scale", n);
					});
				}, _getNodeGlobalScale: function _getNodeGlobalScale(t) {
					var e = t.coordinateSystem;if ("view" !== e.type) return 1;var i = this._nodeScaleRatio,
					    n = e.scale,
					    a = n && n[0] || 1,
					    o = e.getZoom(),
					    r = (o - 1) * i + 1;return r / a;
				}, updateLayout: function updateLayout(t) {
					c(t.getGraph(), this._getNodeGlobalScale(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
				}, remove: function remove(t, e) {
					this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
				} });
		}, function (t, e, i) {
			function n(t, e, i) {
				for (var n, a = t[0], o = t[1], d = t[2], f = 1 / 0, p = i * i, g = .1, m = .1; m <= .9; m += .1) {
					r[0] = u(a[0], o[0], d[0], m), r[1] = u(a[1], o[1], d[1], m);var v = h(c(r, e) - p);v < f && (f = v, n = m);
				}for (var y = 0; y < 32; y++) {
					var x = n + g;s[0] = u(a[0], o[0], d[0], n), s[1] = u(a[1], o[1], d[1], n), l[0] = u(a[0], o[0], d[0], x), l[1] = u(a[1], o[1], d[1], x);var v = c(s, e) - p;if (h(v) < .01) break;var _ = c(l, e) - p;g /= 2, v < 0 ? _ >= 0 ? n += g : n -= g : _ >= 0 ? n -= g : n += g;
				}return n;
			}var a = i(20),
			    o = i(6),
			    r = [],
			    s = [],
			    l = [],
			    u = a.quadraticAt,
			    c = o.distSquare,
			    h = Math.abs;t.exports = function (t, e) {
				function i(t) {
					var e = t.getVisual("symbolSize");return e instanceof Array && (e = (e[0] + e[1]) / 2), e;
				}var r = [],
				    s = a.quadraticSubdivide,
				    l = [[], [], []],
				    u = [[], []],
				    c = [];e /= 2, t.eachEdge(function (t, a) {
					var h = t.getLayout(),
					    d = t.getVisual("fromSymbol"),
					    f = t.getVisual("toSymbol");h.__original || (h.__original = [o.clone(h[0]), o.clone(h[1])], h[2] && h.__original.push(o.clone(h[2])));var p = h.__original;if (null != h[2]) {
						if (o.copy(l[0], p[0]), o.copy(l[1], p[2]), o.copy(l[2], p[1]), d && "none" != d) {
							var g = i(t.node1),
							    m = n(l, p[0], g * e);s(l[0][0], l[1][0], l[2][0], m, r), l[0][0] = r[3], l[1][0] = r[4], s(l[0][1], l[1][1], l[2][1], m, r), l[0][1] = r[3], l[1][1] = r[4];
						}if (f && "none" != f) {
							var g = i(t.node2),
							    m = n(l, p[1], g * e);s(l[0][0], l[1][0], l[2][0], m, r), l[1][0] = r[1], l[2][0] = r[2], s(l[0][1], l[1][1], l[2][1], m, r), l[1][1] = r[1], l[2][1] = r[2];
						}o.copy(h[0], l[0]), o.copy(h[1], l[2]), o.copy(h[2], l[1]);
					} else {
						if (o.copy(u[0], p[0]), o.copy(u[1], p[1]), o.sub(c, u[1], u[0]), o.normalize(c, c), d && "none" != d) {
							var g = i(t.node1);o.scaleAndAdd(u[0], u[0], c, g * e);
						}if (f && "none" != f) {
							var g = i(t.node2);o.scaleAndAdd(u[1], u[1], c, -g * e);
						}o.copy(h[0], u[0]), o.copy(h[1], u[1]);
					}
				});
			};
		}, function (t, e) {
			t.exports = function (t) {
				var e = t.findComponents({ mainType: "legend" });e && e.length && t.eachSeriesByType("graph", function (t) {
					var i = t.getCategoriesData(),
					    n = t.getGraph(),
					    a = n.data,
					    o = i.mapArray(i.getName);a.filterSelf(function (t) {
						var i = a.getItemModel(t),
						    n = i.getShallow("category");if (null != n) {
							"number" == typeof n && (n = o[n]);for (var r = 0; r < e.length; r++) {
								if (!e[r].isSelected(n)) return !1;
							}
						}return !0;
					});
				}, this);
			};
		}, function (t, e) {
			t.exports = function (t) {
				var e = {};t.eachSeriesByType("graph", function (t) {
					var i = t.getCategoriesData(),
					    n = t.getData(),
					    a = {};i.each(function (n) {
						var o = i.getName(n);a["ec-" + o] = n;var r = i.getItemModel(n),
						    s = r.get("itemStyle.normal.color") || t.getColorFromPalette(o, e);i.setItemVisual(n, "color", s);
					}), i.count() && n.each(function (t) {
						var e = n.getItemModel(t),
						    o = e.getShallow("category");null != o && ("string" == typeof o && (o = a["ec-" + o]), n.getItemVisual(t, "color", !0) || n.setItemVisual(t, "color", i.getItemVisual(o, "color")));
					});
				});
			};
		}, function (t, e, i) {
			var n = i(242);t.exports = function (t) {
				t.eachSeriesByType("graph", function (t) {
					"circular" === t.get("layout") && n(t);
				});
			};
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = t.getBoxLayoutParams();return n.aspect = i, o.getLayoutRect(n, { width: e.getWidth(), height: e.getHeight() });
			}var a = i(260),
			    o = i(12),
			    r = i(85);t.exports = function (t, e) {
				var i = [];return t.eachSeriesByType("graph", function (t) {
					var o = t.get("coordinateSystem");if (!o || "view" === o) {
						var s = t.getData(),
						    l = s.mapArray(function (t) {
							var e = s.getItemModel(t);return [+e.get("x"), +e.get("y")];
						}),
						    u = [],
						    c = [];r.fromPoints(l, u, c), c[0] - u[0] === 0 && (c[0] += 1, u[0] -= 1), c[1] - u[1] === 0 && (c[1] += 1, u[1] -= 1);var h = (c[0] - u[0]) / (c[1] - u[1]),
						    d = n(t, e, h);isNaN(h) && (u = [d.x, d.y], c = [d.x + d.width, d.y + d.height]);var f = c[0] - u[0],
						    p = c[1] - u[1],
						    g = d.width,
						    m = d.height,
						    v = t.coordinateSystem = new a();v.zoomLimit = t.get("scaleLimit"), v.setBoundingRect(u[0], u[1], f, p), v.setViewRect(d.x, d.y, g, m), v.setCenter(t.get("center")), v.setZoom(t.get("zoom")), i.push(v);
					}
				}), i;
			};
		}, function (t, e) {
			function i(t) {
				return t instanceof Array || (t = [t, t]), t;
			}t.exports = function (t) {
				t.eachSeriesByType("graph", function (t) {
					var e = t.getGraph(),
					    n = t.getEdgeData(),
					    a = i(t.get("edgeSymbol")),
					    o = i(t.get("edgeSymbolSize")),
					    r = "lineStyle.normal.color".split("."),
					    s = "lineStyle.normal.opacity".split(".");n.setVisual("fromSymbol", a && a[0]), n.setVisual("toSymbol", a && a[1]), n.setVisual("fromSymbolSize", o && o[0]), n.setVisual("toSymbolSize", o && o[1]), n.setVisual("color", t.get(r)), n.setVisual("opacity", t.get(s)), n.each(function (t) {
						var a = n.getItemModel(t),
						    o = e.getEdgeByIndex(t),
						    l = i(a.getShallow("symbol", !0)),
						    u = i(a.getShallow("symbolSize", !0)),
						    c = a.get(r),
						    h = a.get(s);switch (c) {case "source":
								c = o.node1.getVisual("color");break;case "target":
								c = o.node2.getVisual("color");}l[0] && o.setVisual("fromSymbol", l[0]), l[1] && o.setVisual("toSymbol", l[1]), u[0] && o.setVisual("fromSymbolSize", u[0]), u[1] && o.setVisual("toSymbolSize", u[1]), o.setVisual("color", c), o.setVisual("opacity", h);
					});
				});
			};
		}, function (t, e, i) {
			var n = i(6),
			    a = n.scaleAndAdd;t.exports = function (t, e, i) {
				for (var o = i.rect, r = o.width, s = o.height, l = [o.x + r / 2, o.y + s / 2], u = null == i.gravity ? .1 : i.gravity, c = 0; c < t.length; c++) {
					var h = t[c];h.p || (h.p = n.create(r * (Math.random() - .5) + l[0], s * (Math.random() - .5) + l[1])), h.pp = n.clone(h.p), h.edges = null;
				}var d = .6;return { warmUp: function warmUp() {
						d = .5;
					}, setFixed: function setFixed(e) {
						t[e].fixed = !0;
					}, setUnfixed: function setUnfixed(e) {
						t[e].fixed = !1;
					}, step: function step(i) {
						for (var o = [], r = t.length, s = 0; s < e.length; s++) {
							var c = e[s],
							    h = c.n1,
							    f = c.n2;n.sub(o, f.p, h.p);var p = n.len(o) - c.d,
							    g = f.w / (h.w + f.w);n.normalize(o, o), !h.fixed && a(h.p, h.p, o, g * p * d), !f.fixed && a(f.p, f.p, o, -(1 - g) * p * d);
						}for (var s = 0; s < r; s++) {
							var m = t[s];m.fixed || (n.sub(o, l, m.p), n.scaleAndAdd(m.p, m.p, o, u * d));
						}for (var s = 0; s < r; s++) {
							for (var h = t[s], v = s + 1; v < r; v++) {
								var f = t[v];n.sub(o, f.p, h.p);var p = n.len(o);0 === p && (n.set(o, Math.random() - .5, Math.random() - .5), p = 1);var y = (h.rep + f.rep) / p / p;!h.fixed && a(h.pp, h.pp, o, y), !f.fixed && a(f.pp, f.pp, o, -y);
							}
						}for (var x = [], s = 0; s < r; s++) {
							var m = t[s];m.fixed || (n.sub(x, m.p, m.pp), n.scaleAndAdd(m.p, m.p, x, d), n.copy(m.pp, m.p));
						}d = .992 * d, i && i(t, e, d < .01);
					} };
			};
		}, function (t, e, i) {
			var n = i(302),
			    a = i(4),
			    o = i(244),
			    r = i(242),
			    s = i(6),
			    l = i(1);t.exports = function (t) {
				t.eachSeriesByType("graph", function (t) {
					var e = t.coordinateSystem;if (!e || "view" === e.type) if ("force" === t.get("layout")) {
						var i = t.preservedPoints || {},
						    u = t.getGraph(),
						    c = u.data,
						    h = u.edgeData,
						    d = t.getModel("force"),
						    f = d.get("initLayout");t.preservedPoints ? c.each(function (t) {
							var e = c.getId(t);c.setItemLayout(t, i[e] || [NaN, NaN]);
						}) : f && "none" !== f ? "circular" === f && r(t) : o(t);var p = c.getDataExtent("value"),
						    g = h.getDataExtent("value"),
						    m = d.get("repulsion"),
						    v = d.get("edgeLength");l.isArray(m) || (m = [m, m]), l.isArray(v) || (v = [v, v]), v = [v[1], v[0]];var y = c.mapArray("value", function (t, e) {
							var i = c.getItemLayout(e),
							    n = a.linearMap(t, p, m);return isNaN(n) && (n = (m[0] + m[1]) / 2), { w: n, rep: n, p: !i || isNaN(i[0]) || isNaN(i[1]) ? null : i };
						}),
						    x = h.mapArray("value", function (t, e) {
							var i = u.getEdgeByIndex(e),
							    n = a.linearMap(t, g, v);return isNaN(n) && (n = (v[0] + v[1]) / 2), { n1: y[i.node1.dataIndex], n2: y[i.node2.dataIndex], d: n, curveness: i.getModel().get("lineStyle.normal.curveness") || 0 };
						}),
						    e = t.coordinateSystem,
						    _ = e.getBoundingRect(),
						    b = n(y, x, { rect: _, gravity: d.get("gravity") }),
						    w = b.step;b.step = function (t) {
							for (var e = 0, n = y.length; e < n; e++) {
								y[e].fixed && s.copy(y[e].p, u.getNodeByIndex(e).getLayout());
							}w(function (e, n, a) {
								for (var o = 0, r = e.length; o < r; o++) {
									e[o].fixed || u.getNodeByIndex(o).setLayout(e[o].p), i[c.getId(o)] = e[o].p;
								}for (var o = 0, r = n.length; o < r; o++) {
									var l = n[o],
									    h = u.getEdgeByIndex(o),
									    d = l.n1.p,
									    f = l.n2.p,
									    p = h.getLayout();p = p ? p.slice() : [], p[0] = p[0] || [], p[1] = p[1] || [], s.copy(p[0], d), s.copy(p[1], f), +l.curveness && (p[2] = [(d[0] + f[0]) / 2 - (d[1] - f[1]) * l.curveness, (d[1] + f[1]) / 2 - (f[0] - d[0]) * l.curveness]), h.setLayout(p);
								}t && t(a);
							});
						}, t.forceLayout = b, t.preservedPoints = i, b.step();
					} else t.forceLayout = null;
				});
			};
		}, function (t, e, i) {
			var n = i(2),
			    a = i(241),
			    o = { type: "graphRoam", event: "graphRoam", update: "none" };n.registerAction(o, function (t, e) {
				e.eachComponent({ mainType: "series", query: t }, function (e) {
					var i = e.coordinateSystem,
					    n = a.updateCenterAndZoom(i, t);e.setCenter && e.setCenter(n.center), e.setZoom && e.setZoom(n.zoom);
				});
			}), n.registerAction({ type: "focusNodeAdjacency", event: "focusNodeAdjacency", update: "series.graph:focusNodeAdjacency" }, function () {}), n.registerAction({ type: "unfocusNodeAdjacency", event: "unfocusNodeAdjacency", update: "series.graph:unfocusNodeAdjacency" }, function () {});
		}, function (t, e, i) {
			var n = i(244),
			    a = i(243);t.exports = function (t, e) {
				t.eachSeriesByType("graph", function (t) {
					var e = t.get("layout"),
					    i = t.coordinateSystem;if (i && "view" !== i.type) {
						var o = t.getData(),
						    r = i.dimensions;o.each(r, function () {
							for (var t, e = arguments, n = [], a = 0; a < r.length; a++) {
								isNaN(e[a]) || (t = !0), n.push(e[a]);
							}var s = e[e.length - 1];t ? o.setItemLayout(s, i.dataToPoint(n)) : o.setItemLayout(s, [NaN, NaN]);
						}), a(o.graph);
					} else e && "none" !== e || n(t);
				});
			};
		}, function (t, e, i) {
			i(308), i(309);
		}, function (t, e, i) {
			function n() {
				var t = o.createCanvas();this.canvas = t, this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {};
			}var a = 256,
			    o = i(1);n.prototype = { update: function update(t, e, i, n, o, r) {
					var s = this._getBrush(),
					    l = this._getGradient(t, o, "inRange"),
					    u = this._getGradient(t, o, "outOfRange"),
					    c = this.pointSize + this.blurSize,
					    h = this.canvas,
					    d = h.getContext("2d"),
					    f = t.length;h.width = e, h.height = i;for (var p = 0; p < f; ++p) {
						var g = t[p],
						    m = g[0],
						    v = g[1],
						    y = g[2],
						    x = n(y);d.globalAlpha = x, d.drawImage(s, m - c, v - c);
					}for (var _ = d.getImageData(0, 0, h.width, h.height), b = _.data, w = 0, S = b.length, M = this.minOpacity, I = this.maxOpacity, T = I - M; w < S;) {
						var x = b[w + 3] / 256,
						    A = 4 * Math.floor(x * (a - 1));if (x > 0) {
							var C = r(x) ? l : u;x > 0 && (x = x * T + M), b[w++] = C[A], b[w++] = C[A + 1], b[w++] = C[A + 2], b[w++] = C[A + 3] * x * 256;
						} else w += 4;
					}return d.putImageData(_, 0, 0), h;
				}, _getBrush: function _getBrush() {
					var t = this._brushCanvas || (this._brushCanvas = o.createCanvas()),
					    e = this.pointSize + this.blurSize,
					    i = 2 * e;t.width = i, t.height = i;var n = t.getContext("2d");return n.clearRect(0, 0, i, i), n.shadowOffsetX = i, n.shadowBlur = this.blurSize, n.shadowColor = "#000", n.beginPath(), n.arc(-e, e, this.pointSize, 0, 2 * Math.PI, !0), n.closePath(), n.fill(), t;
				}, _getGradient: function _getGradient(t, e, i) {
					for (var n = this._gradientPixels, a = n[i] || (n[i] = new Uint8ClampedArray(1024)), o = [0, 0, 0, 0], r = 0, s = 0; s < 256; s++) {
						e[i](s / 255, !0, o), a[r++] = o[0], a[r++] = o[1], a[r++] = o[2], a[r++] = o[3];
					}return a;
				} }, t.exports = n;
		}, function (t, e, i) {
			var n = i(17),
			    a = i(28);t.exports = n.extend({ type: "series.heatmap", getInitialData: function getInitialData(t, e) {
					return a(t.data, this, e);
				}, defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, geoIndex: 0, blurSize: 30, pointSize: 20, maxOpacity: 1, minOpacity: 0 } });
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = t[1] - t[0];e = l.map(e, function (e) {
					return { interval: [(e.interval[0] - t[0]) / n, (e.interval[1] - t[0]) / n] };
				});var a = e.length,
				    o = 0;return function (t) {
					for (var n = o; n < a; n++) {
						var r = e[n].interval;if (r[0] <= t && t <= r[1]) {
							o = n;break;
						}
					}if (n === a) for (var n = o - 1; n >= 0; n--) {
						var r = e[n].interval;if (r[0] <= t && t <= r[1]) {
							o = n;break;
						}
					}return n >= 0 && n < a && i[n];
				};
			}function a(t, e) {
				var i = t[1] - t[0];return e = [(e[0] - t[0]) / i, (e[1] - t[0]) / i], function (t) {
					return t >= e[0] && t <= e[1];
				};
			}function o(t) {
				var e = t.dimensions;return "lng" === e[0] && "lat" === e[1];
			}var r = i(3),
			    s = i(307),
			    l = i(1);t.exports = i(2).extendChartView({ type: "heatmap", render: function render(t, e, i) {
					var n;e.eachComponent("visualMap", function (e) {
						e.eachTargetSeries(function (i) {
							i === t && (n = e);
						});
					}), this.group.removeAll();var a = t.coordinateSystem;"cartesian2d" === a.type || "calendar" === a.type ? this._renderOnCartesianAndCalendar(a, t, i) : o(a) && this._renderOnGeo(a, t, n, i);
				}, dispose: function dispose() {}, _renderOnCartesianAndCalendar: function _renderOnCartesianAndCalendar(t, e, i) {
					if ("cartesian2d" === t.type) var n = t.getAxis("x"),
					    a = t.getAxis("y"),
					    o = n.getBandWidth(),
					    s = a.getBandWidth();var u = this.group,
					    c = e.getData(),
					    h = "itemStyle.normal",
					    d = "itemStyle.emphasis",
					    f = "label.normal",
					    p = "label.emphasis",
					    g = e.getModel(h).getItemStyle(["color"]),
					    m = e.getModel(d).getItemStyle(),
					    v = e.getModel("label.normal"),
					    y = e.getModel("label.emphasis"),
					    x = t.type,
					    _ = "cartesian2d" === x ? [e.coordDimToDataDim("x")[0], e.coordDimToDataDim("y")[0], e.coordDimToDataDim("value")[0]] : [e.coordDimToDataDim("time")[0], e.coordDimToDataDim("value")[0]];c.each(function (i) {
						var n;if ("cartesian2d" === x) {
							if (isNaN(c.get(_[2], i))) return;var a = t.dataToPoint([c.get(_[0], i), c.get(_[1], i)]);n = new r.Rect({ shape: { x: a[0] - o / 2, y: a[1] - s / 2, width: o, height: s }, style: { fill: c.getItemVisual(i, "color"), opacity: c.getItemVisual(i, "opacity") } });
						} else {
							if (isNaN(c.get(_[1], i))) return;n = new r.Rect({ z2: 1, shape: t.dataToRect([c.get(_[0], i)]).contentShape, style: { fill: c.getItemVisual(i, "color"), opacity: c.getItemVisual(i, "opacity") } });
						}var b = c.getItemModel(i);c.hasItemOption && (g = b.getModel(h).getItemStyle(["color"]), m = b.getModel(d).getItemStyle(), v = b.getModel(f), y = b.getModel(p));var w = e.getRawValue(i),
						    S = "-";w && null != w[2] && (S = w[2]), v.getShallow("show") && (r.setText(g, v), g.text = e.getFormattedLabel(i, "normal") || S), y.getShallow("show") && (r.setText(m, y), m.text = e.getFormattedLabel(i, "emphasis") || S), n.setStyle(g), r.setHoverStyle(n, c.hasItemOption ? m : l.extend({}, m)), u.add(n), c.setItemGraphicEl(i, n);
					});
				}, _renderOnGeo: function _renderOnGeo(t, e, i, o) {
					var l = i.targetVisuals.inRange,
					    u = i.targetVisuals.outOfRange,
					    c = e.getData(),
					    h = this._hmLayer || this._hmLayer || new s();h.blurSize = e.get("blurSize"), h.pointSize = e.get("pointSize"), h.minOpacity = e.get("minOpacity"), h.maxOpacity = e.get("maxOpacity");var d = t.getViewRect().clone(),
					    f = t.getRoamTransform().transform;d.applyTransform(f);var p = Math.max(d.x, 0),
					    g = Math.max(d.y, 0),
					    m = Math.min(d.width + d.x, o.getWidth()),
					    v = Math.min(d.height + d.y, o.getHeight()),
					    y = m - p,
					    x = v - g,
					    _ = c.mapArray(["lng", "lat", "value"], function (e, i, n) {
						var a = t.dataToPoint([e, i]);return a[0] -= p, a[1] -= g, a.push(n), a;
					}),
					    b = i.getExtent(),
					    w = "visualMap.continuous" === i.type ? a(b, i.option.range) : n(b, i.getPieceList(), i.option.selected);h.update(_, y, x, l.color.getNormalizer(), { inRange: l.color.getColorMapper(), outOfRange: u.color.getColorMapper() }, w);var S = new r.Image({ style: { width: y, height: x, x: p, y: g, image: h.canvas }, silent: !0 });this.group.add(S);
				} });
		}, function (t, e, i) {
			function n(t, e, i) {
				r.call(this, t, e, i), this._lastFrame = 0, this._lastFramePercent = 0;
			}var a = i(246),
			    o = i(1),
			    r = i(245),
			    s = i(6),
			    l = n.prototype;l.createLine = function (t, e, i) {
				return new a(t, e, i);
			}, l.updateAnimationPoints = function (t, e) {
				this._points = e;for (var i = [0], n = 0, a = 1; a < e.length; a++) {
					var o = e[a - 1],
					    r = e[a];n += s.dist(o, r), i.push(n);
				}if (0 !== n) {
					for (var a = 0; a < i.length; a++) {
						i[a] /= n;
					}this._offsets = i, this._length = n;
				}
			}, l.getLineLength = function (t) {
				return this._length;
			}, l.updateSymbolPosition = function (t) {
				var e = t.__t,
				    i = this._points,
				    n = this._offsets,
				    a = i.length;if (n) {
					var o,
					    r = this._lastFrame;if (e < this._lastFramePercent) {
						var l = Math.min(r + 1, a - 1);for (o = l; o >= 0 && !(n[o] <= e); o--) {}o = Math.min(o, a - 2);
					} else {
						for (var o = r; o < a && !(n[o] > e); o++) {}o = Math.min(o - 1, a - 2);
					}s.lerp(t.position, i[o], i[o + 1], (e - n[o]) / (n[o + 1] - n[o]));var u = i[o + 1][0] - i[o][0],
					    c = i[o + 1][1] - i[o][1];t.rotation = -Math.atan2(c, u) - Math.PI / 2, this._lastFrame = o, this._lastFramePercent = e, t.ignore = !1;
				}
			}, o.inherits(n, r), t.exports = n;
		}, function (t, e, i) {
			function n(t) {
				return r.isArray(t) || (t = [+t, +t]), t;
			}function a(t, e) {
				t.eachChild(function (t) {
					t.attr({ z: e.z, zlevel: e.zlevel, style: { stroke: "stroke" === e.brushType ? e.color : null, fill: "fill" === e.brushType ? e.color : null } });
				});
			}function o(t, e) {
				h.call(this);var i = new c(t, e),
				    n = new h();this.add(i), this.add(n), n.beforeUpdate = function () {
					this.attr(i.getScale());
				}, this.updateData(t, e);
			}var r = i(1),
			    s = i(24),
			    l = i(3),
			    u = i(4),
			    c = i(54),
			    h = l.Group,
			    d = 3,
			    f = o.prototype;f.stopEffectAnimation = function () {
				this.childAt(1).removeAll();
			}, f.startEffectAnimation = function (t) {
				for (var e = t.symbolType, i = t.color, n = this.childAt(1), o = 0; o < d; o++) {
					var r = s.createSymbol(e, -1, -1, 2, 2, i);r.attr({ style: { strokeNoScale: !0 }, z2: 99, silent: !0, scale: [.5, .5] });var l = -o / d * t.period + t.effectOffset;r.animate("", !0).when(t.period, { scale: [t.rippleScale / 2, t.rippleScale / 2] }).delay(l).start(), r.animateStyle(!0).when(t.period, { opacity: 0 }).delay(l).start(), n.add(r);
				}a(n, t);
			}, f.updateEffectAnimation = function (t) {
				for (var e = this._effectCfg, i = this.childAt(1), n = ["symbolType", "period", "rippleScale"], o = 0; o < n; o++) {
					var r = n[o];if (e[r] !== t[r]) return this.stopEffectAnimation(), void this.startEffectAnimation(t);
				}a(i, t);
			}, f.highlight = function () {
				this.trigger("emphasis");
			}, f.downplay = function () {
				this.trigger("normal");
			}, f.updateData = function (t, e) {
				var i = t.hostModel;this.childAt(0).updateData(t, e);var a = this.childAt(1),
				    o = t.getItemModel(e),
				    r = t.getItemVisual(e, "symbol"),
				    s = n(t.getItemVisual(e, "symbolSize")),
				    l = t.getItemVisual(e, "color");a.attr("scale", s), a.traverse(function (t) {
					t.attr({ fill: l });
				});var c = o.getShallow("symbolOffset");if (c) {
					var h = a.position;h[0] = u.parsePercent(c[0], s[0]), h[1] = u.parsePercent(c[1], s[1]);
				}a.rotation = (o.getShallow("symbolRotate") || 0) * Math.PI / 180 || 0;var d = {};if (d.showEffectOn = i.get("showEffectOn"), d.rippleScale = o.get("rippleEffect.scale"), d.brushType = o.get("rippleEffect.brushType"), d.period = 1e3 * o.get("rippleEffect.period"), d.effectOffset = e / t.count(), d.z = o.getShallow("z") || 0, d.zlevel = o.getShallow("zlevel") || 0, d.symbolType = r, d.color = l, this.off("mouseover").off("mouseout").off("emphasis").off("normal"), "render" === d.showEffectOn) this._effectCfg ? this.updateEffectAnimation(d) : this.startEffectAnimation(d), this._effectCfg = d;else {
					this._effectCfg = null, this.stopEffectAnimation();var f = this.childAt(0),
					    p = function p() {
						f.trigger("emphasis"), "render" !== d.showEffectOn && this.startEffectAnimation(d);
					},
					    g = function g() {
						f.trigger("normal"), "render" !== d.showEffectOn && this.stopEffectAnimation();
					};this.on("mouseover", p, this).on("mouseout", g, this).on("emphasis", p, this).on("normal", g, this);
				}this._effectCfg = d;
			}, f.fadeOut = function (t) {
				this.off("mouseover").off("mouseout").off("emphasis").off("normal"), t && t();
			}, r.inherits(o, h), t.exports = o;
		}, function (t, e, i) {
			function n() {
				this.group = new a.Group(), this._lineEl = new s();
			}var a = i(3),
			    o = i(98),
			    r = i(97),
			    s = a.extendShape({ shape: { polyline: !1, segs: [] }, buildPath: function buildPath(t, e) {
					for (var i = e.segs, n = e.polyline, a = 0; a < i.length; a++) {
						var o = i[a];if (n) {
							t.moveTo(o[0][0], o[0][1]);for (var r = 1; r < o.length; r++) {
								t.lineTo(o[r][0], o[r][1]);
							}
						} else t.moveTo(o[0][0], o[0][1]), o.length > 2 ? t.quadraticCurveTo(o[2][0], o[2][1], o[1][0], o[1][1]) : t.lineTo(o[1][0], o[1][1]);
					}
				}, findDataIndex: function findDataIndex(t, e) {
					for (var i = this.shape, n = i.segs, a = i.polyline, s = Math.max(this.style.lineWidth, 1), l = 0; l < n.length; l++) {
						var u = n[l];if (a) {
							for (var c = 1; c < u.length; c++) {
								if (r.containStroke(u[c - 1][0], u[c - 1][1], u[c][0], u[c][1], s, t, e)) return l;
							}
						} else if (u.length > 2) {
							if (o.containStroke(u[0][0], u[0][1], u[2][0], u[2][1], u[1][0], u[1][1], s, t, e)) return l;
						} else if (r.containStroke(u[0][0], u[0][1], u[1][0], u[1][1], s, t, e)) return l;
					}return -1;
				} }),
			    l = n.prototype;l.updateData = function (t) {
				this.group.removeAll();var e = this._lineEl,
				    i = t.hostModel;e.setShape({ segs: t.mapArray(t.getItemLayout), polyline: i.get("polyline") }), e.useStyle(i.getModel("lineStyle.normal").getLineStyle());var n = t.getVisual("color");n && e.setStyle("stroke", n), e.setStyle("fill"), e.seriesIndex = i.seriesIndex, e.on("mousemove", function (t) {
					e.dataIndex = null;var i = e.findDataIndex(t.offsetX, t.offsetY);i > 0 && (e.dataIndex = i);
				}), this.group.add(e);
			}, l.updateLayout = function (t) {
				var e = t.getData();this._lineEl.setShape({ segs: e.mapArray(e.getItemLayout) });
			}, l.remove = function () {
				this.group.removeAll();
			}, t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i, n) {
				l.Group.call(this), this.bodyIndex, this.whiskerIndex, this.styleUpdater = i, this._createContent(t, e, n), this.updateData(t, e, n), this._seriesModel;
			}function a(t, e, i) {
				return s.map(t, function (t) {
					return t = t.slice(), t[e] = i.initBaseline, t;
				});
			}function o(t) {
				var e = {};return s.each(t, function (t, i) {
					e["ends" + i] = t;
				}), e;
			}function r(t) {
				this.group = new l.Group(), this.styleUpdater = t;
			}var s = i(1),
			    l = i(3),
			    u = i(8),
			    c = u.extend({ type: "whiskerInBox", shape: {}, buildPath: function buildPath(t, e) {
					for (var i in e) {
						if (e.hasOwnProperty(i) && 0 === i.indexOf("ends")) {
							var n = e[i];t.moveTo(n[0][0], n[0][1]), t.lineTo(n[1][0], n[1][1]);
						}
					}
				} }),
			    h = n.prototype;h._createContent = function (t, e, i) {
				var n = t.getItemLayout(e),
				    r = "horizontal" === n.chartLayout ? 1 : 0,
				    u = 0;this.add(new l.Polygon({ shape: { points: i ? a(n.bodyEnds, r, n) : n.bodyEnds }, style: { strokeNoScale: !0 }, z2: 100 })), this.bodyIndex = u++;var h = s.map(n.whiskerEnds, function (t) {
					return i ? a(t, r, n) : t;
				});this.add(new c({ shape: o(h), style: { strokeNoScale: !0 }, z2: 100 })), this.whiskerIndex = u++;
			}, h.updateData = function (t, e, i) {
				var n = this._seriesModel = t.hostModel,
				    a = t.getItemLayout(e),
				    r = l[i ? "initProps" : "updateProps"];r(this.childAt(this.bodyIndex), { shape: { points: a.bodyEnds } }, n, e), r(this.childAt(this.whiskerIndex), { shape: o(a.whiskerEnds) }, n, e), this.styleUpdater.call(null, this, t, e);
			}, s.inherits(n, l.Group);var d = r.prototype;d.updateData = function (t) {
				var e = this.group,
				    i = this._data,
				    a = this.styleUpdater;t.diff(i).add(function (i) {
					if (t.hasValue(i)) {
						var o = new n(t, i, a, !0);t.setItemGraphicEl(i, o), e.add(o);
					}
				}).update(function (o, r) {
					var s = i.getItemGraphicEl(r);return t.hasValue(o) ? (s ? s.updateData(t, o) : s = new n(t, o, a), e.add(s), void t.setItemGraphicEl(o, s)) : void e.remove(s);
				}).remove(function (t) {
					var n = i.getItemGraphicEl(t);n && e.remove(n);
				}).execute(), this._data = t;
			}, d.remove = function () {
				var t = this.group,
				    e = this._data;this._data = null, e && e.eachItemGraphicEl(function (e) {
					e && t.remove(e);
				});
			}, t.exports = r;
		}, function (t, e, i) {
			i(315), i(316);var n = i(2);n.registerLayout(i(317)), n.registerVisual(i(318));
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				var e = t.data;e && e[0] && e[0][0] && e[0][0].coord && (t.data = r.map(e, function (t) {
					var e = [t[0].coord, t[1].coord],
					    i = { coords: e };return t[0].name && (i.fromName = t[0].name), t[1].name && (i.toName = t[1].name), r.mergeAll([i, t[0], t[1]]);
				}));
			}var a = i(17),
			    o = i(14),
			    r = i(1),
			    s = i(7),
			    l = (i(26), a.extend({ type: "series.lines", dependencies: ["grid", "polar"], visualColorAccessPath: "lineStyle.normal.color", init: function init(t) {
					n(t), l.superApply(this, "init", arguments);
				}, mergeOption: function mergeOption(t) {
					n(t), l.superApply(this, "mergeOption", arguments);
				}, getInitialData: function getInitialData(t, e) {
					var i = new o(["value"], this);return i.hasItemOption = !1, i.initData(t.data, [], function (t, e, n, a) {
						if (t instanceof Array) return NaN;i.hasItemOption = !0;var o = t.value;return null != o ? o instanceof Array ? o[a] : o : void 0;
					}), i;
				}, formatTooltip: function formatTooltip(t) {
					var e = this.getData(),
					    i = e.getItemModel(t),
					    n = i.get("name");if (n) return n;var a = i.get("fromName"),
					    o = i.get("toName"),
					    r = [];return null != a && r.push(a), null != o && r.push(o), s.encodeHTML(r.join(" > "));
				}, defaultOption: { coordinateSystem: "geo", zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, xAxisIndex: 0, yAxisIndex: 0, symbol: ["none", "none"], symbolSize: [10, 10], geoIndex: 0, effect: { show: !1, period: 4, constantSpeed: 0, symbol: "circle", symbolSize: 3, loop: !0, trailLength: .2 }, large: !1, largeThreshold: 2e3, polyline: !1, label: { normal: { show: !1, position: "end" } }, lineStyle: { normal: { opacity: .5 } } } }));
		}, function (t, e, i) {
			var n = i(107),
			    a = i(245),
			    o = i(106),
			    r = i(246),
			    s = i(310),
			    l = i(312);i(2).extendChartView({ type: "lines", init: function init() {}, render: function render(t, e, i) {
					var u = t.getData(),
					    c = this._lineDraw,
					    h = t.get("effect.show"),
					    d = t.get("polyline"),
					    f = t.get("large") && u.count() >= t.get("largeThreshold");h === this._hasEffet && d === this._isPolyline && f === this._isLarge || (c && c.remove(), c = this._lineDraw = f ? new l() : new n(d ? h ? s : r : h ? a : o), this._hasEffet = h, this._isPolyline = d, this._isLarge = f);var p = t.get("zlevel"),
					    g = t.get("effect.trailLength"),
					    m = i.getZr();if (m.painter.getLayer(p).clear(!0), null != this._lastZlevel && m.configLayer(this._lastZlevel, { motionBlur: !1 }), h && g) {
						m.configLayer(p, { motionBlur: !0, lastFrameAlpha: Math.max(Math.min(g / 10 + .9, 1), 0) });
					}this.group.add(c.group), c.updateData(u), this._lastZlevel = p;
				}, updateLayout: function updateLayout(t, e, i) {
					this._lineDraw.updateLayout(t);var n = i.getZr();n.painter.getLayer(this._lastZlevel).clear(!0);
				}, remove: function remove(t, e) {
					this._lineDraw && this._lineDraw.remove(e, !0);
				}, dispose: function dispose() {} });
		}, function (t, e, i) {
			t.exports = function (t) {
				t.eachSeriesByType("lines", function (t) {
					var e = t.coordinateSystem,
					    i = t.getData();i.each(function (n) {
						var a = i.getItemModel(n),
						    o = a.option instanceof Array ? a.option : a.get("coords"),
						    r = [];if (t.get("polyline")) for (var s = 0; s < o.length; s++) {
							r.push(e.dataToPoint(o[s]));
						} else {
							r[0] = e.dataToPoint(o[0]), r[1] = e.dataToPoint(o[1]);var l = a.get("lineStyle.normal.curveness");+l && (r[2] = [(r[0][0] + r[1][0]) / 2 - (r[0][1] - r[1][1]) * l, (r[0][1] + r[1][1]) / 2 - (r[1][0] - r[0][0]) * l]);
						}i.setItemLayout(n, r);
					});
				});
			};
		}, function (t, e) {
			function i(t) {
				return t instanceof Array || (t = [t, t]), t;
			}t.exports = function (t) {
				t.eachSeriesByType("lines", function (t) {
					var e = t.getData(),
					    n = i(t.get("symbol")),
					    a = i(t.get("symbolSize")),
					    o = "lineStyle.normal.opacity".split(".");e.setVisual("fromSymbol", n && n[0]), e.setVisual("toSymbol", n && n[1]), e.setVisual("fromSymbolSize", a && a[0]), e.setVisual("toSymbolSize", a && a[1]), e.setVisual("opacity", t.get(o)), e.each(function (t) {
						var n = e.getItemModel(t),
						    a = i(n.getShallow("symbol", !0)),
						    r = i(n.getShallow("symbolSize", !0)),
						    s = n.get(o);a[0] && e.setItemVisual(t, "fromSymbol", a[0]), a[1] && e.setItemVisual(t, "toSymbol", a[1]), r[0] && e.setItemVisual(t, "fromSymbolSize", r[0]), r[1] && e.setItemVisual(t, "toSymbolSize", r[1]), e.setItemVisual(t, "opacity", s);
					});
				});
			};
		}, function (t, e, i) {
			var n = i(2),
			    a = n.PRIORITY;i(320), i(321), i(240), i(186), n.registerLayout(i(324)), n.registerVisual(i(325)), n.registerProcessor(a.PROCESSOR.STATISTIC, i(323)), n.registerPreprocessor(i(322)), i(89)("map", [{ type: "mapToggleSelect", event: "mapselectchanged", method: "toggleSelected" }, { type: "mapSelect", event: "mapselected", method: "select" }, { type: "mapUnSelect", event: "mapunselected", method: "unSelect" }]);
		}, function (t, e, i) {
			var n = i(14),
			    a = i(17),
			    o = i(1),
			    r = i(25),
			    s = i(7),
			    l = s.encodeHTML,
			    u = s.addCommas,
			    c = i(78),
			    h = i(186),
			    d = a.extend({ type: "series.map", dependencies: ["geo"], layoutMode: "box", needsDrawMap: !1, seriesGroup: [], init: function init(t) {
					t = this._fillOption(t, this.getMapType()), this.option = t, d.superApply(this, "init", arguments), this.updateSelectedMap(t.data);
				}, getInitialData: function getInitialData(t) {
					var e = r(["value"], t.data || []),
					    i = new n(e, this);return i.initData(t.data), i;
				}, mergeOption: function mergeOption(t) {
					t.data && (t = this._fillOption(t, this.getMapType())), d.superCall(this, "mergeOption", t), this.updateSelectedMap(this.option.data);
				}, getHostGeoModel: function getHostGeoModel() {
					var t = this.option.geoIndex;return null != t ? this.dependentModels.geo[t] : null;
				}, getMapType: function getMapType() {
					return (this.getHostGeoModel() || this).option.map;
				}, _fillOption: function _fillOption(t, e) {
					return t = o.extend({}, t), t.data = h.getFilledRegions(t.data, e), t;
				}, getRawValue: function getRawValue(t) {
					return this.getData().get("value", t);
				}, getRegionModel: function getRegionModel(t) {
					var e = this.getData();return e.getItemModel(e.indexOfName(t));
				}, formatTooltip: function formatTooltip(t) {
					for (var e = this.getData(), i = u(this.getRawValue(t)), n = e.getName(t), a = this.seriesGroup, o = [], r = 0; r < a.length; r++) {
						var s = a[r].originalData.indexOfName(n);isNaN(a[r].originalData.get("value", s)) || o.push(l(a[r].name));
					}return o.join(", ") + "<br />" + l(n + " : " + i);
				}, getTooltipPosition: function getTooltipPosition(t) {
					if (null != t) {
						var e = this.getData().getName(t),
						    i = this.coordinateSystem,
						    n = i.getRegion(e);return n && i.dataToPoint(n.center);
					}
				}, setZoom: function setZoom(t) {
					this.option.zoom = t;
				}, setCenter: function setCenter(t) {
					this.option.center = t;
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "geo", map: "", left: "center", top: "center", aspectScale: .75, showLegendSymbol: !0, dataRangeHoverLink: !0, boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { normal: { show: !1, textStyle: { color: "#000" } }, emphasis: { show: !0, textStyle: { color: "rgb(100,0,0)" } } }, itemStyle: { normal: { borderWidth: .5, borderColor: "#444", areaColor: "#eee" }, emphasis: { areaColor: "rgba(255,215,0,0.8)" } } } });o.mixin(d, c), t.exports = d;
		}, function (t, e, i) {
			var n = i(3),
			    a = i(249);i(2).extendChartView({ type: "map", render: function render(t, e, i, n) {
					if (!n || "mapToggleSelect" !== n.type || n.from !== this.uid) {
						var o = this.group;if (o.removeAll(), !t.getHostGeoModel()) {
							if (n && "geoRoam" === n.type && "series" === n.componentType && n.seriesId === t.id) {
								var r = this._mapDraw;r && o.add(r.group);
							} else if (t.needsDrawMap) {
								var r = this._mapDraw || new a(i, !0);o.add(r.group), r.draw(t, e, i, this, n), this._mapDraw = r;
							} else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;t.get("showLegendSymbol") && e.getComponent("legend") && this._renderSymbols(t, e, i);
						}
					}
				}, remove: function remove() {
					this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
				}, dispose: function dispose() {
					this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
				}, _renderSymbols: function _renderSymbols(t, e, i) {
					var a = t.originalData,
					    o = this.group;a.each("value", function (e, i) {
						if (!isNaN(e)) {
							var r = a.getItemLayout(i);if (r && r.point) {
								var s = r.point,
								    l = r.offset,
								    u = new n.Circle({ style: { fill: t.getData().getVisual("color") }, shape: { cx: s[0] + 9 * l, cy: s[1], r: 3 }, silent: !0, z2: 10 });if (!l) {
									var c = t.mainSeries.getData(),
									    h = a.getName(i),
									    d = h,
									    f = c.indexOfName(h),
									    p = a.getItemModel(i),
									    g = p.getModel("label.normal"),
									    m = p.getModel("label.emphasis"),
									    v = g.getModel("textStyle"),
									    y = m.getModel("textStyle"),
									    x = c.getItemGraphicEl(f);u.setStyle({ textPosition: "bottom" });var _ = function _() {
										u.setStyle({ text: m.get("show") ? d : "", textFill: y.getTextColor(), textFont: y.getFont() });
									},
									    b = function b() {
										u.setStyle({ text: g.get("show") ? d : "", textFill: v.getTextColor(), textFont: v.getFont() });
									};x.on("mouseover", _).on("mouseout", b).on("emphasis", _).on("normal", b), b();
								}o.add(u);
							}
						}
					});
				} });
		}, function (t, e, i) {
			var n = i(1);t.exports = function (t) {
				var e = [];n.each(t.series, function (t) {
					"map" === t.type && e.push(t);
				}), n.each(e, function (t) {
					t.map = t.map || t.mapType, n.defaults(t, t.mapLocation);
				});
			};
		}, function (t, e, i) {
			function n(t, e) {
				var i = {},
				    n = ["value"];return a.each(t, function (t) {
					t.each(n, function (e, n) {
						var a = "ec-" + t.getName(n);i[a] = i[a] || [], isNaN(e) || i[a].push(e);
					});
				}), t[0].map(n, function (n, a) {
					for (var o = "ec-" + t[0].getName(a), r = 0, s = 1 / 0, l = -(1 / 0), u = i[o].length, c = 0; c < u; c++) {
						s = Math.min(s, i[o][c]), l = Math.max(l, i[o][c]), r += i[o][c];
					}var h;return h = "min" === e ? s : "max" === e ? l : "average" === e ? r / u : r, 0 === u ? NaN : h;
				});
			}var a = i(1);t.exports = function (t) {
				var e = {};t.eachSeriesByType("map", function (t) {
					var i = t.getHostGeoModel(),
					    n = i ? "o" + i.id : "i" + t.getMapType();(e[n] = e[n] || []).push(t);
				}), a.each(e, function (t, e) {
					for (var i = n(a.map(t, function (t) {
						return t.getData();
					}), t[0].get("mapValueCalculation")), o = 0; o < t.length; o++) {
						t[o].originalData = t[o].getData();
					}for (var o = 0; o < t.length; o++) {
						t[o].seriesGroup = t, t[o].needsDrawMap = 0 === o && !t[o].getHostGeoModel(), t[o].setData(i.cloneShallow()), t[o].mainSeries = t[0];
					}
				});
			};
		}, function (t, e, i) {
			var n = i(1);t.exports = function (t) {
				var e = {};t.eachSeriesByType("map", function (i) {
					var a = i.getMapType();if (!i.getHostGeoModel() && !e[a]) {
						var o = {};n.each(i.seriesGroup, function (e) {
							var i = e.coordinateSystem,
							    n = e.originalData;e.get("showLegendSymbol") && t.getComponent("legend") && n.each("value", function (t, e) {
								var a = n.getName(e),
								    r = i.getRegion(a);if (r && !isNaN(t)) {
									var s = o[a] || 0,
									    l = i.dataToPoint(r.center);o[a] = s + 1, n.setItemLayout(e, { point: l, offset: s });
								}
							});
						});var r = i.getData();r.each(function (t) {
							var e = r.getName(t),
							    i = r.getItemLayout(t) || {};i.showLabel = !o[e], r.setItemLayout(t, i);
						}), e[a] = !0;
					}
				});
			};
		}, function (t, e) {
			t.exports = function (t) {
				t.eachSeriesByType("map", function (t) {
					var e = t.get("color"),
					    i = t.getModel("itemStyle.normal"),
					    n = i.get("areaColor"),
					    a = i.get("color") || e[t.seriesIndex % e.length];t.getData().setVisual({ areaColor: n, color: a });
				});
			};
		}, function (t, e, i) {
			var n = i(2);i(251), i(327), i(328), n.registerVisual(i(329));
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = t.get("data"),
				    o = a(e);n && n.length && s.each(i, function (t) {
					if (t) {
						var e = s.indexOf(n, t[o]);t[o] = e >= 0 ? e : NaN;
					}
				});
			}function a(t) {
				return +t.replace("dim", "");
			}function o(t, e) {
				var i = 0;s.each(t, function (t) {
					var e = a(t);e > i && (i = e);
				});var n = e[0];n && n.length - 1 > i && (i = n.length - 1);for (var o = [], r = 0; r <= i; r++) {
					o.push("dim" + r);
				}return o;
			}var r = i(14),
			    s = i(1),
			    l = i(17),
			    u = i(25);t.exports = l.extend({ type: "series.parallel", dependencies: ["parallel"], visualColorAccessPath: "lineStyle.normal.color", getInitialData: function getInitialData(t, e) {
					var i = e.getComponent("parallel", this.get("parallelIndex")),
					    a = i.parallelAxisIndex,
					    l = t.data,
					    c = i.dimensions,
					    h = o(c, l),
					    d = s.map(h, function (t, i) {
						var o = s.indexOf(c, t),
						    r = o >= 0 && e.getComponent("parallelAxis", a[o]);return r && "category" === r.get("type") ? (n(r, t, l), { name: t, type: "ordinal" }) : o < 0 && u.guessOrdinal(l, i) ? { name: t, type: "ordinal" } : t;
					}),
					    f = new r(d, this);return f.initData(l), this.option.progressive && (this.option.animation = !1), f;
				}, getRawIndicesByActiveState: function getRawIndicesByActiveState(t) {
					var e = this.coordinateSystem,
					    i = this.getData(),
					    n = [];return e.eachActiveState(i, function (e, a) {
						t === e && n.push(i.getRawIndex(a));
					}), n;
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "parallel", parallelIndex: 0, label: { normal: { show: !1 }, emphasis: { show: !1 } }, inactiveOpacity: .05, activeOpacity: 1, lineStyle: { normal: { width: 1, opacity: .45, type: "solid" } }, progressive: !1, smooth: !1, animationEasing: "linear" } });
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = t.model,
				    a = t.getRect(),
				    o = new l.Rect({ shape: { x: a.x, y: a.y, width: a.width, height: a.height } }),
				    r = "horizontal" === n.get("layout") ? "width" : "height";return o.setShape(r, 0), l.initProps(o, { shape: { width: a.width, height: a.height } }, e, i), o;
			}function a(t, e, i, n) {
				for (var a = [], o = 0; o < i.length; o++) {
					var r = i[o],
					    l = t.get(r, e);s(l, n.getAxis(r).type) || a.push(n.dataToPoint(l, r));
				}return a;
			}function o(t, e, i, n, o) {
				var r = a(t, i, n, o),
				    s = new l.Polyline({ shape: { points: r }, silent: !0, z2: 10 });e.add(s), t.setItemGraphicEl(i, s);
			}function r(t, e) {
				var i = t.hostModel.getModel("lineStyle.normal"),
				    n = i.getLineStyle();t.eachItemGraphicEl(function (a, o) {
					if (t.hasItemOption) {
						var r = t.getItemModel(o),
						    s = r.getModel("lineStyle.normal", i);n = s.getLineStyle(["color", "stroke"]);
					}a.useStyle(u.extend(n, { fill: null, stroke: t.getItemVisual(o, "color"), opacity: t.getItemVisual(o, "opacity") })), a.shape.smooth = e;
				});
			}function s(t, e) {
				return "category" === e ? null == t : null == t || isNaN(t);
			}var l = i(3),
			    u = i(1),
			    c = .3,
			    h = i(30).extend({ type: "parallel", init: function init() {
					this._dataGroup = new l.Group(), this.group.add(this._dataGroup), this._data;
				}, render: function render(t, e, i, n) {
					this._renderForNormal(t, n);
				}, dispose: function dispose() {}, _renderForNormal: function _renderForNormal(t, e) {
					function i(t) {
						o(d, h, t, g, p, null, v);
					}function s(i, n) {
						var o = f.getItemGraphicEl(n),
						    r = a(d, i, g, p);d.setItemGraphicEl(i, o);var s = e && e.animation === !1 ? null : t;l.updateProps(o, { shape: { points: r } }, s, i);
					}function u(t) {
						var e = f.getItemGraphicEl(t);h.remove(e);
					}var h = this._dataGroup,
					    d = t.getData(),
					    f = this._data,
					    p = t.coordinateSystem,
					    g = p.dimensions,
					    m = t.option,
					    v = m.smooth ? c : null;if (d.diff(f).add(i).update(s).remove(u).execute(), r(d, v), !this._data) {
						var y = n(p, t, function () {
							setTimeout(function () {
								h.removeClipPath();
							});
						});h.setClipPath(y);
					}this._data = d;
				}, remove: function remove() {
					this._dataGroup && this._dataGroup.removeAll(), this._data = null;
				} });t.exports = h;
		}, function (t, e) {
			var i = ["lineStyle", "normal", "opacity"];t.exports = function (t) {
				t.eachSeriesByType("parallel", function (e) {
					var n = e.getModel("itemStyle.normal"),
					    a = e.getModel("lineStyle.normal"),
					    o = t.get("color"),
					    r = a.get("color") || n.get("color") || o[e.seriesIndex % o.length],
					    s = e.get("inactiveOpacity"),
					    l = e.get("activeOpacity"),
					    u = e.getModel("lineStyle.normal").getLineStyle(),
					    c = e.coordinateSystem,
					    h = e.getData(),
					    d = { normal: u.opacity, active: l, inactive: s };c.eachActiveState(h, function (t, e) {
						var n = h.getItemModel(e),
						    a = d[t];if ("normal" === t) {
							var o = n.get(i, !0);null != o && (a = o);
						}h.setItemVisual(e, "opacity", a);
					}), h.setVisual("color", r);
				});
			};
		}, function (t, e, i) {
			var n = i(1);i(57), i(268), i(269);var a = i(82),
			    o = i(2);o.registerLayout(n.curry(a, "pictorialBar")), o.registerVisual(n.curry(i(50), "pictorialBar", "roundRect", null)), i(32);
		}, function (t, e, i) {
			var n = i(1),
			    a = i(2);i(374), i(332), i(333), a.registerVisual(n.curry(i(84), "radar")), a.registerVisual(n.curry(i(50), "radar", "circle", null)), a.registerLayout(i(335)), a.registerProcessor(n.curry(i(63), "radar")), a.registerPreprocessor(i(334));
		}, function (t, e, i) {
			"use strict";
			var n = i(17),
			    a = i(14),
			    o = i(25),
			    r = i(1),
			    s = i(7).encodeHTML,
			    l = n.extend({ type: "series.radar", dependencies: ["radar"], init: function init(t) {
					l.superApply(this, "init", arguments), this.legendDataProvider = function () {
						return this.getRawData();
					};
				}, getInitialData: function getInitialData(t, e) {
					var i = t.data || [],
					    n = o([], i, { extraPrefix: "indicator_", extraFromZero: !0 }),
					    r = new a(n, this);return r.initData(i), r;
				}, formatTooltip: function formatTooltip(t) {
					var e = this.getRawValue(t),
					    i = this.coordinateSystem,
					    n = i.getIndicatorAxes(),
					    a = this.getData().getName(t);return s("" === a ? this.name : a) + "<br/>" + r.map(n, function (t, i) {
						return s(t.name + " : " + e[i]);
					}).join("<br />");
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "radar", legendHoverLink: !0, radarIndex: 0, lineStyle: { normal: { width: 2, type: "solid" } }, label: { normal: { position: "top" } }, symbol: "emptyCircle", symbolSize: 4 } });t.exports = l;
		}, function (t, e, i) {
			function n(t) {
				return o.isArray(t) || (t = [+t, +t]), t;
			}var a = i(3),
			    o = i(1),
			    r = i(24);t.exports = i(2).extendChartView({ type: "radar", render: function render(t, e, i) {
					function s(t, e) {
						var i = t.getItemVisual(e, "symbol") || "circle",
						    a = t.getItemVisual(e, "color");if ("none" !== i) {
							var o = r.createSymbol(i, -.5, -.5, 1, 1, a);return o.attr({ style: { strokeNoScale: !0 }, z2: 100, scale: n(t.getItemVisual(e, "symbolSize")) }), o;
						}
					}function l(e, i, n, o, r, l) {
						n.removeAll();for (var u = 0; u < i.length - 1; u++) {
							var c = s(o, r);c && (c.__dimIdx = u, e[u] ? (c.attr("position", e[u]), a[l ? "initProps" : "updateProps"](c, { position: i[u] }, t, r)) : c.attr("position", i[u]), n.add(c));
						}
					}function u(t) {
						return o.map(t, function (t) {
							return [c.cx, c.cy];
						});
					}var c = t.coordinateSystem,
					    h = this.group,
					    d = t.getData(),
					    f = this._data;d.diff(f).add(function (e) {
						var i = d.getItemLayout(e);if (i) {
							var n = new a.Polygon(),
							    o = new a.Polyline(),
							    r = { shape: { points: i } };n.shape.points = u(i), o.shape.points = u(i), a.initProps(n, r, t, e), a.initProps(o, r, t, e);var s = new a.Group(),
							    c = new a.Group();s.add(o), s.add(n), s.add(c), l(o.shape.points, i, c, d, e, !0), d.setItemGraphicEl(e, s);
						}
					}).update(function (e, i) {
						var n = f.getItemGraphicEl(i),
						    o = n.childAt(0),
						    r = n.childAt(1),
						    s = n.childAt(2),
						    u = { shape: { points: d.getItemLayout(e) } };u.shape.points && (l(o.shape.points, u.shape.points, s, d, e, !1), a.updateProps(o, u, t), a.updateProps(r, u, t), d.setItemGraphicEl(e, n));
					}).remove(function (t) {
						h.remove(f.getItemGraphicEl(t));
					}).execute(), d.eachItemGraphicEl(function (e, i) {
						function n() {
							u.attr("ignore", v);
						}function r() {
							u.attr("ignore", m);
						}var s = d.getItemModel(i),
						    l = e.childAt(0),
						    u = e.childAt(1),
						    c = e.childAt(2),
						    f = d.getItemVisual(i, "color");h.add(e), l.useStyle(o.defaults(s.getModel("lineStyle.normal").getLineStyle(), { fill: "none", stroke: f })), l.hoverStyle = s.getModel("lineStyle.emphasis").getLineStyle();var p = s.getModel("areaStyle.normal"),
						    g = s.getModel("areaStyle.emphasis"),
						    m = p.isEmpty() && p.parentModel.isEmpty(),
						    v = g.isEmpty() && g.parentModel.isEmpty();v = v && m, u.ignore = m, u.useStyle(o.defaults(p.getAreaStyle(), { fill: f, opacity: .7 })), u.hoverStyle = g.getAreaStyle();var y = s.getModel("itemStyle.normal").getItemStyle(["color"]),
						    x = s.getModel("itemStyle.emphasis").getItemStyle(),
						    _ = s.getModel("label.normal"),
						    b = s.getModel("label.emphasis");c.eachChild(function (e) {
							e.setStyle(y), e.hoverStyle = o.clone(x);var n = d.get(d.dimensions[e.__dimIdx], i);a.setText(e.style, _, f), e.setStyle({ text: _.get("show") ? o.retrieve(t.getFormattedLabel(i, "normal", null, e.__dimIdx), n) : "" }), a.setText(e.hoverStyle, b, f), e.hoverStyle.text = b.get("show") ? o.retrieve(t.getFormattedLabel(i, "emphasis", null, e.__dimIdx), n) : "";
						}), e.off("mouseover").off("mouseout").off("normal").off("emphasis"), e.on("emphasis", n).on("mouseover", n).on("normal", r).on("mouseout", r), a.setHoverStyle(e);
					}), this._data = d;
				}, remove: function remove() {
					this.group.removeAll(), this._data = null;
				}, dispose: function dispose() {} });
		}, function (t, e, i) {
			var n = i(1);t.exports = function (t) {
				var e = t.polar;if (e) {
					n.isArray(e) || (e = [e]);var i = [];n.each(e, function (e, a) {
						e.indicator ? (e.type && !e.shape && (e.shape = e.type), t.radar = t.radar || [], n.isArray(t.radar) || (t.radar = [t.radar]), t.radar.push(e)) : i.push(e);
					}), t.polar = i;
				}n.each(t.series, function (t) {
					"radar" === t.type && t.polarIndex && (t.radarIndex = t.polarIndex);
				});
			};
		}, function (t, e) {
			t.exports = function (t) {
				t.eachSeriesByType("radar", function (t) {
					function e(t, e) {
						n[e] = n[e] || [], n[e][o] = a.dataToPoint(t, o);
					}var i = t.getData(),
					    n = [],
					    a = t.coordinateSystem;if (a) {
						for (var o = 0; o < a.getIndicatorAxes().length; o++) {
							var r = i.dimensions[o];i.each(r, e);
						}i.each(function (t) {
							n[t][0] && n[t].push(n[t][0].slice()), i.setItemLayout(t, n[t]);
						});
					}
				});
			};
		}, function (t, e, i) {
			var n = i(2);i(337), i(338), n.registerLayout(i(339)), n.registerVisual(i(340));
		}, function (t, e, i) {
			var n = i(17),
			    a = i(247),
			    o = i(7).encodeHTML,
			    r = n.extend({ type: "series.sankey", layoutInfo: null, getInitialData: function getInitialData(t) {
					var e = t.edges || t.links,
					    i = t.data || t.nodes;if (i && e) {
						var n = a(i, e, this, !0);return n.data;
					}
				}, getGraph: function getGraph() {
					return this.getData().graph;
				}, getEdgeData: function getEdgeData() {
					return this.getGraph().edgeData;
				}, formatTooltip: function formatTooltip(t, e, i) {
					if ("edge" === i) {
						var n = this.getDataParams(t, i),
						    a = n.data,
						    s = a.source + " -- " + a.target;return n.value && (s += " : " + n.value), o(s);
					}return r.superCall(this, "formatTooltip", t, e);
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "view", layout: null, left: "5%", top: "5%", right: "20%", bottom: "5%", nodeWidth: 20, nodeGap: 8, layoutIterations: 32, label: { normal: { show: !0, position: "right", textStyle: { color: "#000", fontSize: 12 } }, emphasis: { show: !0 } }, itemStyle: { normal: { borderWidth: 1, borderColor: "#333" } }, lineStyle: { normal: { color: "#314656", opacity: .2, curveness: .5 }, emphasis: { opacity: .6 } }, animationEasing: "linear", animationDuration: 1e3 } });t.exports = r;
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = new a.Rect({ shape: { x: t.x - 10, y: t.y - 10, width: 0, height: t.height + 20 } });return a.initProps(n, { shape: { width: t.width + 20, height: t.height + 20 } }, e, i), n;
			}var a = i(3),
			    o = i(1),
			    r = a.extendShape({ shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, cpx2: 0, cpy2: 0, extent: 0 }, buildPath: function buildPath(t, e) {
					var i = e.extent / 2;t.moveTo(e.x1, e.y1 - i), t.bezierCurveTo(e.cpx1, e.cpy1 - i, e.cpx2, e.cpy2 - i, e.x2, e.y2 - i), t.lineTo(e.x2, e.y2 + i), t.bezierCurveTo(e.cpx2, e.cpy2 + i, e.cpx1, e.cpy1 + i, e.x1, e.y1 + i), t.closePath();
				} });t.exports = i(2).extendChartView({ type: "sankey", _model: null, render: function render(t, e, i) {
					var s = t.getGraph(),
					    l = this.group,
					    u = t.layoutInfo,
					    c = t.getData(),
					    h = t.getData("edge");this._model = t, l.removeAll(), l.position = [u.x, u.y], s.eachEdge(function (e) {
						var i = new r();i.dataIndex = e.dataIndex, i.seriesIndex = t.seriesIndex, i.dataType = "edge";var n = e.getModel("lineStyle.normal"),
						    o = n.get("curveness"),
						    s = e.node1.getLayout(),
						    u = e.node2.getLayout(),
						    c = e.getLayout();i.shape.extent = Math.max(1, c.dy);var d = s.x + s.dx,
						    f = s.y + c.sy + c.dy / 2,
						    p = u.x,
						    g = u.y + c.ty + c.dy / 2,
						    m = d * (1 - o) + p * o,
						    v = f,
						    y = d * o + p * (1 - o),
						    x = g;switch (i.setShape({ x1: d, y1: f, x2: p, y2: g, cpx1: m, cpy1: v, cpx2: y, cpy2: x }), i.setStyle(n.getItemStyle()), i.style.fill) {case "source":
								i.style.fill = e.node1.getVisual("color");break;case "target":
								i.style.fill = e.node2.getVisual("color");}a.setHoverStyle(i, e.getModel("lineStyle.emphasis").getItemStyle()), l.add(i), h.setItemGraphicEl(e.dataIndex, i);
					}), s.eachNode(function (e) {
						var i = e.getLayout(),
						    n = e.getModel(),
						    r = n.getModel("label.normal"),
						    s = r.getModel("textStyle"),
						    u = n.getModel("label.emphasis"),
						    h = u.getModel("textStyle"),
						    d = new a.Rect({ shape: { x: i.x, y: i.y, width: e.getLayout().dx, height: e.getLayout().dy }, style: { text: r.get("show") ? t.getFormattedLabel(e.dataIndex, "normal") || e.id : "", textFont: s.getFont(), textFill: s.getTextColor(), textPosition: r.get("position") } });d.setStyle(o.defaults({ fill: e.getVisual("color") }, n.getModel("itemStyle.normal").getItemStyle())), a.setHoverStyle(d, o.extend(e.getModel("itemStyle.emphasis"), { text: u.get("show") ? t.getFormattedLabel(e.dataIndex, "emphasis") || e.id : "", textFont: h.getFont(), textFill: h.getTextColor(), textPosition: u.get("position") })), l.add(d), c.setItemGraphicEl(e.dataIndex, d), d.dataType = "node";
					}), !this._data && t.get("animation") && l.setClipPath(n(l.getBoundingRect(), t, function () {
						l.removeClipPath();
					})), this._data = t.getData();
				}, dispose: function dispose() {} });
		}, function (t, e, i) {
			function n(t, e) {
				return M.getLayoutRect(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() });
			}function a(t, e, i, n, a, o, s) {
				r(t, i, a), u(t, e, o, n, s), m(t);
			}function o(t) {
				T.each(t, function (t) {
					var e = x(t.outEdges, S),
					    i = x(t.inEdges, S),
					    n = Math.max(e, i);t.setLayout({ value: n }, !0);
				});
			}function r(t, e, i) {
				for (var n = t, a = null, o = 0, r = 0; n.length;) {
					a = [];for (var u = 0, c = n.length; u < c; u++) {
						var h = n[u];h.setLayout({ x: o }, !0), h.setLayout({ dx: e }, !0);for (var d = 0, f = h.outEdges.length; d < f; d++) {
							a.push(h.outEdges[d].node2);
						}
					}n = a, ++o;
				}s(t, o), r = (i - e) / (o - 1), l(t, r);
			}function s(t, e) {
				T.each(t, function (t) {
					t.outEdges.length || t.setLayout({ x: e - 1 }, !0);
				});
			}function l(t, e) {
				T.each(t, function (t) {
					var i = t.getLayout().x * e;t.setLayout({ x: i }, !0);
				});
			}function u(t, e, i, n, a) {
				var o = I().key(function (t) {
					return t.getLayout().x;
				}).sortKeys(w).entries(t).map(function (t) {
					return t.values;
				});c(t, o, e, i, n), h(o, n, i);for (var r = 1; a > 0; a--) {
					r *= .99, d(o, r), h(o, n, i), p(o, r), h(o, n, i);
				}
			}function c(t, e, i, n, a) {
				var o = [];T.each(e, function (t) {
					var e = t.length,
					    i = 0;T.each(t, function (t) {
						i += t.getLayout().value;
					});var r = (n - (e - 1) * a) / i;o.push(r);
				}), o.sort(function (t, e) {
					return t - e;
				});var r = o[0];T.each(e, function (t) {
					T.each(t, function (t, e) {
						t.setLayout({ y: e }, !0);var i = t.getLayout().value * r;t.setLayout({ dy: i }, !0);
					});
				}), T.each(i, function (t) {
					var e = +t.getValue() * r;t.setLayout({ dy: e }, !0);
				});
			}function h(t, e, i) {
				T.each(t, function (t) {
					var n,
					    a,
					    o,
					    r = 0,
					    s = t.length;for (t.sort(b), o = 0; o < s; o++) {
						if (n = t[o], a = r - n.getLayout().y, a > 0) {
							var l = n.getLayout().y + a;n.setLayout({ y: l }, !0);
						}r = n.getLayout().y + n.getLayout().dy + e;
					}if (a = r - e - i, a > 0) {
						var l = n.getLayout().y - a;for (n.setLayout({ y: l }, !0), r = n.getLayout().y, o = s - 2; o >= 0; --o) {
							n = t[o], a = n.getLayout().y + n.getLayout().dy + e - r, a > 0 && (l = n.getLayout().y - a, n.setLayout({ y: l }, !0)), r = n.getLayout().y;
						}
					}
				});
			}function d(t, e) {
				T.each(t.slice().reverse(), function (t) {
					T.each(t, function (t) {
						if (t.outEdges.length) {
							var i = x(t.outEdges, f) / x(t.outEdges, S),
							    n = t.getLayout().y + (i - _(t)) * e;t.setLayout({ y: n }, !0);
						}
					});
				});
			}function f(t) {
				return _(t.node2) * t.getValue();
			}function p(t, e) {
				T.each(t, function (t) {
					T.each(t, function (t) {
						if (t.inEdges.length) {
							var i = x(t.inEdges, g) / x(t.inEdges, S),
							    n = t.getLayout().y + (i - _(t)) * e;t.setLayout({ y: n }, !0);
						}
					});
				});
			}function g(t) {
				return _(t.node1) * t.getValue();
			}function m(t) {
				T.each(t, function (t) {
					t.outEdges.sort(v), t.inEdges.sort(y);
				}), T.each(t, function (t) {
					var e = 0,
					    i = 0;T.each(t.outEdges, function (t) {
						t.setLayout({ sy: e }, !0), e += t.getLayout().dy;
					}), T.each(t.inEdges, function (t) {
						t.setLayout({ ty: i }, !0), i += t.getLayout().dy;
					});
				});
			}function v(t, e) {
				return t.node2.getLayout().y - e.node2.getLayout().y;
			}function y(t, e) {
				return t.node1.getLayout().y - e.node1.getLayout().y;
			}function x(t, e) {
				for (var i = 0, n = t.length, a = -1; ++a < n;) {
					var o = +e.call(t, t[a], a);isNaN(o) || (i += o);
				}return i;
			}function _(t) {
				return t.getLayout().y + t.getLayout().dy / 2;
			}function b(t, e) {
				return t.getLayout().y - e.getLayout().y;
			}function w(t, e) {
				return t < e ? -1 : t > e ? 1 : t === e ? 0 : NaN;
			}function S(t) {
				return t.getValue();
			}var M = i(12),
			    I = i(265),
			    T = i(1);t.exports = function (t, e, i) {
				t.eachSeriesByType("sankey", function (t) {
					var i = t.get("nodeWidth"),
					    r = t.get("nodeGap"),
					    s = n(t, e);t.layoutInfo = s;var l = s.width,
					    u = s.height,
					    c = t.getGraph(),
					    h = c.nodes,
					    d = c.edges;o(h);var f = T.filter(h, function (t) {
						return 0 === t.getLayout().value;
					}),
					    p = 0 !== f.length ? 0 : t.get("layoutIterations");a(h, d, i, r, l, u, p);
				});
			};
		}, function (t, e, i) {
			var n = i(83),
			    a = i(1);t.exports = function (t, e) {
				t.eachSeriesByType("sankey", function (t) {
					var e = t.getGraph(),
					    i = e.nodes;i.sort(function (t, e) {
						return t.getLayout().value - e.getLayout().value;
					});var o = i[0].getLayout().value,
					    r = i[i.length - 1].getLayout().value;a.each(i, function (e) {
						var i = new n({ type: "color", mappingMethod: "linear", dataExtent: [o, r], visual: t.get("color") }),
						    a = i.mapValueToVisual(e.getLayout().value);e.setVisual("color", a);var s = e.getModel(),
						    l = s.get("itemStyle.normal.color");null != l && e.setVisual("color", l);
					});
				});
			};
		}, function (t, e, i) {
			var n = i(2),
			    a = i(1);i(252), i(342), i(343), n.registerLayout(i(344)), n.registerVisual(i(345)), n.registerProcessor(a.curry(i(63), "themeRiver"));
		}, function (t, e, i) {
			"use strict";
			var n = i(25),
			    a = i(17),
			    o = i(14),
			    r = i(1),
			    s = i(7),
			    l = s.encodeHTML,
			    u = i(265),
			    c = 2,
			    h = a.extend({ type: "series.themeRiver", dependencies: ["singleAxis"], nameMap: null, init: function init(t) {
					h.superApply(this, "init", arguments), this.legendDataProvider = function () {
						return this.getRawData();
					};
				}, fixData: function fixData(t) {
					for (var e = t.length, i = u().key(function (t) {
						return t[2];
					}).entries(t), n = r.map(i, function (t) {
						return { name: t.key, dataList: t.values };
					}), a = n.length, o = -1, s = -1, l = 0; l < a; ++l) {
						var c = n[l].dataList.length;c > o && (o = c, s = l);
					}for (var h = 0; h < a; ++h) {
						if (h !== s) for (var d = n[h].name, f = 0; f < o; ++f) {
							for (var p = n[s].dataList[f][0], g = n[h].dataList.length, m = -1, v = 0; v < g; ++v) {
								var y = n[h].dataList[v][0];if (y === p) {
									m = v;break;
								}
							}m === -1 && (t[e] = [], t[e][0] = p, t[e][1] = 0, t[e][2] = d, e++);
						}
					}return t;
				}, getInitialData: function getInitialData(t, e) {
					var i = [],
					    a = e.queryComponents({ mainType: "singleAxis", index: this.get("singleAxisIndex"), id: this.get("singleAxisId") })[0],
					    s = a.get("type");i = [{ name: "time", type: "category" === s ? "ordinal" : "time" === s ? "time" : "float" }, { name: "value", type: "float" }, { name: "name", type: "ordinal" }];for (var l = r.filter(t.data, function (t) {
						return void 0 !== t[2];
					}), u = this.fixData(l || []), h = [], d = this.nameMap = r.createHashMap(), f = 0, p = 0; p < u.length; ++p) {
						h.push(u[p][c]), d.get(u[p][c]) || (d.set(u[p][c], f), f++);
					}i = n(i, u);var g = new o(i, this);return g.initData(u, h), g;
				}, coordDimToDataDim: function coordDimToDataDim(t) {
					return ["time"];
				}, getLayerSeries: function getLayerSeries() {
					function t(t, i) {
						return e.get("time", t) - e.get("time", i);
					}for (var e = this.getData(), i = e.count(), n = [], a = 0; a < i; ++a) {
						n[a] = a;
					}for (var o = u().key(function (t) {
						return e.get("name", t);
					}).entries(n), s = r.map(o, function (t) {
						return { name: t.key, indices: t.values };
					}), l = 0; l < s.length; ++l) {
						s[l].indices.sort(t);
					}return s;
				}, getAxisTooltipData: function getAxisTooltipData(t, e, i) {
					r.isArray(t) || (t = t ? [t] : []);for (var n, a = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, u = 0; u < l; ++u) {
						for (var c = Number.MAX_VALUE, h = -1, d = o[u].indices.length, f = 0; f < d; ++f) {
							var p = a.get(t[0], o[u].indices[f]),
							    g = Math.abs(p - e);g <= c && (n = p, c = g, h = o[u].indices[f]);
						}s.push(h);
					}return { dataIndices: s, nestestValue: n };
				}, formatTooltip: function formatTooltip(t) {
					var e = this.getData(),
					    i = e.get("name", t),
					    n = e.get("value", t);return (isNaN(n) || null == n) && (n = "-"), l(i + " : " + n);
				}, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "singleAxis", boundaryGap: ["10%", "10%"], singleAxisIndex: 0, animationEasing: "linear", label: { normal: { margin: 4, textAlign: "right", show: !0, position: "left", textStyle: { color: "#000", fontSize: 11 } }, emphasis: { show: !0 } } } });t.exports = h;
		}, function (t, e, i) {
			(function (e) {
				function n(t, e, i) {
					var n = new o.Rect({ shape: { x: t.x - 10, y: t.y - 10, width: 0, height: t.height + 20 } });return o.initProps(n, { shape: { width: t.width + 20, height: t.height + 20 } }, e, i), n;
				}var a = i(93),
				    o = i(3),
				    r = i(1),
				    s = i(48);t.exports = i(2).extendChartView({ type: "themeRiver", init: function init() {
						this._layers = [];
					}, render: function render(t, e, i) {
						function l(t) {
							return t.name;
						}function u(e, i, s) {
							var l = this._layers;if ("remove" === e) return void d.remove(l[i]);for (var u, p = [], g = [], m = f[i].indices, v = 0; v < m.length; v++) {
								var x = c.getItemLayout(m[v]),
								    _ = x.x,
								    b = x.y0,
								    w = x.y;p.push([_, b]), g.push([_, b + w]), u = h.getItemVisual(m[v], "color");
							}var S,
							    M,
							    I = c.getItemLayout(m[0]),
							    T = c.getItemModel(m[v - 1]),
							    A = T.getModel("label.normal"),
							    C = A.get("margin");if ("add" === e) {
								var L = y[i] = new o.Group();S = new a.Polygon({ shape: { points: p, stackedOnPoints: g, smooth: .4, stackedOnSmooth: .4, smoothConstraint: !1 }, z2: 0 }), M = new o.Text({ style: { x: I.x - C, y: I.y0 + I.y / 2 } }), L.add(S), L.add(M), d.add(L), S.setClipPath(n(S.getBoundingRect(), t, function () {
									S.removeClipPath();
								}));
							} else {
								var L = l[s];S = L.childAt(0), M = L.childAt(1), d.add(L), y[i] = L, o.updateProps(S, { shape: { points: p, stackedOnPoints: g } }, t), o.updateProps(M, { style: { x: I.x - C, y: I.y0 + I.y / 2 } }, t);
							}var D = T.getModel("itemStyle.emphasis"),
							    P = T.getModel("itemStyle.normal"),
							    k = A.getModel("textStyle");M.setStyle({ text: A.get("show") ? t.getFormattedLabel(m[v - 1], "normal") || c.getName(m[v - 1]) : "", textFont: k.getFont(), textAlign: A.get("textAlign"), textVerticalAlign: "middle" }), S.setStyle(r.extend({ fill: u }, P.getItemStyle(["color"]))), o.setHoverStyle(S, D.getItemStyle());
						}var c = t.getData(),
						    h = t.getRawData();if (c.count()) {
							var d = this.group,
							    f = t.getLayerSeries(),
							    p = c.getLayout("layoutInfo"),
							    g = p.rect,
							    m = p.boundaryGap;d.attr("position", [0, g.y + m[0]]);var v = new s(this._layersSeries || [], f, l, l),
							    y = {};v.add(r.bind(r.curry(u, "add"), this)).update(r.bind(r.curry(u, "update"), this)).remove(r.bind(r.curry(u, "remove"), this)).execute(), this._layersSeries = f, this._layers = y;
						}
					}, dispose: function dispose() {} });
			}).call(e, i(188));
		}, function (t, e, i) {
			function n(t, e, i) {
				if (t.count()) for (var n, r = e.coordinateSystem, s = e.getLayerSeries(), l = o.map(s, function (e) {
					return o.map(e.indices, function (e) {
						var i = r.dataToPoint(t.get("time", e));return i[1] = t.get("value", e), i;
					});
				}), u = a(l), c = u.y0, h = i / u.max, d = s.length, f = s[0].indices.length, p = 0; p < f; ++p) {
					n = c[p] * h, t.setItemLayout(s[0].indices[p], { layerIndex: 0, x: l[0][p][0], y0: n, y: l[0][p][1] * h });for (var g = 1; g < d; ++g) {
						n += l[g - 1][p][1] * h, t.setItemLayout(s[g].indices[p], { layerIndex: g, x: l[g][p][0], y0: n, y: l[g][p][1] * h });
					}
				}
			}function a(t) {
				for (var e, i = t.length, n = t[0].length, a = [], o = [], r = 0, s = {}, l = 0; l < n; ++l) {
					for (var u = 0, e = 0; u < i; ++u) {
						e += t[u][l][1];
					}e > r && (r = e), a.push(e);
				}for (var c = 0; c < n; ++c) {
					o[c] = (r - a[c]) / 2;
				}r = 0;for (var h = 0; h < n; ++h) {
					var d = a[h] + o[h];d > r && (r = d);
				}return s.y0 = o, s.max = r, s;
			}var o = i(1),
			    r = i(4);t.exports = function (t, e) {
				t.eachSeriesByType("themeRiver", function (t) {
					var e = t.getData(),
					    i = t.coordinateSystem,
					    a = {},
					    o = i.getRect();a.rect = o;var s = t.get("boundaryGap"),
					    l = i.getAxis();if (a.boundaryGap = s, "horizontal" === l.orient) {
						s[0] = r.parsePercent(s[0], o.height), s[1] = r.parsePercent(s[1], o.height);var u = o.height - s[0] - s[1];n(e, t, u);
					} else {
						s[0] = r.parsePercent(s[0], o.width), s[1] = r.parsePercent(s[1], o.width);var c = o.width - s[0] - s[1];n(e, t, c);
					}e.setLayout("layoutInfo", a);
				});
			};
		}, function (t, e) {
			t.exports = function (t) {
				t.eachSeriesByType("themeRiver", function (t) {
					var e = t.getData(),
					    i = t.getRawData(),
					    n = t.get("color");e.each(function (a) {
						var o = e.getName(a),
						    r = n[(t.nameMap.get(o) - 1) % n.length];i.setItemVisual(a, "color", r);
					});
				});
			};
		}, function (t, e, i) {
			var n = i(2);i(348), i(349), i(350), n.registerVisual(i(352)), n.registerLayout(i(351));
		}, function (t, e, i) {
			function n(t) {
				this.group = new r.Group(), t.add(this.group);
			}function a(t, e, i, n, a, o) {
				var r = [[a ? t : t - d, e], [t + i, e], [t + i, e + n], [a ? t : t - d, e + n]];return !o && r.splice(2, 0, [t + i + d, e + n / 2]), !a && r.push([t, e + n / 2]), r;
			}function o(t, e, i) {
				t.eventData = { componentType: "series", componentSubType: "treemap", seriesIndex: e.componentIndex, seriesName: e.name, seriesType: "treemap", selfType: "breadcrumb", nodeData: { dataIndex: i && i.dataIndex, name: i && i.name }, treePathInfo: i && u.wrapTreePathInfo(i, e) };
			}var r = i(3),
			    s = i(12),
			    l = i(1),
			    u = i(94),
			    c = 8,
			    h = 8,
			    d = 5;n.prototype = { constructor: n, render: function render(t, e, i, n) {
					var a = t.getModel("breadcrumb"),
					    o = this.group;if (o.removeAll(), a.get("show") && i) {
						var r = a.getModel("itemStyle.normal"),
						    l = r.getModel("textStyle"),
						    u = { pos: { left: a.get("left"), right: a.get("right"), top: a.get("top"), bottom: a.get("bottom") }, box: { width: e.getWidth(), height: e.getHeight() }, emptyItemWidth: a.get("emptyItemWidth"), totalWidth: 0, renderList: [] };this._prepare(i, u, l), this._renderContent(t, u, r, l, n), s.positionElement(o, u.pos, u.box);
					}
				}, _prepare: function _prepare(t, e, i) {
					for (var n = t; n; n = n.parentNode) {
						var a = n.getModel().get("name"),
						    o = i.getTextRect(a),
						    r = Math.max(o.width + 2 * c, e.emptyItemWidth);e.totalWidth += r + h, e.renderList.push({ node: n, text: a, width: r });
					}
				}, _renderContent: function _renderContent(t, e, i, n, u) {
					for (var c = 0, d = e.emptyItemWidth, f = t.get("breadcrumb.height"), p = s.getAvailableSize(e.pos, e.box), g = e.totalWidth, m = e.renderList, v = m.length - 1; v >= 0; v--) {
						var y = m[v],
						    x = y.node,
						    _ = y.width,
						    b = y.text;g > p.width && (g -= _ - d, _ = d, b = "");var w = new r.Polygon({ shape: { points: a(c, 0, _, f, v === m.length - 1, 0 === v) }, style: l.defaults(i.getItemStyle(), { lineJoin: "bevel", text: b, textFill: n.getTextColor(), textFont: n.getFont() }), z: 10, onclick: l.curry(u, x) });this.group.add(w), o(w, t, x), c += _ + h;
					}
				}, remove: function remove() {
					this.group.removeAll();
				} }, t.exports = n;
		}, function (t, e, i) {
			function n(t) {
				var e = 0;s.each(t.children, function (t) {
					n(t);var i = t.value;s.isArray(i) && (i = i[0]), e += i;
				});var i = t.value;s.isArray(i) && (i = i[0]), (null == i || isNaN(i)) && (i = e), i < 0 && (i = 0), s.isArray(t.value) ? t.value[0] = i : t.value = i;
			}function a(t, e) {
				var i = e.get("color");if (i) {
					t = t || [];var n;if (s.each(t, function (t) {
						var e = new l(t),
						    i = e.get("color");(e.get("itemStyle.normal.color") || i && "none" !== i) && (n = !0);
					}), !n) {
						var a = t[0] || (t[0] = {});a.color = i.slice();
					}return t;
				}
			}var o = i(17),
			    r = i(424),
			    s = i(1),
			    l = i(10),
			    u = i(7),
			    c = i(94),
			    h = u.encodeHTML,
			    d = u.addCommas;t.exports = o.extend({ type: "series.treemap", layoutMode: "box", dependencies: ["grid", "polar"], _viewRoot: null, defaultOption: { progressive: 0, hoverLayerThreshold: 1 / 0, left: "center", top: "middle", right: null, bottom: null, width: "80%", height: "80%", sort: !0, clipWindow: "origin", squareRatio: .5 * (1 + Math.sqrt(5)), leafDepth: null, drillDownIcon: "", zoomToNodeRatio: .1024, roam: !0, nodeClick: "zoomToNode", animation: !0, animationDurationUpdate: 900, animationEasing: "quinticInOut", breadcrumb: { show: !0, height: 22, left: "center", top: "bottom", emptyItemWidth: 25, itemStyle: { normal: { color: "rgba(0,0,0,0.7)", borderColor: "rgba(255,255,255,0.7)", borderWidth: 1, shadowColor: "rgba(150,150,150,1)", shadowBlur: 3, shadowOffsetX: 0, shadowOffsetY: 0, textStyle: { color: "#fff" } }, emphasis: { textStyle: {} } } }, label: { normal: { show: !0, position: "inside", textStyle: { color: "#fff", ellipsis: !0 } } }, itemStyle: { normal: { color: null, colorAlpha: null, colorSaturation: null, borderWidth: 0, gapWidth: 0, borderColor: "#fff", borderColorSaturation: null }, emphasis: {} }, visualDimension: 0, visualMin: null, visualMax: null, color: [], colorAlpha: null, colorSaturation: null, colorMappingBy: "index", visibleMin: 10, childrenVisibleMin: null, levels: [] }, getInitialData: function getInitialData(t, e) {
					var i = t.name;null == i && (i = t.name);var o = { name: i, children: t.data };n(o);var s = t.levels || [];return s = t.levels = a(s, e), r.createTree(o, this, s).data;
				}, optionUpdated: function optionUpdated() {
					this.resetViewRoot();
				}, formatTooltip: function formatTooltip(t) {
					var e = this.getData(),
					    i = this.getRawValue(t),
					    n = d(s.isArray(i) ? i[0] : i),
					    a = e.getName(t);return h(a + ": " + n);
				}, getDataParams: function getDataParams(t) {
					var e = o.prototype.getDataParams.apply(this, arguments),
					    i = this.getData().tree.getNodeByDataIndex(t);return e.treePathInfo = c.wrapTreePathInfo(i, this), e;
				}, setLayoutInfo: function setLayoutInfo(t) {
					this.layoutInfo = this.layoutInfo || {}, s.extend(this.layoutInfo, t);
				}, mapIdToIndex: function mapIdToIndex(t) {
					var e = this._idIndexMap;e || (e = this._idIndexMap = s.createHashMap(), this._idIndexMapCount = 0);var i = e.get(t);return null == i && e.set(t, i = this._idIndexMapCount++), i;
				}, getViewRoot: function getViewRoot() {
					return this._viewRoot;
				}, resetViewRoot: function resetViewRoot(t) {
					t ? this._viewRoot = t : t = this._viewRoot;var e = this.getData().tree.root;t && (t === e || e.contains(t)) || (this._viewRoot = e);
				} });
		}, function (t, e, i) {
			function n() {
				return { nodeGroup: [], background: [], content: [] };
			}function a(t, e, i, n, a, l, u, c, h, d) {
				function f(e) {
					E.dataIndex = u.dataIndex, E.seriesIndex = t.seriesIndex;var i = T.borderWidth,
					    n = Math.max(A - 2 * i, 0),
					    a = Math.max(C - 2 * i, 0);E.culling = !0, E.setShape({ x: i, y: i, width: n, height: a });var o = u.getVisual("color", !0);p(E, function () {
						var t = { fill: o },
						    e = u.getModel("itemStyle.emphasis").getItemStyle();g(t, e, o, n, a), E.setStyle(t), s.setHoverStyle(E, e);
					}), e.add(E);
				}function p(t, e) {
					L ? !t.invisible && l.push(t) : (e(), t.__tmWillVisible || (t.invisible = !1));
				}function g(e, i, n, a, o) {
					var r = u.getModel(),
					    s = r.get("name");if (T.isLeafRoot) {
						var l = t.get("drillDownIcon", !0);s = l ? l + " " + s : s;
					}y(s, e, r, _, n, a, o), y(s, i, r, b, n, a, o);
				}function y(t, e, i, n, a, o, r) {
					var l = i.getModel(n),
					    u = l.getModel("textStyle");s.setText(e, l, a), e.textAlign = u.get("align"), e.textVerticalAlign = u.get("baseline");var c = u.getTextRect(t);!l.getShallow("show") || c.height > r ? e.text = "" : c.width > o ? e.text = u.get("ellipsis") ? u.truncateText(t, o, null, { minChar: 2 }) : "" : e.text = t;
				}function x(t, n, r, s) {
					var l = null != P && i[t][P],
					    u = a[t];return l ? (i[t][P] = null, w(u, l, t)) : L || (l = new n({ z: o(r, s) }), l.__tmDepth = r, l.__tmStorageName = t, I(u, l, t)), e[t][D] = l;
				}function w(t, e, i) {
					var n = t[D] = {};n.old = "nodeGroup" === i ? e.position.slice() : r.extend({}, e.shape);
				}function I(t, e, i) {
					var o = t[D] = {},
					    r = u.parentNode;if (r && (!n || "drillDown" === n.direction)) {
						var s = 0,
						    l = 0,
						    c = a.background[r.getRawIndex()];!n && c && c.old && (s = c.old.width, l = c.old.height), o.old = "nodeGroup" === i ? [0, l] : { x: s, y: l, width: 0, height: 0 };
					}o.fadein = "nodeGroup" !== i;
				}if (u) {
					var T = u.getLayout();if (T && T.isInView) {
						var A = T.width,
						    C = T.height,
						    L = T.invisible,
						    D = u.getRawIndex(),
						    P = c && c.getRawIndex(),
						    k = x("nodeGroup", m);if (k) {
							if (h.add(k), k.attr("position", [T.x || 0, T.y || 0]), k.__tmNodeWidth = A, k.__tmNodeHeight = C, T.isAboveViewRoot) return k;var O = x("background", v, d, S);O && (O.setShape({ x: 0, y: 0, width: A, height: C }), p(O, function () {
								O.setStyle("fill", u.getVisual("borderColor", !0));
							}), k.add(O));var z = u.viewChildren;if (!z || !z.length) {
								var E = x("content", v, d, M);E && f(k);
							}return k;
						}
					}
				}
			}function o(t, e) {
				var i = t * w + e;return (i - 1) / i;
			}var r = i(1),
			    s = i(3),
			    l = i(48),
			    u = i(94),
			    c = i(347),
			    h = i(95),
			    d = i(11),
			    f = i(19),
			    p = i(426),
			    g = r.bind,
			    m = s.Group,
			    v = s.Rect,
			    y = r.each,
			    x = 3,
			    _ = ["label", "normal"],
			    b = ["label", "emphasis"],
			    w = 10,
			    S = 1,
			    M = 2;t.exports = i(2).extendChartView({ type: "treemap", init: function init(t, e) {
					this._containerGroup, this._storage = n(), this._oldTree, this._breadcrumb, this._controller, this._state = "ready", this._mayClick;
				}, render: function render(t, e, i, n) {
					var a = e.findComponents({ mainType: "series", subType: "treemap", query: n });if (!(r.indexOf(a, t) < 0)) {
						this.seriesModel = t, this.api = i, this.ecModel = e;var o = u.retrieveTargetInfo(n, t),
						    s = n && n.type,
						    l = t.layoutInfo,
						    c = !this._oldTree,
						    h = this._storage,
						    d = "treemapRootToNode" === s && o && h ? { rootNodeGroup: h.nodeGroup[o.node.getRawIndex()], direction: n.direction } : null,
						    f = this._giveContainerGroup(l),
						    p = this._doRender(f, t, d);c || s && "treemapZoomToNode" !== s && "treemapRootToNode" !== s ? p.renderFinally() : this._doAnimation(f, p, t, d), this._resetController(i), this._renderBreadcrumb(t, i, o);
					}
				}, _giveContainerGroup: function _giveContainerGroup(t) {
					var e = this._containerGroup;return e || (e = this._containerGroup = new m(), this._initEvents(e), this.group.add(e)), e.attr("position", [t.x, t.y]), e;
				}, _doRender: function _doRender(t, e, i) {
					function o(t, e, i, n, a) {
						function s(t) {
							return t.getId();
						}function u(r, s) {
							var l = null != r ? t[r] : null,
							    u = null != s ? e[s] : null,
							    c = m(l, u, i, a);c && o(l && l.viewChildren || [], u && u.viewChildren || [], c, n, a + 1);
						}n ? (e = t, y(t, function (t, e) {
							!t.isRemoved() && u(e, e);
						})) : new l(e, t, s, s).add(u).update(u).remove(r.curry(u, null)).execute();
					}function s(t) {
						var e = n();return t && y(t, function (t, i) {
							var n = e[i];y(t, function (t) {
								t && (n.push(t), t.__tmWillDelete = 1);
							});
						}), e;
					}function u() {
						y(v, function (t) {
							y(t, function (t) {
								t.parent && t.parent.remove(t);
							});
						}), y(g, function (t) {
							t.invisible = !0, t.dirty();
						});
					}var c = e.getData().tree,
					    h = this._oldTree,
					    d = n(),
					    f = n(),
					    p = this._storage,
					    g = [],
					    m = r.curry(a, e, f, p, i, d, g);o(c.root ? [c.root] : [], h && h.root ? [h.root] : [], t, c === h || !h, 0);var v = s(p);return this._oldTree = c, this._storage = f, { lastsForAnimation: d, willDeleteEls: v, renderFinally: u };
				}, _doAnimation: function _doAnimation(t, e, i, n) {
					if (i.get("animation")) {
						var a = i.get("animationDurationUpdate"),
						    o = i.get("animationEasing"),
						    s = p.createWrap();y(e.willDeleteEls, function (t, e) {
							y(t, function (t, i) {
								if (!t.invisible) {
									var r,
									    l = t.parent;if (n && "drillDown" === n.direction) r = l === n.rootNodeGroup ? { shape: { x: 0, y: 0, width: l.__tmNodeWidth, height: l.__tmNodeHeight }, style: { opacity: 0 } } : { style: { opacity: 0 } };else {
										var u = 0,
										    c = 0;l.__tmWillDelete || (u = l.__tmNodeWidth / 2, c = l.__tmNodeHeight / 2), r = "nodeGroup" === e ? { position: [u, c], style: { opacity: 0 } } : { shape: { x: u, y: c, width: 0, height: 0 }, style: { opacity: 0 } };
									}r && s.add(t, r, a, o);
								}
							});
						}), y(this._storage, function (t, i) {
							y(t, function (t, n) {
								var l = e.lastsForAnimation[i][n],
								    u = {};l && ("nodeGroup" === i ? l.old && (u.position = t.position.slice(), t.attr("position", l.old)) : (l.old && (u.shape = r.extend({}, t.shape), t.setShape(l.old)), l.fadein ? (t.setStyle("opacity", 0), u.style = { opacity: 1 }) : 1 !== t.style.opacity && (u.style = { opacity: 1 })), s.add(t, u, a, o));
							});
						}, this), this._state = "animating", s.done(g(function () {
							this._state = "ready", e.renderFinally();
						}, this)).start();
					}
				}, _resetController: function _resetController(t) {
					var e = this._controller;e || (e = this._controller = new h(t.getZr()), e.enable(this.seriesModel.get("roam")), e.on("pan", g(this._onPan, this)), e.on("zoom", g(this._onZoom, this)));var i = new d(0, 0, t.getWidth(), t.getHeight());e.setPointerChecker(function (t, e, n) {
						return i.contain(e, n);
					});
				}, _clearController: function _clearController() {
					var t = this._controller;t && (t.dispose(), t = null);
				}, _onPan: function _onPan(t, e) {
					if (this._mayClick = !1, "animating" !== this._state && (Math.abs(t) > x || Math.abs(e) > x)) {
						var i = this.seriesModel.getData().tree.root;if (!i) return;var n = i.getLayout();if (!n) return;this.api.dispatchAction({ type: "treemapMove", from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: n.x + t, y: n.y + e, width: n.width, height: n.height } });
					}
				}, _onZoom: function _onZoom(t, e, i) {
					if (this._mayClick = !1, "animating" !== this._state) {
						var n = this.seriesModel.getData().tree.root;if (!n) return;var a = n.getLayout();if (!a) return;var o = new d(a.x, a.y, a.width, a.height),
						    r = this.seriesModel.layoutInfo;e -= r.x, i -= r.y;var s = f.create();f.translate(s, s, [-e, -i]), f.scale(s, s, [t, t]), f.translate(s, s, [e, i]), o.applyTransform(s), this.api.dispatchAction({ type: "treemapRender", from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: o.x, y: o.y, width: o.width, height: o.height } });
					}
				}, _initEvents: function _initEvents(t) {
					function e(t) {
						var e = this.seriesModel.get("nodeClick", !0);if (e) {
							var i = this.findTarget(t.offsetX, t.offsetY);if (i) {
								var n = i.node;if (n.getLayout().isLeafRoot) this._rootToNode(i);else if ("zoomToNode" === e) this._zoomToNode(i);else if ("link" === e) {
									var a = n.hostTree.data.getItemModel(n.dataIndex),
									    o = a.get("link", !0),
									    r = a.get("target", !0) || "blank";o && window.open(o, r);
								}
							}
						}
					}t.on("mousedown", function (t) {
						"ready" === this._state && (this._mayClick = !0);
					}, this), t.on("mouseup", function (t) {
						this._mayClick && (this._mayClick = !1, "ready" === this._state && e.call(this, t));
					}, this);
				}, _renderBreadcrumb: function _renderBreadcrumb(t, e, i) {
					function n(e) {
						"animating" !== this._state && (u.aboveViewRoot(t.getViewRoot(), e) ? this._rootToNode({ node: e }) : this._zoomToNode({ node: e }));
					}i || (i = null != t.get("leafDepth", !0) ? { node: t.getViewRoot() } : this.findTarget(e.getWidth() / 2, e.getHeight() / 2), i || (i = { node: t.getData().tree.root })), (this._breadcrumb || (this._breadcrumb = new c(this.group))).render(t, e, i.node, g(n, this));
				}, remove: function remove() {
					this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = n(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
				}, dispose: function dispose() {
					this._clearController();
				}, _zoomToNode: function _zoomToNode(t) {
					this.api.dispatchAction({ type: "treemapZoomToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: t.node });
				}, _rootToNode: function _rootToNode(t) {
					this.api.dispatchAction({ type: "treemapRootToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: t.node });
				}, findTarget: function findTarget(t, e) {
					var i,
					    n = this.seriesModel.getViewRoot();return n.eachNode({ attr: "viewChildren", order: "preorder" }, function (n) {
						var a = this._storage.background[n.getRawIndex()];if (a) {
							var o = a.transformCoordToLocal(t, e),
							    r = a.shape;if (!(r.x <= o[0] && o[0] <= r.x + r.width && r.y <= o[1] && o[1] <= r.y + r.height)) return !1;i = { node: n, offsetX: o[0], offsetY: o[1] };
						}
					}, this), i;
				} });
		}, function (t, e, i) {
			for (var n = i(2), a = i(94), o = function o() {}, r = ["treemapZoomToNode", "treemapRender", "treemapMove"], s = 0; s < r.length; s++) {
				n.registerAction({ type: r[s], update: "updateView" }, o);
			}n.registerAction({ type: "treemapRootToNode", update: "updateView" }, function (t, e) {
				function i(e, i) {
					var n = a.retrieveTargetInfo(t, e);if (n) {
						var o = e.getViewRoot();o && (t.direction = a.aboveViewRoot(o, n.node) ? "rollUp" : "drillDown"), e.resetViewRoot(n.node);
					}
				}e.eachComponent({ mainType: "series", subType: "treemap", query: t }, i);
			});
		}, function (t, e, i) {
			function n(t, e, i) {
				var n = { mainType: "series", subType: "treemap", query: i };t.eachComponent(n, function (t) {
					var n = e.getWidth(),
					    o = e.getHeight(),
					    r = t.option,
					    s = m.getLayoutRect(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }),
					    l = r.size || [],
					    u = b(w(s.width, l[0]), n),
					    c = b(w(s.height, l[1]), o),
					    g = i && i.type,
					    x = v.retrieveTargetInfo(i, t),
					    _ = "treemapRender" === g || "treemapMove" === g ? i.rootRect : null,
					    M = t.getViewRoot(),
					    I = v.getPathToRoot(M);if ("treemapMove" !== g) {
						var T = "treemapZoomToNode" === g ? h(t, x, M, u, c) : _ ? [_.width, _.height] : [u, c],
						    A = r.sort;A && "asc" !== A && "desc" !== A && (A = "desc");var C = { squareRatio: r.squareRatio, sort: A, leafDepth: r.leafDepth };M.hostTree.clearLayouts();var L = { x: 0, y: 0, width: T[0], height: T[1], area: T[0] * T[1] };M.setLayout(L), a(M, C, !1, 0);var L = M.getLayout();S(I, function (t, e) {
							var i = (I[e + 1] || M).getValue();t.setLayout(p.extend({ dataExtent: [i, i], borderWidth: 0 }, L));
						});
					}var D = t.getData().tree.root;D.setLayout(d(s, _, x), !0), t.setLayoutInfo(s), f(D, new y(-s.x, -s.y, n, o), I, M, 0);
				});
			}function a(t, e, i, n) {
				var r, s;if (!t.isRemoved()) {
					var l = t.getLayout();r = l.width, s = l.height;var h = t.getModel("itemStyle.normal"),
					    d = h.get("borderWidth"),
					    f = h.get("gapWidth") / 2,
					    p = d - f,
					    g = t.getModel();t.setLayout({ borderWidth: d }, !0), r = x(r - 2 * p, 0), s = x(s - 2 * p, 0);var m = r * s,
					    v = o(t, g, m, e, i, n);if (v.length) {
						var y = { x: p, y: p, width: r, height: s },
						    b = _(r, s),
						    w = 1 / 0,
						    S = [];S.area = 0;for (var M = 0, I = v.length; M < I;) {
							var T = v[M];S.push(T), S.area += T.getLayout().area;var A = u(S, b, e.squareRatio);A <= w ? (M++, w = A) : (S.area -= S.pop().getLayout().area, c(S, b, y, f, !1), b = _(y.width, y.height), S.length = S.area = 0, w = 1 / 0);
						}if (S.length && c(S, b, y, f, !0), !i) {
							var C = g.get("childrenVisibleMin");null != C && m < C && (i = !0);
						}for (var M = 0, I = v.length; M < I; M++) {
							a(v[M], e, i, n + 1);
						}
					}
				}
			}function o(t, e, i, n, a, o) {
				var u = t.children || [],
				    c = n.sort;"asc" !== c && "desc" !== c && (c = null);var h = null != n.leafDepth && n.leafDepth <= o;if (a && !h) return t.viewChildren = [];u = p.filter(u, function (t) {
					return !t.isRemoved();
				}), s(u, c);var d = l(e, u, c);if (0 === d.sum) return t.viewChildren = [];if (d.sum = r(e, i, d.sum, c, u), 0 === d.sum) return t.viewChildren = [];for (var f = 0, g = u.length; f < g; f++) {
					var m = u[f].getValue() / d.sum * i;u[f].setLayout({ area: m });
				}return h && (u.length && t.setLayout({ isLeafRoot: !0 }, !0), u.length = 0), t.viewChildren = u, t.setLayout({ dataExtent: d.dataExtent }, !0), u;
			}function r(t, e, i, n, a) {
				if (!n) return i;for (var o = t.get("visibleMin"), r = a.length, s = r, l = r - 1; l >= 0; l--) {
					var u = a["asc" === n ? r - l - 1 : l].getValue();u / i * e < o && (s = l, i -= u);
				}return "asc" === n ? a.splice(0, r - s) : a.splice(s, r - s), i;
			}function s(t, e) {
				return e && t.sort(function (t, i) {
					var n = "asc" === e ? t.getValue() - i.getValue() : i.getValue() - t.getValue();return 0 === n ? "asc" === e ? t.dataIndex - i.dataIndex : i.dataIndex - t.dataIndex : n;
				}), t;
			}function l(t, e, i) {
				for (var n = 0, a = 0, o = e.length; a < o; a++) {
					n += e[a].getValue();
				}var r,
				    s = t.get("visualDimension");if (e && e.length) {
					if ("value" === s && i) r = [e[e.length - 1].getValue(), e[0].getValue()], "asc" === i && r.reverse();else {
						var r = [1 / 0, -(1 / 0)];S(e, function (t) {
							var e = t.getValue(s);e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);
						});
					}
				} else r = [NaN, NaN];return { sum: n, dataExtent: r };
			}function u(t, e, i) {
				for (var n, a = 0, o = 1 / 0, r = 0, s = t.length; r < s; r++) {
					n = t[r].getLayout().area, n && (n < o && (o = n), n > a && (a = n));
				}var l = t.area * t.area,
				    u = e * e * i;return l ? x(u * a / l, l / (u * o)) : 1 / 0;
			}function c(t, e, i, n, a) {
				var o = e === i.width ? 0 : 1,
				    r = 1 - o,
				    s = ["x", "y"],
				    l = ["width", "height"],
				    u = i[s[o]],
				    c = e ? t.area / e : 0;(a || c > i[l[r]]) && (c = i[l[r]]);for (var h = 0, d = t.length; h < d; h++) {
					var f = t[h],
					    p = {},
					    g = c ? f.getLayout().area / c : 0,
					    m = p[l[r]] = x(c - 2 * n, 0),
					    v = i[s[o]] + i[l[o]] - u,
					    y = h === d - 1 || v < g ? v : g,
					    b = p[l[o]] = x(y - 2 * n, 0);p[s[r]] = i[s[r]] + _(n, m / 2), p[s[o]] = u + _(n, b / 2), u += y, f.setLayout(p, !0);
				}i[s[r]] += c, i[l[r]] -= c;
			}function h(t, e, i, n, a) {
				var o = (e || {}).node,
				    r = [n, a];if (!o || o === i) return r;for (var s, l = n * a, u = l * t.option.zoomToNodeRatio; s = o.parentNode;) {
					for (var c = 0, h = s.children, d = 0, f = h.length; d < f; d++) {
						c += h[d].getValue();
					}var p = o.getValue();if (0 === p) return r;u *= c / p;var m = s.getModel("itemStyle.normal").get("borderWidth");isFinite(m) && (u += 4 * m * m + 4 * m * Math.pow(u, .5)), u > g.MAX_SAFE_INTEGER && (u = g.MAX_SAFE_INTEGER), o = s;
				}u < l && (u = l);var v = Math.pow(u / l, .5);return [n * v, a * v];
			}function d(t, e, i) {
				if (e) return { x: e.x, y: e.y };var n = { x: 0, y: 0 };if (!i) return n;var a = i.node,
				    o = a.getLayout();if (!o) return n;for (var r = [o.width / 2, o.height / 2], s = a; s;) {
					var l = s.getLayout();r[0] += l.x, r[1] += l.y, s = s.parentNode;
				}return { x: t.width / 2 - r[0], y: t.height / 2 - r[1] };
			}function f(t, e, i, n, a) {
				var o = t.getLayout(),
				    r = i[a],
				    s = r && r === t;if (!(r && !s || a === i.length && t !== n)) {
					t.setLayout({ isInView: !0, invisible: !s && !e.intersect(o), isAboveViewRoot: s }, !0);var l = new y(e.x - o.x, e.y - o.y, e.width, e.height);S(t.viewChildren || [], function (t) {
						f(t, l, i, n, a + 1);
					});
				}
			}var p = i(1),
			    g = i(4),
			    m = i(12),
			    v = i(94),
			    y = i(11),
			    v = i(94),
			    x = Math.max,
			    _ = Math.min,
			    b = g.parsePercent,
			    w = p.retrieve,
			    S = p.each;t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i, s, u, h) {
				var d = t.getModel(),
				    p = t.getLayout();if (p && !p.invisible && p.isInView) {
					var m,
					    v = t.getModel(g),
					    y = i[t.depth],
					    x = a(v, e, y, s),
					    _ = v.get("borderColor"),
					    b = v.get("borderColorSaturation");null != b && (m = o(x, t), _ = r(b, m)), t.setVisual("borderColor", _);var w = t.viewChildren;if (w && w.length) {
						var S = l(t, d, p, v, x, w);f.each(w, function (t, e) {
							if (t.depth >= u.length || t === u[t.depth]) {
								var a = c(d, x, t, e, S, h);n(t, a, i, s, u, h);
							}
						});
					} else m = o(x, t), t.setVisual("color", m);
				}
			}function a(t, e, i, n) {
				var a = f.extend({}, e);return f.each(["color", "colorAlpha", "colorSaturation"], function (o) {
					var r = t.get(o, !0);null == r && i && (r = i[o]), null == r && (r = e[o]), null == r && (r = n.get(o)), null != r && (a[o] = r);
				}), a;
			}function o(t) {
				var e = s(t, "color");if (e) {
					var i = s(t, "colorAlpha"),
					    n = s(t, "colorSaturation");return n && (e = d.modifyHSL(e, null, null, n)), i && (e = d.modifyAlpha(e, i)), e;
				}
			}function r(t, e) {
				return null != e ? d.modifyHSL(e, null, null, t) : null;
			}function s(t, e) {
				var i = t[e];if (null != i && "none" !== i) return i;
			}function l(t, e, i, n, a, o) {
				if (o && o.length) {
					var r = u(e, "color") || null != a.color && "none" !== a.color && (u(e, "colorAlpha") || u(e, "colorSaturation"));if (r) {
						var s = e.get("visualMin"),
						    l = e.get("visualMax"),
						    c = i.dataExtent.slice();null != s && s < c[0] && (c[0] = s), null != l && l > c[1] && (c[1] = l);var d = e.get("colorMappingBy"),
						    f = { type: r.name, dataExtent: c, visual: r.range };"color" !== f.type || "index" !== d && "id" !== d ? f.mappingMethod = "linear" : (f.mappingMethod = "category", f.loop = !0);var p = new h(f);return p.__drColorMappingBy = d, p;
					}
				}
			}function u(t, e) {
				var i = t.get(e);return p(i) && i.length ? { name: e, range: i } : null;
			}function c(t, e, i, n, a, o) {
				var r = f.extend({}, e);if (a) {
					var s = a.type,
					    l = "color" === s && a.__drColorMappingBy,
					    u = "index" === l ? n : "id" === l ? o.mapIdToIndex(i.getId()) : i.getValue(t.get("visualDimension"));r[s] = a.mapValueToVisual(u);
				}return r;
			}var h = i(83),
			    d = i(22),
			    f = i(1),
			    p = f.isArray,
			    g = "itemStyle.normal";t.exports = function (t, e, i) {
				var a = { mainType: "series", subType: "treemap", query: i };t.eachComponent(a, function (t) {
					var e = t.getData().tree,
					    i = e.root,
					    a = t.getModel(g);if (!i.isRemoved()) {
						var o = f.map(e.levelModels, function (t) {
							return t ? t.get(g) : null;
						});n(i, {}, o, a, t.getViewRoot().getAncestors(), t);
					}
				});
			};
		}, function (t, e, i) {
			"use strict";
			i(236), i(354);
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i, n) {
				var a = t.coordToPoint([e, n]),
				    o = t.coordToPoint([i, n]);return { x1: a[0], y1: a[1], x2: o[0], y2: o[1] };
			}var a = i(1),
			    o = i(3),
			    r = i(10),
			    s = ["axisLine", "axisLabel", "axisTick", "splitLine", "splitArea"];i(41).extend({ type: "angleAxis", axisPointerClass: "PolarAxisPointer", render: function render(t, e) {
					if (this.group.removeAll(), t.get("show")) {
						var i = t.axis,
						    n = i.polar,
						    o = n.getRadiusAxis().getExtent(),
						    r = i.getTicksCoords();"category" !== i.type && r.pop(), a.each(s, function (e) {
							!t.get(e + ".show") || i.scale.isBlank() && "axisLine" !== e || this["_" + e](t, n, r, o);
						}, this);
					}
				}, _axisLine: function _axisLine(t, e, i, n) {
					var a = t.getModel("axisLine.lineStyle"),
					    r = new o.Circle({ shape: { cx: e.cx, cy: e.cy, r: n[1] }, style: a.getLineStyle(), z2: 1, silent: !0 });r.style.fill = null, this.group.add(r);
				}, _axisTick: function _axisTick(t, e, i, r) {
					var s = t.getModel("axisTick"),
					    l = (s.get("inside") ? -1 : 1) * s.get("length"),
					    u = a.map(i, function (t) {
						return new o.Line({ shape: n(e, r[1], r[1] + l, t) });
					});this.group.add(o.mergePath(u, { style: a.defaults(s.getModel("lineStyle").getLineStyle(), { stroke: t.get("axisLine.lineStyle.color") }) }));
				}, _axisLabel: function _axisLabel(t, e, i, n) {
					for (var a = t.axis, s = t.get("data"), l = t.getModel("axisLabel"), u = l.getModel("textStyle"), c = t.getFormattedLabels(), h = l.get("margin"), d = a.getLabelsCoords(), f = 0; f < i.length; f++) {
						var p = n[1],
						    g = e.coordToPoint([p + h, d[f]]),
						    m = e.cx,
						    v = e.cy,
						    y = Math.abs(g[0] - m) / p < .3 ? "center" : g[0] > m ? "left" : "right",
						    x = Math.abs(g[1] - v) / p < .3 ? "middle" : g[1] > v ? "top" : "bottom",
						    _ = u;s && s[f] && s[f].textStyle && (_ = new r(s[f].textStyle, u)), this.group.add(new o.Text({ style: { x: g[0], y: g[1], fill: _.getTextColor() || t.get("axisLine.lineStyle.color"), text: c[f], textAlign: y, textVerticalAlign: x, textFont: _.getFont() }, silent: !0 }));
					}
				}, _splitLine: function _splitLine(t, e, i, r) {
					var s = t.getModel("splitLine"),
					    l = s.getModel("lineStyle"),
					    u = l.get("color"),
					    c = 0;u = u instanceof Array ? u : [u];for (var h = [], d = 0; d < i.length; d++) {
						var f = c++ % u.length;h[f] = h[f] || [], h[f].push(new o.Line({ shape: n(e, r[0], r[1], i[d]) }));
					}for (var d = 0; d < h.length; d++) {
						this.group.add(o.mergePath(h[d], { style: a.defaults({ stroke: u[d % u.length] }, l.getLineStyle()), silent: !0, z: t.get("z") }));
					}
				}, _splitArea: function _splitArea(t, e, i, n) {
					var r = t.getModel("splitArea"),
					    s = r.getModel("areaStyle"),
					    l = s.get("color"),
					    u = 0;l = l instanceof Array ? l : [l];for (var c = [], h = Math.PI / 180, d = -i[0] * h, f = Math.min(n[0], n[1]), p = Math.max(n[0], n[1]), g = t.get("clockwise"), m = 1; m < i.length; m++) {
						var v = u++ % l.length;c[v] = c[v] || [], c[v].push(new o.Sector({ shape: { cx: e.cx, cy: e.cy, r0: f, r: p, startAngle: d, endAngle: -i[m] * h, clockwise: g }, silent: !0 })), d = -i[m] * h;
					}for (var m = 0; m < c.length; m++) {
						this.group.add(o.mergePath(c[m], { style: a.defaults({ fill: l[m % l.length] }, s.getAreaStyle()), silent: !0 }));
					}
				} });
		}, function (t, e, i) {
			function n(t, e, i) {
				return i && "axisAreaSelect" === i.type && e.findComponents({ mainType: "parallelAxis", query: i })[0] === t;
			}function a(t) {
				var e = t.axis;return r.map(t.activeIntervals, function (t) {
					return { brushType: "lineX", panelId: "pl", range: [e.dataToCoord(t[0], !0), e.dataToCoord(t[1], !0)] };
				});
			}function o(t, e) {
				return e.getComponent("parallel", t.get("parallelIndex"));
			}var r = i(1),
			    s = i(40),
			    l = i(127),
			    u = i(185),
			    c = i(3),
			    h = ["axisLine", "axisLabel", "axisTick", "axisName"],
			    d = i(2).extendComponentView({ type: "parallelAxis", init: function init(t, e) {
					d.superApply(this, "init", arguments), (this._brushController = new l(e.getZr())).on("brush", r.bind(this._onBrush, this));
				}, render: function render(t, e, i, a) {
					if (!n(t, e, a)) {
						this.axisModel = t, this.api = i, this.group.removeAll();var l = this._axisGroup;if (this._axisGroup = new c.Group(), this.group.add(this._axisGroup), t.get("show")) {
							var u = o(t, e),
							    d = u.coordinateSystem,
							    f = t.getAreaSelectStyle(),
							    p = f.width,
							    g = t.axis.dim,
							    m = d.getAxisLayout(g),
							    v = r.extend({ strokeContainThreshold: p }, m),
							    y = new s(t, v);r.each(h, y.add, y), this._axisGroup.add(y.getGroup()), this._refreshBrushController(v, f, t, u, p, i);var x = a && a.animation === !1 ? null : t;c.groupTransition(l, this._axisGroup, x);
						}
					}
				}, updateVisual: function updateVisual(t, e, i, n) {
					this._brushController && this._brushController.updateCovers(a(t));
				}, _refreshBrushController: function _refreshBrushController(t, e, i, n, o, r) {
					var s = i.axis.getExtent(),
					    l = s[1] - s[0],
					    h = Math.min(30, .1 * Math.abs(l)),
					    d = c.BoundingRect.create({ x: s[0], y: -o / 2, width: l, height: o });d.x -= h, d.width += 2 * h, this._brushController.mount({ enableGlobalPan: !0, rotation: t.rotation, position: t.position }).setPanels([{ panelId: "pl", clipPath: u.makeRectPanelClipPath(d), isTargetByCursor: u.makeRectIsTargetByCursor(d, r, n), getLinearBrushOtherExtent: u.makeLinearBrushOtherExtent(d, 0) }]).enableBrush({ brushType: "lineX", brushStyle: e, removeOnClick: !0 }).updateCovers(a(i));
				}, _onBrush: function _onBrush(t, e) {
					var i = this.axisModel,
					    n = i.axis,
					    a = r.map(t, function (t) {
						return [n.coordToData(t.range[0], !0), n.coordToData(t.range[1], !0)];
					});(!i.option.realtime === e.isEnd || e.removeOnClick) && this.api.dispatchAction({ type: "axisAreaSelect", parallelAxisId: i.id, intervals: a });
				}, dispose: function dispose() {
					this._brushController.dispose();
				} });t.exports = d;
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				return { position: [t.cx, t.cy], rotation: i / 180 * Math.PI, labelDirection: -1, tickDirection: -1, nameDirection: 1, labelRotate: e.getModel("axisLabel").get("rotate"), z2: 1 };
			}var a = i(1),
			    o = i(3),
			    r = i(40),
			    s = ["axisLine", "axisLabel", "axisTick", "axisName"],
			    l = ["splitLine", "splitArea"];i(41).extend({ type: "radiusAxis", axisPointerClass: "PolarAxisPointer", render: function render(t, e) {
					if (this.group.removeAll(), t.get("show")) {
						var i = t.axis,
						    o = i.polar,
						    u = o.getAngleAxis(),
						    c = i.getTicksCoords(),
						    h = u.getExtent()[0],
						    d = i.getExtent(),
						    f = n(o, t, h),
						    p = new r(t, f);a.each(s, p.add, p), this.group.add(p.getGroup()), a.each(l, function (e) {
							t.get(e + ".show") && !i.scale.isBlank() && this["_" + e](t, o, h, d, c);
						}, this);
					}
				}, _splitLine: function _splitLine(t, e, i, n, r) {
					var s = t.getModel("splitLine"),
					    l = s.getModel("lineStyle"),
					    u = l.get("color"),
					    c = 0;u = u instanceof Array ? u : [u];for (var h = [], d = 0; d < r.length; d++) {
						var f = c++ % u.length;h[f] = h[f] || [], h[f].push(new o.Circle({ shape: { cx: e.cx, cy: e.cy, r: r[d] }, silent: !0 }));
					}for (var d = 0; d < h.length; d++) {
						this.group.add(o.mergePath(h[d], { style: a.defaults({ stroke: u[d % u.length], fill: null }, l.getLineStyle()), silent: !0 }));
					}
				}, _splitArea: function _splitArea(t, e, i, n, r) {
					var s = t.getModel("splitArea"),
					    l = s.getModel("areaStyle"),
					    u = l.get("color"),
					    c = 0;u = u instanceof Array ? u : [u];for (var h = [], d = r[0], f = 1; f < r.length; f++) {
						var p = c++ % u.length;h[p] = h[p] || [], h[p].push(new o.Sector({ shape: { cx: e.cx, cy: e.cy, r0: d, r: r[f], startAngle: 0, endAngle: 2 * Math.PI }, silent: !0 })), d = r[f];
					}for (var f = 0; f < h.length; f++) {
						this.group.add(o.mergePath(h[f], { style: a.defaults({ fill: u[f % u.length] }, l.getAreaStyle()), silent: !0 }));
					}
				} });
		}, function (t, e, i) {
			var n = i(40),
			    a = i(1),
			    o = i(3),
			    r = i(248),
			    s = n.getInterval,
			    l = n.ifIgnoreOnTick,
			    u = ["axisLine", "axisLabel", "axisTick", "axisName"],
			    c = "splitLine",
			    h = i(41).extend({ type: "singleAxis", axisPointerClass: "SingleAxisPointer", render: function render(t, e, i, o) {
					var s = this.group;s.removeAll();var l = r.layout(t),
					    d = new n(t, l);a.each(u, d.add, d), s.add(d.getGroup()), t.get(c + ".show") && this["_" + c](t, l.labelInterval), h.superCall(this, "render", t, e, i, o);
				}, _splitLine: function _splitLine(t, e) {
					var i = t.axis;if (!i.scale.isBlank()) {
						var n = t.getModel("splitLine"),
						    a = n.getModel("lineStyle"),
						    r = a.get("width"),
						    u = a.get("color"),
						    c = s(n, e);u = u instanceof Array ? u : [u];for (var h = t.coordinateSystem.getRect(), d = i.isHorizontal(), f = [], p = 0, g = i.getTicksCoords(), m = [], v = [], y = 0; y < g.length; ++y) {
							if (!l(i, y, c)) {
								var x = i.toGlobalCoord(g[y]);d ? (m[0] = x, m[1] = h.y, v[0] = x, v[1] = h.y + h.height) : (m[0] = h.x, m[1] = x, v[0] = h.x + h.width, v[1] = x);var _ = p++ % u.length;f[_] = f[_] || [], f[_].push(new o.Line(o.subPixelOptimizeLine({ shape: { x1: m[0], y1: m[1], x2: v[0], y2: v[1] }, style: { lineWidth: r }, silent: !0 })));
							}
						}for (var y = 0; y < f.length; ++y) {
							this.group.add(o.mergePath(f[y], { style: { stroke: u[y % u.length], lineDash: a.getLineDash(r), lineWidth: r }, silent: !0 }));
						}
					}
				} });t.exports = h;
		}, function (t, e, i) {
			var n = i(2),
			    a = { type: "axisAreaSelect", event: "axisAreaSelected", update: "updateVisual" };n.registerAction(a, function (t, e) {
				e.eachComponent({ mainType: "parallelAxis", query: t }, function (e) {
					e.axis.model.setActiveIntervals(t.intervals);
				});
			}), n.registerAction("parallelAxisExpand", function (t, e) {
				e.eachComponent({ mainType: "parallel", query: t }, function (e) {
					e.setAxisExpand(t);
				});
			});
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i, n, a) {
				var o = e.axis,
				    s = o.dataToCoord(t),
				    c = n.getAngleAxis().getExtent()[0];c = c / 180 * Math.PI;var h,
				    d,
				    f,
				    p = n.getRadiusAxis().getExtent();if ("radius" === o.dim) {
					var g = l.create();l.rotate(g, g, c), l.translate(g, g, [n.cx, n.cy]), h = r.applyTransform([s, -a], g);var m = e.getModel("axisLabel").get("rotate") || 0,
					    v = u.innerTextLayout(c, m * Math.PI / 180, -1);d = v.textAlign, f = v.textVerticalAlign;
				} else {
					var y = p[1];h = n.coordToPoint([y + a, s]);var x = n.cx,
					    _ = n.cy;d = Math.abs(h[0] - x) / y < .3 ? "center" : h[0] > x ? "left" : "right", f = Math.abs(h[1] - _) / y < .3 ? "middle" : h[1] > _ ? "top" : "bottom";
				}return { position: h, align: d, verticalAlign: f };
			}var a = i(7),
			    o = i(119),
			    r = i(3),
			    s = i(76),
			    l = i(19),
			    u = i(40),
			    c = i(41),
			    h = o.extend({ makeElOption: function makeElOption(t, e, i, o, r) {
					var l = i.axis;"angle" === l.dim && (this.animationThreshold = Math.PI / 18);var u,
					    c = l.polar,
					    h = c.getOtherAxis(l),
					    f = h.getExtent();u = l["dataTo" + a.capitalFirst(l.dim)](e);var p = o.get("type");if (p && "none" !== p) {
						var g = s.buildElStyle(o),
						    m = d[p](l, c, u, f, g);m.style = g, t.graphicKey = m.type, t.pointer = m;
					}var v = o.get("label.margin"),
					    y = n(e, i, o, c, v);s.buildLabelElOption(t, i, o, r, y);
				} }),
			    d = { line: function line(t, e, i, n, a) {
					return "angle" === t.dim ? { type: "Line", shape: s.makeLineShape(e.coordToPoint([n[0], i]), e.coordToPoint([n[1], i])) } : { type: "Circle", shape: { cx: e.cx, cy: e.cy, r: i } };
				}, shadow: function shadow(t, e, i, n, a) {
					var o = t.getBandWidth(),
					    r = Math.PI / 180;return "angle" === t.dim ? { type: "Sector", shape: s.makeSectorShape(e.cx, e.cy, n[0], n[1], (-i - o / 2) * r, (-i + o / 2) * r) } : { type: "Sector", shape: s.makeSectorShape(e.cx, e.cy, i - o / 2, i + o / 2, 0, 2 * Math.PI) };
				} };c.registerAxisPointerClass("PolarAxisPointer", h), t.exports = h;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return t.isHorizontal() ? 0 : 1;
			}function a(t, e) {
				var i = t.getRect();return [i[c[e]], i[c[e]] + i[h[e]]];
			}var o = i(3),
			    r = i(119),
			    s = i(76),
			    l = i(248),
			    u = i(41),
			    c = ["x", "y"],
			    h = ["width", "height"],
			    d = r.extend({ makeElOption: function makeElOption(t, e, i, o, r) {
					var u = i.axis,
					    c = u.coordinateSystem,
					    h = a(c, 1 - n(u)),
					    d = c.dataToPoint(e)[0],
					    p = o.get("type");if (p && "none" !== p) {
						var g = s.buildElStyle(o),
						    m = f[p](u, d, h, g);m.style = g, t.graphicKey = m.type, t.pointer = m;
					}var v = l.layout(i);s.buildCartesianSingleLabelElOption(e, t, v, i, o, r);
				}, getHandleTransform: function getHandleTransform(t, e, i) {
					var n = l.layout(e, { labelInside: !1 });return n.labelMargin = i.get("handle.margin"), { position: s.getTransformedPosition(e.axis, t, n), rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0) };
				}, updateHandleTransform: function updateHandleTransform(t, e, i, o) {
					var r = i.axis,
					    s = r.coordinateSystem,
					    l = n(r),
					    u = a(s, l),
					    c = t.position;c[l] += e[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);var h = a(s, 1 - l),
					    d = (h[1] + h[0]) / 2,
					    f = [d, d];return f[l] = c[l], { position: c, rotation: t.rotation, cursorPoint: f, tooltipOption: { verticalAlign: "middle" } };
				} }),
			    f = { line: function line(t, e, i, a) {
					var r = s.makeLineShape([e, i[0]], [e, i[1]], n(t));return o.subPixelOptimizeLine({ shape: r, style: a }), { type: "Line", shape: r };
				}, shadow: function shadow(t, e, i, a) {
					var o = t.getBandWidth(),
					    r = i[1] - i[0];return { type: "Rect", shape: s.makeRectShape([e - o / 2, i[0]], [o, r], n(t)) };
				} };u.registerAxisPointerClass("SingleAxisPointer", d), t.exports = d;
		}, function (t, e, i) {
			i(2).registerPreprocessor(i(365)), i(367), i(362), i(363), i(364), i(386);
		}, function (t, e, i) {
			function n(t, e) {
				return o.merge({ brushType: t.brushType, brushMode: t.brushMode, transformable: t.transformable, brushStyle: new s(t.brushStyle).getItemStyle(), removeOnClick: t.removeOnClick, z: t.z }, e, !0);
			}var a = i(2),
			    o = i(1),
			    r = i(187),
			    s = i(10),
			    l = ["#ddd"],
			    u = a.extendComponentModel({ type: "brush", dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], defaultOption: { toolbox: null, brushLink: null, seriesIndex: "all", geoIndex: null, xAxisIndex: null, yAxisIndex: null, brushType: "rect", brushMode: "single", transformable: !0, brushStyle: { borderWidth: 1, color: "rgba(120,140,180,0.3)", borderColor: "rgba(120,140,180,0.8)" }, throttleType: "fixRate", throttleDelay: 0, removeOnClick: !0, z: 1e4 }, areas: [], brushType: null, brushOption: {}, coordInfoList: [], optionUpdated: function optionUpdated(t, e) {
					var i = this.option;!e && r.replaceVisualOption(i, t, ["inBrush", "outOfBrush"]), i.inBrush = i.inBrush || {}, i.outOfBrush = i.outOfBrush || { color: l };
				}, setAreas: function setAreas(t) {
					t && (this.areas = o.map(t, function (t) {
						return n(this.option, t);
					}, this));
				}, setBrushOption: function setBrushOption(t) {
					this.brushOption = n(this.option, t), this.brushType = this.brushOption.brushType;
				} });t.exports = u;
		}, function (t, e, i) {
			function n(t, e, i, n) {
				(!n || n.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption).updateCovers(t.areas.slice());
			}var a = i(1),
			    o = i(127),
			    r = i(2);t.exports = r.extendComponentView({ type: "brush", init: function init(t, e) {
					this.ecModel = t, this.api = e, this.model, (this._brushController = new o(e.getZr())).on("brush", a.bind(this._onBrush, this)).mount();
				}, render: function render(t) {
					return this.model = t, n.apply(this, arguments);
				}, updateView: n, updateLayout: n, updateVisual: n, dispose: function dispose() {
					this._brushController.dispose();
				}, _onBrush: function _onBrush(t, e) {
					var i = this.model.id;this.model.brushTargetManager.setOutputRanges(t, this.ecModel), (!e.isEnd || e.removeOnClick) && this.api.dispatchAction({ type: "brush", brushId: i, areas: a.clone(t), $from: i });
				} });
		}, function (t, e, i) {
			var n = i(2);n.registerAction({ type: "brush", event: "brush", update: "updateView" }, function (t, e) {
				e.eachComponent({ mainType: "brush", query: t }, function (e) {
					e.setAreas(t.areas);
				});
			}), n.registerAction({ type: "brushSelect", event: "brushSelected", update: "none" }, function () {});
		}, function (t, e, i) {
			function n(t) {
				var e = {};a.each(t, function (t) {
					e[t] = 1;
				}), t.length = 0, a.each(e, function (e, i) {
					t.push(i);
				});
			}var a = i(1),
			    o = ["rect", "polygon", "keep", "clear"];t.exports = function (t, e) {
				var i = t && t.brush;if (a.isArray(i) || (i = i ? [i] : []), i.length) {
					var r = [];a.each(i, function (t) {
						var e = t.hasOwnProperty("toolbox") ? t.toolbox : [];e instanceof Array && (r = r.concat(e));
					});var s = t && t.toolbox;a.isArray(s) && (s = s[0]), s || (s = { feature: {} }, t.toolbox = [s]);var l = s.feature || (s.feature = {}),
					    u = l.brush || (l.brush = {}),
					    c = u.type || (u.type = []);c.push.apply(c, r), n(c), e && !c.length && c.push.apply(c, o);
				}
			};
		}, function (t, e, i) {
			function n(t) {
				var e = ["x", "y"],
				    i = ["width", "height"];return { point: function point(e, i, n) {
						var o = n.range,
						    r = e[t];return a(r, o);
					}, rect: function rect(n, o, r) {
						var s = r.range,
						    l = [n[e[t]], n[e[t]] + n[i[t]]];return l[1] < l[0] && l.reverse(), a(l[0], s) || a(l[1], s) || a(s[0], l) || a(s[1], l);
					} };
			}function a(t, e) {
				return e[0] <= t && t <= e[1];
			}function o(t, e, i, n, a) {
				for (var o = 0, s = a[a.length - 1]; o < a.length; o++) {
					var l = a[o];if (r(t, e, i, n, l[0], l[1], s[0], s[1])) return !0;s = l;
				}
			}function r(t, e, i, n, a, o, r, u) {
				var c = l(i - t, a - r, n - e, o - u);if (s(c)) return !1;var h = l(a - t, a - r, o - e, o - u) / c;if (h < 0 || h > 1) return !1;var d = l(i - t, a - t, n - e, o - e) / c;return !(d < 0 || d > 1);
			}function s(t) {
				return t <= 1e-6 && t >= -1e-6;
			}function l(t, e, i, n) {
				return t * n - e * i;
			}var u = i(267).contain,
			    c = i(11),
			    h = { lineX: n(0), lineY: n(1), rect: { point: function point(t, e, i) {
						return i.boundingRect.contain(t[0], t[1]);
					}, rect: function rect(t, e, i) {
						return i.boundingRect.intersect(t);
					} }, polygon: { point: function point(t, e, i) {
						return i.boundingRect.contain(t[0], t[1]) && u(i.range, t[0], t[1]);
					}, rect: function rect(t, e, i) {
						var n = i.range;if (n.length <= 1) return !1;var a = t.x,
						    r = t.y,
						    s = t.width,
						    l = t.height,
						    h = n[0];return !!(u(n, a, r) || u(n, a + s, r) || u(n, a, r + l) || u(n, a + s, r + l) || c.create(t).contain(h[0], h[1]) || o(a, r, a + s, r, n) || o(a, r, a, r + l, n) || o(a + s, r, a + s, r + l, n) || o(a, r + l, a + s, r + l, n)) || void 0;
					} } };t.exports = h;
		}, function (t, e, i) {
			function n(t, e, i, n, o) {
				if (o) {
					var r = t.getZr();if (!r[x]) {
						r[y] || (r[y] = a);var s = g.createOrUpdate(r, y, i, e);s(t, n);
					}
				}
			}function a(t, e) {
				if (!t.isDisposed()) {
					var i = t.getZr();i[x] = !0, t.dispatchAction({ type: "brushSelect", batch: e }), i[x] = !1;
				}
			}function o(t, e, i, n) {
				for (var a = 0, o = e.length; a < o; a++) {
					var r = e[a];if (t[r.brushType](n, i, r.selectors, r)) return !0;
				}
			}function r(t) {
				var e = t.brushSelector;if (d.isString(e)) {
					var i = [];return d.each(p, function (t, n) {
						i[n] = function (i, n, a, o) {
							var r = n.getItemLayout(i);return t[e](r, a, o);
						};
					}), i;
				}if (d.isFunction(e)) {
					var n = {};return d.each(p, function (t, i) {
						n[i] = e;
					}), n;
				}return e;
			}function s(t, e) {
				var i = t.option.seriesIndex;return null != i && "all" !== i && (d.isArray(i) ? d.indexOf(i, e) < 0 : e !== i);
			}function l(t) {
				var e = t.selectors = {};return d.each(p[t.brushType], function (i, n) {
					e[n] = function (n) {
						return i(n, e, t);
					};
				}), t;
			}function u(t) {
				return new f(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0]);
			}var c = i(2),
			    h = i(187),
			    d = i(1),
			    f = i(11),
			    p = i(366),
			    g = i(37),
			    m = i(184),
			    v = ["inBrush", "outOfBrush"],
			    y = "__ecBrushSelect",
			    x = "__ecInBrushSelectEvent",
			    _ = c.PRIORITY.VISUAL.BRUSH;c.registerLayout(_, function (t, e, i) {
				t.eachComponent({ mainType: "brush" }, function (e) {
					i && "takeGlobalCursor" === i.type && e.setBrushOption("brush" === i.key ? i.brushOption : { brushType: !1 });var n = e.brushTargetManager = new m(e.option, t);n.setInputRanges(e.areas, t);
				});
			}), c.registerVisual(_, function (t, e, i) {
				var a,
				    u,
				    c = [];t.eachComponent({ mainType: "brush" }, function (e, i) {
					function n(t) {
						return "all" === x || _[t];
					}function f(t) {
						return !!t.length;
					}function p(t, e) {
						var i = t.coordinateSystem;M |= i.hasAxisBrushed(), n(e) && i.eachActiveState(t.getData(), function (t, e) {
							"active" === t && (w[e] = 1);
						});
					}function g(i, a, l) {
						var u = r(i);if (u && !s(e, a) && (d.each(I, function (n) {
							u[n.brushType] && e.brushTargetManager.controlSeries(n, i, t) && l.push(n), M |= f(l);
						}), n(a) && f(l))) {
							var c = i.getData();c.each(function (t) {
								o(u, l, c, t) && (w[t] = 1);
							});
						}
					}var m = { brushId: e.id, brushIndex: i, brushName: e.name, areas: d.clone(e.areas), selected: [] };c.push(m);var y = e.option,
					    x = y.brushLink,
					    _ = [],
					    w = [],
					    S = [],
					    M = 0;i || (a = y.throttleType, u = y.throttleDelay);var I = d.map(e.areas, function (t) {
						return l(d.defaults({ boundingRect: b[t.brushType](t) }, t));
					}),
					    T = h.createVisualMappings(e.option, v, function (t) {
						t.mappingMethod = "fixed";
					});d.isArray(x) && d.each(x, function (t) {
						_[t] = 1;
					}), t.eachSeries(function (t, e) {
						var i = S[e] = [];"parallel" === t.subType ? p(t, e, i) : g(t, e, i);
					}), t.eachSeries(function (t, e) {
						var i = { seriesId: t.id, seriesIndex: e, seriesName: t.name, dataIndex: [] };m.selected.push(i);var a = r(t),
						    s = S[e],
						    l = t.getData(),
						    u = n(e) ? function (t) {
							return w[t] ? (i.dataIndex.push(l.getRawIndex(t)), "inBrush") : "outOfBrush";
						} : function (t) {
							return o(a, s, l, t) ? (i.dataIndex.push(l.getRawIndex(t)), "inBrush") : "outOfBrush";
						};(n(e) ? M : f(s)) && h.applyVisual(v, T, l, u);
					});
				}), n(e, a, u, c, i);
			});var b = { lineX: d.noop, lineY: d.noop, rect: function rect(t) {
					return u(t.range);
				}, polygon: function polygon(t) {
					for (var e, i = t.range, n = 0, a = i.length; n < a; n++) {
						e = e || [[1 / 0, -(1 / 0)], [1 / 0, -(1 / 0)]];var o = i[n];o[0] < e[0][0] && (e[0][0] = o[0]), o[0] > e[0][1] && (e[0][1] = o[0]), o[1] < e[1][0] && (e[1][0] = o[1]), o[1] > e[1][1] && (e[1][1] = o[1]);
					}return e && u(e);
				} };
		}, function (t, e, i) {
			"use strict";
			i(394), i(395), i(369);
		}, function (t, e, i) {
			"use strict";
			var n = i(1),
			    a = i(3),
			    o = i(7),
			    r = i(4),
			    s = { EN: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], CN: ["", "", "", "", "", "", "", "", "", "", "", ""] },
			    l = { EN: ["S", "M", "T", "W", "T", "F", "S"], CN: ["", "", "", "", "", "", ""] };t.exports = i(2).extendComponentView({ type: "calendar", _tlpoints: null, _blpoints: null, _firstDayOfMonth: null, _firstDayPoints: null, render: function render(t, e, i) {
					var n = this.group;n.removeAll();var a = t.coordinateSystem,
					    o = a.getRangeInfo(),
					    r = a.getOrient();this._renderDayRect(t, o, n), this._renderLines(t, o, r, n), this._renderYearText(t, o, r, n), this._renderMonthText(t, r, n), this._renderWeekText(t, o, r, n);
				}, _renderDayRect: function _renderDayRect(t, e, i) {
					for (var n = t.coordinateSystem, o = t.getModel("itemStyle.normal").getItemStyle(), r = n.getCellWidth(), s = n.getCellHeight(), l = e.start.time; l <= e.end.time; l = n.getNextNDay(l, 1).time) {
						var u = n.dataToRect([l], !1).tl,
						    c = new a.Rect({ shape: { x: u[0], y: u[1], width: r, height: s }, style: o });i.add(c);
					}
				}, _renderLines: function _renderLines(t, e, i, n) {
					function a(e) {
						o._firstDayOfMonth.push(r.getDateInfo(e)), o._firstDayPoints.push(r.dataToRect([e], !1).tl);var a = o._getLinePointsOfOneWeek(t, e, i);o._tlpoints.push(a[0]), o._blpoints.push(a[a.length - 1]), l && o._drawSplitline(a, s, n);
					}var o = this,
					    r = t.coordinateSystem,
					    s = t.getModel("splitLine.lineStyle").getLineStyle(),
					    l = t.get("splitLine.show"),
					    u = s.lineWidth;this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];for (var c = e.start, h = 0; c.time <= e.end.time; h++) {
						a(c.formatedDate), 0 === h && (c = r.getDateInfo(e.start.y + "-" + e.start.m));var d = c.date;d.setMonth(d.getMonth() + 1), c = r.getDateInfo(d);
					}a(r.getNextNDay(e.end.time, 1).formatedDate), l && this._drawSplitline(o._getEdgesPoints(o._tlpoints, u, i), s, n), l && this._drawSplitline(o._getEdgesPoints(o._blpoints, u, i), s, n);
				}, _getEdgesPoints: function _getEdgesPoints(t, e, i) {
					var n = [t[0].slice(), t[t.length - 1].slice()],
					    a = "horizontal" === i ? 0 : 1;return n[0][a] = n[0][a] - e / 2, n[1][a] = n[1][a] + e / 2, n;
				}, _drawSplitline: function _drawSplitline(t, e, i) {
					var n = new a.Polyline({ z2: 20, shape: { points: t }, style: e });i.add(n);
				}, _getLinePointsOfOneWeek: function _getLinePointsOfOneWeek(t, e, i) {
					var n = t.coordinateSystem;e = n.getDateInfo(e);for (var a = [], o = 0; o < 7; o++) {
						var r = n.getNextNDay(e.time, o),
						    s = n.dataToRect([r.time], !1);a[2 * r.day] = s.tl, a[2 * r.day + 1] = s["horizontal" === i ? "bl" : "tr"];
					}return a;
				}, _formatterLabel: function _formatterLabel(t, e) {
					return "string" == typeof t && t ? o.formatTplSimple(t, e) : "function" == typeof t ? t(e) : e.nameMap;
				}, _yearTextPositionControl: function _yearTextPositionControl(t, e, i, n) {
					t = t.slice();var a = ["center", "bottom"];"top" === i && (t[1] -= n), "bottom" === i && (t[1] += n, a = ["center", "top"]), "left" === i && (t[0] -= n), "right" === i && (t[0] += n, a = ["center", "top"]);var o = 0;return "left" !== i && "right" !== i || (o = Math.PI / 2), { rotation: o, origin: t, style: { x: t[0], y: t[1], textAlign: a[0], textVerticalAlign: a[1] } };
				}, _renderYearText: function _renderYearText(t, e, i, o) {
					var r = t.getModel("yearLabel");if (r.get("show")) {
						var s = t.getModel("yearLabel.textStyle"),
						    l = r.get("margin"),
						    u = r.get("position");u || (u = "horizontal" !== i ? "top" : "left");var c = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]],
						    h = (c[0][0] + c[1][0]) / 2,
						    d = (c[0][1] + c[1][1]) / 2,
						    f = "horizontal" === i ? 0 : 1,
						    p = { top: [h, c[f][1]], bottom: [h, c[1 - f][1]], left: [c[1 - f][0], d], right: [c[f][0], d] },
						    g = e.start.y;+e.end.y > +e.start.y && (g = g + "-" + e.end.y);var m = r.get("formatter"),
						    v = { start: e.start.y, end: e.end.y, nameMap: g },
						    y = this._formatterLabel(m, v),
						    x = new a.Text(n.merge({ z2: 30, style: { text: y, font: s.getFont(), fill: s.getTextColor() } }, this._yearTextPositionControl(p[u], i, u, l)));o.add(x);
					}
				}, _monthTextPositionControl: function _monthTextPositionControl(t, e, i, n, a) {
					var o = "left",
					    r = "top",
					    s = t[0],
					    l = t[1];return "horizontal" === i ? (l += a, e && (o = "center"), "start" === n && (r = "bottom")) : (s += a, e && (r = "middle"), "start" === n && (o = "right")), { x: s, y: l, textAlign: o, textVerticalAlign: r };
				}, _renderMonthText: function _renderMonthText(t, e, i) {
					var o = t.getModel("monthLabel");if (o.get("show")) {
						var r = t.getModel("monthLabel.textStyle"),
						    l = o.get("nameMap"),
						    u = o.get("margin"),
						    c = o.get("position"),
						    h = o.get("align"),
						    d = [this._tlpoints, this._blpoints];n.isString(l) && (l = s[l.toUpperCase()] || []);var f = "start" === c ? 0 : 1,
						    p = "horizontal" === e ? 0 : 1;u = "start" === c ? -u : u;for (var g = "center" === h, m = 0; m < d[f].length - 1; m++) {
							var v = d[f][m].slice(),
							    y = this._firstDayOfMonth[m];if (g) {
								var x = this._firstDayPoints[m];v[p] = (x[p] + d[0][m + 1][p]) / 2;
							}var _ = o.get("formatter"),
							    b = l[+y.m - 1],
							    w = { yyyy: y.y, yy: (y.y + "").slice(2), MM: y.m, M: +y.m, nameMap: b },
							    S = this._formatterLabel(_, w),
							    M = new a.Text({ z2: 30, style: n.extend({ text: S, font: r.getFont(), fill: r.getTextColor() }, this._monthTextPositionControl(v, g, e, c, u)) });i.add(M);
						}
					}
				}, _weekTextPositionControl: function _weekTextPositionControl(t, e, i, n, a) {
					var o = "center",
					    r = "middle",
					    s = t[0],
					    l = t[1],
					    u = "start" === i;return "horizontal" === e ? (s = s + n + (u ? 1 : -1) * a[0] / 2, o = u ? "right" : "left") : (l = l + n + (u ? 1 : -1) * a[1] / 2, r = u ? "bottom" : "top"), { x: s, y: l, textAlign: o, textVerticalAlign: r };
				}, _renderWeekText: function _renderWeekText(t, e, i, o) {
					var s = t.getModel("dayLabel");if (s.get("show")) {
						var u = t.coordinateSystem,
						    c = t.getModel("dayLabel.textStyle"),
						    h = s.get("position"),
						    d = s.get("nameMap"),
						    f = s.get("margin"),
						    p = u.getFirstDayOfWeek();n.isString(d) && (d = l[d.toUpperCase()] || []);var g = u.getNextNDay(e.end.time, 7 - e.lweek).time,
						    m = [u.getCellWidth(), u.getCellHeight()];f = r.parsePercent(f, m["horizontal" === i ? 0 : 1]), "start" === h && (g = u.getNextNDay(e.start.time, -(7 + e.fweek)).time, f = -f);for (var v = 0; v < 7; v++) {
							var y = u.getNextNDay(g, v),
							    x = u.dataToRect([y.time], !1).center,
							    _ = v;_ = Math.abs((v + p) % 7);var b = new a.Text({ z2: 30, style: n.extend({ text: d[_], font: c.getFont(),
									fill: c.getTextColor() }, this._weekTextPositionControl(x, i, h, f, m)) });o.add(b);
						}
					}
				} });
		}, function (t, e, i) {
			function n(t, e) {
				e.update = "updateView", a.registerAction(e, function (e, i) {
					var n = {};return i.eachComponent({ mainType: "geo", query: e }, function (i) {
						i[t](e.name);var a = i.coordinateSystem;o.each(a.regions, function (t) {
							n[t.name] = i.isSelected(t.name) || !1;
						});
					}), { selected: n, name: e.name };
				});
			}i(399), i(186), i(371), i(240);var a = i(2),
			    o = i(1);n("toggleSelected", { type: "geoToggleSelect", event: "geoselectchanged" }), n("select", { type: "geoSelect", event: "geoselected" }), n("unSelect", { type: "geoUnSelect", event: "geounselected" });
		}, function (t, e, i) {
			"use strict";
			var n = i(249);t.exports = i(2).extendComponentView({ type: "geo", init: function init(t, e) {
					var i = new n(e, !0);this._mapDraw = i, this.group.add(i.group);
				}, render: function render(t, e, i, n) {
					if (!n || "geoToggleSelect" !== n.type || n.from !== this.uid) {
						var a = this._mapDraw;t.get("show") ? a.draw(t, e, i, this, n) : this._mapDraw.group.removeAll(), this.group.silent = t.get("silent");
					}
				}, dispose: function dispose() {
					this._mapDraw && this._mapDraw.remove();
				} });
		}, function (t, e, i) {
			i(263), i(358), i(355);
		}, function (t, e, i) {
			"use strict";
			var n = i(1);i(236), i(353), i(376), i(55), i(359), i(2).registerLayout(n.curry(i(425), "bar")), i(2).extendComponentView({ type: "polar" });
		}, function (t, e, i) {
			i(416), i(417), i(375);
		}, function (t, e, i) {
			var n = i(40),
			    a = i(1),
			    o = i(3),
			    r = ["axisLine", "axisLabel", "axisTick", "axisName"];t.exports = i(2).extendComponentView({ type: "radar", render: function render(t, e, i) {
					var n = this.group;n.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t);
				}, _buildAxes: function _buildAxes(t) {
					var e = t.coordinateSystem,
					    i = e.getIndicatorAxes(),
					    o = a.map(i, function (t) {
						var i = new n(t.model, { position: [e.cx, e.cy], rotation: t.angle, labelDirection: -1, tickDirection: -1, nameDirection: 1 });return i;
					});a.each(o, function (t) {
						a.each(r, t.add, t), this.group.add(t.getGroup());
					}, this);
				}, _buildSplitLineAndArea: function _buildSplitLineAndArea(t) {
					function e(t, e, i) {
						var n = i % e.length;return t[n] = t[n] || [], n;
					}var i = t.coordinateSystem,
					    n = i.getIndicatorAxes();if (n.length) {
						var r = t.get("shape"),
						    s = t.getModel("splitLine"),
						    l = t.getModel("splitArea"),
						    u = s.getModel("lineStyle"),
						    c = l.getModel("areaStyle"),
						    h = s.get("show"),
						    d = l.get("show"),
						    f = u.get("color"),
						    p = c.get("color");f = a.isArray(f) ? f : [f], p = a.isArray(p) ? p : [p];var g = [],
						    m = [];if ("circle" === r) for (var v = n[0].getTicksCoords(), y = i.cx, x = i.cy, _ = 0; _ < v.length; _++) {
							if (h) {
								var b = e(g, f, _);g[b].push(new o.Circle({ shape: { cx: y, cy: x, r: v[_] } }));
							}if (d && _ < v.length - 1) {
								var b = e(m, p, _);m[b].push(new o.Ring({ shape: { cx: y, cy: x, r0: v[_], r: v[_ + 1] } }));
							}
						} else for (var w = -1, S = a.map(n, function (t, e) {
							var n = t.getTicksCoords();return w = Math.max(n.length - 1, w), a.map(n, function (t) {
								return i.coordToPoint(t, e);
							});
						}), M = [], _ = 0; _ <= w; _++) {
							for (var I = [], T = 0; T < n.length; T++) {
								I.push(S[T][_]);
							}if (I[0] && I.push(I[0].slice()), h) {
								var b = e(g, f, _);g[b].push(new o.Polyline({ shape: { points: I } }));
							}if (d && M) {
								var b = e(m, p, _ - 1);m[b].push(new o.Polygon({ shape: { points: I.concat(M) } }));
							}M = I.slice().reverse();
						}var A = u.getLineStyle(),
						    C = c.getAreaStyle();a.each(m, function (t, e) {
							this.group.add(o.mergePath(t, { style: a.defaults({ stroke: "none", fill: p[e % p.length] }, C), silent: !0 }));
						}, this), a.each(g, function (t, e) {
							this.group.add(o.mergePath(t, { style: a.defaults({ fill: "none", stroke: f[e % f.length] }, A), silent: !0 }));
						}, this);
					}
				} });
		}, function (t, e, i) {
			i(236), i(356);
		}, function (t, e, i) {
			var n = i(2);n.registerPreprocessor(i(383)), i(385), i(384), i(378), i(379);
		}, function (t, e, i) {
			var n = i(381),
			    a = i(1),
			    o = i(5),
			    r = n.extend({ type: "timeline.slider", defaultOption: { backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, orient: "horizontal", inverse: !1, tooltip: { trigger: "item" }, symbol: "emptyCircle", symbolSize: 10, lineStyle: { show: !0, width: 2, color: "#304654" }, label: { position: "auto", normal: { show: !0, interval: "auto", rotate: 0, textStyle: { color: "#304654" } }, emphasis: { show: !0, textStyle: { color: "#c23531" } } }, itemStyle: { normal: { color: "#304654", borderWidth: 1 }, emphasis: { color: "#c23531" } }, checkpointStyle: { symbol: "circle", symbolSize: 13, color: "#c23531", borderWidth: 5, borderColor: "rgba(194,53,49, 0.5)", animation: !0, animationDuration: 300, animationEasing: "quinticInOut" }, controlStyle: { show: !0, showPlayBtn: !0, showPrevBtn: !0, showNextBtn: !0, itemSize: 22, itemGap: 12, position: "left", playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z", stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z", nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z", prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z", normal: { color: "#304654", borderColor: "#304654", borderWidth: 1 }, emphasis: { color: "#c23531", borderColor: "#c23531", borderWidth: 2 } }, data: [] } });a.mixin(r, o.dataFormatMixin), t.exports = r;
		}, function (t, e, i) {
			function n(t, e) {
				return u.getLayoutRect(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }, t.get("padding"));
			}function a(t, e, i, n) {
				var a = l.makePath(t.get(e).replace(/^path:\/\//, ""), s.clone(n || {}), new p(i[0], i[1], i[2], i[3]), "center");return a;
			}function o(t, e, i, n, a, o) {
				var r = e.get("color");if (a) a.setColor(r), i.add(a), o && o.onUpdate(a);else {
					var l = t.get("symbol");a = d.createSymbol(l, -1, -1, 2, 2, r), a.setStyle("strokeNoScale", !0), i.add(a), o && o.onCreate(a);
				}var u = e.getItemStyle(["color", "symbol", "symbolSize"]);a.setStyle(u), n = s.merge({ rectHover: !0, z2: 100 }, n, !0);var c = t.get("symbolSize");c = c instanceof Array ? c.slice() : [+c, +c], c[0] /= 2, c[1] /= 2, n.scale = c;var h = t.get("symbolOffset");if (h) {
					var f = n.position = n.position || [0, 0];f[0] += m.parsePercent(h[0], c[0]), f[1] += m.parsePercent(h[1], c[1]);
				}var p = t.get("symbolRotate");return n.rotation = (p || 0) * Math.PI / 180 || 0, a.attr(n), a.updateTransform(), a;
			}function r(t, e, i, n, a) {
				if (!t.dragging) {
					var o = n.getModel("checkpointStyle"),
					    r = i.dataToCoord(n.getData().get(["value"], e));a || !o.get("animation", !0) ? t.attr({ position: [r, 0] }) : (t.stopAnimation(!0), t.animateTo({ position: [r, 0] }, o.get("animationDuration", !0), o.get("animationEasing", !0)));
				}
			}var s = i(1),
			    l = i(3),
			    u = i(12),
			    c = i(382),
			    h = i(380),
			    d = i(24),
			    f = i(18),
			    p = i(11),
			    g = i(19),
			    m = i(4),
			    v = i(7),
			    y = v.encodeHTML,
			    x = s.bind,
			    _ = s.each,
			    b = Math.PI;t.exports = c.extend({ type: "timeline.slider", init: function init(t, e) {
					this.api = e, this._axis, this._viewRect, this._timer, this._currentPointer, this._mainGroup, this._labelGroup;
				}, render: function render(t, e, i, n) {
					if (this.model = t, this.api = i, this.ecModel = e, this.group.removeAll(), t.get("show", !0)) {
						var a = this._layout(t, i),
						    o = this._createGroup("mainGroup"),
						    r = this._createGroup("labelGroup"),
						    s = this._axis = this._createAxis(a, t);t.formatTooltip = function (t) {
							return y(s.scale.getLabel(t));
						}, _(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function (e) {
							this["_render" + e](a, o, s, t);
						}, this), this._renderAxisLabel(a, r, s, t), this._position(a, t);
					}this._doPlayStop();
				}, remove: function remove() {
					this._clearTimer(), this.group.removeAll();
				}, dispose: function dispose() {
					this._clearTimer();
				}, _layout: function _layout(t, e) {
					var i = t.get("label.normal.position"),
					    a = t.get("orient"),
					    o = n(t, e);null == i || "auto" === i ? i = "horizontal" === a ? o.y + o.height / 2 < e.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < e.getWidth() / 2 ? "+" : "-" : isNaN(i) && (i = { horizontal: { top: "-", bottom: "+" }, vertical: { left: "-", right: "+" } }[a][i]);var r = { horizontal: "center", vertical: i >= 0 || "+" === i ? "left" : "right" },
					    s = { horizontal: i >= 0 || "+" === i ? "top" : "bottom", vertical: "middle" },
					    l = { horizontal: 0, vertical: b / 2 },
					    u = "vertical" === a ? o.height : o.width,
					    c = t.getModel("controlStyle"),
					    h = c.get("show"),
					    d = h ? c.get("itemSize") : 0,
					    f = h ? c.get("itemGap") : 0,
					    p = d + f,
					    g = t.get("label.normal.rotate") || 0;g = g * b / 180;var m,
					    v,
					    y,
					    x,
					    _ = c.get("position", !0),
					    h = c.get("show", !0),
					    w = h && c.get("showPlayBtn", !0),
					    S = h && c.get("showPrevBtn", !0),
					    M = h && c.get("showNextBtn", !0),
					    I = 0,
					    T = u;return "left" === _ || "bottom" === _ ? (w && (m = [0, 0], I += p), S && (v = [I, 0], I += p), M && (y = [T - d, 0], T -= p)) : (w && (m = [T - d, 0], T -= p), S && (v = [0, 0], I += p), M && (y = [T - d, 0], T -= p)), x = [I, T], t.get("inverse") && x.reverse(), { viewRect: o, mainLength: u, orient: a, rotation: l[a], labelRotation: g, labelPosOpt: i, labelAlign: r[a], labelBaseline: s[a], playPosition: m, prevBtnPosition: v, nextBtnPosition: y, axisExtent: x, controlSize: d, controlGap: f };
				}, _position: function _position(t, e) {
					function i(t) {
						var e = t.position;t.origin = [h[0][0] - e[0], h[1][0] - e[1]];
					}function n(t) {
						return [[t.x, t.x + t.width], [t.y, t.y + t.height]];
					}function a(t, e, i, n, a) {
						t[n] += i[n][a] - e[n][a];
					}var o = this._mainGroup,
					    r = this._labelGroup,
					    s = t.viewRect;if ("vertical" === t.orient) {
						var l = g.create(),
						    u = s.x,
						    c = s.y + s.height;g.translate(l, l, [-u, -c]), g.rotate(l, l, -b / 2), g.translate(l, l, [u, c]), s = s.clone(), s.applyTransform(l);
					}var h = n(s),
					    d = n(o.getBoundingRect()),
					    f = n(r.getBoundingRect()),
					    p = o.position,
					    m = r.position;m[0] = p[0] = h[0][0];var v = t.labelPosOpt;if (isNaN(v)) {
						var y = "+" === v ? 0 : 1;a(p, d, h, 1, y), a(m, f, h, 1, 1 - y);
					} else {
						var y = v >= 0 ? 0 : 1;a(p, d, h, 1, y), m[1] = p[1] + v;
					}o.attr("position", p), r.attr("position", m), o.rotation = r.rotation = t.rotation, i(o), i(r);
				}, _createAxis: function _createAxis(t, e) {
					var i = e.getData(),
					    n = e.get("axisType"),
					    a = f.createScaleByModel(e, n),
					    o = i.getDataExtent("value");a.setExtent(o[0], o[1]), this._customizeScale(a, i), a.niceTicks();var r = new h("value", a, t.axisExtent, n);return r.model = e, r;
				}, _customizeScale: function _customizeScale(t, e) {
					t.getTicks = function () {
						return e.mapArray(["value"], function (t) {
							return t;
						});
					}, t.getTicksLabels = function () {
						return s.map(this.getTicks(), t.getLabel, t);
					};
				}, _createGroup: function _createGroup(t) {
					var e = this["_" + t] = new l.Group();return this.group.add(e), e;
				}, _renderAxisLine: function _renderAxisLine(t, e, i, n) {
					var a = i.getExtent();n.get("lineStyle.show") && e.add(new l.Line({ shape: { x1: a[0], y1: 0, x2: a[1], y2: 0 }, style: s.extend({ lineCap: "round" }, n.getModel("lineStyle").getLineStyle()), silent: !0, z2: 1 }));
				}, _renderAxisTick: function _renderAxisTick(t, e, i, n) {
					var a = n.getData(),
					    r = i.scale.getTicks();_(r, function (t, r) {
						var s = i.dataToCoord(t),
						    u = a.getItemModel(r),
						    c = u.getModel("itemStyle.normal"),
						    h = u.getModel("itemStyle.emphasis"),
						    d = { position: [s, 0], onclick: x(this._changeTimeline, this, r) },
						    f = o(u, c, e, d);l.setHoverStyle(f, h.getItemStyle()), u.get("tooltip") ? (f.dataIndex = r, f.dataModel = n) : f.dataIndex = f.dataModel = null;
					}, this);
				}, _renderAxisLabel: function _renderAxisLabel(t, e, i, n) {
					var a = n.getModel("label.normal");if (a.get("show")) {
						var o = n.getData(),
						    r = i.scale.getTicks(),
						    s = f.getFormattedLabels(i, a.get("formatter")),
						    u = i.getLabelInterval();_(r, function (n, a) {
							if (!i.isLabelIgnored(a, u)) {
								var r = o.getItemModel(a),
								    c = r.getModel("label.normal.textStyle"),
								    h = r.getModel("label.emphasis.textStyle"),
								    d = i.dataToCoord(n),
								    f = new l.Text({ style: { text: s[a], textAlign: t.labelAlign, textVerticalAlign: t.labelBaseline, textFont: c.getFont(), fill: c.getTextColor() }, position: [d, 0], rotation: t.labelRotation - t.rotation, onclick: x(this._changeTimeline, this, a), silent: !1 });e.add(f), l.setHoverStyle(f, h.getItemStyle());
							}
						}, this);
					}
				}, _renderControl: function _renderControl(t, e, i, n) {
					function o(t, i, o, d) {
						if (t) {
							var f = { position: t, origin: [r / 2, 0], rotation: d ? -s : 0, rectHover: !0, style: u, onclick: o },
							    p = a(n, i, h, f);e.add(p), l.setHoverStyle(p, c);
						}
					}var r = t.controlSize,
					    s = t.rotation,
					    u = n.getModel("controlStyle.normal").getItemStyle(),
					    c = n.getModel("controlStyle.emphasis").getItemStyle(),
					    h = [0, -r / 2, r, r],
					    d = n.getPlayState(),
					    f = n.get("inverse", !0);o(t.nextBtnPosition, "controlStyle.nextIcon", x(this._changeTimeline, this, f ? "-" : "+")), o(t.prevBtnPosition, "controlStyle.prevIcon", x(this._changeTimeline, this, f ? "+" : "-")), o(t.playPosition, "controlStyle." + (d ? "stopIcon" : "playIcon"), x(this._handlePlayClick, this, !d), !0);
				}, _renderCurrentPointer: function _renderCurrentPointer(t, e, i, n) {
					var a = n.getData(),
					    s = n.getCurrentIndex(),
					    l = a.getItemModel(s).getModel("checkpointStyle"),
					    u = this,
					    c = { onCreate: function onCreate(t) {
							t.draggable = !0, t.drift = x(u._handlePointerDrag, u), t.ondragend = x(u._handlePointerDragend, u), r(t, s, i, n, !0);
						}, onUpdate: function onUpdate(t) {
							r(t, s, i, n);
						} };this._currentPointer = o(l, l, this._mainGroup, {}, this._currentPointer, c);
				}, _handlePlayClick: function _handlePlayClick(t) {
					this._clearTimer(), this.api.dispatchAction({ type: "timelinePlayChange", playState: t, from: this.uid });
				}, _handlePointerDrag: function _handlePointerDrag(t, e, i) {
					this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY]);
				}, _handlePointerDragend: function _handlePointerDragend(t) {
					this._pointerChangeTimeline([t.offsetX, t.offsetY], !0);
				}, _pointerChangeTimeline: function _pointerChangeTimeline(t, e) {
					var i = this._toAxisCoord(t)[0],
					    n = this._axis,
					    a = m.asc(n.getExtent().slice());i > a[1] && (i = a[1]), i < a[0] && (i = a[0]), this._currentPointer.position[0] = i, this._currentPointer.dirty();var o = this._findNearestTick(i),
					    r = this.model;(e || o !== r.getCurrentIndex() && r.get("realtime")) && this._changeTimeline(o);
				}, _doPlayStop: function _doPlayStop() {
					function t() {
						var t = this.model;this._changeTimeline(t.getCurrentIndex() + (t.get("rewind", !0) ? -1 : 1));
					}this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(x(t, this), this.model.get("playInterval")));
				}, _toAxisCoord: function _toAxisCoord(t) {
					var e = this._mainGroup.getLocalTransform();return l.applyTransform(t, e, !0);
				}, _findNearestTick: function _findNearestTick(t) {
					var e,
					    i = this.model.getData(),
					    n = 1 / 0,
					    a = this._axis;return i.each(["value"], function (i, o) {
						var r = a.dataToCoord(i),
						    s = Math.abs(r - t);s < n && (n = s, e = o);
					}), e;
				}, _clearTimer: function _clearTimer() {
					this._timer && (clearTimeout(this._timer), this._timer = null);
				}, _changeTimeline: function _changeTimeline(t) {
					var e = this.model.getCurrentIndex();"+" === t ? t = e + 1 : "-" === t && (t = e - 1), this.api.dispatchAction({ type: "timelineChange", currentIndex: t, from: this.uid });
				} });
		}, function (t, e, i) {
			var n = i(1),
			    a = i(33),
			    o = i(18),
			    r = function r(t, e, i, n) {
				a.call(this, t, e, i), this.type = n || "value", this._autoLabelInterval, this.model = null;
			};r.prototype = { constructor: r, getLabelInterval: function getLabelInterval() {
					var t = this.model,
					    e = t.getModel("label.normal"),
					    i = e.get("interval");if (null != i && "auto" != i) return i;var i = this._autoLabelInterval;return i || (i = this._autoLabelInterval = o.getAxisLabelInterval(n.map(this.scale.getTicks(), this.dataToCoord, this), o.getFormattedLabels(this, e.get("formatter")), e.getModel("textStyle").getFont(), "horizontal" === t.get("orient"))), i;
				}, isLabelIgnored: function isLabelIgnored(t) {
					if ("category" === this.type) {
						var e = this.getLabelInterval();return "function" == typeof e && !e(t, this.scale.getLabel(t)) || t % (e + 1);
					}
				} }, n.inherits(r, a), t.exports = r;
		}, function (t, e, i) {
			var n = i(13),
			    a = i(14),
			    o = i(1),
			    r = i(5),
			    s = n.extend({ type: "timeline", layoutMode: "box", defaultOption: { zlevel: 0, z: 4, show: !0, axisType: "time", realtime: !0, left: "20%", top: null, right: "20%", bottom: 0, width: null, height: 40, padding: 5, controlPosition: "left", autoPlay: !1, rewind: !1, loop: !0, playInterval: 2e3, currentIndex: 0, itemStyle: { normal: {}, emphasis: {} }, label: { normal: { textStyle: { color: "#000" } }, emphasis: {} }, data: [] }, init: function init(t, e, i) {
					this._data, this._names, this.mergeDefaultAndTheme(t, i), this._initData();
				}, mergeOption: function mergeOption(t) {
					s.superApply(this, "mergeOption", arguments), this._initData();
				}, setCurrentIndex: function setCurrentIndex(t) {
					null == t && (t = this.option.currentIndex);var e = this._data.count();this.option.loop ? t = (t % e + e) % e : (t >= e && (t = e - 1), t < 0 && (t = 0)), this.option.currentIndex = t;
				}, getCurrentIndex: function getCurrentIndex() {
					return this.option.currentIndex;
				}, isIndexMax: function isIndexMax() {
					return this.getCurrentIndex() >= this._data.count() - 1;
				}, setPlayState: function setPlayState(t) {
					this.option.autoPlay = !!t;
				}, getPlayState: function getPlayState() {
					return !!this.option.autoPlay;
				}, _initData: function _initData() {
					var t = this.option,
					    e = t.data || [],
					    i = t.axisType,
					    n = this._names = [];if ("category" === i) {
						var s = [];o.each(e, function (t, e) {
							var i,
							    a = r.getDataItemValue(t);o.isObject(t) ? (i = o.clone(t), i.value = e) : i = e, s.push(i), o.isString(a) || null != a && !isNaN(a) || (a = ""), n.push(a + "");
						}), e = s;
					}var l = { category: "ordinal", time: "time" }[i] || "number",
					    u = this._data = new a([{ name: "value", type: l }], this);u.initData(e, n);
				}, getData: function getData() {
					return this._data;
				}, getCategories: function getCategories() {
					if ("category" === this.get("axisType")) return this._names.slice();
				} });t.exports = s;
		}, function (t, e, i) {
			var n = i(65);t.exports = n.extend({ type: "timeline" });
		}, function (t, e, i) {
			function n(t) {
				var e = t.type,
				    i = { number: "value", time: "time" };if (i[e] && (t.axisType = i[e], delete t.type), a(t), o(t, "controlPosition")) {
					var n = t.controlStyle || (t.controlStyle = {});o(n, "position") || (n.position = t.controlPosition), "none" !== n.position || o(n, "show") || (n.show = !1, delete n.position), delete t.controlPosition;
				}r.each(t.data || [], function (t) {
					r.isObject(t) && !r.isArray(t) && (!o(t, "value") && o(t, "name") && (t.value = t.name), a(t));
				});
			}function a(t) {
				var e = t.itemStyle || (t.itemStyle = {}),
				    i = e.emphasis || (e.emphasis = {}),
				    n = t.label || t.label || {},
				    a = n.normal || (n.normal = {}),
				    s = { normal: 1, emphasis: 1 };r.each(n, function (t, e) {
					s[e] || o(a, e) || (a[e] = t);
				}), i.label && !o(n, "emphasis") && (n.emphasis = i.label, delete i.label);
			}function o(t, e) {
				return t.hasOwnProperty(e);
			}var r = i(1);t.exports = function (t) {
				var e = t && t.timeline;r.isArray(e) || (e = e ? [e] : []), r.each(e, function (t) {
					t && n(t);
				});
			};
		}, function (t, e, i) {
			var n = i(2),
			    a = i(1);n.registerAction({ type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate" }, function (t, e) {
				var i = e.getComponent("timeline");return i && null != t.currentIndex && (i.setCurrentIndex(t.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.setPlayState(!1)), e.resetOption("timeline"), a.defaults({ currentIndex: i.option.currentIndex }, t);
			}), n.registerAction({ type: "timelinePlayChange", event: "timelinePlayChanged", update: "update" }, function (t, e) {
				var i = e.getComponent("timeline");i && null != t.playState && i.setPlayState(t.playState);
			});
		}, function (t, e, i) {
			i(13).registerSubTypeDefaulter("timeline", function () {
				return "slider";
			});
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				this.model = t, this.ecModel = e, this.api = i, this._brushType, this._brushMode;
			}var a = i(29),
			    o = i(1);n.defaultOption = { show: !0, type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"], icon: { rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13", polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2", lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4", lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4", keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z", clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2" }, title: { rect: "", polygon: "", lineX: "", lineY: "", keep: "", clear: "" } };var r = n.prototype;r.render = r.updateView = r.updateLayout = function (t, e, i) {
				var n, a, r;e.eachComponent({ mainType: "brush" }, function (t) {
					n = t.brushType, a = t.brushOption.brushMode || "single", r |= t.areas.length;
				}), this._brushType = n, this._brushMode = a, o.each(t.get("type", !0), function (e) {
					t.setIconStatus(e, ("keep" === e ? "multiple" === a : "clear" === e ? r : e === n) ? "emphasis" : "normal");
				});
			}, r.getIcons = function () {
				var t = this.model,
				    e = t.get("icon", !0),
				    i = {};return o.each(t.get("type", !0), function (t) {
					e[t] && (i[t] = e[t]);
				}), i;
			}, r.onclick = function (t, e, i) {
				var e = this.api,
				    n = this._brushType,
				    a = this._brushMode;"clear" === i ? (e.dispatchAction({ type: "axisAreaSelect", intervals: [] }), e.dispatchAction({ type: "brush", command: "clear", areas: [] })) : e.dispatchAction({ type: "takeGlobalCursor", key: "brush", brushOption: { brushType: "keep" === i ? n : n !== i && i, brushMode: "keep" === i ? "multiple" === a ? "single" : "multiple" : a } });
			}, a.register("brush", n), t.exports = n;
		}, function (t, e, i) {
			i(392), i(393);
		}, function (t, e, i) {
			function n(t, e, i) {
				if (i[0] === i[1]) return i.slice();for (var n = 200, a = (i[1] - i[0]) / n, o = i[0], r = [], s = 0; s <= n && o < i[1]; s++) {
					r.push(o), o += a;
				}return r.push(i[1]), r;
			}var a = i(253),
			    o = i(1),
			    r = i(4),
			    s = [20, 140],
			    l = a.extend({ type: "visualMap.continuous", defaultOption: { align: "auto", calculable: !1, range: null, realtime: !0, itemHeight: null, itemWidth: null, hoverLink: !0, hoverLinkDataSize: null, hoverLinkOnHandle: !0 }, optionUpdated: function optionUpdated(t, e) {
					l.superApply(this, "optionUpdated", arguments), this.resetTargetSeries(), this.resetExtent(), this.resetVisual(function (t) {
						t.mappingMethod = "linear", t.dataExtent = this.getExtent();
					}), this._resetRange();
				}, resetItemSize: function resetItemSize() {
					l.superApply(this, "resetItemSize", arguments);var t = this.itemSize;"horizontal" === this._orient && t.reverse(), (null == t[0] || isNaN(t[0])) && (t[0] = s[0]), (null == t[1] || isNaN(t[1])) && (t[1] = s[1]);
				}, _resetRange: function _resetRange() {
					var t = this.getExtent(),
					    e = this.option.range;!e || e.auto ? (t.auto = 1, this.option.range = t) : o.isArray(e) && (e[0] > e[1] && e.reverse(), e[0] = Math.max(e[0], t[0]), e[1] = Math.min(e[1], t[1]));
				}, completeVisualOption: function completeVisualOption() {
					a.prototype.completeVisualOption.apply(this, arguments), o.each(this.stateList, function (t) {
						var e = this.option.controller[t].symbolSize;e && e[0] !== e[1] && (e[0] = 0);
					}, this);
				}, setSelected: function setSelected(t) {
					this.option.range = t.slice(), this._resetRange();
				}, getSelected: function getSelected() {
					var t = this.getExtent(),
					    e = r.asc((this.get("range") || []).slice());return e[0] > t[1] && (e[0] = t[1]), e[1] > t[1] && (e[1] = t[1]), e[0] < t[0] && (e[0] = t[0]), e[1] < t[0] && (e[1] = t[0]), e;
				}, getValueState: function getValueState(t) {
					var e = this.option.range,
					    i = this.getExtent();return (e[0] <= i[0] || e[0] <= t) && (e[1] >= i[1] || t <= e[1]) ? "inRange" : "outOfRange";
				}, findTargetDataIndices: function findTargetDataIndices(t) {
					var e = [];return this.eachTargetSeries(function (i) {
						var n = [],
						    a = i.getData();a.each(this.getDataDimension(a), function (e, i) {
							t[0] <= e && e <= t[1] && n.push(i);
						}, !0, this), e.push({ seriesId: i.id, dataIndex: n });
					}, this), e;
				}, getVisualMeta: function getVisualMeta(t) {
					function e(e, i) {
						o.push({ value: e, color: t(e, i) });
					}for (var i = n(this, "outOfRange", this.getExtent()), a = n(this, "inRange", this.option.range.slice()), o = [], r = 0, s = 0, l = a.length, u = i.length; s < u && (!a.length || i[s] <= a[0]); s++) {
						i[s] < a[r] && e(i[s], "outOfRange");
					}for (var c = 1; r < l; r++, c = 0) {
						c && o.length && e(a[r], "outOfRange"), e(a[r], "inRange");
					}for (var c = 1; s < u; s++) {
						(!a.length || a[a.length - 1] < i[s]) && (c && (o.length && e(o[o.length - 1].value, "outOfRange"), c = 0), e(i[s], "outOfRange"));
					}var h = o.length;return { stops: o, outerColors: [h ? o[0].color : "transparent", h ? o[h - 1].color : "transparent"] };
				} });t.exports = l;
		}, function (t, e, i) {
			function n(t, e, i, n) {
				return new u.Polygon({ shape: { points: t }, draggable: !!i, cursor: e, drift: i, onmousemove: function onmousemove(t) {
						m.stop(t.event);
					}, ondragend: n });
			}function a(t, e) {
				return 0 === t ? [[0, 0], [e, 0], [e, -e]] : [[0, 0], [e, 0], [e, e]];
			}function o(t, e, i, n) {
				return t ? [[0, -x(e, _(i, 0))], [w, 0], [0, x(e, _(n - i, 0))]] : [[0, 0], [5, -5], [5, 5]];
			}function r(t, e, i) {
				var n = b / 2,
				    a = t.get("hoverLinkDataSize");return a && (n = v(a, e, i, !0) / 2), n;
			}function s(t) {
				return !t.get("realtime") && t.get("hoverLinkOnHandle");
			}var l = i(254),
			    u = i(3),
			    c = i(1),
			    h = i(4),
			    d = i(56),
			    f = i(100),
			    p = i(255),
			    g = i(5),
			    m = i(21),
			    v = h.linearMap,
			    y = c.each,
			    x = Math.min,
			    _ = Math.max,
			    b = 12,
			    w = 6,
			    S = l.extend({ type: "visualMap.continuous", init: function init() {
					S.superApply(this, "init", arguments), this._shapes = {}, this._dataInterval = [], this._handleEnds = [], this._orient, this._useHandle, this._hoverLinkDataIndices = [], this._dragging, this._hovering;
				}, doRender: function doRender(t, e, i, n) {
					n && "selectDataRange" === n.type && n.from === this.uid || this._buildView();
				}, _buildView: function _buildView() {
					this.group.removeAll();var t = this.visualMapModel,
					    e = this.group;this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(e);var i = t.get("text");this._renderEndsText(e, i, 0), this._renderEndsText(e, i, 1), this._updateView(!0), this.renderBackground(e), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(e);
				}, _renderEndsText: function _renderEndsText(t, e, i) {
					if (e) {
						var n = e[1 - i];n = null != n ? n + "" : "";var a = this.visualMapModel,
						    o = a.get("textGap"),
						    r = a.itemSize,
						    s = this._shapes.barGroup,
						    l = this._applyTransform([r[0] / 2, 0 === i ? -o : r[1] + o], s),
						    c = this._applyTransform(0 === i ? "bottom" : "top", s),
						    h = this._orient,
						    d = this.visualMapModel.textStyleModel;this.group.add(new u.Text({ style: { x: l[0], y: l[1], textVerticalAlign: "horizontal" === h ? "middle" : c, textAlign: "horizontal" === h ? c : "center", text: n, textFont: d.getFont(), fill: d.getTextColor() } }));
					}
				}, _renderBar: function _renderBar(t) {
					var e = this.visualMapModel,
					    i = this._shapes,
					    a = e.itemSize,
					    o = this._orient,
					    r = this._useHandle,
					    s = p.getItemAlign(e, this.api, a),
					    l = i.barGroup = this._createBarGroup(s);l.add(i.outOfRange = n()), l.add(i.inRange = n(null, r ? "move" : null, c.bind(this._dragHandle, this, "all", !1), c.bind(this._dragHandle, this, "all", !0)));var u = e.textStyleModel.getTextRect(""),
					    h = _(u.width, u.height);r && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(l, 0, a, h, o, s), this._createHandle(l, 1, a, h, o, s)), this._createIndicator(l, a, h, o), t.add(l);
				}, _createHandle: function _createHandle(t, e, i, o, r) {
					var s = c.bind(this._dragHandle, this, e, !1),
					    l = c.bind(this._dragHandle, this, e, !0),
					    h = n(a(e, o), "move", s, l);h.position[0] = i[0], t.add(h);var d = this.visualMapModel.textStyleModel,
					    f = new u.Text({ draggable: !0, drift: s, onmousemove: function onmousemove(t) {
							m.stop(t.event);
						}, ondragend: l, style: { x: 0, y: 0, text: "", textFont: d.getFont(), fill: d.getTextColor() } });this.group.add(f);var p = ["horizontal" === r ? o / 2 : 1.5 * o, "horizontal" === r ? 0 === e ? -(1.5 * o) : 1.5 * o : 0 === e ? -o / 2 : o / 2],
					    g = this._shapes;g.handleThumbs[e] = h, g.handleLabelPoints[e] = p, g.handleLabels[e] = f;
				}, _createIndicator: function _createIndicator(t, e, i, a) {
					var o = n([[0, 0]], "move");o.position[0] = e[0], o.attr({ invisible: !0, silent: !0 }), t.add(o);var r = this.visualMapModel.textStyleModel,
					    s = new u.Text({ silent: !0, invisible: !0, style: { x: 0, y: 0, text: "", textFont: r.getFont(), fill: r.getTextColor() } });this.group.add(s);var l = ["horizontal" === a ? i / 2 : w + 3, 0],
					    c = this._shapes;c.indicator = o, c.indicatorLabel = s, c.indicatorLabelPoint = l;
				}, _dragHandle: function _dragHandle(t, e, i, n) {
					if (this._useHandle) {
						if (this._dragging = !e, !e) {
							var a = this._applyTransform([i, n], this._shapes.barGroup, !0);this._updateInterval(t, a[1]), this._updateView();
						}e === !this.visualMapModel.get("realtime") && this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: this._dataInterval.slice() }), e ? !this._hovering && this._clearHoverLinkToSeries() : s(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1);
					}
				}, _resetInterval: function _resetInterval() {
					var t = this.visualMapModel,
					    e = this._dataInterval = t.getSelected(),
					    i = t.getExtent(),
					    n = [0, t.itemSize[1]];this._handleEnds = [v(e[0], i, n, !0), v(e[1], i, n, !0)];
				}, _updateInterval: function _updateInterval(t, e) {
					e = e || 0;var i = this.visualMapModel,
					    n = this._handleEnds,
					    a = [0, i.itemSize[1]];d(e, n, a, t, 0);var o = i.getExtent();this._dataInterval = [v(n[0], a, o, !0), v(n[1], a, o, !0)];
				}, _updateView: function _updateView(t) {
					var e = this.visualMapModel,
					    i = e.getExtent(),
					    n = this._shapes,
					    a = [0, e.itemSize[1]],
					    o = t ? a : this._handleEnds,
					    r = this._createBarVisual(this._dataInterval, i, o, "inRange"),
					    s = this._createBarVisual(i, i, a, "outOfRange");n.inRange.setStyle({ fill: r.barColor, opacity: r.opacity }).setShape("points", r.barPoints), n.outOfRange.setStyle({ fill: s.barColor, opacity: s.opacity }).setShape("points", s.barPoints), this._updateHandle(o, r);
				}, _createBarVisual: function _createBarVisual(t, e, i, n) {
					var a = { forceState: n, convertOpacityToAlpha: !0 },
					    o = this._makeColorGradient(t, a),
					    r = [this.getControllerVisual(t[0], "symbolSize", a), this.getControllerVisual(t[1], "symbolSize", a)],
					    s = this._createBarPoints(i, r);return { barColor: new f(0, 0, 0, 1, o), barPoints: s, handlesColor: [o[0].color, o[o.length - 1].color] };
				}, _makeColorGradient: function _makeColorGradient(t, e) {
					var i = 100,
					    n = [],
					    a = (t[1] - t[0]) / i;n.push({ color: this.getControllerVisual(t[0], "color", e), offset: 0 });for (var o = 1; o < i; o++) {
						var r = t[0] + a * o;if (r > t[1]) break;n.push({ color: this.getControllerVisual(r, "color", e), offset: o / i });
					}return n.push({ color: this.getControllerVisual(t[1], "color", e), offset: 1 }), n;
				}, _createBarPoints: function _createBarPoints(t, e) {
					var i = this.visualMapModel.itemSize;return [[i[0] - e[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - e[1], t[1]]];
				}, _createBarGroup: function _createBarGroup(t) {
					var e = this._orient,
					    i = this.visualMapModel.get("inverse");return new u.Group("horizontal" !== e || i ? "horizontal" === e && i ? { scale: "bottom" === t ? [-1, 1] : [1, 1], rotation: -Math.PI / 2 } : "vertical" !== e || i ? { scale: "left" === t ? [1, 1] : [-1, 1] } : { scale: "left" === t ? [1, -1] : [-1, -1] } : { scale: "bottom" === t ? [1, 1] : [-1, 1], rotation: Math.PI / 2 });
				}, _updateHandle: function _updateHandle(t, e) {
					if (this._useHandle) {
						var i = this._shapes,
						    n = this.visualMapModel,
						    a = i.handleThumbs,
						    o = i.handleLabels;y([0, 1], function (r) {
							var s = a[r];s.setStyle("fill", e.handlesColor[r]), s.position[1] = t[r];var l = u.applyTransform(i.handleLabelPoints[r], u.getTransform(s, this.group));o[r].setStyle({ x: l[0], y: l[1], text: n.formatValueText(this._dataInterval[r]), textVerticalAlign: "middle", textAlign: this._applyTransform("horizontal" === this._orient ? 0 === r ? "bottom" : "top" : "left", i.barGroup) });
						}, this);
					}
				}, _showIndicator: function _showIndicator(t, e, i, n) {
					var a = this.visualMapModel,
					    r = a.getExtent(),
					    s = a.itemSize,
					    l = [0, s[1]],
					    c = v(t, r, l, !0),
					    h = this._shapes,
					    d = h.indicator;if (d) {
						d.position[1] = c, d.attr("invisible", !1), d.setShape("points", o(!!i, n, c, s[1]));var f = { convertOpacityToAlpha: !0 },
						    p = this.getControllerVisual(t, "color", f);d.setStyle("fill", p);var g = u.applyTransform(h.indicatorLabelPoint, u.getTransform(d, this.group)),
						    m = h.indicatorLabel;m.attr("invisible", !1);var y = this._applyTransform("left", h.barGroup),
						    x = this._orient;m.setStyle({ text: (i ? i : "") + a.formatValueText(e), textVerticalAlign: "horizontal" === x ? y : "middle", textAlign: "horizontal" === x ? "center" : y, x: g[0], y: g[1] });
					}
				}, _enableHoverLinkToSeries: function _enableHoverLinkToSeries() {
					var t = this;this._shapes.barGroup.on("mousemove", function (e) {
						if (t._hovering = !0, !t._dragging) {
							var i = t.visualMapModel.itemSize,
							    n = t._applyTransform([e.offsetX, e.offsetY], t._shapes.barGroup, !0, !0);n[1] = x(_(0, n[1]), i[1]), t._doHoverLinkToSeries(n[1], 0 <= n[0] && n[0] <= i[0]);
						}
					}).on("mouseout", function () {
						t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries();
					});
				}, _enableHoverLinkFromSeries: function _enableHoverLinkFromSeries() {
					var t = this.api.getZr();this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
				}, _doHoverLinkToSeries: function _doHoverLinkToSeries(t, e) {
					var i = this.visualMapModel,
					    n = i.itemSize;if (i.option.hoverLink) {
						var a = [0, n[1]],
						    o = i.getExtent();t = x(_(a[0], t), a[1]);var l = r(i, o, a),
						    u = [t - l, t + l],
						    c = v(t, a, o, !0),
						    h = [v(u[0], a, o, !0), v(u[1], a, o, !0)];u[0] < a[0] && (h[0] = -(1 / 0)), u[1] > a[1] && (h[1] = 1 / 0), e && (h[0] === -(1 / 0) ? this._showIndicator(c, h[1], "< ", l) : h[1] === 1 / 0 ? this._showIndicator(c, h[0], "> ", l) : this._showIndicator(c, c, " ", l));var d = this._hoverLinkDataIndices,
						    f = [];(e || s(i)) && (f = this._hoverLinkDataIndices = i.findTargetDataIndices(h));var m = g.compressBatches(d, f);this._dispatchHighDown("downplay", p.convertDataIndex(m[0])), this._dispatchHighDown("highlight", p.convertDataIndex(m[1]));
					}
				}, _hoverLinkFromSeriesMouseOver: function _hoverLinkFromSeriesMouseOver(t) {
					var e = t.target,
					    i = this.visualMapModel;if (e && null != e.dataIndex) {
						var n = this.ecModel.getSeriesByIndex(e.seriesIndex);if (i.isTargetSeries(n)) {
							var a = n.getData(e.dataType),
							    o = a.getDimension(i.getDataDimension(a)),
							    r = a.get(o, e.dataIndex, !0);isNaN(r) || this._showIndicator(r, r);
						}
					}
				}, _hideIndicator: function _hideIndicator() {
					var t = this._shapes;t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0);
				}, _clearHoverLinkToSeries: function _clearHoverLinkToSeries() {
					this._hideIndicator();var t = this._hoverLinkDataIndices;this._dispatchHighDown("downplay", p.convertDataIndex(t)), t.length = 0;
				}, _clearHoverLinkFromSeries: function _clearHoverLinkFromSeries() {
					this._hideIndicator();var t = this.api.getZr();t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator);
				}, _applyTransform: function _applyTransform(t, e, i, n) {
					var a = u.getTransform(e, n ? null : this.group);return u[c.isArray(t) ? "applyTransform" : "transformDirection"](t, a, i);
				}, _dispatchHighDown: function _dispatchHighDown(t, e) {
					e && e.length && this.api.dispatchAction({ type: t, batch: e });
				}, dispose: function dispose() {
					this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
				}, remove: function remove() {
					this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
				} });t.exports = S;
		}, function (t, e, i) {
			function n(t, e) {
				var i = t.inverse;("vertical" === t.orient ? !i : i) && e.reverse();
			}var a = i(253),
			    o = i(1),
			    r = i(83),
			    s = i(266),
			    l = i(4).reformIntervals,
			    u = a.extend({ type: "visualMap.piecewise", defaultOption: { selected: null, minOpen: !1, maxOpen: !1, align: "auto", itemWidth: 20, itemHeight: 14, itemSymbol: "roundRect", pieceList: null, categories: null, splitNumber: 5, selectedMode: "multiple", itemGap: 10, hoverLink: !0, showLabel: null }, optionUpdated: function optionUpdated(t, e) {
					u.superApply(this, "optionUpdated", arguments), this._pieceList = [], this.resetTargetSeries(), this.resetExtent();var i = this._mode = this._determineMode();c[this._mode].call(this), this._resetSelected(t, e);var n = this.option.categories;this.resetVisual(function (t, e) {
						"categories" === i ? (t.mappingMethod = "category", t.categories = o.clone(n)) : (t.dataExtent = this.getExtent(), t.mappingMethod = "piecewise", t.pieceList = o.map(this._pieceList, function (t) {
							var t = o.clone(t);return "inRange" !== e && (t.visual = null), t;
						}));
					});
				}, completeVisualOption: function completeVisualOption() {
					function t(t, e, i) {
						return t && t[e] && (o.isObject(t[e]) ? t[e].hasOwnProperty(i) : t[e] === i);
					}var e = this.option,
					    i = {},
					    n = r.listVisualTypes(),
					    l = this.isCategory();o.each(e.pieces, function (t) {
						o.each(n, function (e) {
							t.hasOwnProperty(e) && (i[e] = 1);
						});
					}), o.each(i, function (i, n) {
						var a = 0;o.each(this.stateList, function (i) {
							a |= t(e, i, n) || t(e.target, i, n);
						}, this), !a && o.each(this.stateList, function (t) {
							(e[t] || (e[t] = {}))[n] = s.get(n, "inRange" === t ? "active" : "inactive", l);
						});
					}, this), a.prototype.completeVisualOption.apply(this, arguments);
				}, _resetSelected: function _resetSelected(t, e) {
					var i = this.option,
					    n = this._pieceList,
					    a = (e ? i : t).selected || {};if (i.selected = a, o.each(n, function (t, e) {
						var i = this.getSelectedMapKey(t);a.hasOwnProperty(i) || (a[i] = !0);
					}, this), "single" === i.selectedMode) {
						var r = !1;o.each(n, function (t, e) {
							var i = this.getSelectedMapKey(t);a[i] && (r ? a[i] = !1 : r = !0);
						}, this);
					}
				}, getSelectedMapKey: function getSelectedMapKey(t) {
					return "categories" === this._mode ? t.value + "" : t.index + "";
				}, getPieceList: function getPieceList() {
					return this._pieceList;
				}, _determineMode: function _determineMode() {
					var t = this.option;return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
				}, setSelected: function setSelected(t) {
					this.option.selected = o.clone(t);
				}, getValueState: function getValueState(t) {
					var e = r.findPieceIndex(t, this._pieceList);return null != e && this.option.selected[this.getSelectedMapKey(this._pieceList[e])] ? "inRange" : "outOfRange";
				}, findTargetDataIndices: function findTargetDataIndices(t) {
					var e = [];return this.eachTargetSeries(function (i) {
						var n = [],
						    a = i.getData();a.each(this.getDataDimension(a), function (e, i) {
							var a = r.findPieceIndex(e, this._pieceList);a === t && n.push(i);
						}, !0, this), e.push({ seriesId: i.id, dataIndex: n });
					}, this), e;
				}, getRepresentValue: function getRepresentValue(t) {
					var e;if (this.isCategory()) e = t.value;else if (null != t.value) e = t.value;else {
						var i = t.interval || [];e = i[0] === -(1 / 0) && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
					}return e;
				}, getVisualMeta: function getVisualMeta(t) {
					function e(e, o) {
						var r = a.getRepresentValue({ interval: e });o || (o = a.getValueState(r));var s = t(r, o);e[0] === -(1 / 0) ? n[0] = s : e[1] === 1 / 0 ? n[1] = s : i.push({ value: e[0], color: s }, { value: e[1], color: s });
					}if (!this.isCategory()) {
						var i = [],
						    n = [],
						    a = this,
						    r = this._pieceList.slice();if (r.length) {
							var s = r[0].interval[0];s !== -(1 / 0) && r.unshift({ interval: [-(1 / 0), s] }), s = r[r.length - 1].interval[1], s !== 1 / 0 && r.push({ interval: [s, 1 / 0] });
						} else r.push({ interval: [-(1 / 0), 1 / 0] });var l = -(1 / 0);return o.each(r, function (t) {
							var i = t.interval;i && (i[0] > l && e([l, i[0]], "outOfRange"), e(i.slice()), l = i[1]);
						}, this), { stops: i, outerColors: n };
					}
				} }),
			    c = { splitNumber: function splitNumber() {
					var t = this.option,
					    e = this._pieceList,
					    i = t.precision,
					    n = this.getExtent(),
					    a = t.splitNumber;a = Math.max(parseInt(a, 10), 1), t.splitNumber = a;for (var r = (n[1] - n[0]) / a; +r.toFixed(i) !== r && i < 5;) {
						i++;
					}t.precision = i, r = +r.toFixed(i);var s = 0;t.minOpen && e.push({ index: s++, interval: [-(1 / 0), n[0]], close: [0, 0] });for (var u = n[0], c = s + a; s < c; u += r) {
						var h = s === a - 1 ? n[1] : u + r;e.push({ index: s++, interval: [u, h], close: [1, 1] });
					}t.maxOpen && e.push({ index: s++, interval: [n[1], 1 / 0], close: [0, 0] }), l(e), o.each(e, function (t) {
						t.text = this.formatValueText(t.interval);
					}, this);
				}, categories: function categories() {
					var t = this.option;o.each(t.categories, function (t) {
						this._pieceList.push({ text: this.formatValueText(t, !0), value: t });
					}, this), n(t, this._pieceList);
				}, pieces: function pieces() {
					var t = this.option,
					    e = this._pieceList;o.each(t.pieces, function (t, i) {
						o.isObject(t) || (t = { value: t });var n = { text: "", index: i };if (null != t.label && (n.text = t.label), t.hasOwnProperty("value")) {
							var a = n.value = t.value;n.interval = [a, a], n.close = [1, 1];
						} else {
							for (var s = n.interval = [], l = n.close = [0, 0], u = [1, 0, 1], c = [-(1 / 0), 1 / 0], h = [], d = 0; d < 2; d++) {
								for (var f = [["gte", "gt", "min"], ["lte", "lt", "max"]][d], p = 0; p < 3 && null == s[d]; p++) {
									s[d] = t[f[p]], l[d] = u[p], h[d] = 2 === p;
								}null == s[d] && (s[d] = c[d]);
							}h[0] && s[1] === 1 / 0 && (l[0] = 0), h[1] && s[0] === -(1 / 0) && (l[1] = 0), s[0] === s[1] && l[0] && l[1] && (n.value = s[0]);
						}n.visual = r.retrieveVisuals(t), e.push(n);
					}, this), n(t, e), l(e), o.each(e, function (t) {
						var e = t.close,
						    i = [["<", ""][e[1]], [">", ""][e[0]]];t.text = t.text || this.formatValueText(null != t.value ? t.value : t.interval, !1, i);
					}, this);
				} };t.exports = u;
		}, function (t, e, i) {
			var n = i(254),
			    a = i(1),
			    o = i(3),
			    r = i(24),
			    s = i(12),
			    l = i(255),
			    u = n.extend({ type: "visualMap.piecewise", doRender: function doRender() {
					function t(t) {
						var r = t.piece,
						    s = new o.Group();s.onclick = a.bind(this._onItemClick, this, r), this._enableHoverLink(s, t.indexInModelPieceList);var d = i.getRepresentValue(r);if (this._createItemSymbol(s, d, [0, 0, h[0], h[1]]), p) {
							var f = this.visualMapModel.getValueState(d);s.add(new o.Text({ style: { x: "right" === c ? -n : h[0] + n, y: h[1] / 2, text: r.text, textVerticalAlign: "middle", textAlign: c, textFont: l, fill: u, opacity: "outOfRange" === f ? .5 : 1 } }));
						}e.add(s);
					}var e = this.group;e.removeAll();var i = this.visualMapModel,
					    n = i.get("textGap"),
					    r = i.textStyleModel,
					    l = r.getFont(),
					    u = r.getTextColor(),
					    c = this._getItemAlign(),
					    h = i.itemSize,
					    d = this._getViewData(),
					    f = d.endsText,
					    p = a.retrieve(i.get("showLabel", !0), !f);f && this._renderEndsText(e, f[0], h, p, c), a.each(d.viewPieceList, t, this), f && this._renderEndsText(e, f[1], h, p, c), s.box(i.get("orient"), e, i.get("itemGap")), this.renderBackground(e), this.positionGroup(e);
				}, _enableHoverLink: function _enableHoverLink(t, e) {
					function i(t) {
						var i = this.visualMapModel;i.option.hoverLink && this.api.dispatchAction({ type: t, batch: l.convertDataIndex(i.findTargetDataIndices(e)) });
					}t.on("mouseover", a.bind(i, this, "highlight")).on("mouseout", a.bind(i, this, "downplay"));
				}, _getItemAlign: function _getItemAlign() {
					var t = this.visualMapModel,
					    e = t.option;if ("vertical" === e.orient) return l.getItemAlign(t, this.api, t.itemSize);var i = e.align;return i && "auto" !== i || (i = "left"), i;
				}, _renderEndsText: function _renderEndsText(t, e, i, n, a) {
					if (e) {
						var r = new o.Group(),
						    s = this.visualMapModel.textStyleModel;r.add(new o.Text({ style: { x: n ? "right" === a ? i[0] : 0 : i[0] / 2, y: i[1] / 2, textVerticalAlign: "middle", textAlign: n ? a : "center", text: e, textFont: s.getFont(), fill: s.getTextColor() } })), t.add(r);
					}
				}, _getViewData: function _getViewData() {
					var t = this.visualMapModel,
					    e = a.map(t.getPieceList(), function (t, e) {
						return { piece: t, indexInModelPieceList: e };
					}),
					    i = t.get("text"),
					    n = t.get("orient"),
					    o = t.get("inverse");return ("horizontal" === n ? o : !o) ? e.reverse() : i && (i = i.slice().reverse()), { viewPieceList: e, endsText: i };
				}, _createItemSymbol: function _createItemSymbol(t, e, i) {
					t.add(r.createSymbol(this.getControllerVisual(e, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(e, "color")));
				}, _onItemClick: function _onItemClick(t) {
					var e = this.visualMapModel,
					    i = e.option,
					    n = a.clone(i.selected),
					    o = e.getSelectedMapKey(t);"single" === i.selectedMode ? (n[o] = !0, a.each(n, function (t, e) {
						n[e] = e === o;
					})) : n[o] = !n[o], this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: n });
				} });t.exports = u;
		}, function (t, e, i) {
			i(2).registerPreprocessor(i(256)), i(257), i(258), i(388), i(389), i(259);
		}, function (t, e, i) {
			i(2).registerPreprocessor(i(256)), i(257), i(258), i(390), i(391), i(259);
		}, function (t, e, i) {
			"use strict";
			function n(t, e, i) {
				this._model = t;
			}function a(t, e, i, n) {
				var a = i.calendarModel,
				    o = i.seriesModel,
				    r = a ? a.coordinateSystem : o ? o.coordinateSystem : null;return r === this ? r[t](n) : null;
			}var o = i(12),
			    r = i(4),
			    s = i(1),
			    l = 864e5;n.prototype = { constructor: n, type: "calendar", dimensions: ["time", "value"], getDimensionsInfo: function getDimensionsInfo() {
					return [{ name: "time", type: "time" }];
				}, getRangeInfo: function getRangeInfo() {
					return this._rangeInfo;
				}, getModel: function getModel() {
					return this._model;
				}, getRect: function getRect() {
					return this._rect;
				}, getCellWidth: function getCellWidth() {
					return this._sw;
				}, getCellHeight: function getCellHeight() {
					return this._sh;
				}, getOrient: function getOrient() {
					return this._orient;
				}, getFirstDayOfWeek: function getFirstDayOfWeek() {
					return this._firstDayOfWeek;
				}, getDateInfo: function getDateInfo(t) {
					t = r.parseDate(t);var e = t.getFullYear(),
					    i = t.getMonth() + 1;i = i < 10 ? "0" + i : i;var n = t.getDate();n = n < 10 ? "0" + n : n;var a = t.getDay();return a = Math.abs((a + 7 - this.getFirstDayOfWeek()) % 7), { y: e, m: i, d: n, day: a, time: t.getTime(), formatedDate: e + "-" + i + "-" + n, date: t };
				}, getNextNDay: function getNextNDay(t, e) {
					if (e = e || 0, 0 === e) return this.getDateInfo(t);var i = this.getDateInfo(t).time;return this.getDateInfo(i + l * e);
				}, update: function update(t, e) {
					function i(t, e) {
						return null != t[e] && "auto" !== t[e];
					}this._firstDayOfWeek = this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle.normal").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());var n = this._rangeInfo.weeks || 1,
					    a = ["width", "height"],
					    r = this._model.get("cellSize").slice(),
					    l = this._model.getBoxLayoutParams(),
					    u = "horizontal" === this._orient ? [n, 7] : [7, n];s.each([0, 1], function (t) {
						i(r, t) && (l[a[t]] = r[t] * u[t]);
					});var c = { width: e.getWidth(), height: e.getHeight() },
					    h = this._rect = o.getLayoutRect(l, c);s.each([0, 1], function (t) {
						i(r, t) || (r[t] = h[a[t]] / u[t]);
					}), this._sw = r[0], this._sh = r[1];
				}, dataToPoint: function dataToPoint(t, e) {
					s.isArray(t) && (t = t[0]), null == e && (e = !0);var i = this.getDateInfo(t),
					    n = this._rangeInfo,
					    a = i.formatedDate;if (e && !(i.time >= n.start.time && i.time <= n.end.time)) return [NaN, NaN];var o = i.day,
					    r = this._getRangeInfo([n.start.time, a]).weeks;return "vertical" === this._orient ? [this._rect.x + o * this._sw + this._sw / 2, this._rect.y + (r - 1) * this._sh + this._sh / 2] : [this._rect.x + (r - 1) * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2];
				}, pointToData: function pointToData(t) {
					var e = this.pointToDate(t);return e && e.time;
				}, dataToRect: function dataToRect(t, e) {
					var i = this.dataToPoint(t, e);return { contentShape: { x: i[0] - (this._sw - this._lineWidth) / 2, y: i[1] - (this._sh - this._lineWidth) / 2, width: this._sw - this._lineWidth, height: this._sh - this._lineWidth }, center: i, tl: [i[0] - this._sw / 2, i[1] - this._sh / 2], tr: [i[0] + this._sw / 2, i[1] - this._sh / 2], br: [i[0] + this._sw / 2, i[1] + this._sh / 2], bl: [i[0] - this._sw / 2, i[1] + this._sh / 2] };
				}, pointToDate: function pointToDate(t) {
					var e = Math.floor((t[0] - this._rect.x) / this._sw) + 1,
					    i = Math.floor((t[1] - this._rect.y) / this._sh) + 1,
					    n = this._rangeInfo.range;return "vertical" === this._orient ? this._getDateByWeeksAndDay(i, e - 1, n) : this._getDateByWeeksAndDay(e, i - 1, n);
				}, convertToPixel: s.curry(a, "dataToPoint"), convertFromPixel: s.curry(a, "pointToData"), _initRangeOption: function _initRangeOption() {
					var t = this._model.get("range"),
					    e = t;if (s.isArray(e) && 1 === e.length && (e = e[0]), /^\d{4}$/.test(e) && (t = [e + "-01-01", e + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(e)) {
						var i = this.getDateInfo(e),
						    n = i.date;n.setMonth(n.getMonth() + 1);var a = this.getNextNDay(n, -1);t = [i.formatedDate, a.formatedDate];
					}/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(e) && (t = [e, e]);var o = this._getRangeInfo(t);return o.start.time > o.end.time && t.reverse(), t;
				}, _getRangeInfo: function _getRangeInfo(t) {
					var e = this.getDateInfo(t[0]),
					    i = this.getDateInfo(t[1]),
					    n = Math.floor(i.time / l) - Math.floor(e.time / l) + 1,
					    a = Math.floor((n + e.day + 6) / 7);return { range: [e.formatedDate, i.formatedDate], start: e, end: i, allDay: n, weeks: a, fweek: e.day, lweek: i.day };
				}, _getDateByWeeksAndDay: function _getDateByWeeksAndDay(t, e, i) {
					var n = this._getRangeInfo(i);if (t > n.weeks || 0 === t && e < n.fweek || t === n.weeks && e > n.lweek) return !1;var a = 7 * (t - 1) - n.fweek + e,
					    o = n.start.time + a * l;return this.getDateInfo(o);
				} }, n.dimensions = n.prototype.dimensions, n.getDimensionsInfo = n.prototype.getDimensionsInfo, n.create = function (t, e) {
				var i = [];return t.eachComponent("calendar", function (a) {
					var o = new n(a, t, e);i.push(o), a.coordinateSystem = o;
				}), t.eachSeries(function (t) {
					"calendar" === t.get("coordinateSystem") && (t.coordinateSystem = i[t.get("calendarIndex") || 0]);
				}), i;
			}, i(26).register("calendar", n), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				var i = t.cellSize;o.isArray(i) ? 1 === i.length && (i[1] = i[0]) : i = t.cellSize = [i, i];var n = o.map([0, 1], function (t) {
					return r.sizeCalculable(e, t) && (i[t] = "auto"), null != i[t] && "auto" !== i[t];
				});r.mergeLayoutParam(t, e, { type: "box", ignoreSize: n });
			}var a = i(13),
			    o = i(1),
			    r = i(12),
			    s = a.extend({ type: "calendar", coordinateSystem: null, defaultOption: { zlevel: 0, z: 2, left: 80, top: 60, cellSize: 20, orient: "horizontal", splitLine: { show: !0, lineStyle: { color: "#000", width: 1, type: "solid" } }, itemStyle: { normal: { color: "#fff", borderWidth: 1, borderColor: "#ccc" } }, dayLabel: { show: !0, firstDay: 0, position: "start", margin: "50%", nameMap: "en", textStyle: { color: "#000" } }, monthLabel: { show: !0, position: "start", margin: 5, align: "center", nameMap: "en", formatter: null, textStyle: { color: "#000" } }, yearLabel: { show: !0, position: null, margin: 30, formatter: null, textStyle: { color: "#ccc", fontFamily: "sans-serif", fontWeight: "bolder", fontSize: 20 } } }, init: function init(t, e, i, a) {
					var o = r.getLayoutParams(t);s.superApply(this, "init", arguments), n(t, o);
				}, mergeOption: function mergeOption(t, e) {
					s.superApply(this, "mergeOption", arguments), n(this.option, t);
				} });t.exports = s;
		}, function (t, e, i) {
			function n(t) {
				var e = t.getRect(),
				    i = t.getRangeInfo();return { coordSys: { type: "calendar", x: e.x, y: e.y, width: e.width, height: e.height, cellWidth: t.getCellWidth(), cellHeight: t.getCellHeight(), rangeInfo: { start: i.start, end: i.end, weeks: i.weeks, dayCount: i.allDay } }, api: { coord: a.bind(t.dataToPoint, t) } };
			}var a = i(1);t.exports = n;
		}, function (t, e, i) {
			function n(t, e) {
				return e = e || [0, 0], o.map(["x", "y"], function (i, n) {
					var a = this.getAxis(i),
					    o = e[n],
					    r = t[n] / 2;return "category" === a.type ? a.getBandWidth() : Math.abs(a.dataToCoord(o - r) - a.dataToCoord(o + r));
				}, this);
			}function a(t) {
				var e = t.grid.getRect();return { coordSys: { type: "cartesian2d", x: e.x, y: e.y, width: e.width, height: e.height }, api: { coord: o.bind(t.dataToPoint, t), size: o.bind(n, t) } };
			}var o = i(1);t.exports = a;
		}, function (t, e, i) {
			function n(t, e, i, n, a) {
				l.call(this, t), this.map = e, this._nameCoordMap = r.createHashMap(), this.loadGeoJson(i, n, a);
			}function a(t, e, i, n) {
				var a = i.geoModel,
				    o = i.seriesModel,
				    r = a ? a.coordinateSystem : o ? o.coordinateSystem || (o.getReferringComponents("geo")[0] || {}).coordinateSystem : null;return r === this ? r[t](n) : null;
			}var o = i(262),
			    r = i(1),
			    s = i(11),
			    l = i(260),
			    u = [i(401), i(402), i(400)];n.prototype = { constructor: n, type: "geo", dimensions: ["lng", "lat"], containCoord: function containCoord(t) {
					for (var e = this.regions, i = 0; i < e.length; i++) {
						if (e[i].contain(t)) return !0;
					}return !1;
				}, loadGeoJson: function loadGeoJson(t, e, i) {
					try {
						this.regions = t ? o(t) : [];
					} catch (n) {
						throw "Invalid geoJson format\n" + n.message;
					}e = e || {}, i = i || {};for (var a = this.regions, s = r.createHashMap(), l = 0; l < a.length; l++) {
						var c = a[l].name;c = i.hasOwnProperty(c) ? i[c] : c, a[l].name = c, s.set(c, a[l]), this.addGeoCoord(c, a[l].center);var h = e[c];h && a[l].transformTo(h.left, h.top, h.width, h.height);
					}this._regionsMap = s, this._rect = null, r.each(u, function (t) {
						t(this);
					}, this);
				}, transformTo: function transformTo(t, e, i, n) {
					var a = this.getBoundingRect();a = a.clone(), a.y = -a.y - a.height;var o = this._viewTransform;o.transform = a.calculateTransform(new s(t, e, i, n)), o.decomposeTransform();var r = o.scale;r[1] = -r[1], o.updateTransform(), this._updateTransform();
				}, getRegion: function getRegion(t) {
					return this._regionsMap.get(t);
				}, getRegionByCoord: function getRegionByCoord(t) {
					for (var e = this.regions, i = 0; i < e.length; i++) {
						if (e[i].contain(t)) return e[i];
					}
				}, addGeoCoord: function addGeoCoord(t, e) {
					this._nameCoordMap.set(t, e);
				}, getGeoCoord: function getGeoCoord(t) {
					return this._nameCoordMap.get(t);
				}, getBoundingRect: function getBoundingRect() {
					if (this._rect) return this._rect;for (var t, e = this.regions, i = 0; i < e.length; i++) {
						var n = e[i].getBoundingRect();t = t || n.clone(), t.union(n);
					}return this._rect = t || new s(0, 0, 0, 0);
				}, dataToPoints: function dataToPoints(t) {
					var e = [];return t.mapArray(["lng", "lat"], function (t, i) {
						return e[0] = t, e[1] = i, this.dataToPoint(e);
					}, this);
				}, dataToPoint: function dataToPoint(t) {
					if ("string" == typeof t && (t = this.getGeoCoord(t)), t) return l.prototype.dataToPoint.call(this, t);
				}, convertToPixel: r.curry(a, "dataToPoint"), convertFromPixel: r.curry(a, "pointToData") }, r.mixin(n, l), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			var n = i(5),
			    a = i(13),
			    o = i(10),
			    r = i(1),
			    s = i(78),
			    l = i(186),
			    u = a.extend({ type: "geo", coordinateSystem: null, layoutMode: "box", init: function init(t) {
					a.prototype.init.apply(this, arguments), n.defaultEmphasis(t.label, ["position", "show", "textStyle", "distance", "formatter"]);
				}, optionUpdated: function optionUpdated() {
					var t = this.option,
					    e = this;t.regions = l.getFilledRegions(t.regions, t.map), this._optionModelMap = r.reduce(t.regions || [], function (t, i) {
						return i.name && t.set(i.name, new o(i, e)), t;
					}, r.createHashMap()), this.updateSelectedMap(t.regions);
				}, defaultOption: { zlevel: 0, z: 0, show: !0, left: "center", top: "center", aspectScale: .75, silent: !1, map: "", boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { normal: { show: !1, textStyle: { color: "#000" } }, emphasis: { show: !0, textStyle: { color: "rgb(100,0,0)" } } }, itemStyle: { normal: { borderWidth: .5, borderColor: "#444", color: "#eee" }, emphasis: { color: "rgba(255,215,0,0.8)" } }, regions: [] }, getRegionModel: function getRegionModel(t) {
					return this._optionModelMap.get(t) || new o(null, this, this.ecModel);
				}, getFormattedLabel: function getFormattedLabel(t, e) {
					var i = this.getRegionModel(t),
					    n = i.get("label." + e + ".formatter"),
					    a = { name: t };if ("function" == typeof n) return a.status = e, n(a);if ("string" == typeof n) {
						var o = a.seriesName;return n.replace("{a}", null != o ? o : "");
					}
				}, setZoom: function setZoom(t) {
					this.option.zoom = t;
				}, setCenter: function setCenter(t) {
					this.option.center = t;
				} });r.mixin(u, s), t.exports = u;
		}, function (t, e, i) {
			var n = i(1),
			    a = { Russia: [100, 60], "United States": [-99, 38], "United States of America": [-99, 38] };t.exports = function (t) {
				n.each(t.regions, function (t) {
					var e = a[t.name];if (e) {
						var i = t.center;i[0] = e[0], i[1] = e[1];
					}
				});
			};
		}, function (t, e, i) {
			for (var n = i(261), a = i(1), o = [126, 25], r = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, .7], [52, .7], [56, 7.7], [59, .7], [64, .7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]], s = 0; s < r.length; s++) {
				for (var l = 0; l < r[s].length; l++) {
					r[s][l][0] /= 10.5, r[s][l][1] /= -14, r[s][l][0] += o[0], r[s][l][1] += o[1];
				}
			}t.exports = function (t) {
				"china" === t.map && t.regions.push(new n("", a.map(r, function (t) {
					return { type: "polygon", exterior: t };
				}), o));
			};
		}, function (t, e, i) {
			var n = i(1),
			    a = { "": [32, 80], "": [0, -10], "": [10, 5], "": [-10, 10], "": [5, 5] };t.exports = function (t) {
				n.each(t.regions, function (t) {
					var e = a[t.name];if (e) {
						var i = t.center;i[0] += e[0] / 10.5, i[1] += -e[1] / 14;
					}
				});
			};
		}, function (t, e, i) {
			function n(t, e) {
				return e = e || [0, 0], o.map([0, 1], function (i) {
					var n = e[i],
					    a = t[i] / 2,
					    o = [],
					    r = [];return o[i] = n - a, r[i] = n + a, o[1 - i] = r[1 - i] = e[1 - i], Math.abs(this.dataToPoint(o)[i] - this.dataToPoint(r)[i]);
				}, this);
			}function a(t) {
				var e = t.getBoundingRect();return { coordSys: { type: "geo", x: e.x, y: e.y, width: e.width, height: e.height }, api: { coord: o.bind(t.dataToPoint, t), size: o.bind(n, t) } };
			}var o = i(1);t.exports = a;
		}, function (t, e, i) {
			function n(t, e) {
				return e.type || (e.data ? "category" : "value");
			}var a = i(13),
			    o = i(1),
			    r = i(31),
			    s = i(59),
			    l = i(4),
			    u = a.extend({ type: "baseParallelAxis", axis: null, activeIntervals: [], getAreaSelectStyle: function getAreaSelectStyle() {
					return r([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]]).call(this.getModel("areaSelectStyle"));
				}, setActiveIntervals: function setActiveIntervals(t) {
					var e = this.activeIntervals = o.clone(t);if (e) for (var i = e.length - 1; i >= 0; i--) {
						l.asc(e[i]);
					}
				}, getActiveState: function getActiveState(t) {
					var e = this.activeIntervals;if (!e.length) return "normal";if (null == t) return "inactive";for (var i = 0, n = e.length; i < n; i++) {
						if (e[i][0] <= t && t <= e[i][1]) return "active";
					}return "inactive";
				} }),
			    c = { type: "value", dim: null, areaSelectStyle: { width: 20, borderWidth: 1, borderColor: "rgba(160,197,232)", color: "rgba(160,197,232)", opacity: .3 }, realtime: !0, z: 10 };o.merge(u.prototype, i(42)), s("parallel", u, n, c), t.exports = u;
		}, function (t, e, i) {
			function n(t, e, i) {
				this._axesMap = u.createHashMap(), this._axesLayout = {}, this.dimensions = t.dimensions, this._rect, this._model = t, this._init(t, e, i);
			}function a(t, e) {
				return m(v(t, e[0]), e[1]);
			}function o(t, e) {
				var i = e.layoutLength / (e.axisCount - 1);return { position: i * t, axisNameAvailableWidth: i, axisLabelShow: !0 };
			}function r(t, e) {
				var i,
				    n,
				    a = e.layoutLength,
				    o = e.axisExpandWidth,
				    r = e.axisCount,
				    s = e.axisCollapseWidth,
				    l = e.winInnerIndices,
				    u = s,
				    c = !1;return t < l[0] ? (i = t * s, n = s) : t <= l[1] ? (i = e.axisExpandWindow0Pos + t * o - e.axisExpandWindow[0], u = o, c = !0) : (i = a - (r - 1 - t) * s, n = s), { position: i, axisNameAvailableWidth: u, axisLabelShow: c, nameTruncateMaxWidth: n };
			}var s = i(12),
			    l = i(18),
			    u = i(1),
			    c = i(406),
			    h = i(3),
			    d = i(19),
			    f = i(4),
			    p = i(56),
			    g = u.each,
			    m = Math.min,
			    v = Math.max,
			    y = Math.floor,
			    x = Math.ceil,
			    _ = f.round,
			    b = Math.PI;n.prototype = { type: "parallel", constructor: n, _init: function _init(t, e, i) {
					var n = t.dimensions,
					    a = t.parallelAxisIndex;g(n, function (t, i) {
						var n = a[i],
						    o = e.getComponent("parallelAxis", n),
						    r = this._axesMap.set(t, new c(t, l.createScaleByModel(o), [0, 0], o.get("type"), n)),
						    s = "category" === r.type;r.onBand = s && o.get("boundaryGap"), r.inverse = o.get("inverse"), o.axis = r, r.model = o, r.coordinateSystem = o.coordinateSystem = this;
					}, this);
				}, update: function update(t, e) {
					this._updateAxesFromSeries(this._model, t);
				}, containPoint: function containPoint(t) {
					var e = this._makeLayoutInfo(),
					    i = e.axisBase,
					    n = e.layoutBase,
					    a = e.pixelDimIndex,
					    o = t[1 - a],
					    r = t[a];return o >= i && o <= i + e.axisLength && r >= n && r <= n + e.layoutLength;
				}, _updateAxesFromSeries: function _updateAxesFromSeries(t, e) {
					e.eachSeries(function (i) {
						if (t.contains(i, e)) {
							var n = i.getData();g(this.dimensions, function (t) {
								var e = this._axesMap.get(t);e.scale.unionExtentFromData(n, t), l.niceScaleExtent(e.scale, e.model);
							}, this);
						}
					}, this);
				}, resize: function resize(t, e) {
					this._rect = s.getLayoutRect(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }), this._layoutAxes();
				}, getRect: function getRect() {
					return this._rect;
				}, _makeLayoutInfo: function _makeLayoutInfo() {
					var t,
					    e = this._model,
					    i = this._rect,
					    n = ["x", "y"],
					    o = ["width", "height"],
					    r = e.get("layout"),
					    s = "horizontal" === r ? 0 : 1,
					    l = i[o[s]],
					    u = [0, l],
					    c = this.dimensions.length,
					    h = a(e.get("axisExpandWidth"), u),
					    d = a(e.get("axisExpandCount") || 0, [0, c]),
					    f = e.get("axisExpandable") && c > 3 && c > d && d > 1 && h > 0 && l > 0,
					    p = e.get("axisExpandWindow");if (p) t = a(p[1] - p[0], u), p[1] = p[0] + t;else {
						t = a(h * (d - 1), u);var g = e.get("axisExpandCenter") || y(c / 2);p = [h * g - t / 2], p[1] = p[0] + t;
					}var m = (l - t) / (c - d);m < 3 && (m = 0);var v = [y(_(p[0] / h, 1)) + 1, x(_(p[1] / h, 1)) - 1],
					    b = m / h * p[0];return { layout: r, pixelDimIndex: s, layoutBase: i[n[s]], layoutLength: l, axisBase: i[n[1 - s]], axisLength: i[o[1 - s]], axisExpandable: f, axisExpandWidth: h, axisCollapseWidth: m, axisExpandWindow: p, axisCount: c, winInnerIndices: v, axisExpandWindow0Pos: b };
				}, _layoutAxes: function _layoutAxes() {
					var t = this._rect,
					    e = this._axesMap,
					    i = this.dimensions,
					    n = this._makeLayoutInfo(),
					    a = n.layout;e.each(function (t) {
						var e = [0, n.axisLength],
						    i = t.inverse ? 1 : 0;t.setExtent(e[i], e[1 - i]);
					}), g(i, function (i, s) {
						var l = (n.axisExpandable ? r : o)(s, n),
						    u = { horizontal: { x: l.position, y: n.axisLength }, vertical: { x: 0, y: l.position } },
						    c = { horizontal: b / 2, vertical: 0 },
						    h = [u[a].x + t.x, u[a].y + t.y],
						    f = c[a],
						    p = d.create();d.rotate(p, p, f), d.translate(p, p, h), this._axesLayout[i] = { position: h, rotation: f, transform: p, axisNameAvailableWidth: l.axisNameAvailableWidth, axisLabelShow: l.axisLabelShow, nameTruncateMaxWidth: l.nameTruncateMaxWidth, tickDirection: 1, labelDirection: 1, labelInterval: e.get(i).getLabelInterval() };
					}, this);
				}, getAxis: function getAxis(t) {
					return this._axesMap.get(t);
				}, dataToPoint: function dataToPoint(t, e) {
					return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e);
				}, eachActiveState: function eachActiveState(t, e, i) {
					for (var n = this.dimensions, a = this._axesMap, o = this.hasAxisBrushed(), r = 0, s = t.count(); r < s; r++) {
						var l,
						    u = t.getValues(n, r);if (o) {
							l = "active";for (var c = 0, h = n.length; c < h; c++) {
								var d = n[c],
								    f = a.get(d).model.getActiveState(u[c], c);if ("inactive" === f) {
									l = "inactive";break;
								}
							}
						} else l = "normal";e.call(i, l, r);
					}
				}, hasAxisBrushed: function hasAxisBrushed() {
					for (var t = this.dimensions, e = this._axesMap, i = !1, n = 0, a = t.length; n < a; n++) {
						"normal" !== e.get(t[n]).model.getActiveState() && (i = !0);
					}return i;
				}, axisCoordToPoint: function axisCoordToPoint(t, e) {
					var i = this._axesLayout[e];return h.applyTransform([t, 0], i.transform);
				}, getAxisLayout: function getAxisLayout(t) {
					return u.clone(this._axesLayout[t]);
				}, getSlidedAxisExpandWindow: function getSlidedAxisExpandWindow(t) {
					var e = this._makeLayoutInfo(),
					    i = e.pixelDimIndex,
					    n = e.axisExpandWindow.slice(),
					    a = n[1] - n[0],
					    o = [0, e.axisExpandWidth * (e.axisCount - 1)];if (!this.containPoint(t)) return { behavior: "none", axisExpandWindow: n };var r,
					    s = t[i] - e.layoutBase - e.axisExpandWindow0Pos,
					    l = "slide",
					    u = e.axisCollapseWidth,
					    c = this._model.get("axisExpandSlideTriggerArea"),
					    h = null != c[0];if (u) h && u && s < a * c[0] ? (l = "jump", r = s - a * c[2]) : h && u && s > a * (1 - c[0]) ? (l = "jump", r = s - a * (1 - c[2])) : (r = s - a * c[1]) >= 0 && (r = s - a * (1 - c[1])) <= 0 && (r = 0), r *= e.axisExpandWidth / u, r ? p(r, n, o, "all") : l = "none";else {
						var a = n[1] - n[0],
						    d = o[1] * s / a;n = [v(0, d - a / 2)], n[1] = m(o[1], n[0] + a), n[0] = n[1] - a;
					}return { axisExpandWindow: n, behavior: l };
				} }, t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(33),
			    o = function o(t, e, i, n, _o4) {
				a.call(this, t, e, i), this.type = n || "value", this.axisIndex = _o4;
			};o.prototype = { constructor: o, model: null }, n.inherits(o, a), t.exports = o;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(13);i(404), a.extend({ type: "parallel", dependencies: ["parallelAxis"], coordinateSystem: null, dimensions: null, parallelAxisIndex: null, layoutMode: "box", defaultOption: { zlevel: 0, z: 0, left: 80, top: 60, right: 80, bottom: 60, layout: "horizontal", axisExpandable: !1, axisExpandCenter: null, axisExpandCount: 0, axisExpandWidth: 50, axisExpandRate: 17, axisExpandDebounce: 50, axisExpandSlideTriggerArea: [-.15, .05, .4], axisExpandTriggerOn: "click", parallelAxisDefault: null }, init: function init() {
					a.prototype.init.apply(this, arguments), this.mergeOption({});
				}, mergeOption: function mergeOption(t) {
					var e = this.option;t && n.merge(e, t, !0), this._initDimensions();
				}, contains: function contains(t, e) {
					var i = t.get("parallelIndex");return null != i && e.getComponent("parallel", i) === this;
				}, setAxisExpand: function setAxisExpand(t) {
					n.each(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function (e) {
						t.hasOwnProperty(e) && (this.option[e] = t[e]);
					}, this);
				}, _initDimensions: function _initDimensions() {
					var t = this.dimensions = [],
					    e = this.parallelAxisIndex = [],
					    i = n.filter(this.dependentModels.parallelAxis, function (t) {
						return t.get("parallelIndex") === this.componentIndex;
					});n.each(i, function (i) {
						t.push("dim" + i.get("dim")), e.push(i.componentIndex);
					});
				} });
		}, function (t, e, i) {
			function n(t) {
				if (!t.parallel) {
					var e = !1;o.each(t.series, function (t) {
						t && "parallel" === t.type && (e = !0);
					}), e && (t.parallel = [{}]);
				}
			}function a(t) {
				var e = r.normalizeToArray(t.parallelAxis);o.each(e, function (e) {
					if (o.isObject(e)) {
						var i = e.parallelIndex || 0,
						    n = r.normalizeToArray(t.parallel)[i];n && n.parallelAxisDefault && o.merge(e, n.parallelAxisDefault, !1);
					}
				});
			}var o = i(1),
			    r = i(5);t.exports = function (t) {
				n(t), a(t);
			};
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				e = e || [0, 360], o.call(this, "angle", t, e), this.type = "category";
			}var a = i(1),
			    o = i(33);n.prototype = { constructor: n, pointToData: function pointToData(t, e) {
					return this.polar.pointToData(t, e)["radius" === this.dim ? 0 : 1];
				}, dataToAngle: o.prototype.dataToCoord, angleToData: o.prototype.coordToData }, a.inherits(n, o), t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				return e.type || (e.data ? "category" : "value");
			}var a = i(1),
			    o = i(13),
			    r = i(59),
			    s = o.extend({ type: "polarAxis", axis: null, getCoordSysModel: function getCoordSysModel() {
					return this.ecModel.queryComponents({ mainType: "polar", index: this.option.polarIndex, id: this.option.polarId })[0];
				} });a.merge(s.prototype, i(42));var l = { angle: { startAngle: 90, clockwise: !0, splitNumber: 12, axisLabel: { rotate: !1 } }, radius: { splitNumber: 5 } };r("angle", s, n, l.angle), r("radius", s, n, l.radius);
		}, function (t, e, i) {
			"use strict";
			var n = i(413),
			    a = i(409),
			    o = function o(t) {
				this.name = t || "", this.cx = 0, this.cy = 0, this._radiusAxis = new n(), this._angleAxis = new a(), this._radiusAxis.polar = this._angleAxis.polar = this;
			};o.prototype = { type: "polar", axisPointerEnabled: !0, constructor: o, dimensions: ["radius", "angle"], model: null, containPoint: function containPoint(t) {
					var e = this.pointToCoord(t);return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1]);
				}, containData: function containData(t) {
					return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]);
				}, getAxis: function getAxis(t) {
					return this["_" + t + "Axis"];
				}, getAxes: function getAxes() {
					return [this._radiusAxis, this._angleAxis];
				}, getAxesByScale: function getAxesByScale(t) {
					var e = [],
					    i = this._angleAxis,
					    n = this._radiusAxis;return i.scale.type === t && e.push(i), n.scale.type === t && e.push(n), e;
				}, getAngleAxis: function getAngleAxis() {
					return this._angleAxis;
				}, getRadiusAxis: function getRadiusAxis() {
					return this._radiusAxis;
				}, getOtherAxis: function getOtherAxis(t) {
					var e = this._angleAxis;return t === e ? this._radiusAxis : e;
				}, getBaseAxis: function getBaseAxis() {
					return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
				}, getTooltipAxes: function getTooltipAxes(t) {
					var e = null != t && "auto" !== t ? this.getAxis(t) : this.getBaseAxis();return { baseAxes: [e], otherAxes: [this.getOtherAxis(e)] };
				}, dataToPoints: function dataToPoints(t) {
					return t.mapArray(this.dimensions, function (t, e) {
						return this.dataToPoint([t, e]);
					}, !0, this);
				}, dataToPoint: function dataToPoint(t, e) {
					return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)]);
				}, pointToData: function pointToData(t, e) {
					var i = this.pointToCoord(t);return [this._radiusAxis.radiusToData(i[0], e), this._angleAxis.angleToData(i[1], e)];
				}, pointToCoord: function pointToCoord(t) {
					var e = t[0] - this.cx,
					    i = t[1] - this.cy,
					    n = this.getAngleAxis(),
					    a = n.getExtent(),
					    o = Math.min(a[0], a[1]),
					    r = Math.max(a[0], a[1]);n.inverse ? o = r - 360 : r = o + 360;var s = Math.sqrt(e * e + i * i);e /= s, i /= s;for (var l = Math.atan2(-i, e) / Math.PI * 180, u = l < o ? 1 : -1; l < o || l > r;) {
						l += 360 * u;
					}return [s, l];
				}, coordToPoint: function coordToPoint(t) {
					var e = t[0],
					    i = t[1] / 180 * Math.PI,
					    n = Math.cos(i) * e + this.cx,
					    a = -Math.sin(i) * e + this.cy;return [n, a];
				} }, t.exports = o;
		}, function (t, e, i) {
			"use strict";
			i(410), i(2).extendComponentModel({ type: "polar", dependencies: ["polarAxis", "angleAxis"], coordinateSystem: null, findAxisModel: function findAxisModel(t) {
					var e,
					    i = this.ecModel;return i.eachComponent(t, function (t) {
						t.getCoordSysModel() === this && (e = t);
					}, this), e;
				}, defaultOption: { zlevel: 0, z: 0, center: ["50%", "50%"], radius: "80%" } });
		}, function (t, e, i) {
			"use strict";
			function n(t, e) {
				o.call(this, "radius", t, e), this.type = "category";
			}var a = i(1),
			    o = i(33);n.prototype = { constructor: n, pointToData: function pointToData(t, e) {
					return this.polar.pointToData(t, e)["radius" === this.dim ? 0 : 1];
				}, dataToRadius: o.prototype.dataToCoord, radiusToData: o.prototype.coordToData }, a.inherits(n, o), t.exports = n;
		}, function (t, e, i) {
			function n(t, e) {
				return o.map(["Radius", "Angle"], function (i, n) {
					var a = this["get" + i + "Axis"](),
					    o = e[n],
					    r = t[n] / 2,
					    s = "dataTo" + i,
					    l = "category" === a.type ? a.getBandWidth() : Math.abs(a[s](o - r) - a[s](o + r));return "Angle" === i && (l = l * Math.PI / 180), l;
				}, this);
			}function a(t) {
				var e = t.getRadiusAxis(),
				    i = t.getAngleAxis(),
				    a = e.getExtent();return a[0] > a[1] && a.reverse(), { coordSys: { type: "polar", cx: t.cx, cy: t.cy, r: a[1], r0: a[0] }, api: { coord: o.bind(function (n) {
							var a = e.dataToRadius(n[0]),
							    o = i.dataToAngle(n[1]),
							    r = t.coordToPoint([a, o]);return r.push(a, o * Math.PI / 180), r;
						}), size: o.bind(n, t) } };
			}var o = i(1);t.exports = a;
		}, function (t, e, i) {
			function n(t, e, i) {
				o.call(this, t, e, i), this.type = "value", this.angle = 0, this.name = "", this.model;
			}var a = i(1),
			    o = i(33);a.inherits(n, o), t.exports = n;
		}, function (t, e, i) {
			function n(t, e, i) {
				this._model = t, this.dimensions = [], this._indicatorAxes = a.map(t.getIndicatorModels(), function (t, e) {
					var i = "indicator_" + e,
					    n = new o(i, new r());return n.name = t.get("name"), n.model = t, t.axis = n, this.dimensions.push(i), n;
				}, this), this.resize(t, i), this.cx, this.cy, this.r, this.startAngle;
			}var a = i(1),
			    o = i(415),
			    r = i(43),
			    s = i(4),
			    l = i(18);n.prototype.getIndicatorAxes = function () {
				return this._indicatorAxes;
			}, n.prototype.dataToPoint = function (t, e) {
				var i = this._indicatorAxes[e];return this.coordToPoint(i.dataToCoord(t), e);
			}, n.prototype.coordToPoint = function (t, e) {
				var i = this._indicatorAxes[e],
				    n = i.angle,
				    a = this.cx + t * Math.cos(n),
				    o = this.cy - t * Math.sin(n);return [a, o];
			}, n.prototype.pointToData = function (t) {
				var e = t[0] - this.cx,
				    i = t[1] - this.cy,
				    n = Math.sqrt(e * e + i * i);e /= n, i /= n;for (var a, o = Math.atan2(-i, e), r = 1 / 0, s = -1, l = 0; l < this._indicatorAxes.length; l++) {
					var u = this._indicatorAxes[l],
					    c = Math.abs(o - u.angle);c < r && (a = u, s = l, r = c);
				}return [s, +(a && a.coodToData(n))];
			}, n.prototype.resize = function (t, e) {
				var i = t.get("center"),
				    n = e.getWidth(),
				    o = e.getHeight(),
				    r = Math.min(n, o) / 2;this.cx = s.parsePercent(i[0], n), this.cy = s.parsePercent(i[1], o), this.startAngle = t.get("startAngle") * Math.PI / 180, this.r = s.parsePercent(t.get("radius"), r), a.each(this._indicatorAxes, function (t, e) {
					t.setExtent(0, this.r);var i = this.startAngle + e * Math.PI * 2 / this._indicatorAxes.length;
					i = Math.atan2(Math.sin(i), Math.cos(i)), t.angle = i;
				}, this);
			}, n.prototype.update = function (t, e) {
				function i(t) {
					var e = Math.pow(10, Math.floor(Math.log(t) / Math.LN10)),
					    i = t / e;return 2 === i ? i = 5 : i *= 2, i * e;
				}var n = this._indicatorAxes,
				    o = this._model;a.each(n, function (t) {
					t.scale.setExtent(1 / 0, -(1 / 0));
				}), t.eachSeriesByType("radar", function (e, i) {
					if ("radar" === e.get("coordinateSystem") && t.getComponent("radar", e.get("radarIndex")) === o) {
						var r = e.getData();a.each(n, function (t) {
							t.scale.unionExtentFromData(r, t.dim);
						});
					}
				}, this);var r = o.get("splitNumber");a.each(n, function (t, e) {
					var n = l.getScaleExtent(t.scale, t.model);l.niceScaleExtent(t.scale, t.model);var a = t.model,
					    o = t.scale,
					    u = a.getMin(),
					    c = a.getMax(),
					    h = o.getInterval();if (null != u && null != c) o.setInterval((c - u) / r);else if (null != u) {
						var d;do {
							d = u + h * r, o.setExtent(+u, d), o.setInterval(h), h = i(h);
						} while (d < n[1] && isFinite(d) && isFinite(n[1]));
					} else if (null != c) {
						var f;do {
							f = c - h * r, o.setExtent(f, +c), o.setInterval(h), h = i(h);
						} while (f > n[0] && isFinite(f) && isFinite(n[0]));
					} else {
						var p = o.getTicks().length - 1;p > r && (h = i(h));var g = Math.round((n[0] + n[1]) / 2 / h) * h,
						    m = Math.round(r / 2);o.setExtent(s.round(g - m * h), s.round(g + (r - m) * h)), o.setInterval(h);
					}
				});
			}, n.dimensions = [], n.create = function (t, e) {
				var i = [];return t.eachComponent("radar", function (a) {
					var o = new n(a, t, e);i.push(o), a.coordinateSystem = o;
				}), t.eachSeriesByType("radar", function (t) {
					"radar" === t.get("coordinateSystem") && (t.coordinateSystem = i[t.get("radarIndex") || 0]);
				}), i;
			}, i(26).register("radar", n), t.exports = n;
		}, function (t, e, i) {
			function n(t, e) {
				return s.defaults({ show: e }, t);
			}var a = i(96),
			    o = a.valueAxis,
			    r = i(10),
			    s = i(1),
			    l = i(42),
			    u = i(2).extendComponentModel({ type: "radar", optionUpdated: function optionUpdated() {
					var t = this.get("boundaryGap"),
					    e = this.get("splitNumber"),
					    i = this.get("scale"),
					    n = this.get("axisLine"),
					    a = this.get("axisTick"),
					    o = this.get("axisLabel"),
					    u = this.get("name.textStyle"),
					    c = this.get("name.show"),
					    h = this.get("name.formatter"),
					    d = this.get("nameGap"),
					    f = this.get("triggerEvent"),
					    p = s.map(this.get("indicator") || [], function (p) {
						if (null != p.max && p.max > 0 && !p.min ? p.min = 0 : null != p.min && p.min < 0 && !p.max && (p.max = 0), p = s.merge(s.clone(p), { boundaryGap: t, splitNumber: e, scale: i, axisLine: n, axisTick: a, axisLabel: o, name: p.text, nameLocation: "end", nameGap: d, nameTextStyle: u, triggerEvent: f }, !1), c || (p.name = ""), "string" == typeof h) {
							var g = p.name;p.name = h.replace("{value}", null != g ? g : "");
						} else "function" == typeof h && (p.name = h(p.name, p));var m = s.extend(new r(p, null, this.ecModel), l);return m.mainType = "radar", m.componentIndex = this.componentIndex, m;
					}, this);this.getIndicatorModels = function () {
						return p;
					};
				}, defaultOption: { zlevel: 0, z: 0, center: ["50%", "50%"], radius: "75%", startAngle: 90, name: { show: !0 }, boundaryGap: [0, 0], splitNumber: 5, nameGap: 15, scale: !1, shape: "polygon", axisLine: s.merge({ lineStyle: { color: "#bbb" } }, o.axisLine), axisLabel: n(o.axisLabel, !1), axisTick: n(o.axisTick, !1), splitLine: n(o.splitLine, !0), splitArea: n(o.splitArea, !0), indicator: [] } });t.exports = u;
		}, function (t, e, i) {
			function n(t, e) {
				return e.type || (e.data ? "category" : "value");
			}var a = i(13),
			    o = i(59),
			    r = i(1),
			    s = a.extend({ type: "singleAxis", layoutMode: "box", axis: null, coordinateSystem: null, getCoordSysModel: function getCoordSysModel() {
					return this;
				} }),
			    l = { left: "5%", top: "5%", right: "5%", bottom: "5%", type: "value", position: "bottom", orient: "horizontal", axisLine: { show: !0, lineStyle: { width: 2, type: "solid" } }, tooltip: { show: !0 }, axisTick: { show: !0, length: 6, lineStyle: { width: 2 } }, axisLabel: { show: !0, interval: "auto" }, splitLine: { show: !0, lineStyle: { type: "dashed", opacity: .2 } } };r.merge(s.prototype, i(42)), o("single", s, n, l), t.exports = s;
		}, function (t, e, i) {
			function n(t, e, i) {
				this.dimension = "single", this.dimensions = ["single"], this._axis = null, this._rect, this._init(t, e, i), this.model = t;
			}var a = i(420),
			    o = i(18),
			    r = i(12);n.prototype = { type: "singleAxis", axisPointerEnabled: !0, constructor: n, _init: function _init(t, e, i) {
					var n = this.dimension,
					    r = new a(n, o.createScaleByModel(t), [0, 0], t.get("type"), t.get("position")),
					    s = "category" === r.type;r.onBand = s && t.get("boundaryGap"), r.inverse = t.get("inverse"), r.orient = t.get("orient"), t.axis = r, r.model = t, r.coordinateSystem = this, this._axis = r;
				}, update: function update(t, e) {
					t.eachSeries(function (t) {
						if (t.coordinateSystem === this) {
							var e = t.getData(),
							    i = this.dimension;this._axis.scale.unionExtentFromData(e, t.coordDimToDataDim(i)), o.niceScaleExtent(this._axis.scale, this._axis.model);
						}
					}, this);
				}, resize: function resize(t, e) {
					this._rect = r.getLayoutRect({ left: t.get("left"), top: t.get("top"), right: t.get("right"), bottom: t.get("bottom"), width: t.get("width"), height: t.get("height") }, { width: e.getWidth(), height: e.getHeight() }), this._adjustAxis();
				}, getRect: function getRect() {
					return this._rect;
				}, _adjustAxis: function _adjustAxis() {
					var t = this._rect,
					    e = this._axis,
					    i = e.isHorizontal(),
					    n = i ? [0, t.width] : [0, t.height],
					    a = e.reverse ? 1 : 0;e.setExtent(n[a], n[1 - a]), this._updateAxisTransform(e, i ? t.x : t.y);
				}, _updateAxisTransform: function _updateAxisTransform(t, e) {
					var i = t.getExtent(),
					    n = i[0] + i[1],
					    a = t.isHorizontal();t.toGlobalCoord = a ? function (t) {
						return t + e;
					} : function (t) {
						return n - t + e;
					}, t.toLocalCoord = a ? function (t) {
						return t - e;
					} : function (t) {
						return n - t + e;
					};
				}, getAxis: function getAxis() {
					return this._axis;
				}, getBaseAxis: function getBaseAxis() {
					return this._axis;
				}, getAxes: function getAxes() {
					return [this._axis];
				}, getTooltipAxes: function getTooltipAxes() {
					return { baseAxes: [this.getAxis()] };
				}, containPoint: function containPoint(t) {
					var e = this.getRect(),
					    i = this.getAxis(),
					    n = i.orient;return "horizontal" === n ? i.contain(i.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : i.contain(i.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height;
				}, pointToData: function pointToData(t) {
					var e = this.getAxis();return [e.coordToData(e.toLocalCoord(t["horizontal" === e.orient ? 0 : 1]))];
				}, dataToPoint: function dataToPoint(t) {
					var e = this.getAxis(),
					    i = this.getRect(),
					    n = [],
					    a = "horizontal" === e.orient ? 0 : 1;return t instanceof Array && (t = t[0]), n[a] = e.toGlobalCoord(e.dataToCoord(+t)), n[1 - a] = 0 === a ? i.y + i.height / 2 : i.x + i.width / 2, n;
				} }, t.exports = n;
		}, function (t, e, i) {
			var n = i(1),
			    a = i(33),
			    o = function o(t, e, i, n, _o5) {
				a.call(this, t, e, i), this.type = n || "value", this.position = _o5 || "bottom", this.orient = null, this._labelInterval = null;
			};o.prototype = { constructor: o, model: null, isHorizontal: function isHorizontal() {
					var t = this.position;return "top" === t || "bottom" === t;
				}, pointToData: function pointToData(t, e) {
					return this.coordinateSystem.pointToData(t, e)[0];
				}, toGlobalCoord: null, toLocalCoord: null }, n.inherits(o, a), t.exports = o;
		}, function (t, e, i) {
			function n(t, e) {
				var i = this.getAxis(),
				    n = e instanceof Array ? e[0] : e,
				    a = (t instanceof Array ? t[0] : t) / 2;return "category" === i.type ? i.getBandWidth() : Math.abs(i.dataToCoord(n - a) - i.dataToCoord(n + a));
			}function a(t) {
				var e = t.getRect();return { coordSys: { type: "singleAxis", x: e.x, y: e.y, width: e.width, height: e.height }, api: { coord: o.bind(t.dataToPoint, t), size: o.bind(n, t) } };
			}var o = i(1);t.exports = a;
		}, function (t, e, i) {
			function n(t, e) {
				var i = [];return t.eachComponent("singleAxis", function (n, o) {
					var r = new a(n, t, e);r.name = "single_" + o, r.resize(n, e), n.coordinateSystem = r, i.push(r);
				}), t.eachSeries(function (e) {
					if ("singleAxis" === e.get("coordinateSystem")) {
						var i = t.queryComponents({ mainType: "singleAxis", index: e.get("singleAxisIndex"), id: e.get("singleAxisId") })[0];e.coordinateSystem = i && i.coordinateSystem;
					}
				}), i;
			}var a = i(419);i(26).register("single", { create: n, dimensions: a.prototype.dimensions });
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return "_EC_" + t;
			}function a(t, e) {
				this.id = null == t ? "" : t, this.inEdges = [], this.outEdges = [], this.edges = [], this.hostGraph, this.dataIndex = null == e ? -1 : e;
			}function o(t, e, i) {
				this.node1 = t, this.node2 = e, this.dataIndex = null == i ? -1 : i;
			}var r = i(1),
			    s = function s(t) {
				this._directed = t || !1, this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this.data, this.edgeData;
			},
			    l = s.prototype;l.type = "graph", l.isDirected = function () {
				return this._directed;
			}, l.addNode = function (t, e) {
				t = t || "" + e;var i = this._nodesMap;if (!i[n(t)]) {
					var o = new a(t, e);return o.hostGraph = this, this.nodes.push(o), i[n(t)] = o, o;
				}
			}, l.getNodeByIndex = function (t) {
				var e = this.data.getRawIndex(t);return this.nodes[e];
			}, l.getNodeById = function (t) {
				return this._nodesMap[n(t)];
			}, l.addEdge = function (t, e, i) {
				var r = this._nodesMap,
				    s = this._edgesMap;if ("number" == typeof t && (t = this.nodes[t]), "number" == typeof e && (e = this.nodes[e]), t instanceof a || (t = r[n(t)]), e instanceof a || (e = r[n(e)]), t && e) {
					var l = t.id + "-" + e.id;if (!s[l]) {
						var u = new o(t, e, i);return u.hostGraph = this, this._directed && (t.outEdges.push(u), e.inEdges.push(u)), t.edges.push(u), t !== e && e.edges.push(u), this.edges.push(u), s[l] = u, u;
					}
				}
			}, l.getEdgeByIndex = function (t) {
				var e = this.edgeData.getRawIndex(t);return this.edges[e];
			}, l.getEdge = function (t, e) {
				t instanceof a && (t = t.id), e instanceof a && (e = e.id);var i = this._edgesMap;return this._directed ? i[t + "-" + e] : i[t + "-" + e] || i[e + "-" + t];
			}, l.eachNode = function (t, e) {
				for (var i = this.nodes, n = i.length, a = 0; a < n; a++) {
					i[a].dataIndex >= 0 && t.call(e, i[a], a);
				}
			}, l.eachEdge = function (t, e) {
				for (var i = this.edges, n = i.length, a = 0; a < n; a++) {
					i[a].dataIndex >= 0 && i[a].node1.dataIndex >= 0 && i[a].node2.dataIndex >= 0 && t.call(e, i[a], a);
				}
			}, l.breadthFirstTraverse = function (t, e, i, o) {
				if (e instanceof a || (e = this._nodesMap[n(e)]), e) {
					for (var r = "out" === i ? "outEdges" : "in" === i ? "inEdges" : "edges", s = 0; s < this.nodes.length; s++) {
						this.nodes[s].__visited = !1;
					}if (!t.call(o, e, null)) for (var l = [e]; l.length;) {
						for (var u = l.shift(), c = u[r], s = 0; s < c.length; s++) {
							var h = c[s],
							    d = h.node1 === u ? h.node2 : h.node1;if (!d.__visited) {
								if (t.call(o, d, u)) return;l.push(d), d.__visited = !0;
							}
						}
					}
				}
			}, l.update = function () {
				for (var t = this.data, e = this.edgeData, i = this.nodes, n = this.edges, a = 0, o = i.length; a < o; a++) {
					i[a].dataIndex = -1;
				}for (var a = 0, o = t.count(); a < o; a++) {
					i[t.getRawIndex(a)].dataIndex = a;
				}e.filterSelf(function (t) {
					var i = n[e.getRawIndex(t)];return i.node1.dataIndex >= 0 && i.node2.dataIndex >= 0;
				});for (var a = 0, o = n.length; a < o; a++) {
					n[a].dataIndex = -1;
				}for (var a = 0, o = e.count(); a < o; a++) {
					n[e.getRawIndex(a)].dataIndex = a;
				}
			}, l.clone = function () {
				for (var t = new s(this._directed), e = this.nodes, i = this.edges, n = 0; n < e.length; n++) {
					t.addNode(e[n].id, e[n].dataIndex);
				}for (var n = 0; n < i.length; n++) {
					var a = i[n];t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
				}return t;
			}, a.prototype = { constructor: a, degree: function degree() {
					return this.edges.length;
				}, inDegree: function inDegree() {
					return this.inEdges.length;
				}, outDegree: function outDegree() {
					return this.outEdges.length;
				}, getModel: function getModel(t) {
					if (!(this.dataIndex < 0)) {
						var e = this.hostGraph,
						    i = e.data.getItemModel(this.dataIndex);return i.getModel(t);
					}
				} }, o.prototype.getModel = function (t) {
				if (!(this.dataIndex < 0)) {
					var e = this.hostGraph,
					    i = e.edgeData.getItemModel(this.dataIndex);return i.getModel(t);
				}
			};var u = function u(t, e) {
				return { getValue: function getValue(i) {
						var n = this[t][e];return n.get(n.getDimension(i || "value"), this.dataIndex);
					}, setVisual: function setVisual(i, n) {
						this.dataIndex >= 0 && this[t][e].setItemVisual(this.dataIndex, i, n);
					}, getVisual: function getVisual(i, n) {
						return this[t][e].getItemVisual(this.dataIndex, i, n);
					}, setLayout: function setLayout(i, n) {
						this.dataIndex >= 0 && this[t][e].setItemLayout(this.dataIndex, i, n);
					}, getLayout: function getLayout() {
						return this[t][e].getItemLayout(this.dataIndex);
					}, getGraphicEl: function getGraphicEl() {
						return this[t][e].getItemGraphicEl(this.dataIndex);
					}, getRawIndex: function getRawIndex() {
						return this[t][e].getRawIndex(this.dataIndex);
					} };
			};r.mixin(a, u("hostGraph", "data")), r.mixin(o, u("hostGraph", "edgeData")), s.Node = a, s.Edge = o, t.exports = s;
		}, function (t, e, i) {
			function n(t, e) {
				this.root, this.data, this._nodes = [], this.hostModel = t, this.levelModels = o.map(e || [], function (e) {
					return new r(e, t, t.ecModel);
				});
			}function a(t, e) {
				var i = e.children;t.parentNode !== e && (i.push(t), t.parentNode = e);
			}var o = i(1),
			    r = i(10),
			    s = i(14),
			    l = i(264),
			    u = i(25),
			    c = function c(t, e) {
				this.name = t || "", this.depth = 0, this.height = 0, this.parentNode = null, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.hostTree = e;
			};c.prototype = { constructor: c, isRemoved: function isRemoved() {
					return this.dataIndex < 0;
				}, eachNode: function eachNode(t, e, i) {
					"function" == typeof t && (i = e, e = t, t = null), t = t || {}, o.isString(t) && (t = { order: t });var n,
					    a = t.order || "preorder",
					    r = this[t.attr || "children"];"preorder" === a && (n = e.call(i, this));for (var s = 0; !n && s < r.length; s++) {
						r[s].eachNode(t, e, i);
					}"postorder" === a && e.call(i, this);
				}, updateDepthAndHeight: function updateDepthAndHeight(t) {
					var e = 0;this.depth = t;for (var i = 0; i < this.children.length; i++) {
						var n = this.children[i];n.updateDepthAndHeight(t + 1), n.height > e && (e = n.height);
					}this.height = e + 1;
				}, getNodeById: function getNodeById(t) {
					if (this.getId() === t) return this;for (var e = 0, i = this.children, n = i.length; e < n; e++) {
						var a = i[e].getNodeById(t);if (a) return a;
					}
				}, contains: function contains(t) {
					if (t === this) return !0;for (var e = 0, i = this.children, n = i.length; e < n; e++) {
						var a = i[e].contains(t);if (a) return a;
					}
				}, getAncestors: function getAncestors(t) {
					for (var e = [], i = t ? this : this.parentNode; i;) {
						e.push(i), i = i.parentNode;
					}return e.reverse(), e;
				}, getValue: function getValue(t) {
					var e = this.hostTree.data;return e.get(e.getDimension(t || "value"), this.dataIndex);
				}, setLayout: function setLayout(t, e) {
					this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, e);
				}, getLayout: function getLayout() {
					return this.hostTree.data.getItemLayout(this.dataIndex);
				}, getModel: function getModel(t) {
					if (!(this.dataIndex < 0)) {
						var e = this.hostTree,
						    i = e.data.getItemModel(this.dataIndex),
						    n = this.getLevelModel();return i.getModel(t, (n || e.hostModel).getModel(t));
					}
				}, getLevelModel: function getLevelModel() {
					return (this.hostTree.levelModels || [])[this.depth];
				}, setVisual: function setVisual(t, e) {
					this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, e);
				}, getVisual: function getVisual(t, e) {
					return this.hostTree.data.getItemVisual(this.dataIndex, t, e);
				}, getRawIndex: function getRawIndex() {
					return this.hostTree.data.getRawIndex(this.dataIndex);
				}, getId: function getId() {
					return this.hostTree.data.getId(this.dataIndex);
				} }, n.prototype = { constructor: n, type: "tree", eachNode: function eachNode(t, e, i) {
					this.root.eachNode(t, e, i);
				}, getNodeByDataIndex: function getNodeByDataIndex(t) {
					var e = this.data.getRawIndex(t);return this._nodes[e];
				}, getNodeByName: function getNodeByName(t) {
					return this.root.getNodeByName(t);
				}, update: function update() {
					for (var t = this.data, e = this._nodes, i = 0, n = e.length; i < n; i++) {
						e[i].dataIndex = -1;
					}for (var i = 0, n = t.count(); i < n; i++) {
						e[t.getRawIndex(i)].dataIndex = i;
					}
				}, clearLayouts: function clearLayouts() {
					this.data.clearItemLayouts();
				} }, n.createTree = function (t, e, i) {
				function r(t, e) {
					var i = t.value;f = Math.max(f, o.isArray(i) ? i.length : 1), d.push(t);var n = new c(t.name, h);e ? a(n, e) : h.root = n, h._nodes.push(n);var s = t.children;if (s) for (var l = 0; l < s.length; l++) {
						r(s[l], n);
					}
				}var h = new n(e, i),
				    d = [],
				    f = 1;r(t), h.root.updateDepthAndHeight(0);var p = u([{ name: "value" }], d, { dimCount: f }),
				    g = new s(p, e);return g.initData(d), l({ mainData: g, struct: h, structAttr: "tree" }), h.update(), h;
			}, t.exports = n;
		}, function (t, e, i) {
			"use strict";
			function n(t) {
				return t.get("stack") || "__ec_stack_" + t.seriesIndex;
			}function a(t) {
				return t.dim;
			}function o(t, e, i) {
				var o = i.getWidth(),
				    u = i.getHeight(),
				    c = {},
				    h = {},
				    d = r(s.filter(e.getSeriesByType(t), function (t) {
					return !e.isSeriesFiltered(t) && t.coordinateSystem && "polar" === t.coordinateSystem.type;
				}));e.eachSeriesByType(t, function (t) {
					if ("polar" === t.coordinateSystem.type) {
						var e = t.getData(),
						    i = t.coordinateSystem,
						    r = i.getAngleAxis(),
						    s = i.getBaseAxis(),
						    f = n(t),
						    p = d[a(s)][f],
						    g = p.offset,
						    m = p.width,
						    v = i.getOtherAxis(s),
						    y = t.get("center") || ["50%", "50%"],
						    x = l(y[0], o),
						    _ = l(y[1], u),
						    b = t.get("barMinHeight") || 0,
						    w = t.get("barMinAngle") || 0,
						    S = v.getExtent()[0],
						    M = v.model.get("max"),
						    I = v.model.get("min"),
						    T = i.dataToPoints(e);c[f] = c[f] || [], h[f] = h[f] || [], e.each(v.dim, function (t, n) {
							if (!isNaN(t)) {
								c[f][n] || (c[f][n] = { p: S, n: S }, h[f][n] = { p: S, n: S });var a,
								    o,
								    s,
								    l,
								    u = t >= 0 ? "p" : "n",
								    d = i.pointToCoord(T[n]),
								    p = h[f][n][u];if ("radius" === v.dim) a = p, o = d[0], s = (-d[1] + g) * Math.PI / 180, l = s + m * Math.PI / 180, Math.abs(o) < b && (o = a + (o < 0 ? -1 : 1) * b), h[f][n][u] = o;else {
									a = d[0] + g, o = a + m, null != M && (t = Math.min(t, M)), null != I && (t = Math.max(t, I));var y = r.dataToAngle(t);Math.abs(y - p) < w && (y = p - (t < 0 ? -1 : 1) * w), s = -p * Math.PI / 180, l = -y * Math.PI / 180;var A = r.getExtent(),
									    C = y;C === A[0] && t > 0 ? C = A[1] : C === A[1] && t < 0 && (C = A[0]), h[f][n][u] = C;
								}e.setItemLayout(n, { cx: x, cy: _, r0: a, r: o, startAngle: s, endAngle: l });
							}
						}, !0);
					}
				}, this);
			}function r(t, e) {
				var i = {};s.each(t, function (t, e) {
					var o = t.getData(),
					    r = t.coordinateSystem,
					    s = r.getBaseAxis(),
					    u = s.getExtent(),
					    c = "category" === s.type ? s.getBandWidth() : Math.abs(u[1] - u[0]) / o.count(),
					    h = i[a(s)] || { bandWidth: c, remainedWidth: c, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {} },
					    d = h.stacks;i[a(s)] = h;var f = n(t);d[f] || h.autoWidthCount++, d[f] = d[f] || { width: 0, maxWidth: 0 };var p = l(t.get("barWidth"), c),
					    g = l(t.get("barMaxWidth"), c),
					    m = t.get("barGap"),
					    v = t.get("barCategoryGap");p && !d[f].width && (p = Math.min(h.remainedWidth, p), d[f].width = p, h.remainedWidth -= p), g && (d[f].maxWidth = g), null != m && (h.gap = m), null != v && (h.categoryGap = v);
				});var o = {};return s.each(i, function (t, e) {
					o[e] = {};var i = t.stacks,
					    n = t.bandWidth,
					    a = l(t.categoryGap, n),
					    r = l(t.gap, 1),
					    u = t.remainedWidth,
					    c = t.autoWidthCount,
					    h = (u - a) / (c + (c - 1) * r);h = Math.max(h, 0), s.each(i, function (t, e) {
						var i = t.maxWidth;i && i < h && (i = Math.min(i, u), t.width && (i = Math.min(i, t.width)), u -= i, t.width = i, c--);
					}), h = (u - a) / (c + (c - 1) * r), h = Math.max(h, 0);var d,
					    f = 0;s.each(i, function (t, e) {
						t.width || (t.width = h), d = t, f += t.width * (1 + r);
					}), d && (f -= d.width * r);var p = -f / 2;s.each(i, function (t, i) {
						o[e][i] = o[e][i] || { offset: p, width: t.width }, p += t.width * (1 + r);
					});
				}), o;
			}var s = i(1),
			    l = i(4).parsePercent;t.exports = o;
		}, function (t, e, i) {
			function n() {
				var t,
				    e = [],
				    i = {};return { add: function add(t, n, o, r, s) {
						return a.isString(r) && (s = r, r = 0), !i[t.id] && (i[t.id] = 1, e.push({ el: t, target: n, time: o, delay: r, easing: s }), !0);
					}, done: function done(e) {
						return t = e, this;
					}, start: function start() {
						function n() {
							a--, a || (e.length = 0, i = {}, t && t());
						}for (var a = e.length, o = 0, r = e.length; o < r; o++) {
							var s = e[o];s.el.animateTo(s.target, s.time, s.delay, s.easing, n);
						}return this;
					} };
			}var a = i(1);t.exports = { createWrap: n };
		}]);
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(206)(module)))

/***/ }),
/* 206 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _ListItem = __webpack_require__(208);

	var _ListItem2 = _interopRequireDefault(_ListItem);

	var _reactImmutableRenderMixin = __webpack_require__(185);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var List = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(List, _Component);

	    function List(props) {
	        _classCallCheck(this, List);

	        var _this = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, props));

	        _this.state = {
	            list: [{
	                name: '',
	                icon: [{ icon: 'row', name: '' }, { icon: 'column', name: '' }]
	            }, {
	                name: '',
	                icon: [{ icon: 'div', name: 'div' }, { icon: 'link', name: '' }, { icon: 'pieChart', name: '' }]
	            }]
	        };
	        return _this;
	    }

	    _createClass(List, [{
	        key: 'render',
	        value: function render() {
	            var childrens = this.state.list.map(function (val, i) {
	                return _react2.default.createElement(
	                    'li',
	                    { key: 'list_' + val.name + i, style: { width: '100%', marginTop: i ? '20px' : '0' } },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'list_title' },
	                        val.name
	                    ),
	                    _react2.default.createElement(_ListItem2.default, { icons: val.icon })
	                );
	            });
	            return _react2.default.createElement(
	                'ul',
	                null,
	                childrens
	            );
	        }
	    }]);

	    return List;
	}(_react.Component)) || _class;

	exports.default = List;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _utils = __webpack_require__(195);

	var _utils2 = _interopRequireDefault(_utils);

	var _server = __webpack_require__(192);

	var _server2 = _interopRequireDefault(_server);

	var _reactImmutableRenderMixin = __webpack_require__(185);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ListItem = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(ListItem, _Component);

	    function ListItem(props) {
	        _classCallCheck(this, ListItem);

	        return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).call(this, props));
	    }

	    _createClass(ListItem, [{
	        key: 'mouseDown',
	        value: function mouseDown(iconItem, event) {
	            var offset = _utils2.default.offset(event.target),
	                icon = event._targetInst._currentElement.props.icon,
	                param = {
	                offset: offset,
	                icon: iconItem
	            };
	            _server2.default.emit('listItem:drag_start', param);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this2 = this;

	            var icons = this.props.icons;

	            icons = icons.map(function (val, index) {
	                return _react2.default.createElement(
	                    'li',
	                    { className: 'list_item', key: 'list_item_' + val.icon },
	                    _react2.default.createElement('div', { className: "drag-item iconfont icon-" + val.icon, icon: val.icon, onMouseDown: _this2.mouseDown.bind(_this2, val) }),
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'icon_info' },
	                        val.name
	                    )
	                );
	            });
	            return _react2.default.createElement(
	                'ul',
	                { className: 'list_block' },
	                icons
	            );
	        }
	    }]);

	    return ListItem;
	}(_react.Component)) || _class;

	exports.default = ListItem;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _utils = __webpack_require__(195);

	var _utils2 = _interopRequireDefault(_utils);

	var _server = __webpack_require__(192);

	var _server2 = _interopRequireDefault(_server);

	var _reactImmutableRenderMixin = __webpack_require__(185);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var DragItem = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(DragItem, _Component);

	    function DragItem(props) {
	        _classCallCheck(this, DragItem);

	        var _this = _possibleConstructorReturn(this, (DragItem.__proto__ || Object.getPrototypeOf(DragItem)).call(this, props));

	        _this.state = {
	            currentIcon: {},
	            isShow: false,
	            offset: {
	                left: 0,
	                top: 0
	            }
	        };
	        return _this;
	    }

	    _createClass(DragItem, [{
	        key: 'mouseMove',
	        value: function mouseMove(event) {
	            if (this.state.isShow) {
	                var offset = {
	                    left: event.clientX - 22,
	                    top: event.clientY - 28
	                };
	                this.setState({ offset: offset });
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var currentIcon = this.state.currentIcon;
	            return _react2.default.createElement(
	                'div',
	                { className: 'list_item drag_item', style: { display: this.state.isShow ? 'block' : 'none', left: this.state.offset.left, top: this.state.offset.top - 35 } },
	                _react2.default.createElement('div', { className: "drag-item iconfont icon-" + currentIcon.icon, icon: currentIcon.icon }),
	                _react2.default.createElement(
	                    'div',
	                    { className: 'icon_info' },
	                    currentIcon.name
	                )
	            );
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this2 = this;

	            var instance = this;
	            _server2.default.on('listItem:drag_start', function (param) {
	                _this2.setState({
	                    isShow: true,
	                    currentIcon: param.icon,
	                    offset: param.offset
	                });
	            });
	            _server2.default.on('listItem:drag_move', function (offset) {
	                _this2.setState({
	                    offset: offset
	                });
	            });
	            _server2.default.on('listItem:drag_end2', function (offset) {
	                _this2.setState({
	                    isShow: false
	                });
	            });
	        }
	    }]);

	    return DragItem;
	}(_react.Component)) || _class;

	exports.default = DragItem;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _utils = __webpack_require__(195);

	var _utils2 = _interopRequireDefault(_utils);

	var _server = __webpack_require__(192);

	var _server2 = _interopRequireDefault(_server);

	var _reactImmutableRenderMixin = __webpack_require__(185);

	var _CodeMirror = __webpack_require__(211);

	var _CodeMirror2 = _interopRequireDefault(_CodeMirror);

	var _showHint = __webpack_require__(212);

	var _showHint2 = _interopRequireDefault(_showHint);

	var _cssHint = __webpack_require__(213);

	var _cssHint2 = _interopRequireDefault(_cssHint);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var RightSlider = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(RightSlider, _Component);

	    function RightSlider(props) {
	        _classCallCheck(this, RightSlider);

	        var _this = _possibleConstructorReturn(this, (RightSlider.__proto__ || Object.getPrototypeOf(RightSlider)).call(this, props));

	        _this.clickSlider = _this.clickSlider.bind(_this);
	        _this.state = {
	            active: true,
	            btnClass: "icon-slider",
	            dom: {
	                active: false
	            },
	            attr: {
	                active: false
	            },
	            style: {
	                active: true
	            }
	        };
	        return _this;
	    }

	    _createClass(RightSlider, [{
	        key: 'mouseUp',
	        value: function mouseUp() {
	            _server2.default.emit('listItem:drag_start', param);
	        }
	    }, {
	        key: 'getInitData',
	        value: function getInitData() {
	            return {
	                dom: {
	                    active: false
	                },
	                attr: {
	                    active: false
	                },
	                style: {
	                    active: false
	                }
	            };
	        }
	    }, {
	        key: 'clickLi',
	        value: function clickLi(type) {
	            var data = this.getInitData();
	            data[type].active = true;
	            this.setState(data);
	        }
	    }, {
	        key: 'clickSlider',
	        value: function clickSlider() {
	            var btnClass = "icon-slider";
	            if (this.state.active) {
	                btnClass = "icon-open";
	            }
	            this.setState({ active: !this.state.active, btnClass: btnClass });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { id: 'rightSlider', className: this.state.active ? "open" : "close" },
	                _react2.default.createElement('div', { className: 'iconfont sliderBtn ' + this.state.btnClass, onClick: this.clickSlider }),
	                _react2.default.createElement(
	                    'ul',
	                    { className: 'tabList' },
	                    _react2.default.createElement(
	                        'li',
	                        { className: this.state.style.active ? "active" : "", onClick: this.clickLi.bind(this, "style") },
	                        'Style'
	                    ),
	                    _react2.default.createElement(
	                        'li',
	                        { className: this.state.attr.active ? "active" : "", onClick: this.clickLi.bind(this, "attr") },
	                        '\u5C5E\u6027'
	                    ),
	                    _react2.default.createElement(
	                        'li',
	                        { className: this.state.dom.active ? "active" : "", onClick: this.clickLi.bind(this, "dom") },
	                        'DOM\u6811'
	                    )
	                ),
	                _react2.default.createElement(
	                    'div',
	                    { className: 'styleBlock' },
	                    _react2.default.createElement('textarea', { ref: 'style', name: 'style', id: 'style' })
	                )
	            );
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            if (!this.style) {
	                this.style = _CodeMirror2.default.fromTextArea(this.refs.style, {
	                    extraKeys: { "Ctrl-Space": "autocomplete" },
	                    "theme": "darcula",
	                    lineNumbers: true,
	                    styleActiveLine: true,
	                    matchBrackets: true
	                });
	            }
	        }
	    }]);

	    return RightSlider;
	}(_react.Component)) || _class;

	exports.default = RightSlider;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	// This is CodeMirror (http://codemirror.net), a code editor
	// implemented in JavaScript on top of the browser's DOM.
	//
	// You can find some technical background for some of the code below
	// at http://marijnhaverbeke.nl/blog/#cm-internals .

	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.CodeMirror = factory());
	}(this, (function () { 'use strict';

	// Kludges for bugs and behavior differences that can't be feature
	// detected are enabled based on userAgent etc sniffing.
	var userAgent = navigator.userAgent;
	var platform = navigator.platform;

	var gecko = /gecko\/\d/i.test(userAgent);
	var ie_upto10 = /MSIE \d/.test(userAgent);
	var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
	var edge = /Edge\/(\d+)/.exec(userAgent);
	var ie = ie_upto10 || ie_11up || edge;
	var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
	var webkit = !edge && /WebKit\//.test(userAgent);
	var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
	var chrome = !edge && /Chrome\//.test(userAgent);
	var presto = /Opera\//.test(userAgent);
	var safari = /Apple Computer/.test(navigator.vendor);
	var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
	var phantom = /PhantomJS/.test(userAgent);

	var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
	var android = /Android/.test(userAgent);
	// This is woefully incomplete. Suggestions for alternative methods welcome.
	var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
	var mac = ios || /Mac/.test(platform);
	var chromeOS = /\bCrOS\b/.test(userAgent);
	var windows = /win/i.test(platform);

	var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
	if (presto_version) { presto_version = Number(presto_version[1]); }
	if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
	// Some browsers use the wrong event properties to signal cmd/ctrl on OS X
	var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
	var captureRightClick = gecko || (ie && ie_version >= 9);

	function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

	var rmClass = function(node, cls) {
	  var current = node.className;
	  var match = classTest(cls).exec(current);
	  if (match) {
	    var after = current.slice(match.index + match[0].length);
	    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
	  }
	};

	function removeChildren(e) {
	  for (var count = e.childNodes.length; count > 0; --count)
	    { e.removeChild(e.firstChild); }
	  return e
	}

	function removeChildrenAndAdd(parent, e) {
	  return removeChildren(parent).appendChild(e)
	}

	function elt(tag, content, className, style) {
	  var e = document.createElement(tag);
	  if (className) { e.className = className; }
	  if (style) { e.style.cssText = style; }
	  if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
	  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
	  return e
	}
	// wrapper for elt, which removes the elt from the accessibility tree
	function eltP(tag, content, className, style) {
	  var e = elt(tag, content, className, style);
	  e.setAttribute("role", "presentation");
	  return e
	}

	var range;
	if (document.createRange) { range = function(node, start, end, endNode) {
	  var r = document.createRange();
	  r.setEnd(endNode || node, end);
	  r.setStart(node, start);
	  return r
	}; }
	else { range = function(node, start, end) {
	  var r = document.body.createTextRange();
	  try { r.moveToElementText(node.parentNode); }
	  catch(e) { return r }
	  r.collapse(true);
	  r.moveEnd("character", end);
	  r.moveStart("character", start);
	  return r
	}; }

	function contains(parent, child) {
	  if (child.nodeType == 3) // Android browser always returns false when child is a textnode
	    { child = child.parentNode; }
	  if (parent.contains)
	    { return parent.contains(child) }
	  do {
	    if (child.nodeType == 11) { child = child.host; }
	    if (child == parent) { return true }
	  } while (child = child.parentNode)
	}

	function activeElt() {
	  // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
	  // IE < 10 will throw when accessed while the page is loading or in an iframe.
	  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
	  var activeElement;
	  try {
	    activeElement = document.activeElement;
	  } catch(e) {
	    activeElement = document.body || null;
	  }
	  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
	    { activeElement = activeElement.shadowRoot.activeElement; }
	  return activeElement
	}

	function addClass(node, cls) {
	  var current = node.className;
	  if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
	}
	function joinClasses(a, b) {
	  var as = a.split(" ");
	  for (var i = 0; i < as.length; i++)
	    { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
	  return b
	}

	var selectInput = function(node) { node.select(); };
	if (ios) // Mobile Safari apparently has a bug where select() is broken.
	  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
	else if (ie) // Suppress mysterious IE10 errors
	  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

	function bind(f) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  return function(){return f.apply(null, args)}
	}

	function copyObj(obj, target, overwrite) {
	  if (!target) { target = {}; }
	  for (var prop in obj)
	    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
	      { target[prop] = obj[prop]; } }
	  return target
	}

	// Counts the column offset in a string, taking tabs into account.
	// Used mostly to find indentation.
	function countColumn(string, end, tabSize, startIndex, startValue) {
	  if (end == null) {
	    end = string.search(/[^\s\u00a0]/);
	    if (end == -1) { end = string.length; }
	  }
	  for (var i = startIndex || 0, n = startValue || 0;;) {
	    var nextTab = string.indexOf("\t", i);
	    if (nextTab < 0 || nextTab >= end)
	      { return n + (end - i) }
	    n += nextTab - i;
	    n += tabSize - (n % tabSize);
	    i = nextTab + 1;
	  }
	}

	var Delayed = function() {this.id = null;};
	Delayed.prototype.set = function (ms, f) {
	  clearTimeout(this.id);
	  this.id = setTimeout(f, ms);
	};

	function indexOf(array, elt) {
	  for (var i = 0; i < array.length; ++i)
	    { if (array[i] == elt) { return i } }
	  return -1
	}

	// Number of pixels added to scroller and sizer to hide scrollbar
	var scrollerGap = 30;

	// Returned or thrown by various protocols to signal 'I'm not
	// handling this'.
	var Pass = {toString: function(){return "CodeMirror.Pass"}};

	// Reused option objects for setSelection & friends
	var sel_dontScroll = {scroll: false};
	var sel_mouse = {origin: "*mouse"};
	var sel_move = {origin: "+move"};

	// The inverse of countColumn -- find the offset that corresponds to
	// a particular column.
	function findColumn(string, goal, tabSize) {
	  for (var pos = 0, col = 0;;) {
	    var nextTab = string.indexOf("\t", pos);
	    if (nextTab == -1) { nextTab = string.length; }
	    var skipped = nextTab - pos;
	    if (nextTab == string.length || col + skipped >= goal)
	      { return pos + Math.min(skipped, goal - col) }
	    col += nextTab - pos;
	    col += tabSize - (col % tabSize);
	    pos = nextTab + 1;
	    if (col >= goal) { return pos }
	  }
	}

	var spaceStrs = [""];
	function spaceStr(n) {
	  while (spaceStrs.length <= n)
	    { spaceStrs.push(lst(spaceStrs) + " "); }
	  return spaceStrs[n]
	}

	function lst(arr) { return arr[arr.length-1] }

	function map(array, f) {
	  var out = [];
	  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
	  return out
	}

	function insertSorted(array, value, score) {
	  var pos = 0, priority = score(value);
	  while (pos < array.length && score(array[pos]) <= priority) { pos++; }
	  array.splice(pos, 0, value);
	}

	function nothing() {}

	function createObj(base, props) {
	  var inst;
	  if (Object.create) {
	    inst = Object.create(base);
	  } else {
	    nothing.prototype = base;
	    inst = new nothing();
	  }
	  if (props) { copyObj(props, inst); }
	  return inst
	}

	var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
	function isWordCharBasic(ch) {
	  return /\w/.test(ch) || ch > "\x80" &&
	    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
	}
	function isWordChar(ch, helper) {
	  if (!helper) { return isWordCharBasic(ch) }
	  if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
	  return helper.test(ch)
	}

	function isEmpty(obj) {
	  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
	  return true
	}

	// Extending unicode characters. A series of a non-extending char +
	// any number of extending chars is treated as a single unit as far
	// as editing and measuring is concerned. This is not fully correct,
	// since some scripts/fonts/browsers also treat other configurations
	// of code points as a group.
	var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
	function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

	// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
	function skipExtendingChars(str, pos, dir) {
	  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
	  return pos
	}

	// Returns the value from the range [`from`; `to`] that satisfies
	// `pred` and is closest to `from`. Assumes that at least `to`
	// satisfies `pred`. Supports `from` being greater than `to`.
	function findFirst(pred, from, to) {
	  // At any point we are certain `to` satisfies `pred`, don't know
	  // whether `from` does.
	  var dir = from > to ? -1 : 1;
	  for (;;) {
	    if (from == to) { return from }
	    var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
	    if (mid == from) { return pred(mid) ? from : to }
	    if (pred(mid)) { to = mid; }
	    else { from = mid + dir; }
	  }
	}

	// The display handles the DOM integration, both for input reading
	// and content drawing. It holds references to DOM nodes and
	// display-related state.

	function Display(place, doc, input) {
	  var d = this;
	  this.input = input;

	  // Covers bottom-right square when both scrollbars are present.
	  d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
	  d.scrollbarFiller.setAttribute("cm-not-content", "true");
	  // Covers bottom of gutter when coverGutterNextToScrollbar is on
	  // and h scrollbar is present.
	  d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
	  d.gutterFiller.setAttribute("cm-not-content", "true");
	  // Will contain the actual code, positioned to cover the viewport.
	  d.lineDiv = eltP("div", null, "CodeMirror-code");
	  // Elements are added to these to represent selection and cursors.
	  d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
	  d.cursorDiv = elt("div", null, "CodeMirror-cursors");
	  // A visibility: hidden element used to find the size of things.
	  d.measure = elt("div", null, "CodeMirror-measure");
	  // When lines outside of the viewport are measured, they are drawn in this.
	  d.lineMeasure = elt("div", null, "CodeMirror-measure");
	  // Wraps everything that needs to exist inside the vertically-padded coordinate system
	  d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
	                    null, "position: relative; outline: none");
	  var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
	  // Moved around its parent to cover visible view.
	  d.mover = elt("div", [lines], null, "position: relative");
	  // Set to the height of the document, allowing scrolling.
	  d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
	  d.sizerWidth = null;
	  // Behavior of elts with overflow: auto and padding is
	  // inconsistent across browsers. This is used to ensure the
	  // scrollable area is big enough.
	  d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
	  // Will contain the gutters, if any.
	  d.gutters = elt("div", null, "CodeMirror-gutters");
	  d.lineGutter = null;
	  // Actual scrollable element.
	  d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
	  d.scroller.setAttribute("tabIndex", "-1");
	  // The element in which the editor lives.
	  d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

	  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
	  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
	  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

	  if (place) {
	    if (place.appendChild) { place.appendChild(d.wrapper); }
	    else { place(d.wrapper); }
	  }

	  // Current rendered range (may be bigger than the view window).
	  d.viewFrom = d.viewTo = doc.first;
	  d.reportedViewFrom = d.reportedViewTo = doc.first;
	  // Information about the rendered lines.
	  d.view = [];
	  d.renderedView = null;
	  // Holds info about a single rendered line when it was rendered
	  // for measurement, while not in view.
	  d.externalMeasured = null;
	  // Empty space (in pixels) above the view
	  d.viewOffset = 0;
	  d.lastWrapHeight = d.lastWrapWidth = 0;
	  d.updateLineNumbers = null;

	  d.nativeBarWidth = d.barHeight = d.barWidth = 0;
	  d.scrollbarsClipped = false;

	  // Used to only resize the line number gutter when necessary (when
	  // the amount of lines crosses a boundary that makes its width change)
	  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
	  // Set to true when a non-horizontal-scrolling line widget is
	  // added. As an optimization, line widget aligning is skipped when
	  // this is false.
	  d.alignWidgets = false;

	  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

	  // Tracks the maximum line length so that the horizontal scrollbar
	  // can be kept static when scrolling.
	  d.maxLine = null;
	  d.maxLineLength = 0;
	  d.maxLineChanged = false;

	  // Used for measuring wheel scrolling granularity
	  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

	  // True when shift is held down.
	  d.shift = false;

	  // Used to track whether anything happened since the context menu
	  // was opened.
	  d.selForContextMenu = null;

	  d.activeTouch = null;

	  input.init(d);
	}

	// Find the line object corresponding to the given line number.
	function getLine(doc, n) {
	  n -= doc.first;
	  if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
	  var chunk = doc;
	  while (!chunk.lines) {
	    for (var i = 0;; ++i) {
	      var child = chunk.children[i], sz = child.chunkSize();
	      if (n < sz) { chunk = child; break }
	      n -= sz;
	    }
	  }
	  return chunk.lines[n]
	}

	// Get the part of a document between two positions, as an array of
	// strings.
	function getBetween(doc, start, end) {
	  var out = [], n = start.line;
	  doc.iter(start.line, end.line + 1, function (line) {
	    var text = line.text;
	    if (n == end.line) { text = text.slice(0, end.ch); }
	    if (n == start.line) { text = text.slice(start.ch); }
	    out.push(text);
	    ++n;
	  });
	  return out
	}
	// Get the lines between from and to, as array of strings.
	function getLines(doc, from, to) {
	  var out = [];
	  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
	  return out
	}

	// Update the height of a line, propagating the height change
	// upwards to parent nodes.
	function updateLineHeight(line, height) {
	  var diff = height - line.height;
	  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
	}

	// Given a line object, find its line number by walking up through
	// its parent links.
	function lineNo(line) {
	  if (line.parent == null) { return null }
	  var cur = line.parent, no = indexOf(cur.lines, line);
	  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
	    for (var i = 0;; ++i) {
	      if (chunk.children[i] == cur) { break }
	      no += chunk.children[i].chunkSize();
	    }
	  }
	  return no + cur.first
	}

	// Find the line at the given vertical position, using the height
	// information in the document tree.
	function lineAtHeight(chunk, h) {
	  var n = chunk.first;
	  outer: do {
	    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
	      var child = chunk.children[i$1], ch = child.height;
	      if (h < ch) { chunk = child; continue outer }
	      h -= ch;
	      n += child.chunkSize();
	    }
	    return n
	  } while (!chunk.lines)
	  var i = 0;
	  for (; i < chunk.lines.length; ++i) {
	    var line = chunk.lines[i], lh = line.height;
	    if (h < lh) { break }
	    h -= lh;
	  }
	  return n + i
	}

	function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

	function lineNumberFor(options, i) {
	  return String(options.lineNumberFormatter(i + options.firstLineNumber))
	}

	// A Pos instance represents a position within the text.
	function Pos(line, ch, sticky) {
	  if ( sticky === void 0 ) sticky = null;

	  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
	  this.line = line;
	  this.ch = ch;
	  this.sticky = sticky;
	}

	// Compare two positions, return 0 if they are the same, a negative
	// number when a is less, and a positive number otherwise.
	function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

	function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

	function copyPos(x) {return Pos(x.line, x.ch)}
	function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
	function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

	// Most of the external API clips given positions to make sure they
	// actually exist within the document.
	function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
	function clipPos(doc, pos) {
	  if (pos.line < doc.first) { return Pos(doc.first, 0) }
	  var last = doc.first + doc.size - 1;
	  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
	  return clipToLen(pos, getLine(doc, pos.line).text.length)
	}
	function clipToLen(pos, linelen) {
	  var ch = pos.ch;
	  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
	  else if (ch < 0) { return Pos(pos.line, 0) }
	  else { return pos }
	}
	function clipPosArray(doc, array) {
	  var out = [];
	  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
	  return out
	}

	// Optimize some code when these features are not used.
	var sawReadOnlySpans = false;
	var sawCollapsedSpans = false;

	function seeReadOnlySpans() {
	  sawReadOnlySpans = true;
	}

	function seeCollapsedSpans() {
	  sawCollapsedSpans = true;
	}

	// TEXTMARKER SPANS

	function MarkedSpan(marker, from, to) {
	  this.marker = marker;
	  this.from = from; this.to = to;
	}

	// Search an array of spans for a span matching the given marker.
	function getMarkedSpanFor(spans, marker) {
	  if (spans) { for (var i = 0; i < spans.length; ++i) {
	    var span = spans[i];
	    if (span.marker == marker) { return span }
	  } }
	}
	// Remove a span from an array, returning undefined if no spans are
	// left (we don't store arrays for lines without spans).
	function removeMarkedSpan(spans, span) {
	  var r;
	  for (var i = 0; i < spans.length; ++i)
	    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
	  return r
	}
	// Add a span to a line.
	function addMarkedSpan(line, span) {
	  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
	  span.marker.attachLine(line);
	}

	// Used for the algorithm that adjusts markers for a change in the
	// document. These functions cut an array of spans at a given
	// character position, returning an array of remaining chunks (or
	// undefined if nothing remains).
	function markedSpansBefore(old, startCh, isInsert) {
	  var nw;
	  if (old) { for (var i = 0; i < old.length; ++i) {
	    var span = old[i], marker = span.marker;
	    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
	    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
	      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
	    }
	  } }
	  return nw
	}
	function markedSpansAfter(old, endCh, isInsert) {
	  var nw;
	  if (old) { for (var i = 0; i < old.length; ++i) {
	    var span = old[i], marker = span.marker;
	    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
	    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
	      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
	                                            span.to == null ? null : span.to - endCh));
	    }
	  } }
	  return nw
	}

	// Given a change object, compute the new set of marker spans that
	// cover the line in which the change took place. Removes spans
	// entirely within the change, reconnects spans belonging to the
	// same marker that appear on both sides of the change, and cuts off
	// spans partially within the change. Returns an array of span
	// arrays with one element for each line in (after) the change.
	function stretchSpansOverChange(doc, change) {
	  if (change.full) { return null }
	  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
	  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
	  if (!oldFirst && !oldLast) { return null }

	  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
	  // Get the spans that 'stick out' on both sides
	  var first = markedSpansBefore(oldFirst, startCh, isInsert);
	  var last = markedSpansAfter(oldLast, endCh, isInsert);

	  // Next, merge those two ends
	  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
	  if (first) {
	    // Fix up .to properties of first
	    for (var i = 0; i < first.length; ++i) {
	      var span = first[i];
	      if (span.to == null) {
	        var found = getMarkedSpanFor(last, span.marker);
	        if (!found) { span.to = startCh; }
	        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
	      }
	    }
	  }
	  if (last) {
	    // Fix up .from in last (or move them into first in case of sameLine)
	    for (var i$1 = 0; i$1 < last.length; ++i$1) {
	      var span$1 = last[i$1];
	      if (span$1.to != null) { span$1.to += offset; }
	      if (span$1.from == null) {
	        var found$1 = getMarkedSpanFor(first, span$1.marker);
	        if (!found$1) {
	          span$1.from = offset;
	          if (sameLine) { (first || (first = [])).push(span$1); }
	        }
	      } else {
	        span$1.from += offset;
	        if (sameLine) { (first || (first = [])).push(span$1); }
	      }
	    }
	  }
	  // Make sure we didn't create any zero-length spans
	  if (first) { first = clearEmptySpans(first); }
	  if (last && last != first) { last = clearEmptySpans(last); }

	  var newMarkers = [first];
	  if (!sameLine) {
	    // Fill gap with whole-line-spans
	    var gap = change.text.length - 2, gapMarkers;
	    if (gap > 0 && first)
	      { for (var i$2 = 0; i$2 < first.length; ++i$2)
	        { if (first[i$2].to == null)
	          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
	    for (var i$3 = 0; i$3 < gap; ++i$3)
	      { newMarkers.push(gapMarkers); }
	    newMarkers.push(last);
	  }
	  return newMarkers
	}

	// Remove spans that are empty and don't have a clearWhenEmpty
	// option of false.
	function clearEmptySpans(spans) {
	  for (var i = 0; i < spans.length; ++i) {
	    var span = spans[i];
	    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
	      { spans.splice(i--, 1); }
	  }
	  if (!spans.length) { return null }
	  return spans
	}

	// Used to 'clip' out readOnly ranges when making a change.
	function removeReadOnlyRanges(doc, from, to) {
	  var markers = null;
	  doc.iter(from.line, to.line + 1, function (line) {
	    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	      var mark = line.markedSpans[i].marker;
	      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
	        { (markers || (markers = [])).push(mark); }
	    } }
	  });
	  if (!markers) { return null }
	  var parts = [{from: from, to: to}];
	  for (var i = 0; i < markers.length; ++i) {
	    var mk = markers[i], m = mk.find(0);
	    for (var j = 0; j < parts.length; ++j) {
	      var p = parts[j];
	      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
	      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
	      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
	        { newParts.push({from: p.from, to: m.from}); }
	      if (dto > 0 || !mk.inclusiveRight && !dto)
	        { newParts.push({from: m.to, to: p.to}); }
	      parts.splice.apply(parts, newParts);
	      j += newParts.length - 3;
	    }
	  }
	  return parts
	}

	// Connect or disconnect spans from a line.
	function detachMarkedSpans(line) {
	  var spans = line.markedSpans;
	  if (!spans) { return }
	  for (var i = 0; i < spans.length; ++i)
	    { spans[i].marker.detachLine(line); }
	  line.markedSpans = null;
	}
	function attachMarkedSpans(line, spans) {
	  if (!spans) { return }
	  for (var i = 0; i < spans.length; ++i)
	    { spans[i].marker.attachLine(line); }
	  line.markedSpans = spans;
	}

	// Helpers used when computing which overlapping collapsed span
	// counts as the larger one.
	function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
	function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

	// Returns a number indicating which of two overlapping collapsed
	// spans is larger (and thus includes the other). Falls back to
	// comparing ids when the spans cover exactly the same range.
	function compareCollapsedMarkers(a, b) {
	  var lenDiff = a.lines.length - b.lines.length;
	  if (lenDiff != 0) { return lenDiff }
	  var aPos = a.find(), bPos = b.find();
	  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
	  if (fromCmp) { return -fromCmp }
	  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
	  if (toCmp) { return toCmp }
	  return b.id - a.id
	}

	// Find out whether a line ends or starts in a collapsed span. If
	// so, return the marker for that span.
	function collapsedSpanAtSide(line, start) {
	  var sps = sawCollapsedSpans && line.markedSpans, found;
	  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	    sp = sps[i];
	    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
	        (!found || compareCollapsedMarkers(found, sp.marker) < 0))
	      { found = sp.marker; }
	  } }
	  return found
	}
	function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
	function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

	// Test whether there exists a collapsed span that partially
	// overlaps (covers the start or end, but not both) of a new span.
	// Such overlap is not allowed.
	function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
	  var line = getLine(doc, lineNo$$1);
	  var sps = sawCollapsedSpans && line.markedSpans;
	  if (sps) { for (var i = 0; i < sps.length; ++i) {
	    var sp = sps[i];
	    if (!sp.marker.collapsed) { continue }
	    var found = sp.marker.find(0);
	    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
	    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
	    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
	    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
	        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
	      { return true }
	  } }
	}

	// A visual line is a line as drawn on the screen. Folding, for
	// example, can cause multiple logical lines to appear on the same
	// visual line. This finds the start of the visual line that the
	// given line is part of (usually that is the line itself).
	function visualLine(line) {
	  var merged;
	  while (merged = collapsedSpanAtStart(line))
	    { line = merged.find(-1, true).line; }
	  return line
	}

	function visualLineEnd(line) {
	  var merged;
	  while (merged = collapsedSpanAtEnd(line))
	    { line = merged.find(1, true).line; }
	  return line
	}

	// Returns an array of logical lines that continue the visual line
	// started by the argument, or undefined if there are no such lines.
	function visualLineContinued(line) {
	  var merged, lines;
	  while (merged = collapsedSpanAtEnd(line)) {
	    line = merged.find(1, true).line
	    ;(lines || (lines = [])).push(line);
	  }
	  return lines
	}

	// Get the line number of the start of the visual line that the
	// given line number is part of.
	function visualLineNo(doc, lineN) {
	  var line = getLine(doc, lineN), vis = visualLine(line);
	  if (line == vis) { return lineN }
	  return lineNo(vis)
	}

	// Get the line number of the start of the next visual line after
	// the given line.
	function visualLineEndNo(doc, lineN) {
	  if (lineN > doc.lastLine()) { return lineN }
	  var line = getLine(doc, lineN), merged;
	  if (!lineIsHidden(doc, line)) { return lineN }
	  while (merged = collapsedSpanAtEnd(line))
	    { line = merged.find(1, true).line; }
	  return lineNo(line) + 1
	}

	// Compute whether a line is hidden. Lines count as hidden when they
	// are part of a visual line that starts with another line, or when
	// they are entirely covered by collapsed, non-widget span.
	function lineIsHidden(doc, line) {
	  var sps = sawCollapsedSpans && line.markedSpans;
	  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	    sp = sps[i];
	    if (!sp.marker.collapsed) { continue }
	    if (sp.from == null) { return true }
	    if (sp.marker.widgetNode) { continue }
	    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
	      { return true }
	  } }
	}
	function lineIsHiddenInner(doc, line, span) {
	  if (span.to == null) {
	    var end = span.marker.find(1, true);
	    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
	  }
	  if (span.marker.inclusiveRight && span.to == line.text.length)
	    { return true }
	  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
	    sp = line.markedSpans[i];
	    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
	        (sp.to == null || sp.to != span.from) &&
	        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
	        lineIsHiddenInner(doc, line, sp)) { return true }
	  }
	}

	// Find the height above the given line.
	function heightAtLine(lineObj) {
	  lineObj = visualLine(lineObj);

	  var h = 0, chunk = lineObj.parent;
	  for (var i = 0; i < chunk.lines.length; ++i) {
	    var line = chunk.lines[i];
	    if (line == lineObj) { break }
	    else { h += line.height; }
	  }
	  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
	    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
	      var cur = p.children[i$1];
	      if (cur == chunk) { break }
	      else { h += cur.height; }
	    }
	  }
	  return h
	}

	// Compute the character length of a line, taking into account
	// collapsed ranges (see markText) that might hide parts, and join
	// other lines onto it.
	function lineLength(line) {
	  if (line.height == 0) { return 0 }
	  var len = line.text.length, merged, cur = line;
	  while (merged = collapsedSpanAtStart(cur)) {
	    var found = merged.find(0, true);
	    cur = found.from.line;
	    len += found.from.ch - found.to.ch;
	  }
	  cur = line;
	  while (merged = collapsedSpanAtEnd(cur)) {
	    var found$1 = merged.find(0, true);
	    len -= cur.text.length - found$1.from.ch;
	    cur = found$1.to.line;
	    len += cur.text.length - found$1.to.ch;
	  }
	  return len
	}

	// Find the longest line in the document.
	function findMaxLine(cm) {
	  var d = cm.display, doc = cm.doc;
	  d.maxLine = getLine(doc, doc.first);
	  d.maxLineLength = lineLength(d.maxLine);
	  d.maxLineChanged = true;
	  doc.iter(function (line) {
	    var len = lineLength(line);
	    if (len > d.maxLineLength) {
	      d.maxLineLength = len;
	      d.maxLine = line;
	    }
	  });
	}

	// BIDI HELPERS

	function iterateBidiSections(order, from, to, f) {
	  if (!order) { return f(from, to, "ltr", 0) }
	  var found = false;
	  for (var i = 0; i < order.length; ++i) {
	    var part = order[i];
	    if (part.from < to && part.to > from || from == to && part.to == from) {
	      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
	      found = true;
	    }
	  }
	  if (!found) { f(from, to, "ltr"); }
	}

	var bidiOther = null;
	function getBidiPartAt(order, ch, sticky) {
	  var found;
	  bidiOther = null;
	  for (var i = 0; i < order.length; ++i) {
	    var cur = order[i];
	    if (cur.from < ch && cur.to > ch) { return i }
	    if (cur.to == ch) {
	      if (cur.from != cur.to && sticky == "before") { found = i; }
	      else { bidiOther = i; }
	    }
	    if (cur.from == ch) {
	      if (cur.from != cur.to && sticky != "before") { found = i; }
	      else { bidiOther = i; }
	    }
	  }
	  return found != null ? found : bidiOther
	}

	// Bidirectional ordering algorithm
	// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
	// that this (partially) implements.

	// One-char codes used for character types:
	// L (L):   Left-to-Right
	// R (R):   Right-to-Left
	// r (AL):  Right-to-Left Arabic
	// 1 (EN):  European Number
	// + (ES):  European Number Separator
	// % (ET):  European Number Terminator
	// n (AN):  Arabic Number
	// , (CS):  Common Number Separator
	// m (NSM): Non-Spacing Mark
	// b (BN):  Boundary Neutral
	// s (B):   Paragraph Separator
	// t (S):   Segment Separator
	// w (WS):  Whitespace
	// N (ON):  Other Neutrals

	// Returns null if characters are ordered as they appear
	// (left-to-right), or an array of sections ({from, to, level}
	// objects) in the order in which they occur visually.
	var bidiOrdering = (function() {
	  // Character types for codepoints 0 to 0xff
	  var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
	  // Character types for codepoints 0x600 to 0x6f9
	  var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
	  function charType(code) {
	    if (code <= 0xf7) { return lowTypes.charAt(code) }
	    else if (0x590 <= code && code <= 0x5f4) { return "R" }
	    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
	    else if (0x6ee <= code && code <= 0x8ac) { return "r" }
	    else if (0x2000 <= code && code <= 0x200b) { return "w" }
	    else if (code == 0x200c) { return "b" }
	    else { return "L" }
	  }

	  var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
	  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

	  function BidiSpan(level, from, to) {
	    this.level = level;
	    this.from = from; this.to = to;
	  }

	  return function(str, direction) {
	    var outerType = direction == "ltr" ? "L" : "R";

	    if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
	    var len = str.length, types = [];
	    for (var i = 0; i < len; ++i)
	      { types.push(charType(str.charCodeAt(i))); }

	    // W1. Examine each non-spacing mark (NSM) in the level run, and
	    // change the type of the NSM to the type of the previous
	    // character. If the NSM is at the start of the level run, it will
	    // get the type of sor.
	    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
	      var type = types[i$1];
	      if (type == "m") { types[i$1] = prev; }
	      else { prev = type; }
	    }

	    // W2. Search backwards from each instance of a European number
	    // until the first strong type (R, L, AL, or sor) is found. If an
	    // AL is found, change the type of the European number to Arabic
	    // number.
	    // W3. Change all ALs to R.
	    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
	      var type$1 = types[i$2];
	      if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
	      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
	    }

	    // W4. A single European separator between two European numbers
	    // changes to a European number. A single common separator between
	    // two numbers of the same type changes to that type.
	    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
	      var type$2 = types[i$3];
	      if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
	      else if (type$2 == "," && prev$1 == types[i$3+1] &&
	               (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
	      prev$1 = type$2;
	    }

	    // W5. A sequence of European terminators adjacent to European
	    // numbers changes to all European numbers.
	    // W6. Otherwise, separators and terminators change to Other
	    // Neutral.
	    for (var i$4 = 0; i$4 < len; ++i$4) {
	      var type$3 = types[i$4];
	      if (type$3 == ",") { types[i$4] = "N"; }
	      else if (type$3 == "%") {
	        var end = (void 0);
	        for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
	        var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
	        for (var j = i$4; j < end; ++j) { types[j] = replace; }
	        i$4 = end - 1;
	      }
	    }

	    // W7. Search backwards from each instance of a European number
	    // until the first strong type (R, L, or sor) is found. If an L is
	    // found, then change the type of the European number to L.
	    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
	      var type$4 = types[i$5];
	      if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
	      else if (isStrong.test(type$4)) { cur$1 = type$4; }
	    }

	    // N1. A sequence of neutrals takes the direction of the
	    // surrounding strong text if the text on both sides has the same
	    // direction. European and Arabic numbers act as if they were R in
	    // terms of their influence on neutrals. Start-of-level-run (sor)
	    // and end-of-level-run (eor) are used at level run boundaries.
	    // N2. Any remaining neutrals take the embedding direction.
	    for (var i$6 = 0; i$6 < len; ++i$6) {
	      if (isNeutral.test(types[i$6])) {
	        var end$1 = (void 0);
	        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
	        var before = (i$6 ? types[i$6-1] : outerType) == "L";
	        var after = (end$1 < len ? types[end$1] : outerType) == "L";
	        var replace$1 = before == after ? (before ? "L" : "R") : outerType;
	        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
	        i$6 = end$1 - 1;
	      }
	    }

	    // Here we depart from the documented algorithm, in order to avoid
	    // building up an actual levels array. Since there are only three
	    // levels (0, 1, 2) in an implementation that doesn't take
	    // explicit embedding into account, we can build up the order on
	    // the fly, without following the level-based algorithm.
	    var order = [], m;
	    for (var i$7 = 0; i$7 < len;) {
	      if (countsAsLeft.test(types[i$7])) {
	        var start = i$7;
	        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
	        order.push(new BidiSpan(0, start, i$7));
	      } else {
	        var pos = i$7, at = order.length;
	        for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
	        for (var j$2 = pos; j$2 < i$7;) {
	          if (countsAsNum.test(types[j$2])) {
	            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
	            var nstart = j$2;
	            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
	            order.splice(at, 0, new BidiSpan(2, nstart, j$2));
	            pos = j$2;
	          } else { ++j$2; }
	        }
	        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
	      }
	    }
	    if (direction == "ltr") {
	      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
	        order[0].from = m[0].length;
	        order.unshift(new BidiSpan(0, 0, m[0].length));
	      }
	      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
	        lst(order).to -= m[0].length;
	        order.push(new BidiSpan(0, len - m[0].length, len));
	      }
	    }

	    return direction == "rtl" ? order.reverse() : order
	  }
	})();

	// Get the bidi ordering for the given line (and cache it). Returns
	// false for lines that are fully left-to-right, and an array of
	// BidiSpan objects otherwise.
	function getOrder(line, direction) {
	  var order = line.order;
	  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
	  return order
	}

	// EVENT HANDLING

	// Lightweight event framework. on/off also work on DOM nodes,
	// registering native DOM handlers.

	var noHandlers = [];

	var on = function(emitter, type, f) {
	  if (emitter.addEventListener) {
	    emitter.addEventListener(type, f, false);
	  } else if (emitter.attachEvent) {
	    emitter.attachEvent("on" + type, f);
	  } else {
	    var map$$1 = emitter._handlers || (emitter._handlers = {});
	    map$$1[type] = (map$$1[type] || noHandlers).concat(f);
	  }
	};

	function getHandlers(emitter, type) {
	  return emitter._handlers && emitter._handlers[type] || noHandlers
	}

	function off(emitter, type, f) {
	  if (emitter.removeEventListener) {
	    emitter.removeEventListener(type, f, false);
	  } else if (emitter.detachEvent) {
	    emitter.detachEvent("on" + type, f);
	  } else {
	    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
	    if (arr) {
	      var index = indexOf(arr, f);
	      if (index > -1)
	        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
	    }
	  }
	}

	function signal(emitter, type /*, values...*/) {
	  var handlers = getHandlers(emitter, type);
	  if (!handlers.length) { return }
	  var args = Array.prototype.slice.call(arguments, 2);
	  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
	}

	// The DOM events that CodeMirror handles can be overridden by
	// registering a (non-DOM) handler on the editor for the event name,
	// and preventDefault-ing the event in that handler.
	function signalDOMEvent(cm, e, override) {
	  if (typeof e == "string")
	    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
	  signal(cm, override || e.type, cm, e);
	  return e_defaultPrevented(e) || e.codemirrorIgnore
	}

	function signalCursorActivity(cm) {
	  var arr = cm._handlers && cm._handlers.cursorActivity;
	  if (!arr) { return }
	  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
	  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
	    { set.push(arr[i]); } }
	}

	function hasHandler(emitter, type) {
	  return getHandlers(emitter, type).length > 0
	}

	// Add on and off methods to a constructor's prototype, to make
	// registering events on such objects more convenient.
	function eventMixin(ctor) {
	  ctor.prototype.on = function(type, f) {on(this, type, f);};
	  ctor.prototype.off = function(type, f) {off(this, type, f);};
	}

	// Due to the fact that we still support jurassic IE versions, some
	// compatibility wrappers are needed.

	function e_preventDefault(e) {
	  if (e.preventDefault) { e.preventDefault(); }
	  else { e.returnValue = false; }
	}
	function e_stopPropagation(e) {
	  if (e.stopPropagation) { e.stopPropagation(); }
	  else { e.cancelBubble = true; }
	}
	function e_defaultPrevented(e) {
	  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
	}
	function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

	function e_target(e) {return e.target || e.srcElement}
	function e_button(e) {
	  var b = e.which;
	  if (b == null) {
	    if (e.button & 1) { b = 1; }
	    else if (e.button & 2) { b = 3; }
	    else if (e.button & 4) { b = 2; }
	  }
	  if (mac && e.ctrlKey && b == 1) { b = 3; }
	  return b
	}

	// Detect drag-and-drop
	var dragAndDrop = function() {
	  // There is *some* kind of drag-and-drop support in IE6-8, but I
	  // couldn't get it to work yet.
	  if (ie && ie_version < 9) { return false }
	  var div = elt('div');
	  return "draggable" in div || "dragDrop" in div
	}();

	var zwspSupported;
	function zeroWidthElement(measure) {
	  if (zwspSupported == null) {
	    var test = elt("span", "\u200b");
	    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
	    if (measure.firstChild.offsetHeight != 0)
	      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
	  }
	  var node = zwspSupported ? elt("span", "\u200b") :
	    elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
	  node.setAttribute("cm-text", "");
	  return node
	}

	// Feature-detect IE's crummy client rect reporting for bidi text
	var badBidiRects;
	function hasBadBidiRects(measure) {
	  if (badBidiRects != null) { return badBidiRects }
	  var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
	  var r0 = range(txt, 0, 1).getBoundingClientRect();
	  var r1 = range(txt, 1, 2).getBoundingClientRect();
	  removeChildren(measure);
	  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
	  return badBidiRects = (r1.right - r0.right < 3)
	}

	// See if "".split is the broken IE version, if so, provide an
	// alternative way to split lines.
	var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
	  var pos = 0, result = [], l = string.length;
	  while (pos <= l) {
	    var nl = string.indexOf("\n", pos);
	    if (nl == -1) { nl = string.length; }
	    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
	    var rt = line.indexOf("\r");
	    if (rt != -1) {
	      result.push(line.slice(0, rt));
	      pos += rt + 1;
	    } else {
	      result.push(line);
	      pos = nl + 1;
	    }
	  }
	  return result
	} : function (string) { return string.split(/\r\n?|\n/); };

	var hasSelection = window.getSelection ? function (te) {
	  try { return te.selectionStart != te.selectionEnd }
	  catch(e) { return false }
	} : function (te) {
	  var range$$1;
	  try {range$$1 = te.ownerDocument.selection.createRange();}
	  catch(e) {}
	  if (!range$$1 || range$$1.parentElement() != te) { return false }
	  return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
	};

	var hasCopyEvent = (function () {
	  var e = elt("div");
	  if ("oncopy" in e) { return true }
	  e.setAttribute("oncopy", "return;");
	  return typeof e.oncopy == "function"
	})();

	var badZoomedRects = null;
	function hasBadZoomedRects(measure) {
	  if (badZoomedRects != null) { return badZoomedRects }
	  var node = removeChildrenAndAdd(measure, elt("span", "x"));
	  var normal = node.getBoundingClientRect();
	  var fromRange = range(node, 0, 1).getBoundingClientRect();
	  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
	}

	// Known modes, by name and by MIME
	var modes = {};
	var mimeModes = {};

	// Extra arguments are stored as the mode's dependencies, which is
	// used by (legacy) mechanisms like loadmode.js to automatically
	// load a mode. (Preferred mechanism is the require/define calls.)
	function defineMode(name, mode) {
	  if (arguments.length > 2)
	    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
	  modes[name] = mode;
	}

	function defineMIME(mime, spec) {
	  mimeModes[mime] = spec;
	}

	// Given a MIME type, a {name, ...options} config object, or a name
	// string, return a mode config object.
	function resolveMode(spec) {
	  if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
	    spec = mimeModes[spec];
	  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
	    var found = mimeModes[spec.name];
	    if (typeof found == "string") { found = {name: found}; }
	    spec = createObj(found, spec);
	    spec.name = found.name;
	  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
	    return resolveMode("application/xml")
	  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
	    return resolveMode("application/json")
	  }
	  if (typeof spec == "string") { return {name: spec} }
	  else { return spec || {name: "null"} }
	}

	// Given a mode spec (anything that resolveMode accepts), find and
	// initialize an actual mode object.
	function getMode(options, spec) {
	  spec = resolveMode(spec);
	  var mfactory = modes[spec.name];
	  if (!mfactory) { return getMode(options, "text/plain") }
	  var modeObj = mfactory(options, spec);
	  if (modeExtensions.hasOwnProperty(spec.name)) {
	    var exts = modeExtensions[spec.name];
	    for (var prop in exts) {
	      if (!exts.hasOwnProperty(prop)) { continue }
	      if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
	      modeObj[prop] = exts[prop];
	    }
	  }
	  modeObj.name = spec.name;
	  if (spec.helperType) { modeObj.helperType = spec.helperType; }
	  if (spec.modeProps) { for (var prop$1 in spec.modeProps)
	    { modeObj[prop$1] = spec.modeProps[prop$1]; } }

	  return modeObj
	}

	// This can be used to attach properties to mode objects from
	// outside the actual mode definition.
	var modeExtensions = {};
	function extendMode(mode, properties) {
	  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
	  copyObj(properties, exts);
	}

	function copyState(mode, state) {
	  if (state === true) { return state }
	  if (mode.copyState) { return mode.copyState(state) }
	  var nstate = {};
	  for (var n in state) {
	    var val = state[n];
	    if (val instanceof Array) { val = val.concat([]); }
	    nstate[n] = val;
	  }
	  return nstate
	}

	// Given a mode and a state (for that mode), find the inner mode and
	// state at the position that the state refers to.
	function innerMode(mode, state) {
	  var info;
	  while (mode.innerMode) {
	    info = mode.innerMode(state);
	    if (!info || info.mode == mode) { break }
	    state = info.state;
	    mode = info.mode;
	  }
	  return info || {mode: mode, state: state}
	}

	function startState(mode, a1, a2) {
	  return mode.startState ? mode.startState(a1, a2) : true
	}

	// STRING STREAM

	// Fed to the mode parsers, provides helper functions to make
	// parsers more succinct.

	var StringStream = function(string, tabSize, lineOracle) {
	  this.pos = this.start = 0;
	  this.string = string;
	  this.tabSize = tabSize || 8;
	  this.lastColumnPos = this.lastColumnValue = 0;
	  this.lineStart = 0;
	  this.lineOracle = lineOracle;
	};

	StringStream.prototype.eol = function () {return this.pos >= this.string.length};
	StringStream.prototype.sol = function () {return this.pos == this.lineStart};
	StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
	StringStream.prototype.next = function () {
	  if (this.pos < this.string.length)
	    { return this.string.charAt(this.pos++) }
	};
	StringStream.prototype.eat = function (match) {
	  var ch = this.string.charAt(this.pos);
	  var ok;
	  if (typeof match == "string") { ok = ch == match; }
	  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
	  if (ok) {++this.pos; return ch}
	};
	StringStream.prototype.eatWhile = function (match) {
	  var start = this.pos;
	  while (this.eat(match)){}
	  return this.pos > start
	};
	StringStream.prototype.eatSpace = function () {
	    var this$1 = this;

	  var start = this.pos;
	  while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
	  return this.pos > start
	};
	StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
	StringStream.prototype.skipTo = function (ch) {
	  var found = this.string.indexOf(ch, this.pos);
	  if (found > -1) {this.pos = found; return true}
	};
	StringStream.prototype.backUp = function (n) {this.pos -= n;};
	StringStream.prototype.column = function () {
	  if (this.lastColumnPos < this.start) {
	    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
	    this.lastColumnPos = this.start;
	  }
	  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	};
	StringStream.prototype.indentation = function () {
	  return countColumn(this.string, null, this.tabSize) -
	    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	};
	StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
	  if (typeof pattern == "string") {
	    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
	    var substr = this.string.substr(this.pos, pattern.length);
	    if (cased(substr) == cased(pattern)) {
	      if (consume !== false) { this.pos += pattern.length; }
	      return true
	    }
	  } else {
	    var match = this.string.slice(this.pos).match(pattern);
	    if (match && match.index > 0) { return null }
	    if (match && consume !== false) { this.pos += match[0].length; }
	    return match
	  }
	};
	StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
	StringStream.prototype.hideFirstChars = function (n, inner) {
	  this.lineStart += n;
	  try { return inner() }
	  finally { this.lineStart -= n; }
	};
	StringStream.prototype.lookAhead = function (n) {
	  var oracle = this.lineOracle;
	  return oracle && oracle.lookAhead(n)
	};
	StringStream.prototype.baseToken = function () {
	  var oracle = this.lineOracle;
	  return oracle && oracle.baseToken(this.pos)
	};

	var SavedContext = function(state, lookAhead) {
	  this.state = state;
	  this.lookAhead = lookAhead;
	};

	var Context = function(doc, state, line, lookAhead) {
	  this.state = state;
	  this.doc = doc;
	  this.line = line;
	  this.maxLookAhead = lookAhead || 0;
	  this.baseTokens = null;
	  this.baseTokenPos = 1;
	};

	Context.prototype.lookAhead = function (n) {
	  var line = this.doc.getLine(this.line + n);
	  if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
	  return line
	};

	Context.prototype.baseToken = function (n) {
	    var this$1 = this;

	  if (!this.baseTokens) { return null }
	  while (this.baseTokens[this.baseTokenPos] <= n)
	    { this$1.baseTokenPos += 2; }
	  var type = this.baseTokens[this.baseTokenPos + 1];
	  return {type: type && type.replace(/( |^)overlay .*/, ""),
	          size: this.baseTokens[this.baseTokenPos] - n}
	};

	Context.prototype.nextLine = function () {
	  this.line++;
	  if (this.maxLookAhead > 0) { this.maxLookAhead--; }
	};

	Context.fromSaved = function (doc, saved, line) {
	  if (saved instanceof SavedContext)
	    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
	  else
	    { return new Context(doc, copyState(doc.mode, saved), line) }
	};

	Context.prototype.save = function (copy) {
	  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
	  return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
	};


	// Compute a style array (an array starting with a mode generation
	// -- for invalidation -- followed by pairs of end positions and
	// style strings), which is used to highlight the tokens on the
	// line.
	function highlightLine(cm, line, context, forceToEnd) {
	  // A styles array always starts with a number identifying the
	  // mode/overlays that it is based on (for easy invalidation).
	  var st = [cm.state.modeGen], lineClasses = {};
	  // Compute the base array of styles
	  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
	          lineClasses, forceToEnd);
	  var state = context.state;

	  // Run overlays, adjust style array.
	  var loop = function ( o ) {
	    context.baseTokens = st;
	    var overlay = cm.state.overlays[o], i = 1, at = 0;
	    context.state = true;
	    runMode(cm, line.text, overlay.mode, context, function (end, style) {
	      var start = i;
	      // Ensure there's a token end at the current position, and that i points at it
	      while (at < end) {
	        var i_end = st[i];
	        if (i_end > end)
	          { st.splice(i, 1, end, st[i+1], i_end); }
	        i += 2;
	        at = Math.min(end, i_end);
	      }
	      if (!style) { return }
	      if (overlay.opaque) {
	        st.splice(start, i - start, end, "overlay " + style);
	        i = start + 2;
	      } else {
	        for (; start < i; start += 2) {
	          var cur = st[start+1];
	          st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
	        }
	      }
	    }, lineClasses);
	    context.state = state;
	    context.baseTokens = null;
	    context.baseTokenPos = 1;
	  };

	  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

	  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
	}

	function getLineStyles(cm, line, updateFrontier) {
	  if (!line.styles || line.styles[0] != cm.state.modeGen) {
	    var context = getContextBefore(cm, lineNo(line));
	    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
	    var result = highlightLine(cm, line, context);
	    if (resetState) { context.state = resetState; }
	    line.stateAfter = context.save(!resetState);
	    line.styles = result.styles;
	    if (result.classes) { line.styleClasses = result.classes; }
	    else if (line.styleClasses) { line.styleClasses = null; }
	    if (updateFrontier === cm.doc.highlightFrontier)
	      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
	  }
	  return line.styles
	}

	function getContextBefore(cm, n, precise) {
	  var doc = cm.doc, display = cm.display;
	  if (!doc.mode.startState) { return new Context(doc, true, n) }
	  var start = findStartLine(cm, n, precise);
	  var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
	  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

	  doc.iter(start, n, function (line) {
	    processLine(cm, line.text, context);
	    var pos = context.line;
	    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
	    context.nextLine();
	  });
	  if (precise) { doc.modeFrontier = context.line; }
	  return context
	}

	// Lightweight form of highlight -- proceed over this line and
	// update state, but don't save a style array. Used for lines that
	// aren't currently visible.
	function processLine(cm, text, context, startAt) {
	  var mode = cm.doc.mode;
	  var stream = new StringStream(text, cm.options.tabSize, context);
	  stream.start = stream.pos = startAt || 0;
	  if (text == "") { callBlankLine(mode, context.state); }
	  while (!stream.eol()) {
	    readToken(mode, stream, context.state);
	    stream.start = stream.pos;
	  }
	}

	function callBlankLine(mode, state) {
	  if (mode.blankLine) { return mode.blankLine(state) }
	  if (!mode.innerMode) { return }
	  var inner = innerMode(mode, state);
	  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
	}

	function readToken(mode, stream, state, inner) {
	  for (var i = 0; i < 10; i++) {
	    if (inner) { inner[0] = innerMode(mode, state).mode; }
	    var style = mode.token(stream, state);
	    if (stream.pos > stream.start) { return style }
	  }
	  throw new Error("Mode " + mode.name + " failed to advance stream.")
	}

	var Token = function(stream, type, state) {
	  this.start = stream.start; this.end = stream.pos;
	  this.string = stream.current();
	  this.type = type || null;
	  this.state = state;
	};

	// Utility for getTokenAt and getLineTokens
	function takeToken(cm, pos, precise, asArray) {
	  var doc = cm.doc, mode = doc.mode, style;
	  pos = clipPos(doc, pos);
	  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
	  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
	  if (asArray) { tokens = []; }
	  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
	    stream.start = stream.pos;
	    style = readToken(mode, stream, context.state);
	    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
	  }
	  return asArray ? tokens : new Token(stream, style, context.state)
	}

	function extractLineClasses(type, output) {
	  if (type) { for (;;) {
	    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
	    if (!lineClass) { break }
	    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
	    var prop = lineClass[1] ? "bgClass" : "textClass";
	    if (output[prop] == null)
	      { output[prop] = lineClass[2]; }
	    else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
	      { output[prop] += " " + lineClass[2]; }
	  } }
	  return type
	}

	// Run the given mode's parser over a line, calling f for each token.
	function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
	  var flattenSpans = mode.flattenSpans;
	  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
	  var curStart = 0, curStyle = null;
	  var stream = new StringStream(text, cm.options.tabSize, context), style;
	  var inner = cm.options.addModeClass && [null];
	  if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
	  while (!stream.eol()) {
	    if (stream.pos > cm.options.maxHighlightLength) {
	      flattenSpans = false;
	      if (forceToEnd) { processLine(cm, text, context, stream.pos); }
	      stream.pos = text.length;
	      style = null;
	    } else {
	      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
	    }
	    if (inner) {
	      var mName = inner[0].name;
	      if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
	    }
	    if (!flattenSpans || curStyle != style) {
	      while (curStart < stream.start) {
	        curStart = Math.min(stream.start, curStart + 5000);
	        f(curStart, curStyle);
	      }
	      curStyle = style;
	    }
	    stream.start = stream.pos;
	  }
	  while (curStart < stream.pos) {
	    // Webkit seems to refuse to render text nodes longer than 57444
	    // characters, and returns inaccurate measurements in nodes
	    // starting around 5000 chars.
	    var pos = Math.min(stream.pos, curStart + 5000);
	    f(pos, curStyle);
	    curStart = pos;
	  }
	}

	// Finds the line to start with when starting a parse. Tries to
	// find a line with a stateAfter, so that it can start with a
	// valid state. If that fails, it returns the line with the
	// smallest indentation, which tends to need the least context to
	// parse correctly.
	function findStartLine(cm, n, precise) {
	  var minindent, minline, doc = cm.doc;
	  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
	  for (var search = n; search > lim; --search) {
	    if (search <= doc.first) { return doc.first }
	    var line = getLine(doc, search - 1), after = line.stateAfter;
	    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
	      { return search }
	    var indented = countColumn(line.text, null, cm.options.tabSize);
	    if (minline == null || minindent > indented) {
	      minline = search - 1;
	      minindent = indented;
	    }
	  }
	  return minline
	}

	function retreatFrontier(doc, n) {
	  doc.modeFrontier = Math.min(doc.modeFrontier, n);
	  if (doc.highlightFrontier < n - 10) { return }
	  var start = doc.first;
	  for (var line = n - 1; line > start; line--) {
	    var saved = getLine(doc, line).stateAfter;
	    // change is on 3
	    // state on line 1 looked ahead 2 -- so saw 3
	    // test 1 + 2 < 3 should cover this
	    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
	      start = line + 1;
	      break
	    }
	  }
	  doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
	}

	// LINE DATA STRUCTURE

	// Line objects. These hold state related to a line, including
	// highlighting info (the styles array).
	var Line = function(text, markedSpans, estimateHeight) {
	  this.text = text;
	  attachMarkedSpans(this, markedSpans);
	  this.height = estimateHeight ? estimateHeight(this) : 1;
	};

	Line.prototype.lineNo = function () { return lineNo(this) };
	eventMixin(Line);

	// Change the content (text, markers) of a line. Automatically
	// invalidates cached information and tries to re-estimate the
	// line's height.
	function updateLine(line, text, markedSpans, estimateHeight) {
	  line.text = text;
	  if (line.stateAfter) { line.stateAfter = null; }
	  if (line.styles) { line.styles = null; }
	  if (line.order != null) { line.order = null; }
	  detachMarkedSpans(line);
	  attachMarkedSpans(line, markedSpans);
	  var estHeight = estimateHeight ? estimateHeight(line) : 1;
	  if (estHeight != line.height) { updateLineHeight(line, estHeight); }
	}

	// Detach a line from the document tree and its markers.
	function cleanUpLine(line) {
	  line.parent = null;
	  detachMarkedSpans(line);
	}

	// Convert a style as returned by a mode (either null, or a string
	// containing one or more styles) to a CSS style. This is cached,
	// and also looks for line-wide styles.
	var styleToClassCache = {};
	var styleToClassCacheWithMode = {};
	function interpretTokenStyle(style, options) {
	  if (!style || /^\s*$/.test(style)) { return null }
	  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
	  return cache[style] ||
	    (cache[style] = style.replace(/\S+/g, "cm-$&"))
	}

	// Render the DOM representation of the text of a line. Also builds
	// up a 'line map', which points at the DOM nodes that represent
	// specific stretches of text, and is used by the measuring code.
	// The returned object contains the DOM node, this map, and
	// information about line-wide styles that were set by the mode.
	function buildLineContent(cm, lineView) {
	  // The padding-right forces the element to have a 'border', which
	  // is needed on Webkit to be able to get line-level bounding
	  // rectangles for it (in measureChar).
	  var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
	  var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
	                 col: 0, pos: 0, cm: cm,
	                 trailingSpace: false,
	                 splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
	  lineView.measure = {};

	  // Iterate over the logical lines that make up this visual line.
	  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
	    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
	    builder.pos = 0;
	    builder.addToken = buildToken;
	    // Optionally wire in some hacks into the token-rendering
	    // algorithm, to deal with browser quirks.
	    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
	      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
	    builder.map = [];
	    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
	    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
	    if (line.styleClasses) {
	      if (line.styleClasses.bgClass)
	        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
	      if (line.styleClasses.textClass)
	        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
	    }

	    // Ensure at least a single node is present, for measuring.
	    if (builder.map.length == 0)
	      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

	    // Store the map and a cache object for the current logical line
	    if (i == 0) {
	      lineView.measure.map = builder.map;
	      lineView.measure.cache = {};
	    } else {
	      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
	      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
	    }
	  }

	  // See issue #2901
	  if (webkit) {
	    var last = builder.content.lastChild;
	    if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
	      { builder.content.className = "cm-tab-wrap-hack"; }
	  }

	  signal(cm, "renderLine", cm, lineView.line, builder.pre);
	  if (builder.pre.className)
	    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

	  return builder
	}

	function defaultSpecialCharPlaceholder(ch) {
	  var token = elt("span", "\u2022", "cm-invalidchar");
	  token.title = "\\u" + ch.charCodeAt(0).toString(16);
	  token.setAttribute("aria-label", token.title);
	  return token
	}

	// Build up the DOM representation for a single token, and add it to
	// the line map. Takes care to render special characters separately.
	function buildToken(builder, text, style, startStyle, endStyle, title, css) {
	  if (!text) { return }
	  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
	  var special = builder.cm.state.specialChars, mustWrap = false;
	  var content;
	  if (!special.test(text)) {
	    builder.col += text.length;
	    content = document.createTextNode(displayText);
	    builder.map.push(builder.pos, builder.pos + text.length, content);
	    if (ie && ie_version < 9) { mustWrap = true; }
	    builder.pos += text.length;
	  } else {
	    content = document.createDocumentFragment();
	    var pos = 0;
	    while (true) {
	      special.lastIndex = pos;
	      var m = special.exec(text);
	      var skipped = m ? m.index - pos : text.length - pos;
	      if (skipped) {
	        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
	        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
	        else { content.appendChild(txt); }
	        builder.map.push(builder.pos, builder.pos + skipped, txt);
	        builder.col += skipped;
	        builder.pos += skipped;
	      }
	      if (!m) { break }
	      pos += skipped + 1;
	      var txt$1 = (void 0);
	      if (m[0] == "\t") {
	        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
	        txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
	        txt$1.setAttribute("role", "presentation");
	        txt$1.setAttribute("cm-text", "\t");
	        builder.col += tabWidth;
	      } else if (m[0] == "\r" || m[0] == "\n") {
	        txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
	        txt$1.setAttribute("cm-text", m[0]);
	        builder.col += 1;
	      } else {
	        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
	        txt$1.setAttribute("cm-text", m[0]);
	        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
	        else { content.appendChild(txt$1); }
	        builder.col += 1;
	      }
	      builder.map.push(builder.pos, builder.pos + 1, txt$1);
	      builder.pos++;
	    }
	  }
	  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
	  if (style || startStyle || endStyle || mustWrap || css) {
	    var fullStyle = style || "";
	    if (startStyle) { fullStyle += startStyle; }
	    if (endStyle) { fullStyle += endStyle; }
	    var token = elt("span", [content], fullStyle, css);
	    if (title) { token.title = title; }
	    return builder.content.appendChild(token)
	  }
	  builder.content.appendChild(content);
	}

	function splitSpaces(text, trailingBefore) {
	  if (text.length > 1 && !/  /.test(text)) { return text }
	  var spaceBefore = trailingBefore, result = "";
	  for (var i = 0; i < text.length; i++) {
	    var ch = text.charAt(i);
	    if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
	      { ch = "\u00a0"; }
	    result += ch;
	    spaceBefore = ch == " ";
	  }
	  return result
	}

	// Work around nonsense dimensions being reported for stretches of
	// right-to-left text.
	function buildTokenBadBidi(inner, order) {
	  return function (builder, text, style, startStyle, endStyle, title, css) {
	    style = style ? style + " cm-force-border" : "cm-force-border";
	    var start = builder.pos, end = start + text.length;
	    for (;;) {
	      // Find the part that overlaps with the start of this text
	      var part = (void 0);
	      for (var i = 0; i < order.length; i++) {
	        part = order[i];
	        if (part.to > start && part.from <= start) { break }
	      }
	      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }
	      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
	      startStyle = null;
	      text = text.slice(part.to - start);
	      start = part.to;
	    }
	  }
	}

	function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
	  var widget = !ignoreWidget && marker.widgetNode;
	  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
	  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
	    if (!widget)
	      { widget = builder.content.appendChild(document.createElement("span")); }
	    widget.setAttribute("cm-marker", marker.id);
	  }
	  if (widget) {
	    builder.cm.display.input.setUneditable(widget);
	    builder.content.appendChild(widget);
	  }
	  builder.pos += size;
	  builder.trailingSpace = false;
	}

	// Outputs a number of spans to make up a line, taking highlighting
	// and marked text into account.
	function insertLineContent(line, builder, styles) {
	  var spans = line.markedSpans, allText = line.text, at = 0;
	  if (!spans) {
	    for (var i$1 = 1; i$1 < styles.length; i$1+=2)
	      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
	    return
	  }

	  var len = allText.length, pos = 0, i = 1, text = "", style, css;
	  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
	  for (;;) {
	    if (nextChange == pos) { // Update current marker set
	      spanStyle = spanEndStyle = spanStartStyle = title = css = "";
	      collapsed = null; nextChange = Infinity;
	      var foundBookmarks = [], endStyles = (void 0);
	      for (var j = 0; j < spans.length; ++j) {
	        var sp = spans[j], m = sp.marker;
	        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
	          foundBookmarks.push(m);
	        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
	          if (sp.to != null && sp.to != pos && nextChange > sp.to) {
	            nextChange = sp.to;
	            spanEndStyle = "";
	          }
	          if (m.className) { spanStyle += " " + m.className; }
	          if (m.css) { css = (css ? css + ";" : "") + m.css; }
	          if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
	          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
	          if (m.title && !title) { title = m.title; }
	          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
	            { collapsed = sp; }
	        } else if (sp.from > pos && nextChange > sp.from) {
	          nextChange = sp.from;
	        }
	      }
	      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
	        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

	      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
	        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
	      if (collapsed && (collapsed.from || 0) == pos) {
	        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
	                           collapsed.marker, collapsed.from == null);
	        if (collapsed.to == null) { return }
	        if (collapsed.to == pos) { collapsed = false; }
	      }
	    }
	    if (pos >= len) { break }

	    var upto = Math.min(len, nextChange);
	    while (true) {
	      if (text) {
	        var end = pos + text.length;
	        if (!collapsed) {
	          var tokenText = end > upto ? text.slice(0, upto - pos) : text;
	          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
	                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
	        }
	        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
	        pos = end;
	        spanStartStyle = "";
	      }
	      text = allText.slice(at, at = styles[i++]);
	      style = interpretTokenStyle(styles[i++], builder.cm.options);
	    }
	  }
	}


	// These objects are used to represent the visible (currently drawn)
	// part of the document. A LineView may correspond to multiple
	// logical lines, if those are connected by collapsed ranges.
	function LineView(doc, line, lineN) {
	  // The starting line
	  this.line = line;
	  // Continuing lines, if any
	  this.rest = visualLineContinued(line);
	  // Number of logical lines in this visual line
	  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
	  this.node = this.text = null;
	  this.hidden = lineIsHidden(doc, line);
	}

	// Create a range of LineView objects for the given lines.
	function buildViewArray(cm, from, to) {
	  var array = [], nextPos;
	  for (var pos = from; pos < to; pos = nextPos) {
	    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
	    nextPos = pos + view.size;
	    array.push(view);
	  }
	  return array
	}

	var operationGroup = null;

	function pushOperation(op) {
	  if (operationGroup) {
	    operationGroup.ops.push(op);
	  } else {
	    op.ownsGroup = operationGroup = {
	      ops: [op],
	      delayedCallbacks: []
	    };
	  }
	}

	function fireCallbacksForOps(group) {
	  // Calls delayed callbacks and cursorActivity handlers until no
	  // new ones appear
	  var callbacks = group.delayedCallbacks, i = 0;
	  do {
	    for (; i < callbacks.length; i++)
	      { callbacks[i].call(null); }
	    for (var j = 0; j < group.ops.length; j++) {
	      var op = group.ops[j];
	      if (op.cursorActivityHandlers)
	        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
	          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
	    }
	  } while (i < callbacks.length)
	}

	function finishOperation(op, endCb) {
	  var group = op.ownsGroup;
	  if (!group) { return }

	  try { fireCallbacksForOps(group); }
	  finally {
	    operationGroup = null;
	    endCb(group);
	  }
	}

	var orphanDelayedCallbacks = null;

	// Often, we want to signal events at a point where we are in the
	// middle of some work, but don't want the handler to start calling
	// other methods on the editor, which might be in an inconsistent
	// state or simply not expect any other events to happen.
	// signalLater looks whether there are any handlers, and schedules
	// them to be executed when the last operation ends, or, if no
	// operation is active, when a timeout fires.
	function signalLater(emitter, type /*, values...*/) {
	  var arr = getHandlers(emitter, type);
	  if (!arr.length) { return }
	  var args = Array.prototype.slice.call(arguments, 2), list;
	  if (operationGroup) {
	    list = operationGroup.delayedCallbacks;
	  } else if (orphanDelayedCallbacks) {
	    list = orphanDelayedCallbacks;
	  } else {
	    list = orphanDelayedCallbacks = [];
	    setTimeout(fireOrphanDelayed, 0);
	  }
	  var loop = function ( i ) {
	    list.push(function () { return arr[i].apply(null, args); });
	  };

	  for (var i = 0; i < arr.length; ++i)
	    loop( i );
	}

	function fireOrphanDelayed() {
	  var delayed = orphanDelayedCallbacks;
	  orphanDelayedCallbacks = null;
	  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
	}

	// When an aspect of a line changes, a string is added to
	// lineView.changes. This updates the relevant part of the line's
	// DOM structure.
	function updateLineForChanges(cm, lineView, lineN, dims) {
	  for (var j = 0; j < lineView.changes.length; j++) {
	    var type = lineView.changes[j];
	    if (type == "text") { updateLineText(cm, lineView); }
	    else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
	    else if (type == "class") { updateLineClasses(cm, lineView); }
	    else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
	  }
	  lineView.changes = null;
	}

	// Lines with gutter elements, widgets or a background class need to
	// be wrapped, and have the extra elements added to the wrapper div
	function ensureLineWrapped(lineView) {
	  if (lineView.node == lineView.text) {
	    lineView.node = elt("div", null, null, "position: relative");
	    if (lineView.text.parentNode)
	      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
	    lineView.node.appendChild(lineView.text);
	    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
	  }
	  return lineView.node
	}

	function updateLineBackground(cm, lineView) {
	  var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
	  if (cls) { cls += " CodeMirror-linebackground"; }
	  if (lineView.background) {
	    if (cls) { lineView.background.className = cls; }
	    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
	  } else if (cls) {
	    var wrap = ensureLineWrapped(lineView);
	    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
	    cm.display.input.setUneditable(lineView.background);
	  }
	}

	// Wrapper around buildLineContent which will reuse the structure
	// in display.externalMeasured when possible.
	function getLineContent(cm, lineView) {
	  var ext = cm.display.externalMeasured;
	  if (ext && ext.line == lineView.line) {
	    cm.display.externalMeasured = null;
	    lineView.measure = ext.measure;
	    return ext.built
	  }
	  return buildLineContent(cm, lineView)
	}

	// Redraw the line's text. Interacts with the background and text
	// classes because the mode may output tokens that influence these
	// classes.
	function updateLineText(cm, lineView) {
	  var cls = lineView.text.className;
	  var built = getLineContent(cm, lineView);
	  if (lineView.text == lineView.node) { lineView.node = built.pre; }
	  lineView.text.parentNode.replaceChild(built.pre, lineView.text);
	  lineView.text = built.pre;
	  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
	    lineView.bgClass = built.bgClass;
	    lineView.textClass = built.textClass;
	    updateLineClasses(cm, lineView);
	  } else if (cls) {
	    lineView.text.className = cls;
	  }
	}

	function updateLineClasses(cm, lineView) {
	  updateLineBackground(cm, lineView);
	  if (lineView.line.wrapClass)
	    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
	  else if (lineView.node != lineView.text)
	    { lineView.node.className = ""; }
	  var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
	  lineView.text.className = textClass || "";
	}

	function updateLineGutter(cm, lineView, lineN, dims) {
	  if (lineView.gutter) {
	    lineView.node.removeChild(lineView.gutter);
	    lineView.gutter = null;
	  }
	  if (lineView.gutterBackground) {
	    lineView.node.removeChild(lineView.gutterBackground);
	    lineView.gutterBackground = null;
	  }
	  if (lineView.line.gutterClass) {
	    var wrap = ensureLineWrapped(lineView);
	    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
	                                    ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
	    cm.display.input.setUneditable(lineView.gutterBackground);
	    wrap.insertBefore(lineView.gutterBackground, lineView.text);
	  }
	  var markers = lineView.line.gutterMarkers;
	  if (cm.options.lineNumbers || markers) {
	    var wrap$1 = ensureLineWrapped(lineView);
	    var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
	    cm.display.input.setUneditable(gutterWrap);
	    wrap$1.insertBefore(gutterWrap, lineView.text);
	    if (lineView.line.gutterClass)
	      { gutterWrap.className += " " + lineView.line.gutterClass; }
	    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
	      { lineView.lineNumber = gutterWrap.appendChild(
	        elt("div", lineNumberFor(cm.options, lineN),
	            "CodeMirror-linenumber CodeMirror-gutter-elt",
	            ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
	    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {
	      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
	      if (found)
	        { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
	                                   ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
	    } }
	  }
	}

	function updateLineWidgets(cm, lineView, dims) {
	  if (lineView.alignable) { lineView.alignable = null; }
	  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
	    next = node.nextSibling;
	    if (node.className == "CodeMirror-linewidget")
	      { lineView.node.removeChild(node); }
	  }
	  insertLineWidgets(cm, lineView, dims);
	}

	// Build a line's DOM representation from scratch
	function buildLineElement(cm, lineView, lineN, dims) {
	  var built = getLineContent(cm, lineView);
	  lineView.text = lineView.node = built.pre;
	  if (built.bgClass) { lineView.bgClass = built.bgClass; }
	  if (built.textClass) { lineView.textClass = built.textClass; }

	  updateLineClasses(cm, lineView);
	  updateLineGutter(cm, lineView, lineN, dims);
	  insertLineWidgets(cm, lineView, dims);
	  return lineView.node
	}

	// A lineView may contain multiple logical lines (when merged by
	// collapsed spans). The widgets for all of them need to be drawn.
	function insertLineWidgets(cm, lineView, dims) {
	  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
	  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
	}

	function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
	  if (!line.widgets) { return }
	  var wrap = ensureLineWrapped(lineView);
	  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
	    var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
	    if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
	    positionLineWidget(widget, node, lineView, dims);
	    cm.display.input.setUneditable(node);
	    if (allowAbove && widget.above)
	      { wrap.insertBefore(node, lineView.gutter || lineView.text); }
	    else
	      { wrap.appendChild(node); }
	    signalLater(widget, "redraw");
	  }
	}

	function positionLineWidget(widget, node, lineView, dims) {
	  if (widget.noHScroll) {
	    (lineView.alignable || (lineView.alignable = [])).push(node);
	    var width = dims.wrapperWidth;
	    node.style.left = dims.fixedPos + "px";
	    if (!widget.coverGutter) {
	      width -= dims.gutterTotalWidth;
	      node.style.paddingLeft = dims.gutterTotalWidth + "px";
	    }
	    node.style.width = width + "px";
	  }
	  if (widget.coverGutter) {
	    node.style.zIndex = 5;
	    node.style.position = "relative";
	    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
	  }
	}

	function widgetHeight(widget) {
	  if (widget.height != null) { return widget.height }
	  var cm = widget.doc.cm;
	  if (!cm) { return 0 }
	  if (!contains(document.body, widget.node)) {
	    var parentStyle = "position: relative;";
	    if (widget.coverGutter)
	      { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
	    if (widget.noHScroll)
	      { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
	    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
	  }
	  return widget.height = widget.node.parentNode.offsetHeight
	}

	// Return true when the given mouse event happened in a widget
	function eventInWidget(display, e) {
	  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
	    if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
	        (n.parentNode == display.sizer && n != display.mover))
	      { return true }
	  }
	}

	// POSITION MEASUREMENT

	function paddingTop(display) {return display.lineSpace.offsetTop}
	function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
	function paddingH(display) {
	  if (display.cachedPaddingH) { return display.cachedPaddingH }
	  var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
	  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
	  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
	  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
	  return data
	}

	function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
	function displayWidth(cm) {
	  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
	}
	function displayHeight(cm) {
	  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
	}

	// Ensure the lineView.wrapping.heights array is populated. This is
	// an array of bottom offsets for the lines that make up a drawn
	// line. When lineWrapping is on, there might be more than one
	// height.
	function ensureLineHeights(cm, lineView, rect) {
	  var wrapping = cm.options.lineWrapping;
	  var curWidth = wrapping && displayWidth(cm);
	  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
	    var heights = lineView.measure.heights = [];
	    if (wrapping) {
	      lineView.measure.width = curWidth;
	      var rects = lineView.text.firstChild.getClientRects();
	      for (var i = 0; i < rects.length - 1; i++) {
	        var cur = rects[i], next = rects[i + 1];
	        if (Math.abs(cur.bottom - next.bottom) > 2)
	          { heights.push((cur.bottom + next.top) / 2 - rect.top); }
	      }
	    }
	    heights.push(rect.bottom - rect.top);
	  }
	}

	// Find a line map (mapping character offsets to text nodes) and a
	// measurement cache for the given line number. (A line view might
	// contain multiple lines when collapsed ranges are present.)
	function mapFromLineView(lineView, line, lineN) {
	  if (lineView.line == line)
	    { return {map: lineView.measure.map, cache: lineView.measure.cache} }
	  for (var i = 0; i < lineView.rest.length; i++)
	    { if (lineView.rest[i] == line)
	      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
	  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
	    { if (lineNo(lineView.rest[i$1]) > lineN)
	      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
	}

	// Render a line into the hidden node display.externalMeasured. Used
	// when measurement is needed for a line that's not in the viewport.
	function updateExternalMeasurement(cm, line) {
	  line = visualLine(line);
	  var lineN = lineNo(line);
	  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
	  view.lineN = lineN;
	  var built = view.built = buildLineContent(cm, view);
	  view.text = built.pre;
	  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
	  return view
	}

	// Get a {top, bottom, left, right} box (in line-local coordinates)
	// for a given character.
	function measureChar(cm, line, ch, bias) {
	  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
	}

	// Find a line view that corresponds to the given line number.
	function findViewForLine(cm, lineN) {
	  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
	    { return cm.display.view[findViewIndex(cm, lineN)] }
	  var ext = cm.display.externalMeasured;
	  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
	    { return ext }
	}

	// Measurement can be split in two steps, the set-up work that
	// applies to the whole line, and the measurement of the actual
	// character. Functions like coordsChar, that need to do a lot of
	// measurements in a row, can thus ensure that the set-up work is
	// only done once.
	function prepareMeasureForLine(cm, line) {
	  var lineN = lineNo(line);
	  var view = findViewForLine(cm, lineN);
	  if (view && !view.text) {
	    view = null;
	  } else if (view && view.changes) {
	    updateLineForChanges(cm, view, lineN, getDimensions(cm));
	    cm.curOp.forceUpdate = true;
	  }
	  if (!view)
	    { view = updateExternalMeasurement(cm, line); }

	  var info = mapFromLineView(view, line, lineN);
	  return {
	    line: line, view: view, rect: null,
	    map: info.map, cache: info.cache, before: info.before,
	    hasHeights: false
	  }
	}

	// Given a prepared measurement object, measures the position of an
	// actual character (or fetches it from the cache).
	function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
	  if (prepared.before) { ch = -1; }
	  var key = ch + (bias || ""), found;
	  if (prepared.cache.hasOwnProperty(key)) {
	    found = prepared.cache[key];
	  } else {
	    if (!prepared.rect)
	      { prepared.rect = prepared.view.text.getBoundingClientRect(); }
	    if (!prepared.hasHeights) {
	      ensureLineHeights(cm, prepared.view, prepared.rect);
	      prepared.hasHeights = true;
	    }
	    found = measureCharInner(cm, prepared, ch, bias);
	    if (!found.bogus) { prepared.cache[key] = found; }
	  }
	  return {left: found.left, right: found.right,
	          top: varHeight ? found.rtop : found.top,
	          bottom: varHeight ? found.rbottom : found.bottom}
	}

	var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

	function nodeAndOffsetInLineMap(map$$1, ch, bias) {
	  var node, start, end, collapse, mStart, mEnd;
	  // First, search the line map for the text node corresponding to,
	  // or closest to, the target character.
	  for (var i = 0; i < map$$1.length; i += 3) {
	    mStart = map$$1[i];
	    mEnd = map$$1[i + 1];
	    if (ch < mStart) {
	      start = 0; end = 1;
	      collapse = "left";
	    } else if (ch < mEnd) {
	      start = ch - mStart;
	      end = start + 1;
	    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
	      end = mEnd - mStart;
	      start = end - 1;
	      if (ch >= mEnd) { collapse = "right"; }
	    }
	    if (start != null) {
	      node = map$$1[i + 2];
	      if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
	        { collapse = bias; }
	      if (bias == "left" && start == 0)
	        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
	          node = map$$1[(i -= 3) + 2];
	          collapse = "left";
	        } }
	      if (bias == "right" && start == mEnd - mStart)
	        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
	          node = map$$1[(i += 3) + 2];
	          collapse = "right";
	        } }
	      break
	    }
	  }
	  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
	}

	function getUsefulRect(rects, bias) {
	  var rect = nullRect;
	  if (bias == "left") { for (var i = 0; i < rects.length; i++) {
	    if ((rect = rects[i]).left != rect.right) { break }
	  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
	    if ((rect = rects[i$1]).left != rect.right) { break }
	  } }
	  return rect
	}

	function measureCharInner(cm, prepared, ch, bias) {
	  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
	  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

	  var rect;
	  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
	    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
	      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
	      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
	      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
	        { rect = node.parentNode.getBoundingClientRect(); }
	      else
	        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
	      if (rect.left || rect.right || start == 0) { break }
	      end = start;
	      start = start - 1;
	      collapse = "right";
	    }
	    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
	  } else { // If it is a widget, simply get the box for the whole widget.
	    if (start > 0) { collapse = bias = "right"; }
	    var rects;
	    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
	      { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
	    else
	      { rect = node.getBoundingClientRect(); }
	  }
	  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
	    var rSpan = node.parentNode.getClientRects()[0];
	    if (rSpan)
	      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
	    else
	      { rect = nullRect; }
	  }

	  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
	  var mid = (rtop + rbot) / 2;
	  var heights = prepared.view.measure.heights;
	  var i = 0;
	  for (; i < heights.length - 1; i++)
	    { if (mid < heights[i]) { break } }
	  var top = i ? heights[i - 1] : 0, bot = heights[i];
	  var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
	                right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
	                top: top, bottom: bot};
	  if (!rect.left && !rect.right) { result.bogus = true; }
	  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

	  return result
	}

	// Work around problem with bounding client rects on ranges being
	// returned incorrectly when zoomed on IE10 and below.
	function maybeUpdateRectForZooming(measure, rect) {
	  if (!window.screen || screen.logicalXDPI == null ||
	      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
	    { return rect }
	  var scaleX = screen.logicalXDPI / screen.deviceXDPI;
	  var scaleY = screen.logicalYDPI / screen.deviceYDPI;
	  return {left: rect.left * scaleX, right: rect.right * scaleX,
	          top: rect.top * scaleY, bottom: rect.bottom * scaleY}
	}

	function clearLineMeasurementCacheFor(lineView) {
	  if (lineView.measure) {
	    lineView.measure.cache = {};
	    lineView.measure.heights = null;
	    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	      { lineView.measure.caches[i] = {}; } }
	  }
	}

	function clearLineMeasurementCache(cm) {
	  cm.display.externalMeasure = null;
	  removeChildren(cm.display.lineMeasure);
	  for (var i = 0; i < cm.display.view.length; i++)
	    { clearLineMeasurementCacheFor(cm.display.view[i]); }
	}

	function clearCaches(cm) {
	  clearLineMeasurementCache(cm);
	  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
	  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
	  cm.display.lineNumChars = null;
	}

	function pageScrollX() {
	  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
	  // which causes page_Offset and bounding client rects to use
	  // different reference viewports and invalidate our calculations.
	  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
	  return window.pageXOffset || (document.documentElement || document.body).scrollLeft
	}
	function pageScrollY() {
	  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
	  return window.pageYOffset || (document.documentElement || document.body).scrollTop
	}

	function widgetTopHeight(lineObj) {
	  var height = 0;
	  if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
	    { height += widgetHeight(lineObj.widgets[i]); } } }
	  return height
	}

	// Converts a {top, bottom, left, right} box from line-local
	// coordinates into another coordinate system. Context may be one of
	// "line", "div" (display.lineDiv), "local"./null (editor), "window",
	// or "page".
	function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
	  if (!includeWidgets) {
	    var height = widgetTopHeight(lineObj);
	    rect.top += height; rect.bottom += height;
	  }
	  if (context == "line") { return rect }
	  if (!context) { context = "local"; }
	  var yOff = heightAtLine(lineObj);
	  if (context == "local") { yOff += paddingTop(cm.display); }
	  else { yOff -= cm.display.viewOffset; }
	  if (context == "page" || context == "window") {
	    var lOff = cm.display.lineSpace.getBoundingClientRect();
	    yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
	    var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
	    rect.left += xOff; rect.right += xOff;
	  }
	  rect.top += yOff; rect.bottom += yOff;
	  return rect
	}

	// Coverts a box from "div" coords to another coordinate system.
	// Context may be "window", "page", "div", or "local"./null.
	function fromCoordSystem(cm, coords, context) {
	  if (context == "div") { return coords }
	  var left = coords.left, top = coords.top;
	  // First move into "page" coordinate system
	  if (context == "page") {
	    left -= pageScrollX();
	    top -= pageScrollY();
	  } else if (context == "local" || !context) {
	    var localBox = cm.display.sizer.getBoundingClientRect();
	    left += localBox.left;
	    top += localBox.top;
	  }

	  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
	  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
	}

	function charCoords(cm, pos, context, lineObj, bias) {
	  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
	  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
	}

	// Returns a box for a given cursor position, which may have an
	// 'other' property containing the position of the secondary cursor
	// on a bidi boundary.
	// A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
	// and after `char - 1` in writing order of `char - 1`
	// A cursor Pos(line, char, "after") is on the same visual line as `char`
	// and before `char` in writing order of `char`
	// Examples (upper-case letters are RTL, lower-case are LTR):
	//     Pos(0, 1, ...)
	//     before   after
	// ab     a|b     a|b
	// aB     a|B     aB|
	// Ab     |Ab     A|b
	// AB     B|A     B|A
	// Every position after the last character on a line is considered to stick
	// to the last character on the line.
	function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
	  lineObj = lineObj || getLine(cm.doc, pos.line);
	  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
	  function get(ch, right) {
	    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
	    if (right) { m.left = m.right; } else { m.right = m.left; }
	    return intoCoordSystem(cm, lineObj, m, context)
	  }
	  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
	  if (ch >= lineObj.text.length) {
	    ch = lineObj.text.length;
	    sticky = "before";
	  } else if (ch <= 0) {
	    ch = 0;
	    sticky = "after";
	  }
	  if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

	  function getBidi(ch, partPos, invert) {
	    var part = order[partPos], right = part.level == 1;
	    return get(invert ? ch - 1 : ch, right != invert)
	  }
	  var partPos = getBidiPartAt(order, ch, sticky);
	  var other = bidiOther;
	  var val = getBidi(ch, partPos, sticky == "before");
	  if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
	  return val
	}

	// Used to cheaply estimate the coordinates for a position. Used for
	// intermediate scroll updates.
	function estimateCoords(cm, pos) {
	  var left = 0;
	  pos = clipPos(cm.doc, pos);
	  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
	  var lineObj = getLine(cm.doc, pos.line);
	  var top = heightAtLine(lineObj) + paddingTop(cm.display);
	  return {left: left, right: left, top: top, bottom: top + lineObj.height}
	}

	// Positions returned by coordsChar contain some extra information.
	// xRel is the relative x position of the input coordinates compared
	// to the found position (so xRel > 0 means the coordinates are to
	// the right of the character position, for example). When outside
	// is true, that means the coordinates lie outside the line's
	// vertical range.
	function PosWithInfo(line, ch, sticky, outside, xRel) {
	  var pos = Pos(line, ch, sticky);
	  pos.xRel = xRel;
	  if (outside) { pos.outside = true; }
	  return pos
	}

	// Compute the character position closest to the given coordinates.
	// Input must be lineSpace-local ("div" coordinate system).
	function coordsChar(cm, x, y) {
	  var doc = cm.doc;
	  y += cm.display.viewOffset;
	  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }
	  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
	  if (lineN > last)
	    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }
	  if (x < 0) { x = 0; }

	  var lineObj = getLine(doc, lineN);
	  for (;;) {
	    var found = coordsCharInner(cm, lineObj, lineN, x, y);
	    var merged = collapsedSpanAtEnd(lineObj);
	    var mergedPos = merged && merged.find(0, true);
	    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
	      { lineN = lineNo(lineObj = mergedPos.to.line); }
	    else
	      { return found }
	  }
	}

	function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
	  y -= widgetTopHeight(lineObj);
	  var end = lineObj.text.length;
	  var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
	  end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
	  return {begin: begin, end: end}
	}

	function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
	  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
	  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
	  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
	}

	// Returns true if the given side of a box is after the given
	// coordinates, in top-to-bottom, left-to-right order.
	function boxIsAfter(box, x, y, left) {
	  return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
	}

	function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
	  // Move y into line-local coordinate space
	  y -= heightAtLine(lineObj);
	  var preparedMeasure = prepareMeasureForLine(cm, lineObj);
	  // When directly calling `measureCharPrepared`, we have to adjust
	  // for the widgets at this line.
	  var widgetHeight$$1 = widgetTopHeight(lineObj);
	  var begin = 0, end = lineObj.text.length, ltr = true;

	  var order = getOrder(lineObj, cm.doc.direction);
	  // If the line isn't plain left-to-right text, first figure out
	  // which bidi section the coordinates fall into.
	  if (order) {
	    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
	                 (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
	    ltr = part.level != 1;
	    // The awkward -1 offsets are needed because findFirst (called
	    // on these below) will treat its first bound as inclusive,
	    // second as exclusive, but we want to actually address the
	    // characters in the part's range
	    begin = ltr ? part.from : part.to - 1;
	    end = ltr ? part.to : part.from - 1;
	  }

	  // A binary search to find the first character whose bounding box
	  // starts after the coordinates. If we run across any whose box wrap
	  // the coordinates, store that.
	  var chAround = null, boxAround = null;
	  var ch = findFirst(function (ch) {
	    var box = measureCharPrepared(cm, preparedMeasure, ch);
	    box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;
	    if (!boxIsAfter(box, x, y, false)) { return false }
	    if (box.top <= y && box.left <= x) {
	      chAround = ch;
	      boxAround = box;
	    }
	    return true
	  }, begin, end);

	  var baseX, sticky, outside = false;
	  // If a box around the coordinates was found, use that
	  if (boxAround) {
	    // Distinguish coordinates nearer to the left or right side of the box
	    var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
	    ch = chAround + (atStart ? 0 : 1);
	    sticky = atStart ? "after" : "before";
	    baseX = atLeft ? boxAround.left : boxAround.right;
	  } else {
	    // (Adjust for extended bound, if necessary.)
	    if (!ltr && (ch == end || ch == begin)) { ch++; }
	    // To determine which side to associate with, get the box to the
	    // left of the character and compare it's vertical position to the
	    // coordinates
	    sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
	      (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?
	      "after" : "before";
	    // Now get accurate coordinates for this place, in order to get a
	    // base X position
	    var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
	    baseX = coords.left;
	    outside = y < coords.top || y >= coords.bottom;
	  }

	  ch = skipExtendingChars(lineObj.text, ch, 1);
	  return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
	}

	function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
	  // Bidi parts are sorted left-to-right, and in a non-line-wrapping
	  // situation, we can take this ordering to correspond to the visual
	  // ordering. This finds the first part whose end is after the given
	  // coordinates.
	  var index = findFirst(function (i) {
	    var part = order[i], ltr = part.level != 1;
	    return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"),
	                                   "line", lineObj, preparedMeasure), x, y, true)
	  }, 0, order.length - 1);
	  var part = order[index];
	  // If this isn't the first part, the part's start is also after
	  // the coordinates, and the coordinates aren't on the same line as
	  // that start, move one part back.
	  if (index > 0) {
	    var ltr = part.level != 1;
	    var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"),
	                             "line", lineObj, preparedMeasure);
	    if (boxIsAfter(start, x, y, true) && start.top > y)
	      { part = order[index - 1]; }
	  }
	  return part
	}

	function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
	  // In a wrapped line, rtl text on wrapping boundaries can do things
	  // that don't correspond to the ordering in our `order` array at
	  // all, so a binary search doesn't work, and we want to return a
	  // part that only spans one line so that the binary search in
	  // coordsCharInner is safe. As such, we first find the extent of the
	  // wrapped line, and then do a flat search in which we discard any
	  // spans that aren't on the line.
	  var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
	  var begin = ref.begin;
	  var end = ref.end;
	  if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
	  var part = null, closestDist = null;
	  for (var i = 0; i < order.length; i++) {
	    var p = order[i];
	    if (p.from >= end || p.to <= begin) { continue }
	    var ltr = p.level != 1;
	    var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
	    // Weigh against spans ending before this, so that they are only
	    // picked if nothing ends after
	    var dist = endX < x ? x - endX + 1e9 : endX - x;
	    if (!part || closestDist > dist) {
	      part = p;
	      closestDist = dist;
	    }
	  }
	  if (!part) { part = order[order.length - 1]; }
	  // Clip the part to the wrapped line.
	  if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
	  if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
	  return part
	}

	var measureText;
	// Compute the default text height.
	function textHeight(display) {
	  if (display.cachedTextHeight != null) { return display.cachedTextHeight }
	  if (measureText == null) {
	    measureText = elt("pre");
	    // Measure a bunch of lines, for browsers that compute
	    // fractional heights.
	    for (var i = 0; i < 49; ++i) {
	      measureText.appendChild(document.createTextNode("x"));
	      measureText.appendChild(elt("br"));
	    }
	    measureText.appendChild(document.createTextNode("x"));
	  }
	  removeChildrenAndAdd(display.measure, measureText);
	  var height = measureText.offsetHeight / 50;
	  if (height > 3) { display.cachedTextHeight = height; }
	  removeChildren(display.measure);
	  return height || 1
	}

	// Compute the default character width.
	function charWidth(display) {
	  if (display.cachedCharWidth != null) { return display.cachedCharWidth }
	  var anchor = elt("span", "xxxxxxxxxx");
	  var pre = elt("pre", [anchor]);
	  removeChildrenAndAdd(display.measure, pre);
	  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
	  if (width > 2) { display.cachedCharWidth = width; }
	  return width || 10
	}

	// Do a bulk-read of the DOM positions and sizes needed to draw the
	// view, so that we don't interleave reading and writing to the DOM.
	function getDimensions(cm) {
	  var d = cm.display, left = {}, width = {};
	  var gutterLeft = d.gutters.clientLeft;
	  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
	    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
	    width[cm.options.gutters[i]] = n.clientWidth;
	  }
	  return {fixedPos: compensateForHScroll(d),
	          gutterTotalWidth: d.gutters.offsetWidth,
	          gutterLeft: left,
	          gutterWidth: width,
	          wrapperWidth: d.wrapper.clientWidth}
	}

	// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
	// but using getBoundingClientRect to get a sub-pixel-accurate
	// result.
	function compensateForHScroll(display) {
	  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
	}

	// Returns a function that estimates the height of a line, to use as
	// first approximation until the line becomes visible (and is thus
	// properly measurable).
	function estimateHeight(cm) {
	  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
	  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
	  return function (line) {
	    if (lineIsHidden(cm.doc, line)) { return 0 }

	    var widgetsHeight = 0;
	    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
	      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
	    } }

	    if (wrapping)
	      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
	    else
	      { return widgetsHeight + th }
	  }
	}

	function estimateLineHeights(cm) {
	  var doc = cm.doc, est = estimateHeight(cm);
	  doc.iter(function (line) {
	    var estHeight = est(line);
	    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
	  });
	}

	// Given a mouse event, find the corresponding position. If liberal
	// is false, it checks whether a gutter or scrollbar was clicked,
	// and returns null if it was. forRect is used by rectangular
	// selections, and tries to estimate a character position even for
	// coordinates beyond the right of the text.
	function posFromMouse(cm, e, liberal, forRect) {
	  var display = cm.display;
	  if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

	  var x, y, space = display.lineSpace.getBoundingClientRect();
	  // Fails unpredictably on IE[67] when mouse is dragged around quickly.
	  try { x = e.clientX - space.left; y = e.clientY - space.top; }
	  catch (e) { return null }
	  var coords = coordsChar(cm, x, y), line;
	  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
	    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
	    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
	  }
	  return coords
	}

	// Find the view element corresponding to a given line. Return null
	// when the line isn't visible.
	function findViewIndex(cm, n) {
	  if (n >= cm.display.viewTo) { return null }
	  n -= cm.display.viewFrom;
	  if (n < 0) { return null }
	  var view = cm.display.view;
	  for (var i = 0; i < view.length; i++) {
	    n -= view[i].size;
	    if (n < 0) { return i }
	  }
	}

	function updateSelection(cm) {
	  cm.display.input.showSelection(cm.display.input.prepareSelection());
	}

	function prepareSelection(cm, primary) {
	  if ( primary === void 0 ) primary = true;

	  var doc = cm.doc, result = {};
	  var curFragment = result.cursors = document.createDocumentFragment();
	  var selFragment = result.selection = document.createDocumentFragment();

	  for (var i = 0; i < doc.sel.ranges.length; i++) {
	    if (!primary && i == doc.sel.primIndex) { continue }
	    var range$$1 = doc.sel.ranges[i];
	    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
	    var collapsed = range$$1.empty();
	    if (collapsed || cm.options.showCursorWhenSelecting)
	      { drawSelectionCursor(cm, range$$1.head, curFragment); }
	    if (!collapsed)
	      { drawSelectionRange(cm, range$$1, selFragment); }
	  }
	  return result
	}

	// Draws a cursor for the given range
	function drawSelectionCursor(cm, head, output) {
	  var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

	  var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
	  cursor.style.left = pos.left + "px";
	  cursor.style.top = pos.top + "px";
	  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

	  if (pos.other) {
	    // Secondary cursor, shown when on a 'jump' in bi-directional text
	    var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
	    otherCursor.style.display = "";
	    otherCursor.style.left = pos.other.left + "px";
	    otherCursor.style.top = pos.other.top + "px";
	    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
	  }
	}

	function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

	// Draws the given range as a highlighted selection
	function drawSelectionRange(cm, range$$1, output) {
	  var display = cm.display, doc = cm.doc;
	  var fragment = document.createDocumentFragment();
	  var padding = paddingH(cm.display), leftSide = padding.left;
	  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
	  var docLTR = doc.direction == "ltr";

	  function add(left, top, width, bottom) {
	    if (top < 0) { top = 0; }
	    top = Math.round(top);
	    bottom = Math.round(bottom);
	    fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
	  }

	  function drawForLine(line, fromArg, toArg) {
	    var lineObj = getLine(doc, line);
	    var lineLen = lineObj.text.length;
	    var start, end;
	    function coords(ch, bias) {
	      return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
	    }

	    function wrapX(pos, dir, side) {
	      var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
	      var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
	      var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
	      return coords(ch, prop)[prop]
	    }

	    var order = getOrder(lineObj, doc.direction);
	    iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
	      var ltr = dir == "ltr";
	      var fromPos = coords(from, ltr ? "left" : "right");
	      var toPos = coords(to - 1, ltr ? "right" : "left");

	      var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
	      var first = i == 0, last = !order || i == order.length - 1;
	      if (toPos.top - fromPos.top <= 3) { // Single line
	        var openLeft = (docLTR ? openStart : openEnd) && first;
	        var openRight = (docLTR ? openEnd : openStart) && last;
	        var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
	        var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
	        add(left, fromPos.top, right - left, fromPos.bottom);
	      } else { // Multiple lines
	        var topLeft, topRight, botLeft, botRight;
	        if (ltr) {
	          topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
	          topRight = docLTR ? rightSide : wrapX(from, dir, "before");
	          botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
	          botRight = docLTR && openEnd && last ? rightSide : toPos.right;
	        } else {
	          topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
	          topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
	          botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
	          botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
	        }
	        add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
	        if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
	        add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
	      }

	      if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
	      if (cmpCoords(toPos, start) < 0) { start = toPos; }
	      if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
	      if (cmpCoords(toPos, end) < 0) { end = toPos; }
	    });
	    return {start: start, end: end}
	  }

	  var sFrom = range$$1.from(), sTo = range$$1.to();
	  if (sFrom.line == sTo.line) {
	    drawForLine(sFrom.line, sFrom.ch, sTo.ch);
	  } else {
	    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
	    var singleVLine = visualLine(fromLine) == visualLine(toLine);
	    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
	    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
	    if (singleVLine) {
	      if (leftEnd.top < rightStart.top - 2) {
	        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
	        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
	      } else {
	        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
	      }
	    }
	    if (leftEnd.bottom < rightStart.top)
	      { add(leftSide, leftEnd.bottom, null, rightStart.top); }
	  }

	  output.appendChild(fragment);
	}

	// Cursor-blinking
	function restartBlink(cm) {
	  if (!cm.state.focused) { return }
	  var display = cm.display;
	  clearInterval(display.blinker);
	  var on = true;
	  display.cursorDiv.style.visibility = "";
	  if (cm.options.cursorBlinkRate > 0)
	    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
	      cm.options.cursorBlinkRate); }
	  else if (cm.options.cursorBlinkRate < 0)
	    { display.cursorDiv.style.visibility = "hidden"; }
	}

	function ensureFocus(cm) {
	  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
	}

	function delayBlurEvent(cm) {
	  cm.state.delayingBlurEvent = true;
	  setTimeout(function () { if (cm.state.delayingBlurEvent) {
	    cm.state.delayingBlurEvent = false;
	    onBlur(cm);
	  } }, 100);
	}

	function onFocus(cm, e) {
	  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

	  if (cm.options.readOnly == "nocursor") { return }
	  if (!cm.state.focused) {
	    signal(cm, "focus", cm, e);
	    cm.state.focused = true;
	    addClass(cm.display.wrapper, "CodeMirror-focused");
	    // This test prevents this from firing when a context
	    // menu is closed (since the input reset would kill the
	    // select-all detection hack)
	    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
	      cm.display.input.reset();
	      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
	    }
	    cm.display.input.receivedFocus();
	  }
	  restartBlink(cm);
	}
	function onBlur(cm, e) {
	  if (cm.state.delayingBlurEvent) { return }

	  if (cm.state.focused) {
	    signal(cm, "blur", cm, e);
	    cm.state.focused = false;
	    rmClass(cm.display.wrapper, "CodeMirror-focused");
	  }
	  clearInterval(cm.display.blinker);
	  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
	}

	// Read the actual heights of the rendered lines, and update their
	// stored heights to match.
	function updateHeightsInViewport(cm) {
	  var display = cm.display;
	  var prevBottom = display.lineDiv.offsetTop;
	  for (var i = 0; i < display.view.length; i++) {
	    var cur = display.view[i], height = (void 0);
	    if (cur.hidden) { continue }
	    if (ie && ie_version < 8) {
	      var bot = cur.node.offsetTop + cur.node.offsetHeight;
	      height = bot - prevBottom;
	      prevBottom = bot;
	    } else {
	      var box = cur.node.getBoundingClientRect();
	      height = box.bottom - box.top;
	    }
	    var diff = cur.line.height - height;
	    if (height < 2) { height = textHeight(display); }
	    if (diff > .005 || diff < -.005) {
	      updateLineHeight(cur.line, height);
	      updateWidgetHeight(cur.line);
	      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
	        { updateWidgetHeight(cur.rest[j]); } }
	    }
	  }
	}

	// Read and store the height of line widgets associated with the
	// given line.
	function updateWidgetHeight(line) {
	  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
	    var w = line.widgets[i], parent = w.node.parentNode;
	    if (parent) { w.height = parent.offsetHeight; }
	  } }
	}

	// Compute the lines that are visible in a given viewport (defaults
	// the the current scroll position). viewport may contain top,
	// height, and ensure (see op.scrollToPos) properties.
	function visibleLines(display, doc, viewport) {
	  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
	  top = Math.floor(top - paddingTop(display));
	  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

	  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
	  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
	  // forces those lines into the viewport (if possible).
	  if (viewport && viewport.ensure) {
	    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
	    if (ensureFrom < from) {
	      from = ensureFrom;
	      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
	    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
	      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
	      to = ensureTo;
	    }
	  }
	  return {from: from, to: Math.max(to, from + 1)}
	}

	// Re-align line numbers and gutter marks to compensate for
	// horizontal scrolling.
	function alignHorizontally(cm) {
	  var display = cm.display, view = display.view;
	  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
	  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
	  var gutterW = display.gutters.offsetWidth, left = comp + "px";
	  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
	    if (cm.options.fixedGutter) {
	      if (view[i].gutter)
	        { view[i].gutter.style.left = left; }
	      if (view[i].gutterBackground)
	        { view[i].gutterBackground.style.left = left; }
	    }
	    var align = view[i].alignable;
	    if (align) { for (var j = 0; j < align.length; j++)
	      { align[j].style.left = left; } }
	  } }
	  if (cm.options.fixedGutter)
	    { display.gutters.style.left = (comp + gutterW) + "px"; }
	}

	// Used to ensure that the line number gutter is still the right
	// size for the current document size. Returns true when an update
	// is needed.
	function maybeUpdateLineNumberWidth(cm) {
	  if (!cm.options.lineNumbers) { return false }
	  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
	  if (last.length != display.lineNumChars) {
	    var test = display.measure.appendChild(elt("div", [elt("div", last)],
	                                               "CodeMirror-linenumber CodeMirror-gutter-elt"));
	    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
	    display.lineGutter.style.width = "";
	    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
	    display.lineNumWidth = display.lineNumInnerWidth + padding;
	    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
	    display.lineGutter.style.width = display.lineNumWidth + "px";
	    updateGutterSpace(cm);
	    return true
	  }
	  return false
	}

	// SCROLLING THINGS INTO VIEW

	// If an editor sits on the top or bottom of the window, partially
	// scrolled out of view, this ensures that the cursor is visible.
	function maybeScrollWindow(cm, rect) {
	  if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

	  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
	  if (rect.top + box.top < 0) { doScroll = true; }
	  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
	  if (doScroll != null && !phantom) {
	    var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
	    cm.display.lineSpace.appendChild(scrollNode);
	    scrollNode.scrollIntoView(doScroll);
	    cm.display.lineSpace.removeChild(scrollNode);
	  }
	}

	// Scroll a given position into view (immediately), verifying that
	// it actually became visible (as line heights are accurately
	// measured, the position of something may 'drift' during drawing).
	function scrollPosIntoView(cm, pos, end, margin) {
	  if (margin == null) { margin = 0; }
	  var rect;
	  if (!cm.options.lineWrapping && pos == end) {
	    // Set pos and end to the cursor positions around the character pos sticks to
	    // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
	    // If pos == Pos(_, 0, "before"), pos and end are unchanged
	    pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
	    end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
	  }
	  for (var limit = 0; limit < 5; limit++) {
	    var changed = false;
	    var coords = cursorCoords(cm, pos);
	    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
	    rect = {left: Math.min(coords.left, endCoords.left),
	            top: Math.min(coords.top, endCoords.top) - margin,
	            right: Math.max(coords.left, endCoords.left),
	            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
	    var scrollPos = calculateScrollPos(cm, rect);
	    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
	    if (scrollPos.scrollTop != null) {
	      updateScrollTop(cm, scrollPos.scrollTop);
	      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
	    }
	    if (scrollPos.scrollLeft != null) {
	      setScrollLeft(cm, scrollPos.scrollLeft);
	      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
	    }
	    if (!changed) { break }
	  }
	  return rect
	}

	// Scroll a given set of coordinates into view (immediately).
	function scrollIntoView(cm, rect) {
	  var scrollPos = calculateScrollPos(cm, rect);
	  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
	  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
	}

	// Calculate a new scroll position needed to scroll the given
	// rectangle into view. Returns an object with scrollTop and
	// scrollLeft properties. When these are undefined, the
	// vertical/horizontal position does not need to be adjusted.
	function calculateScrollPos(cm, rect) {
	  var display = cm.display, snapMargin = textHeight(cm.display);
	  if (rect.top < 0) { rect.top = 0; }
	  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
	  var screen = displayHeight(cm), result = {};
	  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
	  var docBottom = cm.doc.height + paddingVert(display);
	  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
	  if (rect.top < screentop) {
	    result.scrollTop = atTop ? 0 : rect.top;
	  } else if (rect.bottom > screentop + screen) {
	    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
	    if (newTop != screentop) { result.scrollTop = newTop; }
	  }

	  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
	  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
	  var tooWide = rect.right - rect.left > screenw;
	  if (tooWide) { rect.right = rect.left + screenw; }
	  if (rect.left < 10)
	    { result.scrollLeft = 0; }
	  else if (rect.left < screenleft)
	    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
	  else if (rect.right > screenw + screenleft - 3)
	    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
	  return result
	}

	// Store a relative adjustment to the scroll position in the current
	// operation (to be applied when the operation finishes).
	function addToScrollTop(cm, top) {
	  if (top == null) { return }
	  resolveScrollToPos(cm);
	  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
	}

	// Make sure that at the end of the operation the current cursor is
	// shown.
	function ensureCursorVisible(cm) {
	  resolveScrollToPos(cm);
	  var cur = cm.getCursor();
	  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
	}

	function scrollToCoords(cm, x, y) {
	  if (x != null || y != null) { resolveScrollToPos(cm); }
	  if (x != null) { cm.curOp.scrollLeft = x; }
	  if (y != null) { cm.curOp.scrollTop = y; }
	}

	function scrollToRange(cm, range$$1) {
	  resolveScrollToPos(cm);
	  cm.curOp.scrollToPos = range$$1;
	}

	// When an operation has its scrollToPos property set, and another
	// scroll action is applied before the end of the operation, this
	// 'simulates' scrolling that position into view in a cheap way, so
	// that the effect of intermediate scroll commands is not ignored.
	function resolveScrollToPos(cm) {
	  var range$$1 = cm.curOp.scrollToPos;
	  if (range$$1) {
	    cm.curOp.scrollToPos = null;
	    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
	    scrollToCoordsRange(cm, from, to, range$$1.margin);
	  }
	}

	function scrollToCoordsRange(cm, from, to, margin) {
	  var sPos = calculateScrollPos(cm, {
	    left: Math.min(from.left, to.left),
	    top: Math.min(from.top, to.top) - margin,
	    right: Math.max(from.right, to.right),
	    bottom: Math.max(from.bottom, to.bottom) + margin
	  });
	  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
	}

	// Sync the scrollable area and scrollbars, ensure the viewport
	// covers the visible area.
	function updateScrollTop(cm, val) {
	  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
	  if (!gecko) { updateDisplaySimple(cm, {top: val}); }
	  setScrollTop(cm, val, true);
	  if (gecko) { updateDisplaySimple(cm); }
	  startWorker(cm, 100);
	}

	function setScrollTop(cm, val, forceScroll) {
	  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
	  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
	  cm.doc.scrollTop = val;
	  cm.display.scrollbars.setScrollTop(val);
	  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
	}

	// Sync scroller and scrollbar, ensure the gutter elements are
	// aligned.
	function setScrollLeft(cm, val, isScroller, forceScroll) {
	  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
	  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
	  cm.doc.scrollLeft = val;
	  alignHorizontally(cm);
	  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
	  cm.display.scrollbars.setScrollLeft(val);
	}

	// SCROLLBARS

	// Prepare DOM reads needed to update the scrollbars. Done in one
	// shot to minimize update/measure roundtrips.
	function measureForScrollbars(cm) {
	  var d = cm.display, gutterW = d.gutters.offsetWidth;
	  var docH = Math.round(cm.doc.height + paddingVert(cm.display));
	  return {
	    clientHeight: d.scroller.clientHeight,
	    viewHeight: d.wrapper.clientHeight,
	    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
	    viewWidth: d.wrapper.clientWidth,
	    barLeft: cm.options.fixedGutter ? gutterW : 0,
	    docHeight: docH,
	    scrollHeight: docH + scrollGap(cm) + d.barHeight,
	    nativeBarWidth: d.nativeBarWidth,
	    gutterWidth: gutterW
	  }
	}

	var NativeScrollbars = function(place, scroll, cm) {
	  this.cm = cm;
	  var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
	  var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
	  place(vert); place(horiz);

	  on(vert, "scroll", function () {
	    if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
	  });
	  on(horiz, "scroll", function () {
	    if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
	  });

	  this.checkedZeroWidth = false;
	  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
	  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
	};

	NativeScrollbars.prototype.update = function (measure) {
	  var needsH = measure.scrollWidth > measure.clientWidth + 1;
	  var needsV = measure.scrollHeight > measure.clientHeight + 1;
	  var sWidth = measure.nativeBarWidth;

	  if (needsV) {
	    this.vert.style.display = "block";
	    this.vert.style.bottom = needsH ? sWidth + "px" : "0";
	    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
	    // A bug in IE8 can cause this value to be negative, so guard it.
	    this.vert.firstChild.style.height =
	      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
	  } else {
	    this.vert.style.display = "";
	    this.vert.firstChild.style.height = "0";
	  }

	  if (needsH) {
	    this.horiz.style.display = "block";
	    this.horiz.style.right = needsV ? sWidth + "px" : "0";
	    this.horiz.style.left = measure.barLeft + "px";
	    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
	    this.horiz.firstChild.style.width =
	      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
	  } else {
	    this.horiz.style.display = "";
	    this.horiz.firstChild.style.width = "0";
	  }

	  if (!this.checkedZeroWidth && measure.clientHeight > 0) {
	    if (sWidth == 0) { this.zeroWidthHack(); }
	    this.checkedZeroWidth = true;
	  }

	  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
	};

	NativeScrollbars.prototype.setScrollLeft = function (pos) {
	  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
	  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
	};

	NativeScrollbars.prototype.setScrollTop = function (pos) {
	  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
	  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
	};

	NativeScrollbars.prototype.zeroWidthHack = function () {
	  var w = mac && !mac_geMountainLion ? "12px" : "18px";
	  this.horiz.style.height = this.vert.style.width = w;
	  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
	  this.disableHoriz = new Delayed;
	  this.disableVert = new Delayed;
	};

	NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
	  bar.style.pointerEvents = "auto";
	  function maybeDisable() {
	    // To find out whether the scrollbar is still visible, we
	    // check whether the element under the pixel in the bottom
	    // right corner of the scrollbar box is the scrollbar box
	    // itself (when the bar is still visible) or its filler child
	    // (when the bar is hidden). If it is still visible, we keep
	    // it enabled, if it's hidden, we disable pointer events.
	    var box = bar.getBoundingClientRect();
	    var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
	        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
	    if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
	    else { delay.set(1000, maybeDisable); }
	  }
	  delay.set(1000, maybeDisable);
	};

	NativeScrollbars.prototype.clear = function () {
	  var parent = this.horiz.parentNode;
	  parent.removeChild(this.horiz);
	  parent.removeChild(this.vert);
	};

	var NullScrollbars = function () {};

	NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
	NullScrollbars.prototype.setScrollLeft = function () {};
	NullScrollbars.prototype.setScrollTop = function () {};
	NullScrollbars.prototype.clear = function () {};

	function updateScrollbars(cm, measure) {
	  if (!measure) { measure = measureForScrollbars(cm); }
	  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
	  updateScrollbarsInner(cm, measure);
	  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
	    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
	      { updateHeightsInViewport(cm); }
	    updateScrollbarsInner(cm, measureForScrollbars(cm));
	    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
	  }
	}

	// Re-synchronize the fake scrollbars with the actual size of the
	// content.
	function updateScrollbarsInner(cm, measure) {
	  var d = cm.display;
	  var sizes = d.scrollbars.update(measure);

	  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
	  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
	  d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

	  if (sizes.right && sizes.bottom) {
	    d.scrollbarFiller.style.display = "block";
	    d.scrollbarFiller.style.height = sizes.bottom + "px";
	    d.scrollbarFiller.style.width = sizes.right + "px";
	  } else { d.scrollbarFiller.style.display = ""; }
	  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
	    d.gutterFiller.style.display = "block";
	    d.gutterFiller.style.height = sizes.bottom + "px";
	    d.gutterFiller.style.width = measure.gutterWidth + "px";
	  } else { d.gutterFiller.style.display = ""; }
	}

	var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

	function initScrollbars(cm) {
	  if (cm.display.scrollbars) {
	    cm.display.scrollbars.clear();
	    if (cm.display.scrollbars.addClass)
	      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
	  }

	  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
	    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
	    // Prevent clicks in the scrollbars from killing focus
	    on(node, "mousedown", function () {
	      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
	    });
	    node.setAttribute("cm-not-content", "true");
	  }, function (pos, axis) {
	    if (axis == "horizontal") { setScrollLeft(cm, pos); }
	    else { updateScrollTop(cm, pos); }
	  }, cm);
	  if (cm.display.scrollbars.addClass)
	    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
	}

	// Operations are used to wrap a series of changes to the editor
	// state in such a way that each change won't have to update the
	// cursor and display (which would be awkward, slow, and
	// error-prone). Instead, display updates are batched and then all
	// combined and executed at once.

	var nextOpId = 0;
	// Start a new operation.
	function startOperation(cm) {
	  cm.curOp = {
	    cm: cm,
	    viewChanged: false,      // Flag that indicates that lines might need to be redrawn
	    startHeight: cm.doc.height, // Used to detect need to update scrollbar
	    forceUpdate: false,      // Used to force a redraw
	    updateInput: null,       // Whether to reset the input textarea
	    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
	    changeObjs: null,        // Accumulated changes, for firing change events
	    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
	    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
	    selectionChanged: false, // Whether the selection needs to be redrawn
	    updateMaxLine: false,    // Set when the widest line needs to be determined anew
	    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
	    scrollToPos: null,       // Used to scroll to a specific position
	    focus: false,
	    id: ++nextOpId           // Unique ID
	  };
	  pushOperation(cm.curOp);
	}

	// Finish an operation, updating the display and signalling delayed events
	function endOperation(cm) {
	  var op = cm.curOp;
	  finishOperation(op, function (group) {
	    for (var i = 0; i < group.ops.length; i++)
	      { group.ops[i].cm.curOp = null; }
	    endOperations(group);
	  });
	}

	// The DOM updates done when an operation finishes are batched so
	// that the minimum number of relayouts are required.
	function endOperations(group) {
	  var ops = group.ops;
	  for (var i = 0; i < ops.length; i++) // Read DOM
	    { endOperation_R1(ops[i]); }
	  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
	    { endOperation_W1(ops[i$1]); }
	  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
	    { endOperation_R2(ops[i$2]); }
	  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
	    { endOperation_W2(ops[i$3]); }
	  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
	    { endOperation_finish(ops[i$4]); }
	}

	function endOperation_R1(op) {
	  var cm = op.cm, display = cm.display;
	  maybeClipScrollbars(cm);
	  if (op.updateMaxLine) { findMaxLine(cm); }

	  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
	    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
	                       op.scrollToPos.to.line >= display.viewTo) ||
	    display.maxLineChanged && cm.options.lineWrapping;
	  op.update = op.mustUpdate &&
	    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
	}

	function endOperation_W1(op) {
	  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
	}

	function endOperation_R2(op) {
	  var cm = op.cm, display = cm.display;
	  if (op.updatedDisplay) { updateHeightsInViewport(cm); }

	  op.barMeasure = measureForScrollbars(cm);

	  // If the max line changed since it was last measured, measure it,
	  // and ensure the document's width matches it.
	  // updateDisplay_W2 will use these properties to do the actual resizing
	  if (display.maxLineChanged && !cm.options.lineWrapping) {
	    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
	    cm.display.sizerWidth = op.adjustWidthTo;
	    op.barMeasure.scrollWidth =
	      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
	    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
	  }

	  if (op.updatedDisplay || op.selectionChanged)
	    { op.preparedSelection = display.input.prepareSelection(); }
	}

	function endOperation_W2(op) {
	  var cm = op.cm;

	  if (op.adjustWidthTo != null) {
	    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
	    if (op.maxScrollLeft < cm.doc.scrollLeft)
	      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
	    cm.display.maxLineChanged = false;
	  }

	  var takeFocus = op.focus && op.focus == activeElt();
	  if (op.preparedSelection)
	    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
	  if (op.updatedDisplay || op.startHeight != cm.doc.height)
	    { updateScrollbars(cm, op.barMeasure); }
	  if (op.updatedDisplay)
	    { setDocumentHeight(cm, op.barMeasure); }

	  if (op.selectionChanged) { restartBlink(cm); }

	  if (cm.state.focused && op.updateInput)
	    { cm.display.input.reset(op.typing); }
	  if (takeFocus) { ensureFocus(op.cm); }
	}

	function endOperation_finish(op) {
	  var cm = op.cm, display = cm.display, doc = cm.doc;

	  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

	  // Abort mouse wheel delta measurement, when scrolling explicitly
	  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
	    { display.wheelStartX = display.wheelStartY = null; }

	  // Propagate the scroll position to the actual DOM scroller
	  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

	  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
	  // If we need to scroll a specific position into view, do so.
	  if (op.scrollToPos) {
	    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
	                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
	    maybeScrollWindow(cm, rect);
	  }

	  // Fire events for markers that are hidden/unidden by editing or
	  // undoing
	  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
	  if (hidden) { for (var i = 0; i < hidden.length; ++i)
	    { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
	  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
	    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

	  if (display.wrapper.offsetHeight)
	    { doc.scrollTop = cm.display.scroller.scrollTop; }

	  // Fire change events, and delayed event handlers
	  if (op.changeObjs)
	    { signal(cm, "changes", cm, op.changeObjs); }
	  if (op.update)
	    { op.update.finish(); }
	}

	// Run the given function in an operation
	function runInOp(cm, f) {
	  if (cm.curOp) { return f() }
	  startOperation(cm);
	  try { return f() }
	  finally { endOperation(cm); }
	}
	// Wraps a function in an operation. Returns the wrapped function.
	function operation(cm, f) {
	  return function() {
	    if (cm.curOp) { return f.apply(cm, arguments) }
	    startOperation(cm);
	    try { return f.apply(cm, arguments) }
	    finally { endOperation(cm); }
	  }
	}
	// Used to add methods to editor and doc instances, wrapping them in
	// operations.
	function methodOp(f) {
	  return function() {
	    if (this.curOp) { return f.apply(this, arguments) }
	    startOperation(this);
	    try { return f.apply(this, arguments) }
	    finally { endOperation(this); }
	  }
	}
	function docMethodOp(f) {
	  return function() {
	    var cm = this.cm;
	    if (!cm || cm.curOp) { return f.apply(this, arguments) }
	    startOperation(cm);
	    try { return f.apply(this, arguments) }
	    finally { endOperation(cm); }
	  }
	}

	// Updates the display.view data structure for a given change to the
	// document. From and to are in pre-change coordinates. Lendiff is
	// the amount of lines added or subtracted by the change. This is
	// used for changes that span multiple lines, or change the way
	// lines are divided into visual lines. regLineChange (below)
	// registers single-line changes.
	function regChange(cm, from, to, lendiff) {
	  if (from == null) { from = cm.doc.first; }
	  if (to == null) { to = cm.doc.first + cm.doc.size; }
	  if (!lendiff) { lendiff = 0; }

	  var display = cm.display;
	  if (lendiff && to < display.viewTo &&
	      (display.updateLineNumbers == null || display.updateLineNumbers > from))
	    { display.updateLineNumbers = from; }

	  cm.curOp.viewChanged = true;

	  if (from >= display.viewTo) { // Change after
	    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
	      { resetView(cm); }
	  } else if (to <= display.viewFrom) { // Change before
	    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
	      resetView(cm);
	    } else {
	      display.viewFrom += lendiff;
	      display.viewTo += lendiff;
	    }
	  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
	    resetView(cm);
	  } else if (from <= display.viewFrom) { // Top overlap
	    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
	    if (cut) {
	      display.view = display.view.slice(cut.index);
	      display.viewFrom = cut.lineN;
	      display.viewTo += lendiff;
	    } else {
	      resetView(cm);
	    }
	  } else if (to >= display.viewTo) { // Bottom overlap
	    var cut$1 = viewCuttingPoint(cm, from, from, -1);
	    if (cut$1) {
	      display.view = display.view.slice(0, cut$1.index);
	      display.viewTo = cut$1.lineN;
	    } else {
	      resetView(cm);
	    }
	  } else { // Gap in the middle
	    var cutTop = viewCuttingPoint(cm, from, from, -1);
	    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
	    if (cutTop && cutBot) {
	      display.view = display.view.slice(0, cutTop.index)
	        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
	        .concat(display.view.slice(cutBot.index));
	      display.viewTo += lendiff;
	    } else {
	      resetView(cm);
	    }
	  }

	  var ext = display.externalMeasured;
	  if (ext) {
	    if (to < ext.lineN)
	      { ext.lineN += lendiff; }
	    else if (from < ext.lineN + ext.size)
	      { display.externalMeasured = null; }
	  }
	}

	// Register a change to a single line. Type must be one of "text",
	// "gutter", "class", "widget"
	function regLineChange(cm, line, type) {
	  cm.curOp.viewChanged = true;
	  var display = cm.display, ext = cm.display.externalMeasured;
	  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
	    { display.externalMeasured = null; }

	  if (line < display.viewFrom || line >= display.viewTo) { return }
	  var lineView = display.view[findViewIndex(cm, line)];
	  if (lineView.node == null) { return }
	  var arr = lineView.changes || (lineView.changes = []);
	  if (indexOf(arr, type) == -1) { arr.push(type); }
	}

	// Clear the view.
	function resetView(cm) {
	  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
	  cm.display.view = [];
	  cm.display.viewOffset = 0;
	}

	function viewCuttingPoint(cm, oldN, newN, dir) {
	  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
	  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
	    { return {index: index, lineN: newN} }
	  var n = cm.display.viewFrom;
	  for (var i = 0; i < index; i++)
	    { n += view[i].size; }
	  if (n != oldN) {
	    if (dir > 0) {
	      if (index == view.length - 1) { return null }
	      diff = (n + view[index].size) - oldN;
	      index++;
	    } else {
	      diff = n - oldN;
	    }
	    oldN += diff; newN += diff;
	  }
	  while (visualLineNo(cm.doc, newN) != newN) {
	    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
	    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
	    index += dir;
	  }
	  return {index: index, lineN: newN}
	}

	// Force the view to cover a given range, adding empty view element
	// or clipping off existing ones as needed.
	function adjustView(cm, from, to) {
	  var display = cm.display, view = display.view;
	  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
	    display.view = buildViewArray(cm, from, to);
	    display.viewFrom = from;
	  } else {
	    if (display.viewFrom > from)
	      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
	    else if (display.viewFrom < from)
	      { display.view = display.view.slice(findViewIndex(cm, from)); }
	    display.viewFrom = from;
	    if (display.viewTo < to)
	      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
	    else if (display.viewTo > to)
	      { display.view = display.view.slice(0, findViewIndex(cm, to)); }
	  }
	  display.viewTo = to;
	}

	// Count the number of lines in the view whose DOM representation is
	// out of date (or nonexistent).
	function countDirtyView(cm) {
	  var view = cm.display.view, dirty = 0;
	  for (var i = 0; i < view.length; i++) {
	    var lineView = view[i];
	    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
	  }
	  return dirty
	}

	// HIGHLIGHT WORKER

	function startWorker(cm, time) {
	  if (cm.doc.highlightFrontier < cm.display.viewTo)
	    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
	}

	function highlightWorker(cm) {
	  var doc = cm.doc;
	  if (doc.highlightFrontier >= cm.display.viewTo) { return }
	  var end = +new Date + cm.options.workTime;
	  var context = getContextBefore(cm, doc.highlightFrontier);
	  var changedLines = [];

	  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
	    if (context.line >= cm.display.viewFrom) { // Visible
	      var oldStyles = line.styles;
	      var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
	      var highlighted = highlightLine(cm, line, context, true);
	      if (resetState) { context.state = resetState; }
	      line.styles = highlighted.styles;
	      var oldCls = line.styleClasses, newCls = highlighted.classes;
	      if (newCls) { line.styleClasses = newCls; }
	      else if (oldCls) { line.styleClasses = null; }
	      var ischange = !oldStyles || oldStyles.length != line.styles.length ||
	        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
	      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
	      if (ischange) { changedLines.push(context.line); }
	      line.stateAfter = context.save();
	      context.nextLine();
	    } else {
	      if (line.text.length <= cm.options.maxHighlightLength)
	        { processLine(cm, line.text, context); }
	      line.stateAfter = context.line % 5 == 0 ? context.save() : null;
	      context.nextLine();
	    }
	    if (+new Date > end) {
	      startWorker(cm, cm.options.workDelay);
	      return true
	    }
	  });
	  doc.highlightFrontier = context.line;
	  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
	  if (changedLines.length) { runInOp(cm, function () {
	    for (var i = 0; i < changedLines.length; i++)
	      { regLineChange(cm, changedLines[i], "text"); }
	  }); }
	}

	// DISPLAY DRAWING

	var DisplayUpdate = function(cm, viewport, force) {
	  var display = cm.display;

	  this.viewport = viewport;
	  // Store some values that we'll need later (but don't want to force a relayout for)
	  this.visible = visibleLines(display, cm.doc, viewport);
	  this.editorIsHidden = !display.wrapper.offsetWidth;
	  this.wrapperHeight = display.wrapper.clientHeight;
	  this.wrapperWidth = display.wrapper.clientWidth;
	  this.oldDisplayWidth = displayWidth(cm);
	  this.force = force;
	  this.dims = getDimensions(cm);
	  this.events = [];
	};

	DisplayUpdate.prototype.signal = function (emitter, type) {
	  if (hasHandler(emitter, type))
	    { this.events.push(arguments); }
	};
	DisplayUpdate.prototype.finish = function () {
	    var this$1 = this;

	  for (var i = 0; i < this.events.length; i++)
	    { signal.apply(null, this$1.events[i]); }
	};

	function maybeClipScrollbars(cm) {
	  var display = cm.display;
	  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
	    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
	    display.heightForcer.style.height = scrollGap(cm) + "px";
	    display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
	    display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
	    display.scrollbarsClipped = true;
	  }
	}

	function selectionSnapshot(cm) {
	  if (cm.hasFocus()) { return null }
	  var active = activeElt();
	  if (!active || !contains(cm.display.lineDiv, active)) { return null }
	  var result = {activeElt: active};
	  if (window.getSelection) {
	    var sel = window.getSelection();
	    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
	      result.anchorNode = sel.anchorNode;
	      result.anchorOffset = sel.anchorOffset;
	      result.focusNode = sel.focusNode;
	      result.focusOffset = sel.focusOffset;
	    }
	  }
	  return result
	}

	function restoreSelection(snapshot) {
	  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
	  snapshot.activeElt.focus();
	  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
	    var sel = window.getSelection(), range$$1 = document.createRange();
	    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
	    range$$1.collapse(false);
	    sel.removeAllRanges();
	    sel.addRange(range$$1);
	    sel.extend(snapshot.focusNode, snapshot.focusOffset);
	  }
	}

	// Does the actual updating of the line display. Bails out
	// (returning false) when there is nothing to be done and forced is
	// false.
	function updateDisplayIfNeeded(cm, update) {
	  var display = cm.display, doc = cm.doc;

	  if (update.editorIsHidden) {
	    resetView(cm);
	    return false
	  }

	  // Bail out if the visible area is already rendered and nothing changed.
	  if (!update.force &&
	      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
	      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
	      display.renderedView == display.view && countDirtyView(cm) == 0)
	    { return false }

	  if (maybeUpdateLineNumberWidth(cm)) {
	    resetView(cm);
	    update.dims = getDimensions(cm);
	  }

	  // Compute a suitable new viewport (from & to)
	  var end = doc.first + doc.size;
	  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
	  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
	  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
	  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
	  if (sawCollapsedSpans) {
	    from = visualLineNo(cm.doc, from);
	    to = visualLineEndNo(cm.doc, to);
	  }

	  var different = from != display.viewFrom || to != display.viewTo ||
	    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
	  adjustView(cm, from, to);

	  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
	  // Position the mover div to align with the current scroll position
	  cm.display.mover.style.top = display.viewOffset + "px";

	  var toUpdate = countDirtyView(cm);
	  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
	      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
	    { return false }

	  // For big changes, we hide the enclosing element during the
	  // update, since that speeds up the operations on most browsers.
	  var selSnapshot = selectionSnapshot(cm);
	  if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
	  patchDisplay(cm, display.updateLineNumbers, update.dims);
	  if (toUpdate > 4) { display.lineDiv.style.display = ""; }
	  display.renderedView = display.view;
	  // There might have been a widget with a focused element that got
	  // hidden or updated, if so re-focus it.
	  restoreSelection(selSnapshot);

	  // Prevent selection and cursors from interfering with the scroll
	  // width and height.
	  removeChildren(display.cursorDiv);
	  removeChildren(display.selectionDiv);
	  display.gutters.style.height = display.sizer.style.minHeight = 0;

	  if (different) {
	    display.lastWrapHeight = update.wrapperHeight;
	    display.lastWrapWidth = update.wrapperWidth;
	    startWorker(cm, 400);
	  }

	  display.updateLineNumbers = null;

	  return true
	}

	function postUpdateDisplay(cm, update) {
	  var viewport = update.viewport;

	  for (var first = true;; first = false) {
	    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
	      // Clip forced viewport to actual scrollable area.
	      if (viewport && viewport.top != null)
	        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
	      // Updated line heights might result in the drawn area not
	      // actually covering the viewport. Keep looping until it does.
	      update.visible = visibleLines(cm.display, cm.doc, viewport);
	      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
	        { break }
	    }
	    if (!updateDisplayIfNeeded(cm, update)) { break }
	    updateHeightsInViewport(cm);
	    var barMeasure = measureForScrollbars(cm);
	    updateSelection(cm);
	    updateScrollbars(cm, barMeasure);
	    setDocumentHeight(cm, barMeasure);
	    update.force = false;
	  }

	  update.signal(cm, "update", cm);
	  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
	    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
	    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
	  }
	}

	function updateDisplaySimple(cm, viewport) {
	  var update = new DisplayUpdate(cm, viewport);
	  if (updateDisplayIfNeeded(cm, update)) {
	    updateHeightsInViewport(cm);
	    postUpdateDisplay(cm, update);
	    var barMeasure = measureForScrollbars(cm);
	    updateSelection(cm);
	    updateScrollbars(cm, barMeasure);
	    setDocumentHeight(cm, barMeasure);
	    update.finish();
	  }
	}

	// Sync the actual display DOM structure with display.view, removing
	// nodes for lines that are no longer in view, and creating the ones
	// that are not there yet, and updating the ones that are out of
	// date.
	function patchDisplay(cm, updateNumbersFrom, dims) {
	  var display = cm.display, lineNumbers = cm.options.lineNumbers;
	  var container = display.lineDiv, cur = container.firstChild;

	  function rm(node) {
	    var next = node.nextSibling;
	    // Works around a throw-scroll bug in OS X Webkit
	    if (webkit && mac && cm.display.currentWheelTarget == node)
	      { node.style.display = "none"; }
	    else
	      { node.parentNode.removeChild(node); }
	    return next
	  }

	  var view = display.view, lineN = display.viewFrom;
	  // Loop over the elements in the view, syncing cur (the DOM nodes
	  // in display.lineDiv) with the view as we go.
	  for (var i = 0; i < view.length; i++) {
	    var lineView = view[i];
	    if (lineView.hidden) {
	    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
	      var node = buildLineElement(cm, lineView, lineN, dims);
	      container.insertBefore(node, cur);
	    } else { // Already drawn
	      while (cur != lineView.node) { cur = rm(cur); }
	      var updateNumber = lineNumbers && updateNumbersFrom != null &&
	        updateNumbersFrom <= lineN && lineView.lineNumber;
	      if (lineView.changes) {
	        if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
	        updateLineForChanges(cm, lineView, lineN, dims);
	      }
	      if (updateNumber) {
	        removeChildren(lineView.lineNumber);
	        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
	      }
	      cur = lineView.node.nextSibling;
	    }
	    lineN += lineView.size;
	  }
	  while (cur) { cur = rm(cur); }
	}

	function updateGutterSpace(cm) {
	  var width = cm.display.gutters.offsetWidth;
	  cm.display.sizer.style.marginLeft = width + "px";
	}

	function setDocumentHeight(cm, measure) {
	  cm.display.sizer.style.minHeight = measure.docHeight + "px";
	  cm.display.heightForcer.style.top = measure.docHeight + "px";
	  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
	}

	// Rebuild the gutter elements, ensure the margin to the left of the
	// code matches their width.
	function updateGutters(cm) {
	  var gutters = cm.display.gutters, specs = cm.options.gutters;
	  removeChildren(gutters);
	  var i = 0;
	  for (; i < specs.length; ++i) {
	    var gutterClass = specs[i];
	    var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
	    if (gutterClass == "CodeMirror-linenumbers") {
	      cm.display.lineGutter = gElt;
	      gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
	    }
	  }
	  gutters.style.display = i ? "" : "none";
	  updateGutterSpace(cm);
	}

	// Make sure the gutters options contains the element
	// "CodeMirror-linenumbers" when the lineNumbers option is true.
	function setGuttersForLineNumbers(options) {
	  var found = indexOf(options.gutters, "CodeMirror-linenumbers");
	  if (found == -1 && options.lineNumbers) {
	    options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
	  } else if (found > -1 && !options.lineNumbers) {
	    options.gutters = options.gutters.slice(0);
	    options.gutters.splice(found, 1);
	  }
	}

	// Since the delta values reported on mouse wheel events are
	// unstandardized between browsers and even browser versions, and
	// generally horribly unpredictable, this code starts by measuring
	// the scroll effect that the first few mouse wheel events have,
	// and, from that, detects the way it can convert deltas to pixel
	// offsets afterwards.
	//
	// The reason we want to know the amount a wheel event will scroll
	// is that it gives us a chance to update the display before the
	// actual scrolling happens, reducing flickering.

	var wheelSamples = 0;
	var wheelPixelsPerUnit = null;
	// Fill in a browser-detected starting value on browsers where we
	// know one. These don't have to be accurate -- the result of them
	// being wrong would just be a slight flicker on the first wheel
	// scroll (if it is large enough).
	if (ie) { wheelPixelsPerUnit = -.53; }
	else if (gecko) { wheelPixelsPerUnit = 15; }
	else if (chrome) { wheelPixelsPerUnit = -.7; }
	else if (safari) { wheelPixelsPerUnit = -1/3; }

	function wheelEventDelta(e) {
	  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
	  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
	  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
	  else if (dy == null) { dy = e.wheelDelta; }
	  return {x: dx, y: dy}
	}
	function wheelEventPixels(e) {
	  var delta = wheelEventDelta(e);
	  delta.x *= wheelPixelsPerUnit;
	  delta.y *= wheelPixelsPerUnit;
	  return delta
	}

	function onScrollWheel(cm, e) {
	  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

	  var display = cm.display, scroll = display.scroller;
	  // Quit if there's nothing to scroll here
	  var canScrollX = scroll.scrollWidth > scroll.clientWidth;
	  var canScrollY = scroll.scrollHeight > scroll.clientHeight;
	  if (!(dx && canScrollX || dy && canScrollY)) { return }

	  // Webkit browsers on OS X abort momentum scrolls when the target
	  // of the scroll event is removed from the scrollable element.
	  // This hack (see related code in patchDisplay) makes sure the
	  // element is kept around.
	  if (dy && mac && webkit) {
	    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
	      for (var i = 0; i < view.length; i++) {
	        if (view[i].node == cur) {
	          cm.display.currentWheelTarget = cur;
	          break outer
	        }
	      }
	    }
	  }

	  // On some browsers, horizontal scrolling will cause redraws to
	  // happen before the gutter has been realigned, causing it to
	  // wriggle around in a most unseemly way. When we have an
	  // estimated pixels/delta value, we just handle horizontal
	  // scrolling entirely here. It'll be slightly off from native, but
	  // better than glitching out.
	  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
	    if (dy && canScrollY)
	      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
	    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
	    // Only prevent default scrolling if vertical scrolling is
	    // actually possible. Otherwise, it causes vertical scroll
	    // jitter on OSX trackpads when deltaX is small and deltaY
	    // is large (issue #3579)
	    if (!dy || (dy && canScrollY))
	      { e_preventDefault(e); }
	    display.wheelStartX = null; // Abort measurement, if in progress
	    return
	  }

	  // 'Project' the visible viewport to cover the area that is being
	  // scrolled into view (if we know enough to estimate it).
	  if (dy && wheelPixelsPerUnit != null) {
	    var pixels = dy * wheelPixelsPerUnit;
	    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
	    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
	    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
	    updateDisplaySimple(cm, {top: top, bottom: bot});
	  }

	  if (wheelSamples < 20) {
	    if (display.wheelStartX == null) {
	      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
	      display.wheelDX = dx; display.wheelDY = dy;
	      setTimeout(function () {
	        if (display.wheelStartX == null) { return }
	        var movedX = scroll.scrollLeft - display.wheelStartX;
	        var movedY = scroll.scrollTop - display.wheelStartY;
	        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
	          (movedX && display.wheelDX && movedX / display.wheelDX);
	        display.wheelStartX = display.wheelStartY = null;
	        if (!sample) { return }
	        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
	        ++wheelSamples;
	      }, 200);
	    } else {
	      display.wheelDX += dx; display.wheelDY += dy;
	    }
	  }
	}

	// Selection objects are immutable. A new one is created every time
	// the selection changes. A selection is one or more non-overlapping
	// (and non-touching) ranges, sorted, and an integer that indicates
	// which one is the primary selection (the one that's scrolled into
	// view, that getCursor returns, etc).
	var Selection = function(ranges, primIndex) {
	  this.ranges = ranges;
	  this.primIndex = primIndex;
	};

	Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

	Selection.prototype.equals = function (other) {
	    var this$1 = this;

	  if (other == this) { return true }
	  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
	  for (var i = 0; i < this.ranges.length; i++) {
	    var here = this$1.ranges[i], there = other.ranges[i];
	    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
	  }
	  return true
	};

	Selection.prototype.deepCopy = function () {
	    var this$1 = this;

	  var out = [];
	  for (var i = 0; i < this.ranges.length; i++)
	    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
	  return new Selection(out, this.primIndex)
	};

	Selection.prototype.somethingSelected = function () {
	    var this$1 = this;

	  for (var i = 0; i < this.ranges.length; i++)
	    { if (!this$1.ranges[i].empty()) { return true } }
	  return false
	};

	Selection.prototype.contains = function (pos, end) {
	    var this$1 = this;

	  if (!end) { end = pos; }
	  for (var i = 0; i < this.ranges.length; i++) {
	    var range = this$1.ranges[i];
	    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
	      { return i }
	  }
	  return -1
	};

	var Range = function(anchor, head) {
	  this.anchor = anchor; this.head = head;
	};

	Range.prototype.from = function () { return minPos(this.anchor, this.head) };
	Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
	Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

	// Take an unsorted, potentially overlapping set of ranges, and
	// build a selection out of it. 'Consumes' ranges array (modifying
	// it).
	function normalizeSelection(ranges, primIndex) {
	  var prim = ranges[primIndex];
	  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
	  primIndex = indexOf(ranges, prim);
	  for (var i = 1; i < ranges.length; i++) {
	    var cur = ranges[i], prev = ranges[i - 1];
	    if (cmp(prev.to(), cur.from()) >= 0) {
	      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
	      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
	      if (i <= primIndex) { --primIndex; }
	      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
	    }
	  }
	  return new Selection(ranges, primIndex)
	}

	function simpleSelection(anchor, head) {
	  return new Selection([new Range(anchor, head || anchor)], 0)
	}

	// Compute the position of the end of a change (its 'to' property
	// refers to the pre-change end).
	function changeEnd(change) {
	  if (!change.text) { return change.to }
	  return Pos(change.from.line + change.text.length - 1,
	             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
	}

	// Adjust a position to refer to the post-change position of the
	// same text, or the end of the change if the change covers it.
	function adjustForChange(pos, change) {
	  if (cmp(pos, change.from) < 0) { return pos }
	  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

	  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
	  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
	  return Pos(line, ch)
	}

	function computeSelAfterChange(doc, change) {
	  var out = [];
	  for (var i = 0; i < doc.sel.ranges.length; i++) {
	    var range = doc.sel.ranges[i];
	    out.push(new Range(adjustForChange(range.anchor, change),
	                       adjustForChange(range.head, change)));
	  }
	  return normalizeSelection(out, doc.sel.primIndex)
	}

	function offsetPos(pos, old, nw) {
	  if (pos.line == old.line)
	    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
	  else
	    { return Pos(nw.line + (pos.line - old.line), pos.ch) }
	}

	// Used by replaceSelections to allow moving the selection to the
	// start or around the replaced test. Hint may be "start" or "around".
	function computeReplacedSel(doc, changes, hint) {
	  var out = [];
	  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
	  for (var i = 0; i < changes.length; i++) {
	    var change = changes[i];
	    var from = offsetPos(change.from, oldPrev, newPrev);
	    var to = offsetPos(changeEnd(change), oldPrev, newPrev);
	    oldPrev = change.to;
	    newPrev = to;
	    if (hint == "around") {
	      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
	      out[i] = new Range(inv ? to : from, inv ? from : to);
	    } else {
	      out[i] = new Range(from, from);
	    }
	  }
	  return new Selection(out, doc.sel.primIndex)
	}

	// Used to get the editor into a consistent state again when options change.

	function loadMode(cm) {
	  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
	  resetModeState(cm);
	}

	function resetModeState(cm) {
	  cm.doc.iter(function (line) {
	    if (line.stateAfter) { line.stateAfter = null; }
	    if (line.styles) { line.styles = null; }
	  });
	  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
	  startWorker(cm, 100);
	  cm.state.modeGen++;
	  if (cm.curOp) { regChange(cm); }
	}

	// DOCUMENT DATA STRUCTURE

	// By default, updates that start and end at the beginning of a line
	// are treated specially, in order to make the association of line
	// widgets and marker elements with the text behave more intuitive.
	function isWholeLineUpdate(doc, change) {
	  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
	    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
	}

	// Perform a change on the document data structure.
	function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
	  function spansFor(n) {return markedSpans ? markedSpans[n] : null}
	  function update(line, text, spans) {
	    updateLine(line, text, spans, estimateHeight$$1);
	    signalLater(line, "change", line, change);
	  }
	  function linesFor(start, end) {
	    var result = [];
	    for (var i = start; i < end; ++i)
	      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
	    return result
	  }

	  var from = change.from, to = change.to, text = change.text;
	  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
	  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

	  // Adjust the line structure
	  if (change.full) {
	    doc.insert(0, linesFor(0, text.length));
	    doc.remove(text.length, doc.size - text.length);
	  } else if (isWholeLineUpdate(doc, change)) {
	    // This is a whole-line replace. Treated specially to make
	    // sure line objects move the way they are supposed to.
	    var added = linesFor(0, text.length - 1);
	    update(lastLine, lastLine.text, lastSpans);
	    if (nlines) { doc.remove(from.line, nlines); }
	    if (added.length) { doc.insert(from.line, added); }
	  } else if (firstLine == lastLine) {
	    if (text.length == 1) {
	      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
	    } else {
	      var added$1 = linesFor(1, text.length - 1);
	      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	      doc.insert(from.line + 1, added$1);
	    }
	  } else if (text.length == 1) {
	    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
	    doc.remove(from.line + 1, nlines);
	  } else {
	    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
	    var added$2 = linesFor(1, text.length - 1);
	    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
	    doc.insert(from.line + 1, added$2);
	  }

	  signalLater(doc, "change", doc, change);
	}

	// Call f for all linked documents.
	function linkedDocs(doc, f, sharedHistOnly) {
	  function propagate(doc, skip, sharedHist) {
	    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
	      var rel = doc.linked[i];
	      if (rel.doc == skip) { continue }
	      var shared = sharedHist && rel.sharedHist;
	      if (sharedHistOnly && !shared) { continue }
	      f(rel.doc, shared);
	      propagate(rel.doc, doc, shared);
	    } }
	  }
	  propagate(doc, null, true);
	}

	// Attach a document to an editor.
	function attachDoc(cm, doc) {
	  if (doc.cm) { throw new Error("This document is already in use.") }
	  cm.doc = doc;
	  doc.cm = cm;
	  estimateLineHeights(cm);
	  loadMode(cm);
	  setDirectionClass(cm);
	  if (!cm.options.lineWrapping) { findMaxLine(cm); }
	  cm.options.mode = doc.modeOption;
	  regChange(cm);
	}

	function setDirectionClass(cm) {
	  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
	}

	function directionChanged(cm) {
	  runInOp(cm, function () {
	    setDirectionClass(cm);
	    regChange(cm);
	  });
	}

	function History(startGen) {
	  // Arrays of change events and selections. Doing something adds an
	  // event to done and clears undo. Undoing moves events from done
	  // to undone, redoing moves them in the other direction.
	  this.done = []; this.undone = [];
	  this.undoDepth = Infinity;
	  // Used to track when changes can be merged into a single undo
	  // event
	  this.lastModTime = this.lastSelTime = 0;
	  this.lastOp = this.lastSelOp = null;
	  this.lastOrigin = this.lastSelOrigin = null;
	  // Used by the isClean() method
	  this.generation = this.maxGeneration = startGen || 1;
	}

	// Create a history change event from an updateDoc-style change
	// object.
	function historyChangeFromChange(doc, change) {
	  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
	  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
	  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
	  return histChange
	}

	// Pop all selection events off the end of a history array. Stop at
	// a change event.
	function clearSelectionEvents(array) {
	  while (array.length) {
	    var last = lst(array);
	    if (last.ranges) { array.pop(); }
	    else { break }
	  }
	}

	// Find the top change event in the history. Pop off selection
	// events that are in the way.
	function lastChangeEvent(hist, force) {
	  if (force) {
	    clearSelectionEvents(hist.done);
	    return lst(hist.done)
	  } else if (hist.done.length && !lst(hist.done).ranges) {
	    return lst(hist.done)
	  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
	    hist.done.pop();
	    return lst(hist.done)
	  }
	}

	// Register a change in the history. Merges changes that are within
	// a single operation, or are close together with an origin that
	// allows merging (starting with "+") into a single event.
	function addChangeToHistory(doc, change, selAfter, opId) {
	  var hist = doc.history;
	  hist.undone.length = 0;
	  var time = +new Date, cur;
	  var last;

	  if ((hist.lastOp == opId ||
	       hist.lastOrigin == change.origin && change.origin &&
	       ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
	        change.origin.charAt(0) == "*")) &&
	      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
	    // Merge this change into the last event
	    last = lst(cur.changes);
	    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
	      // Optimized case for simple insertion -- don't want to add
	      // new changesets for every character typed
	      last.to = changeEnd(change);
	    } else {
	      // Add new sub-event
	      cur.changes.push(historyChangeFromChange(doc, change));
	    }
	  } else {
	    // Can not be merged, start a new event.
	    var before = lst(hist.done);
	    if (!before || !before.ranges)
	      { pushSelectionToHistory(doc.sel, hist.done); }
	    cur = {changes: [historyChangeFromChange(doc, change)],
	           generation: hist.generation};
	    hist.done.push(cur);
	    while (hist.done.length > hist.undoDepth) {
	      hist.done.shift();
	      if (!hist.done[0].ranges) { hist.done.shift(); }
	    }
	  }
	  hist.done.push(selAfter);
	  hist.generation = ++hist.maxGeneration;
	  hist.lastModTime = hist.lastSelTime = time;
	  hist.lastOp = hist.lastSelOp = opId;
	  hist.lastOrigin = hist.lastSelOrigin = change.origin;

	  if (!last) { signal(doc, "historyAdded"); }
	}

	function selectionEventCanBeMerged(doc, origin, prev, sel) {
	  var ch = origin.charAt(0);
	  return ch == "*" ||
	    ch == "+" &&
	    prev.ranges.length == sel.ranges.length &&
	    prev.somethingSelected() == sel.somethingSelected() &&
	    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
	}

	// Called whenever the selection changes, sets the new selection as
	// the pending selection in the history, and pushes the old pending
	// selection into the 'done' array when it was significantly
	// different (in number of selected ranges, emptiness, or time).
	function addSelectionToHistory(doc, sel, opId, options) {
	  var hist = doc.history, origin = options && options.origin;

	  // A new event is started when the previous origin does not match
	  // the current, or the origins don't allow matching. Origins
	  // starting with * are always merged, those starting with + are
	  // merged when similar and close together in time.
	  if (opId == hist.lastSelOp ||
	      (origin && hist.lastSelOrigin == origin &&
	       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
	        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
	    { hist.done[hist.done.length - 1] = sel; }
	  else
	    { pushSelectionToHistory(sel, hist.done); }

	  hist.lastSelTime = +new Date;
	  hist.lastSelOrigin = origin;
	  hist.lastSelOp = opId;
	  if (options && options.clearRedo !== false)
	    { clearSelectionEvents(hist.undone); }
	}

	function pushSelectionToHistory(sel, dest) {
	  var top = lst(dest);
	  if (!(top && top.ranges && top.equals(sel)))
	    { dest.push(sel); }
	}

	// Used to store marked span information in the history.
	function attachLocalSpans(doc, change, from, to) {
	  var existing = change["spans_" + doc.id], n = 0;
	  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
	    if (line.markedSpans)
	      { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
	    ++n;
	  });
	}

	// When un/re-doing restores text containing marked spans, those
	// that have been explicitly cleared should not be restored.
	function removeClearedSpans(spans) {
	  if (!spans) { return null }
	  var out;
	  for (var i = 0; i < spans.length; ++i) {
	    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
	    else if (out) { out.push(spans[i]); }
	  }
	  return !out ? spans : out.length ? out : null
	}

	// Retrieve and filter the old marked spans stored in a change event.
	function getOldSpans(doc, change) {
	  var found = change["spans_" + doc.id];
	  if (!found) { return null }
	  var nw = [];
	  for (var i = 0; i < change.text.length; ++i)
	    { nw.push(removeClearedSpans(found[i])); }
	  return nw
	}

	// Used for un/re-doing changes from the history. Combines the
	// result of computing the existing spans with the set of spans that
	// existed in the history (so that deleting around a span and then
	// undoing brings back the span).
	function mergeOldSpans(doc, change) {
	  var old = getOldSpans(doc, change);
	  var stretched = stretchSpansOverChange(doc, change);
	  if (!old) { return stretched }
	  if (!stretched) { return old }

	  for (var i = 0; i < old.length; ++i) {
	    var oldCur = old[i], stretchCur = stretched[i];
	    if (oldCur && stretchCur) {
	      spans: for (var j = 0; j < stretchCur.length; ++j) {
	        var span = stretchCur[j];
	        for (var k = 0; k < oldCur.length; ++k)
	          { if (oldCur[k].marker == span.marker) { continue spans } }
	        oldCur.push(span);
	      }
	    } else if (stretchCur) {
	      old[i] = stretchCur;
	    }
	  }
	  return old
	}

	// Used both to provide a JSON-safe object in .getHistory, and, when
	// detaching a document, to split the history in two
	function copyHistoryArray(events, newGroup, instantiateSel) {
	  var copy = [];
	  for (var i = 0; i < events.length; ++i) {
	    var event = events[i];
	    if (event.ranges) {
	      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
	      continue
	    }
	    var changes = event.changes, newChanges = [];
	    copy.push({changes: newChanges});
	    for (var j = 0; j < changes.length; ++j) {
	      var change = changes[j], m = (void 0);
	      newChanges.push({from: change.from, to: change.to, text: change.text});
	      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
	        if (indexOf(newGroup, Number(m[1])) > -1) {
	          lst(newChanges)[prop] = change[prop];
	          delete change[prop];
	        }
	      } } }
	    }
	  }
	  return copy
	}

	// The 'scroll' parameter given to many of these indicated whether
	// the new cursor position should be scrolled into view after
	// modifying the selection.

	// If shift is held or the extend flag is set, extends a range to
	// include a given position (and optionally a second position).
	// Otherwise, simply returns the range between the given positions.
	// Used for cursor motion and such.
	function extendRange(range, head, other, extend) {
	  if (extend) {
	    var anchor = range.anchor;
	    if (other) {
	      var posBefore = cmp(head, anchor) < 0;
	      if (posBefore != (cmp(other, anchor) < 0)) {
	        anchor = head;
	        head = other;
	      } else if (posBefore != (cmp(head, other) < 0)) {
	        head = other;
	      }
	    }
	    return new Range(anchor, head)
	  } else {
	    return new Range(other || head, head)
	  }
	}

	// Extend the primary selection range, discard the rest.
	function extendSelection(doc, head, other, options, extend) {
	  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
	  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
	}

	// Extend all selections (pos is an array of selections with length
	// equal the number of selections)
	function extendSelections(doc, heads, options) {
	  var out = [];
	  var extend = doc.cm && (doc.cm.display.shift || doc.extend);
	  for (var i = 0; i < doc.sel.ranges.length; i++)
	    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
	  var newSel = normalizeSelection(out, doc.sel.primIndex);
	  setSelection(doc, newSel, options);
	}

	// Updates a single range in the selection.
	function replaceOneSelection(doc, i, range, options) {
	  var ranges = doc.sel.ranges.slice(0);
	  ranges[i] = range;
	  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
	}

	// Reset the selection to a single range.
	function setSimpleSelection(doc, anchor, head, options) {
	  setSelection(doc, simpleSelection(anchor, head), options);
	}

	// Give beforeSelectionChange handlers a change to influence a
	// selection update.
	function filterSelectionChange(doc, sel, options) {
	  var obj = {
	    ranges: sel.ranges,
	    update: function(ranges) {
	      var this$1 = this;

	      this.ranges = [];
	      for (var i = 0; i < ranges.length; i++)
	        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
	                                   clipPos(doc, ranges[i].head)); }
	    },
	    origin: options && options.origin
	  };
	  signal(doc, "beforeSelectionChange", doc, obj);
	  if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
	  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }
	  else { return sel }
	}

	function setSelectionReplaceHistory(doc, sel, options) {
	  var done = doc.history.done, last = lst(done);
	  if (last && last.ranges) {
	    done[done.length - 1] = sel;
	    setSelectionNoUndo(doc, sel, options);
	  } else {
	    setSelection(doc, sel, options);
	  }
	}

	// Set a new selection.
	function setSelection(doc, sel, options) {
	  setSelectionNoUndo(doc, sel, options);
	  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
	}

	function setSelectionNoUndo(doc, sel, options) {
	  if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
	    { sel = filterSelectionChange(doc, sel, options); }

	  var bias = options && options.bias ||
	    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
	  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

	  if (!(options && options.scroll === false) && doc.cm)
	    { ensureCursorVisible(doc.cm); }
	}

	function setSelectionInner(doc, sel) {
	  if (sel.equals(doc.sel)) { return }

	  doc.sel = sel;

	  if (doc.cm) {
	    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
	    signalCursorActivity(doc.cm);
	  }
	  signalLater(doc, "cursorActivity", doc);
	}

	// Verify that the selection does not partially select any atomic
	// marked ranges.
	function reCheckSelection(doc) {
	  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
	}

	// Return a selection that does not partially select any atomic
	// ranges.
	function skipAtomicInSelection(doc, sel, bias, mayClear) {
	  var out;
	  for (var i = 0; i < sel.ranges.length; i++) {
	    var range = sel.ranges[i];
	    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
	    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
	    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
	    if (out || newAnchor != range.anchor || newHead != range.head) {
	      if (!out) { out = sel.ranges.slice(0, i); }
	      out[i] = new Range(newAnchor, newHead);
	    }
	  }
	  return out ? normalizeSelection(out, sel.primIndex) : sel
	}

	function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
	  var line = getLine(doc, pos.line);
	  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	    var sp = line.markedSpans[i], m = sp.marker;
	    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
	        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
	      if (mayClear) {
	        signal(m, "beforeCursorEnter");
	        if (m.explicitlyCleared) {
	          if (!line.markedSpans) { break }
	          else {--i; continue}
	        }
	      }
	      if (!m.atomic) { continue }

	      if (oldPos) {
	        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
	        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
	          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
	        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
	          { return skipAtomicInner(doc, near, pos, dir, mayClear) }
	      }

	      var far = m.find(dir < 0 ? -1 : 1);
	      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
	        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
	      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
	    }
	  } }
	  return pos
	}

	// Ensure a given position is not inside an atomic range.
	function skipAtomic(doc, pos, oldPos, bias, mayClear) {
	  var dir = bias || 1;
	  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
	      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
	      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
	      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
	  if (!found) {
	    doc.cantEdit = true;
	    return Pos(doc.first, 0)
	  }
	  return found
	}

	function movePos(doc, pos, dir, line) {
	  if (dir < 0 && pos.ch == 0) {
	    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
	    else { return null }
	  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
	    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
	    else { return null }
	  } else {
	    return new Pos(pos.line, pos.ch + dir)
	  }
	}

	function selectAll(cm) {
	  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
	}

	// UPDATING

	// Allow "beforeChange" event handlers to influence a change
	function filterChange(doc, change, update) {
	  var obj = {
	    canceled: false,
	    from: change.from,
	    to: change.to,
	    text: change.text,
	    origin: change.origin,
	    cancel: function () { return obj.canceled = true; }
	  };
	  if (update) { obj.update = function (from, to, text, origin) {
	    if (from) { obj.from = clipPos(doc, from); }
	    if (to) { obj.to = clipPos(doc, to); }
	    if (text) { obj.text = text; }
	    if (origin !== undefined) { obj.origin = origin; }
	  }; }
	  signal(doc, "beforeChange", doc, obj);
	  if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

	  if (obj.canceled) { return null }
	  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
	}

	// Apply a change to a document, and add it to the document's
	// history, and propagating it to all linked documents.
	function makeChange(doc, change, ignoreReadOnly) {
	  if (doc.cm) {
	    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
	    if (doc.cm.state.suppressEdits) { return }
	  }

	  if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
	    change = filterChange(doc, change, true);
	    if (!change) { return }
	  }

	  // Possibly split or suppress the update based on the presence
	  // of read-only spans in its range.
	  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
	  if (split) {
	    for (var i = split.length - 1; i >= 0; --i)
	      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
	  } else {
	    makeChangeInner(doc, change);
	  }
	}

	function makeChangeInner(doc, change) {
	  if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
	  var selAfter = computeSelAfterChange(doc, change);
	  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

	  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
	  var rebased = [];

	  linkedDocs(doc, function (doc, sharedHist) {
	    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	      rebaseHist(doc.history, change);
	      rebased.push(doc.history);
	    }
	    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
	  });
	}

	// Revert a change stored in a document's history.
	function makeChangeFromHistory(doc, type, allowSelectionOnly) {
	  var suppress = doc.cm && doc.cm.state.suppressEdits;
	  if (suppress && !allowSelectionOnly) { return }

	  var hist = doc.history, event, selAfter = doc.sel;
	  var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

	  // Verify that there is a useable event (so that ctrl-z won't
	  // needlessly clear selection events)
	  var i = 0;
	  for (; i < source.length; i++) {
	    event = source[i];
	    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
	      { break }
	  }
	  if (i == source.length) { return }
	  hist.lastOrigin = hist.lastSelOrigin = null;

	  for (;;) {
	    event = source.pop();
	    if (event.ranges) {
	      pushSelectionToHistory(event, dest);
	      if (allowSelectionOnly && !event.equals(doc.sel)) {
	        setSelection(doc, event, {clearRedo: false});
	        return
	      }
	      selAfter = event;
	    } else if (suppress) {
	      source.push(event);
	      return
	    } else { break }
	  }

	  // Build up a reverse change object to add to the opposite history
	  // stack (redo when undoing, and vice versa).
	  var antiChanges = [];
	  pushSelectionToHistory(selAfter, dest);
	  dest.push({changes: antiChanges, generation: hist.generation});
	  hist.generation = event.generation || ++hist.maxGeneration;

	  var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

	  var loop = function ( i ) {
	    var change = event.changes[i];
	    change.origin = type;
	    if (filter && !filterChange(doc, change, false)) {
	      source.length = 0;
	      return {}
	    }

	    antiChanges.push(historyChangeFromChange(doc, change));

	    var after = i ? computeSelAfterChange(doc, change) : lst(source);
	    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
	    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
	    var rebased = [];

	    // Propagate to the linked documents
	    linkedDocs(doc, function (doc, sharedHist) {
	      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	        rebaseHist(doc.history, change);
	        rebased.push(doc.history);
	      }
	      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
	    });
	  };

	  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
	    var returned = loop( i$1 );

	    if ( returned ) return returned.v;
	  }
	}

	// Sub-views need their line numbers shifted when text is added
	// above or below them in the parent document.
	function shiftDoc(doc, distance) {
	  if (distance == 0) { return }
	  doc.first += distance;
	  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
	    Pos(range.anchor.line + distance, range.anchor.ch),
	    Pos(range.head.line + distance, range.head.ch)
	  ); }), doc.sel.primIndex);
	  if (doc.cm) {
	    regChange(doc.cm, doc.first, doc.first - distance, distance);
	    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
	      { regLineChange(doc.cm, l, "gutter"); }
	  }
	}

	// More lower-level change function, handling only a single document
	// (not linked ones).
	function makeChangeSingleDoc(doc, change, selAfter, spans) {
	  if (doc.cm && !doc.cm.curOp)
	    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

	  if (change.to.line < doc.first) {
	    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
	    return
	  }
	  if (change.from.line > doc.lastLine()) { return }

	  // Clip the change to the size of this doc
	  if (change.from.line < doc.first) {
	    var shift = change.text.length - 1 - (doc.first - change.from.line);
	    shiftDoc(doc, shift);
	    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
	              text: [lst(change.text)], origin: change.origin};
	  }
	  var last = doc.lastLine();
	  if (change.to.line > last) {
	    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
	              text: [change.text[0]], origin: change.origin};
	  }

	  change.removed = getBetween(doc, change.from, change.to);

	  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
	  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
	  else { updateDoc(doc, change, spans); }
	  setSelectionNoUndo(doc, selAfter, sel_dontScroll);
	}

	// Handle the interaction of a change to a document with the editor
	// that this document is part of.
	function makeChangeSingleDocInEditor(cm, change, spans) {
	  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

	  var recomputeMaxLength = false, checkWidthStart = from.line;
	  if (!cm.options.lineWrapping) {
	    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
	    doc.iter(checkWidthStart, to.line + 1, function (line) {
	      if (line == display.maxLine) {
	        recomputeMaxLength = true;
	        return true
	      }
	    });
	  }

	  if (doc.sel.contains(change.from, change.to) > -1)
	    { signalCursorActivity(cm); }

	  updateDoc(doc, change, spans, estimateHeight(cm));

	  if (!cm.options.lineWrapping) {
	    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
	      var len = lineLength(line);
	      if (len > display.maxLineLength) {
	        display.maxLine = line;
	        display.maxLineLength = len;
	        display.maxLineChanged = true;
	        recomputeMaxLength = false;
	      }
	    });
	    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
	  }

	  retreatFrontier(doc, from.line);
	  startWorker(cm, 400);

	  var lendiff = change.text.length - (to.line - from.line) - 1;
	  // Remember that these lines changed, for updating the display
	  if (change.full)
	    { regChange(cm); }
	  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
	    { regLineChange(cm, from.line, "text"); }
	  else
	    { regChange(cm, from.line, to.line + 1, lendiff); }

	  var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
	  if (changeHandler || changesHandler) {
	    var obj = {
	      from: from, to: to,
	      text: change.text,
	      removed: change.removed,
	      origin: change.origin
	    };
	    if (changeHandler) { signalLater(cm, "change", cm, obj); }
	    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
	  }
	  cm.display.selForContextMenu = null;
	}

	function replaceRange(doc, code, from, to, origin) {
	  if (!to) { to = from; }
	  if (cmp(to, from) < 0) { var assign;
	    (assign = [to, from], from = assign[0], to = assign[1]); }
	  if (typeof code == "string") { code = doc.splitLines(code); }
	  makeChange(doc, {from: from, to: to, text: code, origin: origin});
	}

	// Rebasing/resetting history to deal with externally-sourced changes

	function rebaseHistSelSingle(pos, from, to, diff) {
	  if (to < pos.line) {
	    pos.line += diff;
	  } else if (from < pos.line) {
	    pos.line = from;
	    pos.ch = 0;
	  }
	}

	// Tries to rebase an array of history events given a change in the
	// document. If the change touches the same lines as the event, the
	// event, and everything 'behind' it, is discarded. If the change is
	// before the event, the event's positions are updated. Uses a
	// copy-on-write scheme for the positions, to avoid having to
	// reallocate them all on every rebase, but also avoid problems with
	// shared position objects being unsafely updated.
	function rebaseHistArray(array, from, to, diff) {
	  for (var i = 0; i < array.length; ++i) {
	    var sub = array[i], ok = true;
	    if (sub.ranges) {
	      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
	      for (var j = 0; j < sub.ranges.length; j++) {
	        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
	        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
	      }
	      continue
	    }
	    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
	      var cur = sub.changes[j$1];
	      if (to < cur.from.line) {
	        cur.from = Pos(cur.from.line + diff, cur.from.ch);
	        cur.to = Pos(cur.to.line + diff, cur.to.ch);
	      } else if (from <= cur.to.line) {
	        ok = false;
	        break
	      }
	    }
	    if (!ok) {
	      array.splice(0, i + 1);
	      i = 0;
	    }
	  }
	}

	function rebaseHist(hist, change) {
	  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
	  rebaseHistArray(hist.done, from, to, diff);
	  rebaseHistArray(hist.undone, from, to, diff);
	}

	// Utility for applying a change to a line by handle or number,
	// returning the number and optionally registering the line as
	// changed.
	function changeLine(doc, handle, changeType, op) {
	  var no = handle, line = handle;
	  if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
	  else { no = lineNo(handle); }
	  if (no == null) { return null }
	  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
	  return line
	}

	// The document is represented as a BTree consisting of leaves, with
	// chunk of lines in them, and branches, with up to ten leaves or
	// other branch nodes below them. The top node is always a branch
	// node, and is the document object itself (meaning it has
	// additional methods and properties).
	//
	// All nodes have parent links. The tree is used both to go from
	// line numbers to line objects, and to go from objects to numbers.
	// It also indexes by height, and is used to convert between height
	// and line object, and to find the total height of the document.
	//
	// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

	function LeafChunk(lines) {
	  var this$1 = this;

	  this.lines = lines;
	  this.parent = null;
	  var height = 0;
	  for (var i = 0; i < lines.length; ++i) {
	    lines[i].parent = this$1;
	    height += lines[i].height;
	  }
	  this.height = height;
	}

	LeafChunk.prototype = {
	  chunkSize: function() { return this.lines.length },

	  // Remove the n lines at offset 'at'.
	  removeInner: function(at, n) {
	    var this$1 = this;

	    for (var i = at, e = at + n; i < e; ++i) {
	      var line = this$1.lines[i];
	      this$1.height -= line.height;
	      cleanUpLine(line);
	      signalLater(line, "delete");
	    }
	    this.lines.splice(at, n);
	  },

	  // Helper used to collapse a small branch into a single leaf.
	  collapse: function(lines) {
	    lines.push.apply(lines, this.lines);
	  },

	  // Insert the given array of lines at offset 'at', count them as
	  // having the given height.
	  insertInner: function(at, lines, height) {
	    var this$1 = this;

	    this.height += height;
	    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
	    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
	  },

	  // Used to iterate over a part of the tree.
	  iterN: function(at, n, op) {
	    var this$1 = this;

	    for (var e = at + n; at < e; ++at)
	      { if (op(this$1.lines[at])) { return true } }
	  }
	};

	function BranchChunk(children) {
	  var this$1 = this;

	  this.children = children;
	  var size = 0, height = 0;
	  for (var i = 0; i < children.length; ++i) {
	    var ch = children[i];
	    size += ch.chunkSize(); height += ch.height;
	    ch.parent = this$1;
	  }
	  this.size = size;
	  this.height = height;
	  this.parent = null;
	}

	BranchChunk.prototype = {
	  chunkSize: function() { return this.size },

	  removeInner: function(at, n) {
	    var this$1 = this;

	    this.size -= n;
	    for (var i = 0; i < this.children.length; ++i) {
	      var child = this$1.children[i], sz = child.chunkSize();
	      if (at < sz) {
	        var rm = Math.min(n, sz - at), oldHeight = child.height;
	        child.removeInner(at, rm);
	        this$1.height -= oldHeight - child.height;
	        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
	        if ((n -= rm) == 0) { break }
	        at = 0;
	      } else { at -= sz; }
	    }
	    // If the result is smaller than 25 lines, ensure that it is a
	    // single leaf node.
	    if (this.size - n < 25 &&
	        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
	      var lines = [];
	      this.collapse(lines);
	      this.children = [new LeafChunk(lines)];
	      this.children[0].parent = this;
	    }
	  },

	  collapse: function(lines) {
	    var this$1 = this;

	    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
	  },

	  insertInner: function(at, lines, height) {
	    var this$1 = this;

	    this.size += lines.length;
	    this.height += height;
	    for (var i = 0; i < this.children.length; ++i) {
	      var child = this$1.children[i], sz = child.chunkSize();
	      if (at <= sz) {
	        child.insertInner(at, lines, height);
	        if (child.lines && child.lines.length > 50) {
	          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
	          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
	          var remaining = child.lines.length % 25 + 25;
	          for (var pos = remaining; pos < child.lines.length;) {
	            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
	            child.height -= leaf.height;
	            this$1.children.splice(++i, 0, leaf);
	            leaf.parent = this$1;
	          }
	          child.lines = child.lines.slice(0, remaining);
	          this$1.maybeSpill();
	        }
	        break
	      }
	      at -= sz;
	    }
	  },

	  // When a node has grown, check whether it should be split.
	  maybeSpill: function() {
	    if (this.children.length <= 10) { return }
	    var me = this;
	    do {
	      var spilled = me.children.splice(me.children.length - 5, 5);
	      var sibling = new BranchChunk(spilled);
	      if (!me.parent) { // Become the parent node
	        var copy = new BranchChunk(me.children);
	        copy.parent = me;
	        me.children = [copy, sibling];
	        me = copy;
	     } else {
	        me.size -= sibling.size;
	        me.height -= sibling.height;
	        var myIndex = indexOf(me.parent.children, me);
	        me.parent.children.splice(myIndex + 1, 0, sibling);
	      }
	      sibling.parent = me.parent;
	    } while (me.children.length > 10)
	    me.parent.maybeSpill();
	  },

	  iterN: function(at, n, op) {
	    var this$1 = this;

	    for (var i = 0; i < this.children.length; ++i) {
	      var child = this$1.children[i], sz = child.chunkSize();
	      if (at < sz) {
	        var used = Math.min(n, sz - at);
	        if (child.iterN(at, used, op)) { return true }
	        if ((n -= used) == 0) { break }
	        at = 0;
	      } else { at -= sz; }
	    }
	  }
	};

	// Line widgets are block elements displayed above or below a line.

	var LineWidget = function(doc, node, options) {
	  var this$1 = this;

	  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
	    { this$1[opt] = options[opt]; } } }
	  this.doc = doc;
	  this.node = node;
	};

	LineWidget.prototype.clear = function () {
	    var this$1 = this;

	  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
	  if (no == null || !ws) { return }
	  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
	  if (!ws.length) { line.widgets = null; }
	  var height = widgetHeight(this);
	  updateLineHeight(line, Math.max(0, line.height - height));
	  if (cm) {
	    runInOp(cm, function () {
	      adjustScrollWhenAboveVisible(cm, line, -height);
	      regLineChange(cm, no, "widget");
	    });
	    signalLater(cm, "lineWidgetCleared", cm, this, no);
	  }
	};

	LineWidget.prototype.changed = function () {
	    var this$1 = this;

	  var oldH = this.height, cm = this.doc.cm, line = this.line;
	  this.height = null;
	  var diff = widgetHeight(this) - oldH;
	  if (!diff) { return }
	  updateLineHeight(line, line.height + diff);
	  if (cm) {
	    runInOp(cm, function () {
	      cm.curOp.forceUpdate = true;
	      adjustScrollWhenAboveVisible(cm, line, diff);
	      signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
	    });
	  }
	};
	eventMixin(LineWidget);

	function adjustScrollWhenAboveVisible(cm, line, diff) {
	  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
	    { addToScrollTop(cm, diff); }
	}

	function addLineWidget(doc, handle, node, options) {
	  var widget = new LineWidget(doc, node, options);
	  var cm = doc.cm;
	  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
	  changeLine(doc, handle, "widget", function (line) {
	    var widgets = line.widgets || (line.widgets = []);
	    if (widget.insertAt == null) { widgets.push(widget); }
	    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
	    widget.line = line;
	    if (cm && !lineIsHidden(doc, line)) {
	      var aboveVisible = heightAtLine(line) < doc.scrollTop;
	      updateLineHeight(line, line.height + widgetHeight(widget));
	      if (aboveVisible) { addToScrollTop(cm, widget.height); }
	      cm.curOp.forceUpdate = true;
	    }
	    return true
	  });
	  if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
	  return widget
	}

	// TEXTMARKERS

	// Created with markText and setBookmark methods. A TextMarker is a
	// handle that can be used to clear or find a marked position in the
	// document. Line objects hold arrays (markedSpans) containing
	// {from, to, marker} object pointing to such marker objects, and
	// indicating that such a marker is present on that line. Multiple
	// lines may point to the same marker when it spans across lines.
	// The spans will have null for their from/to properties when the
	// marker continues beyond the start/end of the line. Markers have
	// links back to the lines they currently touch.

	// Collapsed markers have unique ids, in order to be able to order
	// them, which is needed for uniquely determining an outer marker
	// when they overlap (they may nest, but not partially overlap).
	var nextMarkerId = 0;

	var TextMarker = function(doc, type) {
	  this.lines = [];
	  this.type = type;
	  this.doc = doc;
	  this.id = ++nextMarkerId;
	};

	// Clear the marker.
	TextMarker.prototype.clear = function () {
	    var this$1 = this;

	  if (this.explicitlyCleared) { return }
	  var cm = this.doc.cm, withOp = cm && !cm.curOp;
	  if (withOp) { startOperation(cm); }
	  if (hasHandler(this, "clear")) {
	    var found = this.find();
	    if (found) { signalLater(this, "clear", found.from, found.to); }
	  }
	  var min = null, max = null;
	  for (var i = 0; i < this.lines.length; ++i) {
	    var line = this$1.lines[i];
	    var span = getMarkedSpanFor(line.markedSpans, this$1);
	    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
	    else if (cm) {
	      if (span.to != null) { max = lineNo(line); }
	      if (span.from != null) { min = lineNo(line); }
	    }
	    line.markedSpans = removeMarkedSpan(line.markedSpans, span);
	    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
	      { updateLineHeight(line, textHeight(cm.display)); }
	  }
	  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
	    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
	    if (len > cm.display.maxLineLength) {
	      cm.display.maxLine = visual;
	      cm.display.maxLineLength = len;
	      cm.display.maxLineChanged = true;
	    }
	  } }

	  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
	  this.lines.length = 0;
	  this.explicitlyCleared = true;
	  if (this.atomic && this.doc.cantEdit) {
	    this.doc.cantEdit = false;
	    if (cm) { reCheckSelection(cm.doc); }
	  }
	  if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
	  if (withOp) { endOperation(cm); }
	  if (this.parent) { this.parent.clear(); }
	};

	// Find the position of the marker in the document. Returns a {from,
	// to} object by default. Side can be passed to get a specific side
	// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
	// Pos objects returned contain a line object, rather than a line
	// number (used to prevent looking up the same line twice).
	TextMarker.prototype.find = function (side, lineObj) {
	    var this$1 = this;

	  if (side == null && this.type == "bookmark") { side = 1; }
	  var from, to;
	  for (var i = 0; i < this.lines.length; ++i) {
	    var line = this$1.lines[i];
	    var span = getMarkedSpanFor(line.markedSpans, this$1);
	    if (span.from != null) {
	      from = Pos(lineObj ? line : lineNo(line), span.from);
	      if (side == -1) { return from }
	    }
	    if (span.to != null) {
	      to = Pos(lineObj ? line : lineNo(line), span.to);
	      if (side == 1) { return to }
	    }
	  }
	  return from && {from: from, to: to}
	};

	// Signals that the marker's widget changed, and surrounding layout
	// should be recomputed.
	TextMarker.prototype.changed = function () {
	    var this$1 = this;

	  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
	  if (!pos || !cm) { return }
	  runInOp(cm, function () {
	    var line = pos.line, lineN = lineNo(pos.line);
	    var view = findViewForLine(cm, lineN);
	    if (view) {
	      clearLineMeasurementCacheFor(view);
	      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
	    }
	    cm.curOp.updateMaxLine = true;
	    if (!lineIsHidden(widget.doc, line) && widget.height != null) {
	      var oldHeight = widget.height;
	      widget.height = null;
	      var dHeight = widgetHeight(widget) - oldHeight;
	      if (dHeight)
	        { updateLineHeight(line, line.height + dHeight); }
	    }
	    signalLater(cm, "markerChanged", cm, this$1);
	  });
	};

	TextMarker.prototype.attachLine = function (line) {
	  if (!this.lines.length && this.doc.cm) {
	    var op = this.doc.cm.curOp;
	    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
	      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
	  }
	  this.lines.push(line);
	};

	TextMarker.prototype.detachLine = function (line) {
	  this.lines.splice(indexOf(this.lines, line), 1);
	  if (!this.lines.length && this.doc.cm) {
	    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
	  }
	};
	eventMixin(TextMarker);

	// Create a marker, wire it up to the right lines, and
	function markText(doc, from, to, options, type) {
	  // Shared markers (across linked documents) are handled separately
	  // (markTextShared will call out to this again, once per
	  // document).
	  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
	  // Ensure we are in an operation.
	  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

	  var marker = new TextMarker(doc, type), diff = cmp(from, to);
	  if (options) { copyObj(options, marker, false); }
	  // Don't connect empty markers unless clearWhenEmpty is false
	  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
	    { return marker }
	  if (marker.replacedWith) {
	    // Showing up as a widget implies collapsed (widget replaces text)
	    marker.collapsed = true;
	    marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
	    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
	    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
	  }
	  if (marker.collapsed) {
	    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
	        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
	      { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
	    seeCollapsedSpans();
	  }

	  if (marker.addToHistory)
	    { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

	  var curLine = from.line, cm = doc.cm, updateMaxLine;
	  doc.iter(curLine, to.line + 1, function (line) {
	    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
	      { updateMaxLine = true; }
	    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
	    addMarkedSpan(line, new MarkedSpan(marker,
	                                       curLine == from.line ? from.ch : null,
	                                       curLine == to.line ? to.ch : null));
	    ++curLine;
	  });
	  // lineIsHidden depends on the presence of the spans, so needs a second pass
	  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
	    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
	  }); }

	  if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

	  if (marker.readOnly) {
	    seeReadOnlySpans();
	    if (doc.history.done.length || doc.history.undone.length)
	      { doc.clearHistory(); }
	  }
	  if (marker.collapsed) {
	    marker.id = ++nextMarkerId;
	    marker.atomic = true;
	  }
	  if (cm) {
	    // Sync editor state
	    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
	    if (marker.collapsed)
	      { regChange(cm, from.line, to.line + 1); }
	    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
	      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
	    if (marker.atomic) { reCheckSelection(cm.doc); }
	    signalLater(cm, "markerAdded", cm, marker);
	  }
	  return marker
	}

	// SHARED TEXTMARKERS

	// A shared marker spans multiple linked documents. It is
	// implemented as a meta-marker-object controlling multiple normal
	// markers.
	var SharedTextMarker = function(markers, primary) {
	  var this$1 = this;

	  this.markers = markers;
	  this.primary = primary;
	  for (var i = 0; i < markers.length; ++i)
	    { markers[i].parent = this$1; }
	};

	SharedTextMarker.prototype.clear = function () {
	    var this$1 = this;

	  if (this.explicitlyCleared) { return }
	  this.explicitlyCleared = true;
	  for (var i = 0; i < this.markers.length; ++i)
	    { this$1.markers[i].clear(); }
	  signalLater(this, "clear");
	};

	SharedTextMarker.prototype.find = function (side, lineObj) {
	  return this.primary.find(side, lineObj)
	};
	eventMixin(SharedTextMarker);

	function markTextShared(doc, from, to, options, type) {
	  options = copyObj(options);
	  options.shared = false;
	  var markers = [markText(doc, from, to, options, type)], primary = markers[0];
	  var widget = options.widgetNode;
	  linkedDocs(doc, function (doc) {
	    if (widget) { options.widgetNode = widget.cloneNode(true); }
	    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
	    for (var i = 0; i < doc.linked.length; ++i)
	      { if (doc.linked[i].isParent) { return } }
	    primary = lst(markers);
	  });
	  return new SharedTextMarker(markers, primary)
	}

	function findSharedMarkers(doc) {
	  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
	}

	function copySharedMarkers(doc, markers) {
	  for (var i = 0; i < markers.length; i++) {
	    var marker = markers[i], pos = marker.find();
	    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
	    if (cmp(mFrom, mTo)) {
	      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
	      marker.markers.push(subMark);
	      subMark.parent = marker;
	    }
	  }
	}

	function detachSharedMarkers(markers) {
	  var loop = function ( i ) {
	    var marker = markers[i], linked = [marker.primary.doc];
	    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
	    for (var j = 0; j < marker.markers.length; j++) {
	      var subMarker = marker.markers[j];
	      if (indexOf(linked, subMarker.doc) == -1) {
	        subMarker.parent = null;
	        marker.markers.splice(j--, 1);
	      }
	    }
	  };

	  for (var i = 0; i < markers.length; i++) loop( i );
	}

	var nextDocId = 0;
	var Doc = function(text, mode, firstLine, lineSep, direction) {
	  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
	  if (firstLine == null) { firstLine = 0; }

	  BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
	  this.first = firstLine;
	  this.scrollTop = this.scrollLeft = 0;
	  this.cantEdit = false;
	  this.cleanGeneration = 1;
	  this.modeFrontier = this.highlightFrontier = firstLine;
	  var start = Pos(firstLine, 0);
	  this.sel = simpleSelection(start);
	  this.history = new History(null);
	  this.id = ++nextDocId;
	  this.modeOption = mode;
	  this.lineSep = lineSep;
	  this.direction = (direction == "rtl") ? "rtl" : "ltr";
	  this.extend = false;

	  if (typeof text == "string") { text = this.splitLines(text); }
	  updateDoc(this, {from: start, to: start, text: text});
	  setSelection(this, simpleSelection(start), sel_dontScroll);
	};

	Doc.prototype = createObj(BranchChunk.prototype, {
	  constructor: Doc,
	  // Iterate over the document. Supports two forms -- with only one
	  // argument, it calls that for each line in the document. With
	  // three, it iterates over the range given by the first two (with
	  // the second being non-inclusive).
	  iter: function(from, to, op) {
	    if (op) { this.iterN(from - this.first, to - from, op); }
	    else { this.iterN(this.first, this.first + this.size, from); }
	  },

	  // Non-public interface for adding and removing lines.
	  insert: function(at, lines) {
	    var height = 0;
	    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
	    this.insertInner(at - this.first, lines, height);
	  },
	  remove: function(at, n) { this.removeInner(at - this.first, n); },

	  // From here, the methods are part of the public interface. Most
	  // are also available from CodeMirror (editor) instances.

	  getValue: function(lineSep) {
	    var lines = getLines(this, this.first, this.first + this.size);
	    if (lineSep === false) { return lines }
	    return lines.join(lineSep || this.lineSeparator())
	  },
	  setValue: docMethodOp(function(code) {
	    var top = Pos(this.first, 0), last = this.first + this.size - 1;
	    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
	                      text: this.splitLines(code), origin: "setValue", full: true}, true);
	    if (this.cm) { scrollToCoords(this.cm, 0, 0); }
	    setSelection(this, simpleSelection(top), sel_dontScroll);
	  }),
	  replaceRange: function(code, from, to, origin) {
	    from = clipPos(this, from);
	    to = to ? clipPos(this, to) : from;
	    replaceRange(this, code, from, to, origin);
	  },
	  getRange: function(from, to, lineSep) {
	    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
	    if (lineSep === false) { return lines }
	    return lines.join(lineSep || this.lineSeparator())
	  },

	  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

	  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
	  getLineNumber: function(line) {return lineNo(line)},

	  getLineHandleVisualStart: function(line) {
	    if (typeof line == "number") { line = getLine(this, line); }
	    return visualLine(line)
	  },

	  lineCount: function() {return this.size},
	  firstLine: function() {return this.first},
	  lastLine: function() {return this.first + this.size - 1},

	  clipPos: function(pos) {return clipPos(this, pos)},

	  getCursor: function(start) {
	    var range$$1 = this.sel.primary(), pos;
	    if (start == null || start == "head") { pos = range$$1.head; }
	    else if (start == "anchor") { pos = range$$1.anchor; }
	    else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
	    else { pos = range$$1.from(); }
	    return pos
	  },
	  listSelections: function() { return this.sel.ranges },
	  somethingSelected: function() {return this.sel.somethingSelected()},

	  setCursor: docMethodOp(function(line, ch, options) {
	    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
	  }),
	  setSelection: docMethodOp(function(anchor, head, options) {
	    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
	  }),
	  extendSelection: docMethodOp(function(head, other, options) {
	    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
	  }),
	  extendSelections: docMethodOp(function(heads, options) {
	    extendSelections(this, clipPosArray(this, heads), options);
	  }),
	  extendSelectionsBy: docMethodOp(function(f, options) {
	    var heads = map(this.sel.ranges, f);
	    extendSelections(this, clipPosArray(this, heads), options);
	  }),
	  setSelections: docMethodOp(function(ranges, primary, options) {
	    var this$1 = this;

	    if (!ranges.length) { return }
	    var out = [];
	    for (var i = 0; i < ranges.length; i++)
	      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
	                         clipPos(this$1, ranges[i].head)); }
	    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
	    setSelection(this, normalizeSelection(out, primary), options);
	  }),
	  addSelection: docMethodOp(function(anchor, head, options) {
	    var ranges = this.sel.ranges.slice(0);
	    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
	    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
	  }),

	  getSelection: function(lineSep) {
	    var this$1 = this;

	    var ranges = this.sel.ranges, lines;
	    for (var i = 0; i < ranges.length; i++) {
	      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
	      lines = lines ? lines.concat(sel) : sel;
	    }
	    if (lineSep === false) { return lines }
	    else { return lines.join(lineSep || this.lineSeparator()) }
	  },
	  getSelections: function(lineSep) {
	    var this$1 = this;

	    var parts = [], ranges = this.sel.ranges;
	    for (var i = 0; i < ranges.length; i++) {
	      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
	      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
	      parts[i] = sel;
	    }
	    return parts
	  },
	  replaceSelection: function(code, collapse, origin) {
	    var dup = [];
	    for (var i = 0; i < this.sel.ranges.length; i++)
	      { dup[i] = code; }
	    this.replaceSelections(dup, collapse, origin || "+input");
	  },
	  replaceSelections: docMethodOp(function(code, collapse, origin) {
	    var this$1 = this;

	    var changes = [], sel = this.sel;
	    for (var i = 0; i < sel.ranges.length; i++) {
	      var range$$1 = sel.ranges[i];
	      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
	    }
	    var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
	    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
	      { makeChange(this$1, changes[i$1]); }
	    if (newSel) { setSelectionReplaceHistory(this, newSel); }
	    else if (this.cm) { ensureCursorVisible(this.cm); }
	  }),
	  undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
	  redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
	  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
	  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

	  setExtending: function(val) {this.extend = val;},
	  getExtending: function() {return this.extend},

	  historySize: function() {
	    var hist = this.history, done = 0, undone = 0;
	    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
	    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
	    return {undo: done, redo: undone}
	  },
	  clearHistory: function() {this.history = new History(this.history.maxGeneration);},

	  markClean: function() {
	    this.cleanGeneration = this.changeGeneration(true);
	  },
	  changeGeneration: function(forceSplit) {
	    if (forceSplit)
	      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
	    return this.history.generation
	  },
	  isClean: function (gen) {
	    return this.history.generation == (gen || this.cleanGeneration)
	  },

	  getHistory: function() {
	    return {done: copyHistoryArray(this.history.done),
	            undone: copyHistoryArray(this.history.undone)}
	  },
	  setHistory: function(histData) {
	    var hist = this.history = new History(this.history.maxGeneration);
	    hist.done = copyHistoryArray(histData.done.slice(0), null, true);
	    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
	  },

	  setGutterMarker: docMethodOp(function(line, gutterID, value) {
	    return changeLine(this, line, "gutter", function (line) {
	      var markers = line.gutterMarkers || (line.gutterMarkers = {});
	      markers[gutterID] = value;
	      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
	      return true
	    })
	  }),

	  clearGutter: docMethodOp(function(gutterID) {
	    var this$1 = this;

	    this.iter(function (line) {
	      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
	        changeLine(this$1, line, "gutter", function () {
	          line.gutterMarkers[gutterID] = null;
	          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
	          return true
	        });
	      }
	    });
	  }),

	  lineInfo: function(line) {
	    var n;
	    if (typeof line == "number") {
	      if (!isLine(this, line)) { return null }
	      n = line;
	      line = getLine(this, line);
	      if (!line) { return null }
	    } else {
	      n = lineNo(line);
	      if (n == null) { return null }
	    }
	    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
	            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
	            widgets: line.widgets}
	  },

	  addLineClass: docMethodOp(function(handle, where, cls) {
	    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	      var prop = where == "text" ? "textClass"
	               : where == "background" ? "bgClass"
	               : where == "gutter" ? "gutterClass" : "wrapClass";
	      if (!line[prop]) { line[prop] = cls; }
	      else if (classTest(cls).test(line[prop])) { return false }
	      else { line[prop] += " " + cls; }
	      return true
	    })
	  }),
	  removeLineClass: docMethodOp(function(handle, where, cls) {
	    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	      var prop = where == "text" ? "textClass"
	               : where == "background" ? "bgClass"
	               : where == "gutter" ? "gutterClass" : "wrapClass";
	      var cur = line[prop];
	      if (!cur) { return false }
	      else if (cls == null) { line[prop] = null; }
	      else {
	        var found = cur.match(classTest(cls));
	        if (!found) { return false }
	        var end = found.index + found[0].length;
	        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
	      }
	      return true
	    })
	  }),

	  addLineWidget: docMethodOp(function(handle, node, options) {
	    return addLineWidget(this, handle, node, options)
	  }),
	  removeLineWidget: function(widget) { widget.clear(); },

	  markText: function(from, to, options) {
	    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
	  },
	  setBookmark: function(pos, options) {
	    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
	                    insertLeft: options && options.insertLeft,
	                    clearWhenEmpty: false, shared: options && options.shared,
	                    handleMouseEvents: options && options.handleMouseEvents};
	    pos = clipPos(this, pos);
	    return markText(this, pos, pos, realOpts, "bookmark")
	  },
	  findMarksAt: function(pos) {
	    pos = clipPos(this, pos);
	    var markers = [], spans = getLine(this, pos.line).markedSpans;
	    if (spans) { for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if ((span.from == null || span.from <= pos.ch) &&
	          (span.to == null || span.to >= pos.ch))
	        { markers.push(span.marker.parent || span.marker); }
	    } }
	    return markers
	  },
	  findMarks: function(from, to, filter) {
	    from = clipPos(this, from); to = clipPos(this, to);
	    var found = [], lineNo$$1 = from.line;
	    this.iter(from.line, to.line + 1, function (line) {
	      var spans = line.markedSpans;
	      if (spans) { for (var i = 0; i < spans.length; i++) {
	        var span = spans[i];
	        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
	              span.from == null && lineNo$$1 != from.line ||
	              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
	            (!filter || filter(span.marker)))
	          { found.push(span.marker.parent || span.marker); }
	      } }
	      ++lineNo$$1;
	    });
	    return found
	  },
	  getAllMarks: function() {
	    var markers = [];
	    this.iter(function (line) {
	      var sps = line.markedSpans;
	      if (sps) { for (var i = 0; i < sps.length; ++i)
	        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
	    });
	    return markers
	  },

	  posFromIndex: function(off) {
	    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
	    this.iter(function (line) {
	      var sz = line.text.length + sepSize;
	      if (sz > off) { ch = off; return true }
	      off -= sz;
	      ++lineNo$$1;
	    });
	    return clipPos(this, Pos(lineNo$$1, ch))
	  },
	  indexFromPos: function (coords) {
	    coords = clipPos(this, coords);
	    var index = coords.ch;
	    if (coords.line < this.first || coords.ch < 0) { return 0 }
	    var sepSize = this.lineSeparator().length;
	    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
	      index += line.text.length + sepSize;
	    });
	    return index
	  },

	  copy: function(copyHistory) {
	    var doc = new Doc(getLines(this, this.first, this.first + this.size),
	                      this.modeOption, this.first, this.lineSep, this.direction);
	    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
	    doc.sel = this.sel;
	    doc.extend = false;
	    if (copyHistory) {
	      doc.history.undoDepth = this.history.undoDepth;
	      doc.setHistory(this.getHistory());
	    }
	    return doc
	  },

	  linkedDoc: function(options) {
	    if (!options) { options = {}; }
	    var from = this.first, to = this.first + this.size;
	    if (options.from != null && options.from > from) { from = options.from; }
	    if (options.to != null && options.to < to) { to = options.to; }
	    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
	    if (options.sharedHist) { copy.history = this.history
	    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
	    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
	    copySharedMarkers(copy, findSharedMarkers(this));
	    return copy
	  },
	  unlinkDoc: function(other) {
	    var this$1 = this;

	    if (other instanceof CodeMirror$1) { other = other.doc; }
	    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
	      var link = this$1.linked[i];
	      if (link.doc != other) { continue }
	      this$1.linked.splice(i, 1);
	      other.unlinkDoc(this$1);
	      detachSharedMarkers(findSharedMarkers(this$1));
	      break
	    } }
	    // If the histories were shared, split them again
	    if (other.history == this.history) {
	      var splitIds = [other.id];
	      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
	      other.history = new History(null);
	      other.history.done = copyHistoryArray(this.history.done, splitIds);
	      other.history.undone = copyHistoryArray(this.history.undone, splitIds);
	    }
	  },
	  iterLinkedDocs: function(f) {linkedDocs(this, f);},

	  getMode: function() {return this.mode},
	  getEditor: function() {return this.cm},

	  splitLines: function(str) {
	    if (this.lineSep) { return str.split(this.lineSep) }
	    return splitLinesAuto(str)
	  },
	  lineSeparator: function() { return this.lineSep || "\n" },

	  setDirection: docMethodOp(function (dir) {
	    if (dir != "rtl") { dir = "ltr"; }
	    if (dir == this.direction) { return }
	    this.direction = dir;
	    this.iter(function (line) { return line.order = null; });
	    if (this.cm) { directionChanged(this.cm); }
	  })
	});

	// Public alias.
	Doc.prototype.eachLine = Doc.prototype.iter;

	// Kludge to work around strange IE behavior where it'll sometimes
	// re-fire a series of drag-related events right after the drop (#1551)
	var lastDrop = 0;

	function onDrop(e) {
	  var cm = this;
	  clearDragCursor(cm);
	  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
	    { return }
	  e_preventDefault(e);
	  if (ie) { lastDrop = +new Date; }
	  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
	  if (!pos || cm.isReadOnly()) { return }
	  // Might be a file drop, in which case we simply extract the text
	  // and insert it.
	  if (files && files.length && window.FileReader && window.File) {
	    var n = files.length, text = Array(n), read = 0;
	    var loadFile = function (file, i) {
	      if (cm.options.allowDropFileTypes &&
	          indexOf(cm.options.allowDropFileTypes, file.type) == -1)
	        { return }

	      var reader = new FileReader;
	      reader.onload = operation(cm, function () {
	        var content = reader.result;
	        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
	        text[i] = content;
	        if (++read == n) {
	          pos = clipPos(cm.doc, pos);
	          var change = {from: pos, to: pos,
	                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
	                        origin: "paste"};
	          makeChange(cm.doc, change);
	          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
	        }
	      });
	      reader.readAsText(file);
	    };
	    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
	  } else { // Normal drop
	    // Don't do a replace if the drop happened inside of the selected text.
	    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
	      cm.state.draggingText(e);
	      // Ensure the editor is re-focused
	      setTimeout(function () { return cm.display.input.focus(); }, 20);
	      return
	    }
	    try {
	      var text$1 = e.dataTransfer.getData("Text");
	      if (text$1) {
	        var selected;
	        if (cm.state.draggingText && !cm.state.draggingText.copy)
	          { selected = cm.listSelections(); }
	        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
	        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
	          { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
	        cm.replaceSelection(text$1, "around", "paste");
	        cm.display.input.focus();
	      }
	    }
	    catch(e){}
	  }
	}

	function onDragStart(cm, e) {
	  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
	  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

	  e.dataTransfer.setData("Text", cm.getSelection());
	  e.dataTransfer.effectAllowed = "copyMove";

	  // Use dummy image instead of default browsers image.
	  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
	  if (e.dataTransfer.setDragImage && !safari) {
	    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
	    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
	    if (presto) {
	      img.width = img.height = 1;
	      cm.display.wrapper.appendChild(img);
	      // Force a relayout, or Opera won't use our image for some obscure reason
	      img._top = img.offsetTop;
	    }
	    e.dataTransfer.setDragImage(img, 0, 0);
	    if (presto) { img.parentNode.removeChild(img); }
	  }
	}

	function onDragOver(cm, e) {
	  var pos = posFromMouse(cm, e);
	  if (!pos) { return }
	  var frag = document.createDocumentFragment();
	  drawSelectionCursor(cm, pos, frag);
	  if (!cm.display.dragCursor) {
	    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
	    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
	  }
	  removeChildrenAndAdd(cm.display.dragCursor, frag);
	}

	function clearDragCursor(cm) {
	  if (cm.display.dragCursor) {
	    cm.display.lineSpace.removeChild(cm.display.dragCursor);
	    cm.display.dragCursor = null;
	  }
	}

	// These must be handled carefully, because naively registering a
	// handler for each editor will cause the editors to never be
	// garbage collected.

	function forEachCodeMirror(f) {
	  if (!document.getElementsByClassName) { return }
	  var byClass = document.getElementsByClassName("CodeMirror");
	  for (var i = 0; i < byClass.length; i++) {
	    var cm = byClass[i].CodeMirror;
	    if (cm) { f(cm); }
	  }
	}

	var globalsRegistered = false;
	function ensureGlobalHandlers() {
	  if (globalsRegistered) { return }
	  registerGlobalHandlers();
	  globalsRegistered = true;
	}
	function registerGlobalHandlers() {
	  // When the window resizes, we need to refresh active editors.
	  var resizeTimer;
	  on(window, "resize", function () {
	    if (resizeTimer == null) { resizeTimer = setTimeout(function () {
	      resizeTimer = null;
	      forEachCodeMirror(onResize);
	    }, 100); }
	  });
	  // When the window loses focus, we want to show the editor as blurred
	  on(window, "blur", function () { return forEachCodeMirror(onBlur); });
	}
	// Called when the window resizes
	function onResize(cm) {
	  var d = cm.display;
	  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
	    { return }
	  // Might be a text scaling operation, clear size caches.
	  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	  d.scrollbarsClipped = false;
	  cm.setSize();
	}

	var keyNames = {
	  3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
	  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
	  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
	  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
	  106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete", 145: "ScrollLock",
	  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
	  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
	  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
	};

	// Number keys
	for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
	// Alphabetic keys
	for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
	// Function keys
	for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

	var keyMap = {};

	keyMap.basic = {
	  "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
	  "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
	  "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
	  "Tab": "defaultTab", "Shift-Tab": "indentAuto",
	  "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
	  "Esc": "singleSelection"
	};
	// Note that the save and find-related commands aren't defined by
	// default. User code or addons can define them. Unknown commands
	// are simply ignored.
	keyMap.pcDefault = {
	  "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
	  "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
	  "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
	  "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
	  "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
	  "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
	  "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
	  fallthrough: "basic"
	};
	// Very basic readline/emacs-style bindings, which are standard on Mac.
	keyMap.emacsy = {
	  "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
	  "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
	  "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
	  "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
	  "Ctrl-O": "openLine"
	};
	keyMap.macDefault = {
	  "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
	  "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
	  "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
	  "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
	  "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
	  "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
	  "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
	  fallthrough: ["basic", "emacsy"]
	};
	keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

	// KEYMAP DISPATCH

	function normalizeKeyName(name) {
	  var parts = name.split(/-(?!$)/);
	  name = parts[parts.length - 1];
	  var alt, ctrl, shift, cmd;
	  for (var i = 0; i < parts.length - 1; i++) {
	    var mod = parts[i];
	    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
	    else if (/^a(lt)?$/i.test(mod)) { alt = true; }
	    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
	    else if (/^s(hift)?$/i.test(mod)) { shift = true; }
	    else { throw new Error("Unrecognized modifier name: " + mod) }
	  }
	  if (alt) { name = "Alt-" + name; }
	  if (ctrl) { name = "Ctrl-" + name; }
	  if (cmd) { name = "Cmd-" + name; }
	  if (shift) { name = "Shift-" + name; }
	  return name
	}

	// This is a kludge to keep keymaps mostly working as raw objects
	// (backwards compatibility) while at the same time support features
	// like normalization and multi-stroke key bindings. It compiles a
	// new normalized keymap, and then updates the old object to reflect
	// this.
	function normalizeKeyMap(keymap) {
	  var copy = {};
	  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
	    var value = keymap[keyname];
	    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
	    if (value == "...") { delete keymap[keyname]; continue }

	    var keys = map(keyname.split(" "), normalizeKeyName);
	    for (var i = 0; i < keys.length; i++) {
	      var val = (void 0), name = (void 0);
	      if (i == keys.length - 1) {
	        name = keys.join(" ");
	        val = value;
	      } else {
	        name = keys.slice(0, i + 1).join(" ");
	        val = "...";
	      }
	      var prev = copy[name];
	      if (!prev) { copy[name] = val; }
	      else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
	    }
	    delete keymap[keyname];
	  } }
	  for (var prop in copy) { keymap[prop] = copy[prop]; }
	  return keymap
	}

	function lookupKey(key, map$$1, handle, context) {
	  map$$1 = getKeyMap(map$$1);
	  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
	  if (found === false) { return "nothing" }
	  if (found === "...") { return "multi" }
	  if (found != null && handle(found)) { return "handled" }

	  if (map$$1.fallthrough) {
	    if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
	      { return lookupKey(key, map$$1.fallthrough, handle, context) }
	    for (var i = 0; i < map$$1.fallthrough.length; i++) {
	      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
	      if (result) { return result }
	    }
	  }
	}

	// Modifier key presses don't count as 'real' key presses for the
	// purpose of keymap fallthrough.
	function isModifierKey(value) {
	  var name = typeof value == "string" ? value : keyNames[value.keyCode];
	  return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
	}

	function addModifierNames(name, event, noShift) {
	  var base = name;
	  if (event.altKey && base != "Alt") { name = "Alt-" + name; }
	  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
	  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
	  if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
	  return name
	}

	// Look up the name of a key as indicated by an event object.
	function keyName(event, noShift) {
	  if (presto && event.keyCode == 34 && event["char"]) { return false }
	  var name = keyNames[event.keyCode];
	  if (name == null || event.altGraphKey) { return false }
	  // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
	  // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
	  if (event.keyCode == 3 && event.code) { name = event.code; }
	  return addModifierNames(name, event, noShift)
	}

	function getKeyMap(val) {
	  return typeof val == "string" ? keyMap[val] : val
	}

	// Helper for deleting text near the selection(s), used to implement
	// backspace, delete, and similar functionality.
	function deleteNearSelection(cm, compute) {
	  var ranges = cm.doc.sel.ranges, kill = [];
	  // Build up a set of ranges to kill first, merging overlapping
	  // ranges.
	  for (var i = 0; i < ranges.length; i++) {
	    var toKill = compute(ranges[i]);
	    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
	      var replaced = kill.pop();
	      if (cmp(replaced.from, toKill.from) < 0) {
	        toKill.from = replaced.from;
	        break
	      }
	    }
	    kill.push(toKill);
	  }
	  // Next, remove those actual ranges.
	  runInOp(cm, function () {
	    for (var i = kill.length - 1; i >= 0; i--)
	      { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
	    ensureCursorVisible(cm);
	  });
	}

	function moveCharLogically(line, ch, dir) {
	  var target = skipExtendingChars(line.text, ch + dir, dir);
	  return target < 0 || target > line.text.length ? null : target
	}

	function moveLogically(line, start, dir) {
	  var ch = moveCharLogically(line, start.ch, dir);
	  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
	}

	function endOfLine(visually, cm, lineObj, lineNo, dir) {
	  if (visually) {
	    var order = getOrder(lineObj, cm.doc.direction);
	    if (order) {
	      var part = dir < 0 ? lst(order) : order[0];
	      var moveInStorageOrder = (dir < 0) == (part.level == 1);
	      var sticky = moveInStorageOrder ? "after" : "before";
	      var ch;
	      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
	      // it could be that the last bidi part is not on the last visual line,
	      // since visual lines contain content order-consecutive chunks.
	      // Thus, in rtl, we are looking for the first (content-order) character
	      // in the rtl chunk that is on the last line (that is, the same line
	      // as the last (content-order) character).
	      if (part.level > 0 || cm.doc.direction == "rtl") {
	        var prep = prepareMeasureForLine(cm, lineObj);
	        ch = dir < 0 ? lineObj.text.length - 1 : 0;
	        var targetTop = measureCharPrepared(cm, prep, ch).top;
	        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
	        if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
	      } else { ch = dir < 0 ? part.to : part.from; }
	      return new Pos(lineNo, ch, sticky)
	    }
	  }
	  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
	}

	function moveVisually(cm, line, start, dir) {
	  var bidi = getOrder(line, cm.doc.direction);
	  if (!bidi) { return moveLogically(line, start, dir) }
	  if (start.ch >= line.text.length) {
	    start.ch = line.text.length;
	    start.sticky = "before";
	  } else if (start.ch <= 0) {
	    start.ch = 0;
	    start.sticky = "after";
	  }
	  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
	  if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
	    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
	    // nothing interesting happens.
	    return moveLogically(line, start, dir)
	  }

	  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
	  var prep;
	  var getWrappedLineExtent = function (ch) {
	    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
	    prep = prep || prepareMeasureForLine(cm, line);
	    return wrappedLineExtentChar(cm, line, prep, ch)
	  };
	  var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

	  if (cm.doc.direction == "rtl" || part.level == 1) {
	    var moveInStorageOrder = (part.level == 1) == (dir < 0);
	    var ch = mv(start, moveInStorageOrder ? 1 : -1);
	    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
	      // Case 2: We move within an rtl part or in an rtl editor on the same visual line
	      var sticky = moveInStorageOrder ? "before" : "after";
	      return new Pos(start.line, ch, sticky)
	    }
	  }

	  // Case 3: Could not move within this bidi part in this visual line, so leave
	  // the current bidi part

	  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
	    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
	      ? new Pos(start.line, mv(ch, 1), "before")
	      : new Pos(start.line, ch, "after"); };

	    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
	      var part = bidi[partPos];
	      var moveInStorageOrder = (dir > 0) == (part.level != 1);
	      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
	      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
	      ch = moveInStorageOrder ? part.from : mv(part.to, -1);
	      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
	    }
	  };

	  // Case 3a: Look for other bidi parts on the same visual line
	  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
	  if (res) { return res }

	  // Case 3b: Look for other bidi parts on the next visual line
	  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
	  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
	    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
	    if (res) { return res }
	  }

	  // Case 4: Nowhere to move
	  return null
	}

	// Commands are parameter-less actions that can be performed on an
	// editor, mostly used for keybindings.
	var commands = {
	  selectAll: selectAll,
	  singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
	  killLine: function (cm) { return deleteNearSelection(cm, function (range) {
	    if (range.empty()) {
	      var len = getLine(cm.doc, range.head.line).text.length;
	      if (range.head.ch == len && range.head.line < cm.lastLine())
	        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
	      else
	        { return {from: range.head, to: Pos(range.head.line, len)} }
	    } else {
	      return {from: range.from(), to: range.to()}
	    }
	  }); },
	  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	    from: Pos(range.from().line, 0),
	    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
	  }); }); },
	  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	    from: Pos(range.from().line, 0), to: range.from()
	  }); }); },
	  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5;
	    var leftPos = cm.coordsChar({left: 0, top: top}, "div");
	    return {from: leftPos, to: range.from()}
	  }); },
	  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5;
	    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
	    return {from: range.from(), to: rightPos }
	  }); },
	  undo: function (cm) { return cm.undo(); },
	  redo: function (cm) { return cm.redo(); },
	  undoSelection: function (cm) { return cm.undoSelection(); },
	  redoSelection: function (cm) { return cm.redoSelection(); },
	  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
	  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
	  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
	    {origin: "+move", bias: 1}
	  ); },
	  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
	    {origin: "+move", bias: 1}
	  ); },
	  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
	    {origin: "+move", bias: -1}
	  ); },
	  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.cursorCoords(range.head, "div").top + 5;
	    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
	  }, sel_move); },
	  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.cursorCoords(range.head, "div").top + 5;
	    return cm.coordsChar({left: 0, top: top}, "div")
	  }, sel_move); },
	  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.cursorCoords(range.head, "div").top + 5;
	    var pos = cm.coordsChar({left: 0, top: top}, "div");
	    if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
	    return pos
	  }, sel_move); },
	  goLineUp: function (cm) { return cm.moveV(-1, "line"); },
	  goLineDown: function (cm) { return cm.moveV(1, "line"); },
	  goPageUp: function (cm) { return cm.moveV(-1, "page"); },
	  goPageDown: function (cm) { return cm.moveV(1, "page"); },
	  goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
	  goCharRight: function (cm) { return cm.moveH(1, "char"); },
	  goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
	  goColumnRight: function (cm) { return cm.moveH(1, "column"); },
	  goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
	  goGroupRight: function (cm) { return cm.moveH(1, "group"); },
	  goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
	  goWordRight: function (cm) { return cm.moveH(1, "word"); },
	  delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
	  delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
	  delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
	  delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
	  delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
	  delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
	  indentAuto: function (cm) { return cm.indentSelection("smart"); },
	  indentMore: function (cm) { return cm.indentSelection("add"); },
	  indentLess: function (cm) { return cm.indentSelection("subtract"); },
	  insertTab: function (cm) { return cm.replaceSelection("\t"); },
	  insertSoftTab: function (cm) {
	    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
	    for (var i = 0; i < ranges.length; i++) {
	      var pos = ranges[i].from();
	      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
	      spaces.push(spaceStr(tabSize - col % tabSize));
	    }
	    cm.replaceSelections(spaces);
	  },
	  defaultTab: function (cm) {
	    if (cm.somethingSelected()) { cm.indentSelection("add"); }
	    else { cm.execCommand("insertTab"); }
	  },
	  // Swap the two chars left and right of each selection's head.
	  // Move cursor behind the two swapped characters afterwards.
	  //
	  // Doesn't consider line feeds a character.
	  // Doesn't scan more than one line above to find a character.
	  // Doesn't do anything on an empty line.
	  // Doesn't do anything with non-empty selections.
	  transposeChars: function (cm) { return runInOp(cm, function () {
	    var ranges = cm.listSelections(), newSel = [];
	    for (var i = 0; i < ranges.length; i++) {
	      if (!ranges[i].empty()) { continue }
	      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
	      if (line) {
	        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
	        if (cur.ch > 0) {
	          cur = new Pos(cur.line, cur.ch + 1);
	          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
	                          Pos(cur.line, cur.ch - 2), cur, "+transpose");
	        } else if (cur.line > cm.doc.first) {
	          var prev = getLine(cm.doc, cur.line - 1).text;
	          if (prev) {
	            cur = new Pos(cur.line, 1);
	            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
	                            prev.charAt(prev.length - 1),
	                            Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
	          }
	        }
	      }
	      newSel.push(new Range(cur, cur));
	    }
	    cm.setSelections(newSel);
	  }); },
	  newlineAndIndent: function (cm) { return runInOp(cm, function () {
	    var sels = cm.listSelections();
	    for (var i = sels.length - 1; i >= 0; i--)
	      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
	    sels = cm.listSelections();
	    for (var i$1 = 0; i$1 < sels.length; i$1++)
	      { cm.indentLine(sels[i$1].from().line, null, true); }
	    ensureCursorVisible(cm);
	  }); },
	  openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
	  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
	};


	function lineStart(cm, lineN) {
	  var line = getLine(cm.doc, lineN);
	  var visual = visualLine(line);
	  if (visual != line) { lineN = lineNo(visual); }
	  return endOfLine(true, cm, visual, lineN, 1)
	}
	function lineEnd(cm, lineN) {
	  var line = getLine(cm.doc, lineN);
	  var visual = visualLineEnd(line);
	  if (visual != line) { lineN = lineNo(visual); }
	  return endOfLine(true, cm, line, lineN, -1)
	}
	function lineStartSmart(cm, pos) {
	  var start = lineStart(cm, pos.line);
	  var line = getLine(cm.doc, start.line);
	  var order = getOrder(line, cm.doc.direction);
	  if (!order || order[0].level == 0) {
	    var firstNonWS = Math.max(0, line.text.search(/\S/));
	    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
	    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
	  }
	  return start
	}

	// Run a handler that was bound to a key.
	function doHandleBinding(cm, bound, dropShift) {
	  if (typeof bound == "string") {
	    bound = commands[bound];
	    if (!bound) { return false }
	  }
	  // Ensure previous input has been read, so that the handler sees a
	  // consistent view of the document
	  cm.display.input.ensurePolled();
	  var prevShift = cm.display.shift, done = false;
	  try {
	    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
	    if (dropShift) { cm.display.shift = false; }
	    done = bound(cm) != Pass;
	  } finally {
	    cm.display.shift = prevShift;
	    cm.state.suppressEdits = false;
	  }
	  return done
	}

	function lookupKeyForEditor(cm, name, handle) {
	  for (var i = 0; i < cm.state.keyMaps.length; i++) {
	    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
	    if (result) { return result }
	  }
	  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
	    || lookupKey(name, cm.options.keyMap, handle, cm)
	}

	// Note that, despite the name, this function is also used to check
	// for bound mouse clicks.

	var stopSeq = new Delayed;

	function dispatchKey(cm, name, e, handle) {
	  var seq = cm.state.keySeq;
	  if (seq) {
	    if (isModifierKey(name)) { return "handled" }
	    if (/\'$/.test(name))
	      { cm.state.keySeq = null; }
	    else
	      { stopSeq.set(50, function () {
	        if (cm.state.keySeq == seq) {
	          cm.state.keySeq = null;
	          cm.display.input.reset();
	        }
	      }); }
	    if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
	  }
	  return dispatchKeyInner(cm, name, e, handle)
	}

	function dispatchKeyInner(cm, name, e, handle) {
	  var result = lookupKeyForEditor(cm, name, handle);

	  if (result == "multi")
	    { cm.state.keySeq = name; }
	  if (result == "handled")
	    { signalLater(cm, "keyHandled", cm, name, e); }

	  if (result == "handled" || result == "multi") {
	    e_preventDefault(e);
	    restartBlink(cm);
	  }

	  return !!result
	}

	// Handle a key from the keydown event.
	function handleKeyBinding(cm, e) {
	  var name = keyName(e, true);
	  if (!name) { return false }

	  if (e.shiftKey && !cm.state.keySeq) {
	    // First try to resolve full name (including 'Shift-'). Failing
	    // that, see if there is a cursor-motion command (starting with
	    // 'go') bound to the keyname without 'Shift-'.
	    return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
	        || dispatchKey(cm, name, e, function (b) {
	             if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
	               { return doHandleBinding(cm, b) }
	           })
	  } else {
	    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
	  }
	}

	// Handle a key from the keypress event
	function handleCharBinding(cm, e, ch) {
	  return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
	}

	var lastStoppedKey = null;
	function onKeyDown(e) {
	  var cm = this;
	  cm.curOp.focus = activeElt();
	  if (signalDOMEvent(cm, e)) { return }
	  // IE does strange things with escape.
	  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
	  var code = e.keyCode;
	  cm.display.shift = code == 16 || e.shiftKey;
	  var handled = handleKeyBinding(cm, e);
	  if (presto) {
	    lastStoppedKey = handled ? code : null;
	    // Opera has no cut event... we try to at least catch the key combo
	    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
	      { cm.replaceSelection("", null, "cut"); }
	  }

	  // Turn mouse into crosshair when Alt is held on Mac.
	  if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
	    { showCrossHair(cm); }
	}

	function showCrossHair(cm) {
	  var lineDiv = cm.display.lineDiv;
	  addClass(lineDiv, "CodeMirror-crosshair");

	  function up(e) {
	    if (e.keyCode == 18 || !e.altKey) {
	      rmClass(lineDiv, "CodeMirror-crosshair");
	      off(document, "keyup", up);
	      off(document, "mouseover", up);
	    }
	  }
	  on(document, "keyup", up);
	  on(document, "mouseover", up);
	}

	function onKeyUp(e) {
	  if (e.keyCode == 16) { this.doc.sel.shift = false; }
	  signalDOMEvent(this, e);
	}

	function onKeyPress(e) {
	  var cm = this;
	  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
	  var keyCode = e.keyCode, charCode = e.charCode;
	  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
	  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
	  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
	  // Some browsers fire keypress events for backspace
	  if (ch == "\x08") { return }
	  if (handleCharBinding(cm, e, ch)) { return }
	  cm.display.input.onKeyPress(e);
	}

	var DOUBLECLICK_DELAY = 400;

	var PastClick = function(time, pos, button) {
	  this.time = time;
	  this.pos = pos;
	  this.button = button;
	};

	PastClick.prototype.compare = function (time, pos, button) {
	  return this.time + DOUBLECLICK_DELAY > time &&
	    cmp(pos, this.pos) == 0 && button == this.button
	};

	var lastClick;
	var lastDoubleClick;
	function clickRepeat(pos, button) {
	  var now = +new Date;
	  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
	    lastClick = lastDoubleClick = null;
	    return "triple"
	  } else if (lastClick && lastClick.compare(now, pos, button)) {
	    lastDoubleClick = new PastClick(now, pos, button);
	    lastClick = null;
	    return "double"
	  } else {
	    lastClick = new PastClick(now, pos, button);
	    lastDoubleClick = null;
	    return "single"
	  }
	}

	// A mouse down can be a single click, double click, triple click,
	// start of selection drag, start of text drag, new cursor
	// (ctrl-click), rectangle drag (alt-drag), or xwin
	// middle-click-paste. Or it might be a click on something we should
	// not interfere with, such as a scrollbar or widget.
	function onMouseDown(e) {
	  var cm = this, display = cm.display;
	  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
	  display.input.ensurePolled();
	  display.shift = e.shiftKey;

	  if (eventInWidget(display, e)) {
	    if (!webkit) {
	      // Briefly turn off draggability, to allow widgets to do
	      // normal dragging things.
	      display.scroller.draggable = false;
	      setTimeout(function () { return display.scroller.draggable = true; }, 100);
	    }
	    return
	  }
	  if (clickInGutter(cm, e)) { return }
	  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
	  window.focus();

	  // #3261: make sure, that we're not starting a second selection
	  if (button == 1 && cm.state.selectingText)
	    { cm.state.selectingText(e); }

	  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

	  if (button == 1) {
	    if (pos) { leftButtonDown(cm, pos, repeat, e); }
	    else if (e_target(e) == display.scroller) { e_preventDefault(e); }
	  } else if (button == 2) {
	    if (pos) { extendSelection(cm.doc, pos); }
	    setTimeout(function () { return display.input.focus(); }, 20);
	  } else if (button == 3) {
	    if (captureRightClick) { onContextMenu(cm, e); }
	    else { delayBlurEvent(cm); }
	  }
	}

	function handleMappedButton(cm, button, pos, repeat, event) {
	  var name = "Click";
	  if (repeat == "double") { name = "Double" + name; }
	  else if (repeat == "triple") { name = "Triple" + name; }
	  name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

	  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
	    if (typeof bound == "string") { bound = commands[bound]; }
	    if (!bound) { return false }
	    var done = false;
	    try {
	      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
	      done = bound(cm, pos) != Pass;
	    } finally {
	      cm.state.suppressEdits = false;
	    }
	    return done
	  })
	}

	function configureMouse(cm, repeat, event) {
	  var option = cm.getOption("configureMouse");
	  var value = option ? option(cm, repeat, event) : {};
	  if (value.unit == null) {
	    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
	    value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
	  }
	  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
	  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
	  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
	  return value
	}

	function leftButtonDown(cm, pos, repeat, event) {
	  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
	  else { cm.curOp.focus = activeElt(); }

	  var behavior = configureMouse(cm, repeat, event);

	  var sel = cm.doc.sel, contained;
	  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
	      repeat == "single" && (contained = sel.contains(pos)) > -1 &&
	      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
	      (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
	    { leftButtonStartDrag(cm, event, pos, behavior); }
	  else
	    { leftButtonSelect(cm, event, pos, behavior); }
	}

	// Start a text drag. When it ends, see if any dragging actually
	// happen, and treat as a click if it didn't.
	function leftButtonStartDrag(cm, event, pos, behavior) {
	  var display = cm.display, moved = false;
	  var dragEnd = operation(cm, function (e) {
	    if (webkit) { display.scroller.draggable = false; }
	    cm.state.draggingText = false;
	    off(display.wrapper.ownerDocument, "mouseup", dragEnd);
	    off(display.wrapper.ownerDocument, "mousemove", mouseMove);
	    off(display.scroller, "dragstart", dragStart);
	    off(display.scroller, "drop", dragEnd);
	    if (!moved) {
	      e_preventDefault(e);
	      if (!behavior.addNew)
	        { extendSelection(cm.doc, pos, null, null, behavior.extend); }
	      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
	      if (webkit || ie && ie_version == 9)
	        { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }
	      else
	        { display.input.focus(); }
	    }
	  });
	  var mouseMove = function(e2) {
	    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
	  };
	  var dragStart = function () { return moved = true; };
	  // Let the drag handler handle this.
	  if (webkit) { display.scroller.draggable = true; }
	  cm.state.draggingText = dragEnd;
	  dragEnd.copy = !behavior.moveOnDrag;
	  // IE's approach to draggable
	  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
	  on(display.wrapper.ownerDocument, "mouseup", dragEnd);
	  on(display.wrapper.ownerDocument, "mousemove", mouseMove);
	  on(display.scroller, "dragstart", dragStart);
	  on(display.scroller, "drop", dragEnd);

	  delayBlurEvent(cm);
	  setTimeout(function () { return display.input.focus(); }, 20);
	}

	function rangeForUnit(cm, pos, unit) {
	  if (unit == "char") { return new Range(pos, pos) }
	  if (unit == "word") { return cm.findWordAt(pos) }
	  if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
	  var result = unit(cm, pos);
	  return new Range(result.from, result.to)
	}

	// Normal selection, as opposed to text dragging.
	function leftButtonSelect(cm, event, start, behavior) {
	  var display = cm.display, doc = cm.doc;
	  e_preventDefault(event);

	  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
	  if (behavior.addNew && !behavior.extend) {
	    ourIndex = doc.sel.contains(start);
	    if (ourIndex > -1)
	      { ourRange = ranges[ourIndex]; }
	    else
	      { ourRange = new Range(start, start); }
	  } else {
	    ourRange = doc.sel.primary();
	    ourIndex = doc.sel.primIndex;
	  }

	  if (behavior.unit == "rectangle") {
	    if (!behavior.addNew) { ourRange = new Range(start, start); }
	    start = posFromMouse(cm, event, true, true);
	    ourIndex = -1;
	  } else {
	    var range$$1 = rangeForUnit(cm, start, behavior.unit);
	    if (behavior.extend)
	      { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }
	    else
	      { ourRange = range$$1; }
	  }

	  if (!behavior.addNew) {
	    ourIndex = 0;
	    setSelection(doc, new Selection([ourRange], 0), sel_mouse);
	    startSel = doc.sel;
	  } else if (ourIndex == -1) {
	    ourIndex = ranges.length;
	    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
	                 {scroll: false, origin: "*mouse"});
	  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
	    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
	                 {scroll: false, origin: "*mouse"});
	    startSel = doc.sel;
	  } else {
	    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
	  }

	  var lastPos = start;
	  function extendTo(pos) {
	    if (cmp(lastPos, pos) == 0) { return }
	    lastPos = pos;

	    if (behavior.unit == "rectangle") {
	      var ranges = [], tabSize = cm.options.tabSize;
	      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
	      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
	      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
	      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
	           line <= end; line++) {
	        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
	        if (left == right)
	          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
	        else if (text.length > leftPos)
	          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
	      }
	      if (!ranges.length) { ranges.push(new Range(start, start)); }
	      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
	                   {origin: "*mouse", scroll: false});
	      cm.scrollIntoView(pos);
	    } else {
	      var oldRange = ourRange;
	      var range$$1 = rangeForUnit(cm, pos, behavior.unit);
	      var anchor = oldRange.anchor, head;
	      if (cmp(range$$1.anchor, anchor) > 0) {
	        head = range$$1.head;
	        anchor = minPos(oldRange.from(), range$$1.anchor);
	      } else {
	        head = range$$1.anchor;
	        anchor = maxPos(oldRange.to(), range$$1.head);
	      }
	      var ranges$1 = startSel.ranges.slice(0);
	      ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
	      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
	    }
	  }

	  var editorSize = display.wrapper.getBoundingClientRect();
	  // Used to ensure timeout re-tries don't fire when another extend
	  // happened in the meantime (clearTimeout isn't reliable -- at
	  // least on Chrome, the timeouts still happen even when cleared,
	  // if the clear happens after their scheduled firing time).
	  var counter = 0;

	  function extend(e) {
	    var curCount = ++counter;
	    var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
	    if (!cur) { return }
	    if (cmp(cur, lastPos) != 0) {
	      cm.curOp.focus = activeElt();
	      extendTo(cur);
	      var visible = visibleLines(display, doc);
	      if (cur.line >= visible.to || cur.line < visible.from)
	        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
	    } else {
	      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
	      if (outside) { setTimeout(operation(cm, function () {
	        if (counter != curCount) { return }
	        display.scroller.scrollTop += outside;
	        extend(e);
	      }), 50); }
	    }
	  }

	  function done(e) {
	    cm.state.selectingText = false;
	    counter = Infinity;
	    e_preventDefault(e);
	    display.input.focus();
	    off(display.wrapper.ownerDocument, "mousemove", move);
	    off(display.wrapper.ownerDocument, "mouseup", up);
	    doc.history.lastSelOrigin = null;
	  }

	  var move = operation(cm, function (e) {
	    if (!e_button(e)) { done(e); }
	    else { extend(e); }
	  });
	  var up = operation(cm, done);
	  cm.state.selectingText = up;
	  on(display.wrapper.ownerDocument, "mousemove", move);
	  on(display.wrapper.ownerDocument, "mouseup", up);
	}

	// Used when mouse-selecting to adjust the anchor to the proper side
	// of a bidi jump depending on the visual position of the head.
	function bidiSimplify(cm, range$$1) {
	  var anchor = range$$1.anchor;
	  var head = range$$1.head;
	  var anchorLine = getLine(cm.doc, anchor.line);
	  if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }
	  var order = getOrder(anchorLine);
	  if (!order) { return range$$1 }
	  var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
	  if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }
	  var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
	  if (boundary == 0 || boundary == order.length) { return range$$1 }

	  // Compute the relative visual position of the head compared to the
	  // anchor (<0 is to the left, >0 to the right)
	  var leftSide;
	  if (head.line != anchor.line) {
	    leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
	  } else {
	    var headIndex = getBidiPartAt(order, head.ch, head.sticky);
	    var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
	    if (headIndex == boundary - 1 || headIndex == boundary)
	      { leftSide = dir < 0; }
	    else
	      { leftSide = dir > 0; }
	  }

	  var usePart = order[boundary + (leftSide ? -1 : 0)];
	  var from = leftSide == (usePart.level == 1);
	  var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
	  return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
	}


	// Determines whether an event happened in the gutter, and fires the
	// handlers for the corresponding event.
	function gutterEvent(cm, e, type, prevent) {
	  var mX, mY;
	  if (e.touches) {
	    mX = e.touches[0].clientX;
	    mY = e.touches[0].clientY;
	  } else {
	    try { mX = e.clientX; mY = e.clientY; }
	    catch(e) { return false }
	  }
	  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
	  if (prevent) { e_preventDefault(e); }

	  var display = cm.display;
	  var lineBox = display.lineDiv.getBoundingClientRect();

	  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
	  mY -= lineBox.top - display.viewOffset;

	  for (var i = 0; i < cm.options.gutters.length; ++i) {
	    var g = display.gutters.childNodes[i];
	    if (g && g.getBoundingClientRect().right >= mX) {
	      var line = lineAtHeight(cm.doc, mY);
	      var gutter = cm.options.gutters[i];
	      signal(cm, type, cm, line, gutter, e);
	      return e_defaultPrevented(e)
	    }
	  }
	}

	function clickInGutter(cm, e) {
	  return gutterEvent(cm, e, "gutterClick", true)
	}

	// CONTEXT MENU HANDLING

	// To make the context menu work, we need to briefly unhide the
	// textarea (making it as unobtrusive as possible) to let the
	// right-click take effect on it.
	function onContextMenu(cm, e) {
	  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
	  if (signalDOMEvent(cm, e, "contextmenu")) { return }
	  cm.display.input.onContextMenu(e);
	}

	function contextMenuInGutter(cm, e) {
	  if (!hasHandler(cm, "gutterContextMenu")) { return false }
	  return gutterEvent(cm, e, "gutterContextMenu", false)
	}

	function themeChanged(cm) {
	  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
	    cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
	  clearCaches(cm);
	}

	var Init = {toString: function(){return "CodeMirror.Init"}};

	var defaults = {};
	var optionHandlers = {};

	function defineOptions(CodeMirror) {
	  var optionHandlers = CodeMirror.optionHandlers;

	  function option(name, deflt, handle, notOnInit) {
	    CodeMirror.defaults[name] = deflt;
	    if (handle) { optionHandlers[name] =
	      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
	  }

	  CodeMirror.defineOption = option;

	  // Passed to option handlers when there is no old value.
	  CodeMirror.Init = Init;

	  // These two are, on init, called from the constructor because they
	  // have to be initialized before the editor can start at all.
	  option("value", "", function (cm, val) { return cm.setValue(val); }, true);
	  option("mode", null, function (cm, val) {
	    cm.doc.modeOption = val;
	    loadMode(cm);
	  }, true);

	  option("indentUnit", 2, loadMode, true);
	  option("indentWithTabs", false);
	  option("smartIndent", true);
	  option("tabSize", 4, function (cm) {
	    resetModeState(cm);
	    clearCaches(cm);
	    regChange(cm);
	  }, true);

	  option("lineSeparator", null, function (cm, val) {
	    cm.doc.lineSep = val;
	    if (!val) { return }
	    var newBreaks = [], lineNo = cm.doc.first;
	    cm.doc.iter(function (line) {
	      for (var pos = 0;;) {
	        var found = line.text.indexOf(val, pos);
	        if (found == -1) { break }
	        pos = found + val.length;
	        newBreaks.push(Pos(lineNo, found));
	      }
	      lineNo++;
	    });
	    for (var i = newBreaks.length - 1; i >= 0; i--)
	      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
	  });
	  option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
	    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
	    if (old != Init) { cm.refresh(); }
	  });
	  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
	  option("electricChars", true);
	  option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
	    throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
	  }, true);
	  option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
	  option("rtlMoveVisually", !windows);
	  option("wholeLineUpdateBefore", true);

	  option("theme", "default", function (cm) {
	    themeChanged(cm);
	    guttersChanged(cm);
	  }, true);
	  option("keyMap", "default", function (cm, val, old) {
	    var next = getKeyMap(val);
	    var prev = old != Init && getKeyMap(old);
	    if (prev && prev.detach) { prev.detach(cm, next); }
	    if (next.attach) { next.attach(cm, prev || null); }
	  });
	  option("extraKeys", null);
	  option("configureMouse", null);

	  option("lineWrapping", false, wrappingChanged, true);
	  option("gutters", [], function (cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("fixedGutter", true, function (cm, val) {
	    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
	    cm.refresh();
	  }, true);
	  option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
	  option("scrollbarStyle", "native", function (cm) {
	    initScrollbars(cm);
	    updateScrollbars(cm);
	    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
	    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
	  }, true);
	  option("lineNumbers", false, function (cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("firstLineNumber", 1, guttersChanged, true);
	  option("lineNumberFormatter", function (integer) { return integer; }, guttersChanged, true);
	  option("showCursorWhenSelecting", false, updateSelection, true);

	  option("resetSelectionOnContextMenu", true);
	  option("lineWiseCopyCut", true);
	  option("pasteLinesPerSelection", true);

	  option("readOnly", false, function (cm, val) {
	    if (val == "nocursor") {
	      onBlur(cm);
	      cm.display.input.blur();
	    }
	    cm.display.input.readOnlyChanged(val);
	  });
	  option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
	  option("dragDrop", true, dragDropChanged);
	  option("allowDropFileTypes", null);

	  option("cursorBlinkRate", 530);
	  option("cursorScrollMargin", 0);
	  option("cursorHeight", 1, updateSelection, true);
	  option("singleCursorHeightPerLine", true, updateSelection, true);
	  option("workTime", 100);
	  option("workDelay", 100);
	  option("flattenSpans", true, resetModeState, true);
	  option("addModeClass", false, resetModeState, true);
	  option("pollInterval", 100);
	  option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
	  option("historyEventDelay", 1250);
	  option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
	  option("maxHighlightLength", 10000, resetModeState, true);
	  option("moveInputWithCursor", true, function (cm, val) {
	    if (!val) { cm.display.input.resetPosition(); }
	  });

	  option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
	  option("autofocus", null);
	  option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
	}

	function guttersChanged(cm) {
	  updateGutters(cm);
	  regChange(cm);
	  alignHorizontally(cm);
	}

	function dragDropChanged(cm, value, old) {
	  var wasOn = old && old != Init;
	  if (!value != !wasOn) {
	    var funcs = cm.display.dragFunctions;
	    var toggle = value ? on : off;
	    toggle(cm.display.scroller, "dragstart", funcs.start);
	    toggle(cm.display.scroller, "dragenter", funcs.enter);
	    toggle(cm.display.scroller, "dragover", funcs.over);
	    toggle(cm.display.scroller, "dragleave", funcs.leave);
	    toggle(cm.display.scroller, "drop", funcs.drop);
	  }
	}

	function wrappingChanged(cm) {
	  if (cm.options.lineWrapping) {
	    addClass(cm.display.wrapper, "CodeMirror-wrap");
	    cm.display.sizer.style.minWidth = "";
	    cm.display.sizerWidth = null;
	  } else {
	    rmClass(cm.display.wrapper, "CodeMirror-wrap");
	    findMaxLine(cm);
	  }
	  estimateLineHeights(cm);
	  regChange(cm);
	  clearCaches(cm);
	  setTimeout(function () { return updateScrollbars(cm); }, 100);
	}

	// A CodeMirror instance represents an editor. This is the object
	// that user code is usually dealing with.

	function CodeMirror$1(place, options) {
	  var this$1 = this;

	  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }

	  this.options = options = options ? copyObj(options) : {};
	  // Determine effective options based on given values and defaults.
	  copyObj(defaults, options, false);
	  setGuttersForLineNumbers(options);

	  var doc = options.value;
	  if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
	  this.doc = doc;

	  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);
	  var display = this.display = new Display(place, doc, input);
	  display.wrapper.CodeMirror = this;
	  updateGutters(this);
	  themeChanged(this);
	  if (options.lineWrapping)
	    { this.display.wrapper.className += " CodeMirror-wrap"; }
	  initScrollbars(this);

	  this.state = {
	    keyMaps: [],  // stores maps added by addKeyMap
	    overlays: [], // highlighting overlays, as added by addOverlay
	    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
	    overwrite: false,
	    delayingBlurEvent: false,
	    focused: false,
	    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
	    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
	    selectingText: false,
	    draggingText: false,
	    highlight: new Delayed(), // stores highlight worker timeout
	    keySeq: null,  // Unfinished key sequence
	    specialChars: null
	  };

	  if (options.autofocus && !mobile) { display.input.focus(); }

	  // Override magic textarea content restore that IE sometimes does
	  // on our hidden textarea on reload
	  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

	  registerEventHandlers(this);
	  ensureGlobalHandlers();

	  startOperation(this);
	  this.curOp.forceUpdate = true;
	  attachDoc(this, doc);

	  if ((options.autofocus && !mobile) || this.hasFocus())
	    { setTimeout(bind(onFocus, this), 20); }
	  else
	    { onBlur(this); }

	  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
	    { optionHandlers[opt](this$1, options[opt], Init); } }
	  maybeUpdateLineNumberWidth(this);
	  if (options.finishInit) { options.finishInit(this); }
	  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
	  endOperation(this);
	  // Suppress optimizelegibility in Webkit, since it breaks text
	  // measuring on line wrapping boundaries.
	  if (webkit && options.lineWrapping &&
	      getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
	    { display.lineDiv.style.textRendering = "auto"; }
	}

	// The default configuration options.
	CodeMirror$1.defaults = defaults;
	// Functions to run when options are changed.
	CodeMirror$1.optionHandlers = optionHandlers;

	// Attach the necessary event handlers when initializing the editor
	function registerEventHandlers(cm) {
	  var d = cm.display;
	  on(d.scroller, "mousedown", operation(cm, onMouseDown));
	  // Older IE's will not fire a second mousedown for a double click
	  if (ie && ie_version < 11)
	    { on(d.scroller, "dblclick", operation(cm, function (e) {
	      if (signalDOMEvent(cm, e)) { return }
	      var pos = posFromMouse(cm, e);
	      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
	      e_preventDefault(e);
	      var word = cm.findWordAt(pos);
	      extendSelection(cm.doc, word.anchor, word.head);
	    })); }
	  else
	    { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
	  // Some browsers fire contextmenu *after* opening the menu, at
	  // which point we can't mess with it anymore. Context menu is
	  // handled in onMouseDown for these browsers.
	  if (!captureRightClick) { on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); }); }

	  // Used to suppress mouse event handling when a touch happens
	  var touchFinished, prevTouch = {end: 0};
	  function finishTouch() {
	    if (d.activeTouch) {
	      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
	      prevTouch = d.activeTouch;
	      prevTouch.end = +new Date;
	    }
	  }
	  function isMouseLikeTouchEvent(e) {
	    if (e.touches.length != 1) { return false }
	    var touch = e.touches[0];
	    return touch.radiusX <= 1 && touch.radiusY <= 1
	  }
	  function farAway(touch, other) {
	    if (other.left == null) { return true }
	    var dx = other.left - touch.left, dy = other.top - touch.top;
	    return dx * dx + dy * dy > 20 * 20
	  }
	  on(d.scroller, "touchstart", function (e) {
	    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
	      d.input.ensurePolled();
	      clearTimeout(touchFinished);
	      var now = +new Date;
	      d.activeTouch = {start: now, moved: false,
	                       prev: now - prevTouch.end <= 300 ? prevTouch : null};
	      if (e.touches.length == 1) {
	        d.activeTouch.left = e.touches[0].pageX;
	        d.activeTouch.top = e.touches[0].pageY;
	      }
	    }
	  });
	  on(d.scroller, "touchmove", function () {
	    if (d.activeTouch) { d.activeTouch.moved = true; }
	  });
	  on(d.scroller, "touchend", function (e) {
	    var touch = d.activeTouch;
	    if (touch && !eventInWidget(d, e) && touch.left != null &&
	        !touch.moved && new Date - touch.start < 300) {
	      var pos = cm.coordsChar(d.activeTouch, "page"), range;
	      if (!touch.prev || farAway(touch, touch.prev)) // Single tap
	        { range = new Range(pos, pos); }
	      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
	        { range = cm.findWordAt(pos); }
	      else // Triple tap
	        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
	      cm.setSelection(range.anchor, range.head);
	      cm.focus();
	      e_preventDefault(e);
	    }
	    finishTouch();
	  });
	  on(d.scroller, "touchcancel", finishTouch);

	  // Sync scrolling between fake scrollbars and real scrollable
	  // area, ensure viewport is updated when scrolling.
	  on(d.scroller, "scroll", function () {
	    if (d.scroller.clientHeight) {
	      updateScrollTop(cm, d.scroller.scrollTop);
	      setScrollLeft(cm, d.scroller.scrollLeft, true);
	      signal(cm, "scroll", cm);
	    }
	  });

	  // Listen to wheel events in order to try and update the viewport on time.
	  on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
	  on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

	  // Prevent wrapper from ever scrolling
	  on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

	  d.dragFunctions = {
	    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
	    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
	    start: function (e) { return onDragStart(cm, e); },
	    drop: operation(cm, onDrop),
	    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
	  };

	  var inp = d.input.getField();
	  on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
	  on(inp, "keydown", operation(cm, onKeyDown));
	  on(inp, "keypress", operation(cm, onKeyPress));
	  on(inp, "focus", function (e) { return onFocus(cm, e); });
	  on(inp, "blur", function (e) { return onBlur(cm, e); });
	}

	var initHooks = [];
	CodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };

	// Indent the given line. The how parameter can be "smart",
	// "add"/null, "subtract", or "prev". When aggressive is false
	// (typically set to true for forced single-line indents), empty
	// lines are not indented, and places where the mode returns Pass
	// are left alone.
	function indentLine(cm, n, how, aggressive) {
	  var doc = cm.doc, state;
	  if (how == null) { how = "add"; }
	  if (how == "smart") {
	    // Fall back to "prev" when the mode doesn't have an indentation
	    // method.
	    if (!doc.mode.indent) { how = "prev"; }
	    else { state = getContextBefore(cm, n).state; }
	  }

	  var tabSize = cm.options.tabSize;
	  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
	  if (line.stateAfter) { line.stateAfter = null; }
	  var curSpaceString = line.text.match(/^\s*/)[0], indentation;
	  if (!aggressive && !/\S/.test(line.text)) {
	    indentation = 0;
	    how = "not";
	  } else if (how == "smart") {
	    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
	    if (indentation == Pass || indentation > 150) {
	      if (!aggressive) { return }
	      how = "prev";
	    }
	  }
	  if (how == "prev") {
	    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
	    else { indentation = 0; }
	  } else if (how == "add") {
	    indentation = curSpace + cm.options.indentUnit;
	  } else if (how == "subtract") {
	    indentation = curSpace - cm.options.indentUnit;
	  } else if (typeof how == "number") {
	    indentation = curSpace + how;
	  }
	  indentation = Math.max(0, indentation);

	  var indentString = "", pos = 0;
	  if (cm.options.indentWithTabs)
	    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
	  if (pos < indentation) { indentString += spaceStr(indentation - pos); }

	  if (indentString != curSpaceString) {
	    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
	    line.stateAfter = null;
	    return true
	  } else {
	    // Ensure that, if the cursor was in the whitespace at the start
	    // of the line, it is moved to the end of that space.
	    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
	      var range = doc.sel.ranges[i$1];
	      if (range.head.line == n && range.head.ch < curSpaceString.length) {
	        var pos$1 = Pos(n, curSpaceString.length);
	        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
	        break
	      }
	    }
	  }
	}

	// This will be set to a {lineWise: bool, text: [string]} object, so
	// that, when pasting, we know what kind of selections the copied
	// text was made out of.
	var lastCopied = null;

	function setLastCopied(newLastCopied) {
	  lastCopied = newLastCopied;
	}

	function applyTextInput(cm, inserted, deleted, sel, origin) {
	  var doc = cm.doc;
	  cm.display.shift = false;
	  if (!sel) { sel = doc.sel; }

	  var paste = cm.state.pasteIncoming || origin == "paste";
	  var textLines = splitLinesAuto(inserted), multiPaste = null;
	  // When pasting N lines into N selections, insert one line per selection
	  if (paste && sel.ranges.length > 1) {
	    if (lastCopied && lastCopied.text.join("\n") == inserted) {
	      if (sel.ranges.length % lastCopied.text.length == 0) {
	        multiPaste = [];
	        for (var i = 0; i < lastCopied.text.length; i++)
	          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
	      }
	    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
	      multiPaste = map(textLines, function (l) { return [l]; });
	    }
	  }

	  var updateInput;
	  // Normal behavior is to insert the new text into every selection
	  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
	    var range$$1 = sel.ranges[i$1];
	    var from = range$$1.from(), to = range$$1.to();
	    if (range$$1.empty()) {
	      if (deleted && deleted > 0) // Handle deletion
	        { from = Pos(from.line, from.ch - deleted); }
	      else if (cm.state.overwrite && !paste) // Handle overwrite
	        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
	      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
	        { from = to = Pos(from.line, 0); }
	    }
	    updateInput = cm.curOp.updateInput;
	    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
	                       origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
	    makeChange(cm.doc, changeEvent);
	    signalLater(cm, "inputRead", cm, changeEvent);
	  }
	  if (inserted && !paste)
	    { triggerElectric(cm, inserted); }

	  ensureCursorVisible(cm);
	  cm.curOp.updateInput = updateInput;
	  cm.curOp.typing = true;
	  cm.state.pasteIncoming = cm.state.cutIncoming = false;
	}

	function handlePaste(e, cm) {
	  var pasted = e.clipboardData && e.clipboardData.getData("Text");
	  if (pasted) {
	    e.preventDefault();
	    if (!cm.isReadOnly() && !cm.options.disableInput)
	      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
	    return true
	  }
	}

	function triggerElectric(cm, inserted) {
	  // When an 'electric' character is inserted, immediately trigger a reindent
	  if (!cm.options.electricChars || !cm.options.smartIndent) { return }
	  var sel = cm.doc.sel;

	  for (var i = sel.ranges.length - 1; i >= 0; i--) {
	    var range$$1 = sel.ranges[i];
	    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
	    var mode = cm.getModeAt(range$$1.head);
	    var indented = false;
	    if (mode.electricChars) {
	      for (var j = 0; j < mode.electricChars.length; j++)
	        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
	          indented = indentLine(cm, range$$1.head.line, "smart");
	          break
	        } }
	    } else if (mode.electricInput) {
	      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
	        { indented = indentLine(cm, range$$1.head.line, "smart"); }
	    }
	    if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
	  }
	}

	function copyableRanges(cm) {
	  var text = [], ranges = [];
	  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
	    var line = cm.doc.sel.ranges[i].head.line;
	    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
	    ranges.push(lineRange);
	    text.push(cm.getRange(lineRange.anchor, lineRange.head));
	  }
	  return {text: text, ranges: ranges}
	}

	function disableBrowserMagic(field, spellcheck) {
	  field.setAttribute("autocorrect", "off");
	  field.setAttribute("autocapitalize", "off");
	  field.setAttribute("spellcheck", !!spellcheck);
	}

	function hiddenTextarea() {
	  var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
	  var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
	  // The textarea is kept positioned near the cursor to prevent the
	  // fact that it'll be scrolled into view on input from scrolling
	  // our fake cursor out of view. On webkit, when wrap=off, paste is
	  // very slow. So make the area wide instead.
	  if (webkit) { te.style.width = "1000px"; }
	  else { te.setAttribute("wrap", "off"); }
	  // If border: 0; -- iOS fails to open keyboard (issue #1287)
	  if (ios) { te.style.border = "1px solid black"; }
	  disableBrowserMagic(te);
	  return div
	}

	// The publicly visible API. Note that methodOp(f) means
	// 'wrap f in an operation, performed on its `this` parameter'.

	// This is not the complete set of editor methods. Most of the
	// methods defined on the Doc type are also injected into
	// CodeMirror.prototype, for backwards compatibility and
	// convenience.

	var addEditorMethods = function(CodeMirror) {
	  var optionHandlers = CodeMirror.optionHandlers;

	  var helpers = CodeMirror.helpers = {};

	  CodeMirror.prototype = {
	    constructor: CodeMirror,
	    focus: function(){window.focus(); this.display.input.focus();},

	    setOption: function(option, value) {
	      var options = this.options, old = options[option];
	      if (options[option] == value && option != "mode") { return }
	      options[option] = value;
	      if (optionHandlers.hasOwnProperty(option))
	        { operation(this, optionHandlers[option])(this, value, old); }
	      signal(this, "optionChange", this, option);
	    },

	    getOption: function(option) {return this.options[option]},
	    getDoc: function() {return this.doc},

	    addKeyMap: function(map$$1, bottom) {
	      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
	    },
	    removeKeyMap: function(map$$1) {
	      var maps = this.state.keyMaps;
	      for (var i = 0; i < maps.length; ++i)
	        { if (maps[i] == map$$1 || maps[i].name == map$$1) {
	          maps.splice(i, 1);
	          return true
	        } }
	    },

	    addOverlay: methodOp(function(spec, options) {
	      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
	      if (mode.startState) { throw new Error("Overlays may not be stateful.") }
	      insertSorted(this.state.overlays,
	                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,
	                    priority: (options && options.priority) || 0},
	                   function (overlay) { return overlay.priority; });
	      this.state.modeGen++;
	      regChange(this);
	    }),
	    removeOverlay: methodOp(function(spec) {
	      var this$1 = this;

	      var overlays = this.state.overlays;
	      for (var i = 0; i < overlays.length; ++i) {
	        var cur = overlays[i].modeSpec;
	        if (cur == spec || typeof spec == "string" && cur.name == spec) {
	          overlays.splice(i, 1);
	          this$1.state.modeGen++;
	          regChange(this$1);
	          return
	        }
	      }
	    }),

	    indentLine: methodOp(function(n, dir, aggressive) {
	      if (typeof dir != "string" && typeof dir != "number") {
	        if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
	        else { dir = dir ? "add" : "subtract"; }
	      }
	      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
	    }),
	    indentSelection: methodOp(function(how) {
	      var this$1 = this;

	      var ranges = this.doc.sel.ranges, end = -1;
	      for (var i = 0; i < ranges.length; i++) {
	        var range$$1 = ranges[i];
	        if (!range$$1.empty()) {
	          var from = range$$1.from(), to = range$$1.to();
	          var start = Math.max(end, from.line);
	          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
	          for (var j = start; j < end; ++j)
	            { indentLine(this$1, j, how); }
	          var newRanges = this$1.doc.sel.ranges;
	          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
	            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
	        } else if (range$$1.head.line > end) {
	          indentLine(this$1, range$$1.head.line, how, true);
	          end = range$$1.head.line;
	          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
	        }
	      }
	    }),

	    // Fetch the parser token for a given character. Useful for hacks
	    // that want to inspect the mode state (say, for completion).
	    getTokenAt: function(pos, precise) {
	      return takeToken(this, pos, precise)
	    },

	    getLineTokens: function(line, precise) {
	      return takeToken(this, Pos(line), precise, true)
	    },

	    getTokenTypeAt: function(pos) {
	      pos = clipPos(this.doc, pos);
	      var styles = getLineStyles(this, getLine(this.doc, pos.line));
	      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
	      var type;
	      if (ch == 0) { type = styles[2]; }
	      else { for (;;) {
	        var mid = (before + after) >> 1;
	        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
	        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
	        else { type = styles[mid * 2 + 2]; break }
	      } }
	      var cut = type ? type.indexOf("overlay ") : -1;
	      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
	    },

	    getModeAt: function(pos) {
	      var mode = this.doc.mode;
	      if (!mode.innerMode) { return mode }
	      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
	    },

	    getHelper: function(pos, type) {
	      return this.getHelpers(pos, type)[0]
	    },

	    getHelpers: function(pos, type) {
	      var this$1 = this;

	      var found = [];
	      if (!helpers.hasOwnProperty(type)) { return found }
	      var help = helpers[type], mode = this.getModeAt(pos);
	      if (typeof mode[type] == "string") {
	        if (help[mode[type]]) { found.push(help[mode[type]]); }
	      } else if (mode[type]) {
	        for (var i = 0; i < mode[type].length; i++) {
	          var val = help[mode[type][i]];
	          if (val) { found.push(val); }
	        }
	      } else if (mode.helperType && help[mode.helperType]) {
	        found.push(help[mode.helperType]);
	      } else if (help[mode.name]) {
	        found.push(help[mode.name]);
	      }
	      for (var i$1 = 0; i$1 < help._global.length; i$1++) {
	        var cur = help._global[i$1];
	        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
	          { found.push(cur.val); }
	      }
	      return found
	    },

	    getStateAfter: function(line, precise) {
	      var doc = this.doc;
	      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
	      return getContextBefore(this, line + 1, precise).state
	    },

	    cursorCoords: function(start, mode) {
	      var pos, range$$1 = this.doc.sel.primary();
	      if (start == null) { pos = range$$1.head; }
	      else if (typeof start == "object") { pos = clipPos(this.doc, start); }
	      else { pos = start ? range$$1.from() : range$$1.to(); }
	      return cursorCoords(this, pos, mode || "page")
	    },

	    charCoords: function(pos, mode) {
	      return charCoords(this, clipPos(this.doc, pos), mode || "page")
	    },

	    coordsChar: function(coords, mode) {
	      coords = fromCoordSystem(this, coords, mode || "page");
	      return coordsChar(this, coords.left, coords.top)
	    },

	    lineAtHeight: function(height, mode) {
	      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
	      return lineAtHeight(this.doc, height + this.display.viewOffset)
	    },
	    heightAtLine: function(line, mode, includeWidgets) {
	      var end = false, lineObj;
	      if (typeof line == "number") {
	        var last = this.doc.first + this.doc.size - 1;
	        if (line < this.doc.first) { line = this.doc.first; }
	        else if (line > last) { line = last; end = true; }
	        lineObj = getLine(this.doc, line);
	      } else {
	        lineObj = line;
	      }
	      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
	        (end ? this.doc.height - heightAtLine(lineObj) : 0)
	    },

	    defaultTextHeight: function() { return textHeight(this.display) },
	    defaultCharWidth: function() { return charWidth(this.display) },

	    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

	    addWidget: function(pos, node, scroll, vert, horiz) {
	      var display = this.display;
	      pos = cursorCoords(this, clipPos(this.doc, pos));
	      var top = pos.bottom, left = pos.left;
	      node.style.position = "absolute";
	      node.setAttribute("cm-ignore-events", "true");
	      this.display.input.setUneditable(node);
	      display.sizer.appendChild(node);
	      if (vert == "over") {
	        top = pos.top;
	      } else if (vert == "above" || vert == "near") {
	        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
	        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
	        // Default to positioning above (if specified and possible); otherwise default to positioning below
	        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
	          { top = pos.top - node.offsetHeight; }
	        else if (pos.bottom + node.offsetHeight <= vspace)
	          { top = pos.bottom; }
	        if (left + node.offsetWidth > hspace)
	          { left = hspace - node.offsetWidth; }
	      }
	      node.style.top = top + "px";
	      node.style.left = node.style.right = "";
	      if (horiz == "right") {
	        left = display.sizer.clientWidth - node.offsetWidth;
	        node.style.right = "0px";
	      } else {
	        if (horiz == "left") { left = 0; }
	        else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
	        node.style.left = left + "px";
	      }
	      if (scroll)
	        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
	    },

	    triggerOnKeyDown: methodOp(onKeyDown),
	    triggerOnKeyPress: methodOp(onKeyPress),
	    triggerOnKeyUp: onKeyUp,
	    triggerOnMouseDown: methodOp(onMouseDown),

	    execCommand: function(cmd) {
	      if (commands.hasOwnProperty(cmd))
	        { return commands[cmd].call(null, this) }
	    },

	    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

	    findPosH: function(from, amount, unit, visually) {
	      var this$1 = this;

	      var dir = 1;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      var cur = clipPos(this.doc, from);
	      for (var i = 0; i < amount; ++i) {
	        cur = findPosH(this$1.doc, cur, dir, unit, visually);
	        if (cur.hitSide) { break }
	      }
	      return cur
	    },

	    moveH: methodOp(function(dir, unit) {
	      var this$1 = this;

	      this.extendSelectionsBy(function (range$$1) {
	        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
	          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
	        else
	          { return dir < 0 ? range$$1.from() : range$$1.to() }
	      }, sel_move);
	    }),

	    deleteH: methodOp(function(dir, unit) {
	      var sel = this.doc.sel, doc = this.doc;
	      if (sel.somethingSelected())
	        { doc.replaceSelection("", null, "+delete"); }
	      else
	        { deleteNearSelection(this, function (range$$1) {
	          var other = findPosH(doc, range$$1.head, dir, unit, false);
	          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
	        }); }
	    }),

	    findPosV: function(from, amount, unit, goalColumn) {
	      var this$1 = this;

	      var dir = 1, x = goalColumn;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      var cur = clipPos(this.doc, from);
	      for (var i = 0; i < amount; ++i) {
	        var coords = cursorCoords(this$1, cur, "div");
	        if (x == null) { x = coords.left; }
	        else { coords.left = x; }
	        cur = findPosV(this$1, coords, dir, unit);
	        if (cur.hitSide) { break }
	      }
	      return cur
	    },

	    moveV: methodOp(function(dir, unit) {
	      var this$1 = this;

	      var doc = this.doc, goals = [];
	      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
	      doc.extendSelectionsBy(function (range$$1) {
	        if (collapse)
	          { return dir < 0 ? range$$1.from() : range$$1.to() }
	        var headPos = cursorCoords(this$1, range$$1.head, "div");
	        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
	        goals.push(headPos.left);
	        var pos = findPosV(this$1, headPos, dir, unit);
	        if (unit == "page" && range$$1 == doc.sel.primary())
	          { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
	        return pos
	      }, sel_move);
	      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
	        { doc.sel.ranges[i].goalColumn = goals[i]; } }
	    }),

	    // Find the word at the given position (as returned by coordsChar).
	    findWordAt: function(pos) {
	      var doc = this.doc, line = getLine(doc, pos.line).text;
	      var start = pos.ch, end = pos.ch;
	      if (line) {
	        var helper = this.getHelper(pos, "wordChars");
	        if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
	        var startChar = line.charAt(start);
	        var check = isWordChar(startChar, helper)
	          ? function (ch) { return isWordChar(ch, helper); }
	          : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
	          : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
	        while (start > 0 && check(line.charAt(start - 1))) { --start; }
	        while (end < line.length && check(line.charAt(end))) { ++end; }
	      }
	      return new Range(Pos(pos.line, start), Pos(pos.line, end))
	    },

	    toggleOverwrite: function(value) {
	      if (value != null && value == this.state.overwrite) { return }
	      if (this.state.overwrite = !this.state.overwrite)
	        { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
	      else
	        { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

	      signal(this, "overwriteToggle", this, this.state.overwrite);
	    },
	    hasFocus: function() { return this.display.input.getField() == activeElt() },
	    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

	    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
	    getScrollInfo: function() {
	      var scroller = this.display.scroller;
	      return {left: scroller.scrollLeft, top: scroller.scrollTop,
	              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
	              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
	              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
	    },

	    scrollIntoView: methodOp(function(range$$1, margin) {
	      if (range$$1 == null) {
	        range$$1 = {from: this.doc.sel.primary().head, to: null};
	        if (margin == null) { margin = this.options.cursorScrollMargin; }
	      } else if (typeof range$$1 == "number") {
	        range$$1 = {from: Pos(range$$1, 0), to: null};
	      } else if (range$$1.from == null) {
	        range$$1 = {from: range$$1, to: null};
	      }
	      if (!range$$1.to) { range$$1.to = range$$1.from; }
	      range$$1.margin = margin || 0;

	      if (range$$1.from.line != null) {
	        scrollToRange(this, range$$1);
	      } else {
	        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
	      }
	    }),

	    setSize: methodOp(function(width, height) {
	      var this$1 = this;

	      var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
	      if (width != null) { this.display.wrapper.style.width = interpret(width); }
	      if (height != null) { this.display.wrapper.style.height = interpret(height); }
	      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
	      var lineNo$$1 = this.display.viewFrom;
	      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
	        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
	          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
	        ++lineNo$$1;
	      });
	      this.curOp.forceUpdate = true;
	      signal(this, "refresh", this);
	    }),

	    operation: function(f){return runInOp(this, f)},
	    startOperation: function(){return startOperation(this)},
	    endOperation: function(){return endOperation(this)},

	    refresh: methodOp(function() {
	      var oldHeight = this.display.cachedTextHeight;
	      regChange(this);
	      this.curOp.forceUpdate = true;
	      clearCaches(this);
	      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
	      updateGutterSpace(this);
	      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
	        { estimateLineHeights(this); }
	      signal(this, "refresh", this);
	    }),

	    swapDoc: methodOp(function(doc) {
	      var old = this.doc;
	      old.cm = null;
	      attachDoc(this, doc);
	      clearCaches(this);
	      this.display.input.reset();
	      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
	      this.curOp.forceScroll = true;
	      signalLater(this, "swapDoc", this, old);
	      return old
	    }),

	    getInputField: function(){return this.display.input.getField()},
	    getWrapperElement: function(){return this.display.wrapper},
	    getScrollerElement: function(){return this.display.scroller},
	    getGutterElement: function(){return this.display.gutters}
	  };
	  eventMixin(CodeMirror);

	  CodeMirror.registerHelper = function(type, name, value) {
	    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
	    helpers[type][name] = value;
	  };
	  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
	    CodeMirror.registerHelper(type, name, value);
	    helpers[type]._global.push({pred: predicate, val: value});
	  };
	};

	// Used for horizontal relative motion. Dir is -1 or 1 (left or
	// right), unit can be "char", "column" (like char, but doesn't
	// cross line boundaries), "word" (across next word), or "group" (to
	// the start of next group of word or non-word-non-whitespace
	// chars). The visually param controls whether, in right-to-left
	// text, direction 1 means to move towards the next index in the
	// string, or towards the character to the right of the current
	// position. The resulting position will have a hitSide=true
	// property if it reached the end of the document.
	function findPosH(doc, pos, dir, unit, visually) {
	  var oldPos = pos;
	  var origDir = dir;
	  var lineObj = getLine(doc, pos.line);
	  function findNextLine() {
	    var l = pos.line + dir;
	    if (l < doc.first || l >= doc.first + doc.size) { return false }
	    pos = new Pos(l, pos.ch, pos.sticky);
	    return lineObj = getLine(doc, l)
	  }
	  function moveOnce(boundToLine) {
	    var next;
	    if (visually) {
	      next = moveVisually(doc.cm, lineObj, pos, dir);
	    } else {
	      next = moveLogically(lineObj, pos, dir);
	    }
	    if (next == null) {
	      if (!boundToLine && findNextLine())
	        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
	      else
	        { return false }
	    } else {
	      pos = next;
	    }
	    return true
	  }

	  if (unit == "char") {
	    moveOnce();
	  } else if (unit == "column") {
	    moveOnce(true);
	  } else if (unit == "word" || unit == "group") {
	    var sawType = null, group = unit == "group";
	    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
	    for (var first = true;; first = false) {
	      if (dir < 0 && !moveOnce(!first)) { break }
	      var cur = lineObj.text.charAt(pos.ch) || "\n";
	      var type = isWordChar(cur, helper) ? "w"
	        : group && cur == "\n" ? "n"
	        : !group || /\s/.test(cur) ? null
	        : "p";
	      if (group && !first && !type) { type = "s"; }
	      if (sawType && sawType != type) {
	        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
	        break
	      }

	      if (type) { sawType = type; }
	      if (dir > 0 && !moveOnce(!first)) { break }
	    }
	  }
	  var result = skipAtomic(doc, pos, oldPos, origDir, true);
	  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
	  return result
	}

	// For relative vertical movement. Dir may be -1 or 1. Unit can be
	// "page" or "line". The resulting position will have a hitSide=true
	// property if it reached the end of the document.
	function findPosV(cm, pos, dir, unit) {
	  var doc = cm.doc, x = pos.left, y;
	  if (unit == "page") {
	    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
	    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
	    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

	  } else if (unit == "line") {
	    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
	  }
	  var target;
	  for (;;) {
	    target = coordsChar(cm, x, y);
	    if (!target.outside) { break }
	    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
	    y += dir * 5;
	  }
	  return target
	}

	// CONTENTEDITABLE INPUT STYLE

	var ContentEditableInput = function(cm) {
	  this.cm = cm;
	  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
	  this.polling = new Delayed();
	  this.composing = null;
	  this.gracePeriod = false;
	  this.readDOMTimeout = null;
	};

	ContentEditableInput.prototype.init = function (display) {
	    var this$1 = this;

	  var input = this, cm = input.cm;
	  var div = input.div = display.lineDiv;
	  disableBrowserMagic(div, cm.options.spellcheck);

	  on(div, "paste", function (e) {
	    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
	    // IE doesn't fire input events, so we schedule a read for the pasted content in this way
	    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
	  });

	  on(div, "compositionstart", function (e) {
	    this$1.composing = {data: e.data, done: false};
	  });
	  on(div, "compositionupdate", function (e) {
	    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
	  });
	  on(div, "compositionend", function (e) {
	    if (this$1.composing) {
	      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
	      this$1.composing.done = true;
	    }
	  });

	  on(div, "touchstart", function () { return input.forceCompositionEnd(); });

	  on(div, "input", function () {
	    if (!this$1.composing) { this$1.readFromDOMSoon(); }
	  });

	  function onCopyCut(e) {
	    if (signalDOMEvent(cm, e)) { return }
	    if (cm.somethingSelected()) {
	      setLastCopied({lineWise: false, text: cm.getSelections()});
	      if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
	    } else if (!cm.options.lineWiseCopyCut) {
	      return
	    } else {
	      var ranges = copyableRanges(cm);
	      setLastCopied({lineWise: true, text: ranges.text});
	      if (e.type == "cut") {
	        cm.operation(function () {
	          cm.setSelections(ranges.ranges, 0, sel_dontScroll);
	          cm.replaceSelection("", null, "cut");
	        });
	      }
	    }
	    if (e.clipboardData) {
	      e.clipboardData.clearData();
	      var content = lastCopied.text.join("\n");
	      // iOS exposes the clipboard API, but seems to discard content inserted into it
	      e.clipboardData.setData("Text", content);
	      if (e.clipboardData.getData("Text") == content) {
	        e.preventDefault();
	        return
	      }
	    }
	    // Old-fashioned briefly-focus-a-textarea hack
	    var kludge = hiddenTextarea(), te = kludge.firstChild;
	    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
	    te.value = lastCopied.text.join("\n");
	    var hadFocus = document.activeElement;
	    selectInput(te);
	    setTimeout(function () {
	      cm.display.lineSpace.removeChild(kludge);
	      hadFocus.focus();
	      if (hadFocus == div) { input.showPrimarySelection(); }
	    }, 50);
	  }
	  on(div, "copy", onCopyCut);
	  on(div, "cut", onCopyCut);
	};

	ContentEditableInput.prototype.prepareSelection = function () {
	  var result = prepareSelection(this.cm, false);
	  result.focus = this.cm.state.focused;
	  return result
	};

	ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
	  if (!info || !this.cm.display.view.length) { return }
	  if (info.focus || takeFocus) { this.showPrimarySelection(); }
	  this.showMultipleSelections(info);
	};

	ContentEditableInput.prototype.showPrimarySelection = function () {
	  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
	  var from = prim.from(), to = prim.to();

	  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
	    sel.removeAllRanges();
	    return
	  }

	  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
	  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
	      cmp(minPos(curAnchor, curFocus), from) == 0 &&
	      cmp(maxPos(curAnchor, curFocus), to) == 0)
	    { return }

	  var view = cm.display.view;
	  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
	      {node: view[0].measure.map[2], offset: 0};
	  var end = to.line < cm.display.viewTo && posToDOM(cm, to);
	  if (!end) {
	    var measure = view[view.length - 1].measure;
	    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
	    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
	  }

	  if (!start || !end) {
	    sel.removeAllRanges();
	    return
	  }

	  var old = sel.rangeCount && sel.getRangeAt(0), rng;
	  try { rng = range(start.node, start.offset, end.offset, end.node); }
	  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
	  if (rng) {
	    if (!gecko && cm.state.focused) {
	      sel.collapse(start.node, start.offset);
	      if (!rng.collapsed) {
	        sel.removeAllRanges();
	        sel.addRange(rng);
	      }
	    } else {
	      sel.removeAllRanges();
	      sel.addRange(rng);
	    }
	    if (old && sel.anchorNode == null) { sel.addRange(old); }
	    else if (gecko) { this.startGracePeriod(); }
	  }
	  this.rememberSelection();
	};

	ContentEditableInput.prototype.startGracePeriod = function () {
	    var this$1 = this;

	  clearTimeout(this.gracePeriod);
	  this.gracePeriod = setTimeout(function () {
	    this$1.gracePeriod = false;
	    if (this$1.selectionChanged())
	      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
	  }, 20);
	};

	ContentEditableInput.prototype.showMultipleSelections = function (info) {
	  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
	  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
	};

	ContentEditableInput.prototype.rememberSelection = function () {
	  var sel = window.getSelection();
	  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
	  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
	};

	ContentEditableInput.prototype.selectionInEditor = function () {
	  var sel = window.getSelection();
	  if (!sel.rangeCount) { return false }
	  var node = sel.getRangeAt(0).commonAncestorContainer;
	  return contains(this.div, node)
	};

	ContentEditableInput.prototype.focus = function () {
	  if (this.cm.options.readOnly != "nocursor") {
	    if (!this.selectionInEditor())
	      { this.showSelection(this.prepareSelection(), true); }
	    this.div.focus();
	  }
	};
	ContentEditableInput.prototype.blur = function () { this.div.blur(); };
	ContentEditableInput.prototype.getField = function () { return this.div };

	ContentEditableInput.prototype.supportsTouch = function () { return true };

	ContentEditableInput.prototype.receivedFocus = function () {
	  var input = this;
	  if (this.selectionInEditor())
	    { this.pollSelection(); }
	  else
	    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

	  function poll() {
	    if (input.cm.state.focused) {
	      input.pollSelection();
	      input.polling.set(input.cm.options.pollInterval, poll);
	    }
	  }
	  this.polling.set(this.cm.options.pollInterval, poll);
	};

	ContentEditableInput.prototype.selectionChanged = function () {
	  var sel = window.getSelection();
	  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
	    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
	};

	ContentEditableInput.prototype.pollSelection = function () {
	  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
	  var sel = window.getSelection(), cm = this.cm;
	  // On Android Chrome (version 56, at least), backspacing into an
	  // uneditable block element will put the cursor in that element,
	  // and then, because it's not editable, hide the virtual keyboard.
	  // Because Android doesn't allow us to actually detect backspace
	  // presses in a sane way, this code checks for when that happens
	  // and simulates a backspace press in this case.
	  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
	    this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
	    this.blur();
	    this.focus();
	    return
	  }
	  if (this.composing) { return }
	  this.rememberSelection();
	  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	  var head = domToPos(cm, sel.focusNode, sel.focusOffset);
	  if (anchor && head) { runInOp(cm, function () {
	    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
	    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
	  }); }
	};

	ContentEditableInput.prototype.pollContent = function () {
	  if (this.readDOMTimeout != null) {
	    clearTimeout(this.readDOMTimeout);
	    this.readDOMTimeout = null;
	  }

	  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
	  var from = sel.from(), to = sel.to();
	  if (from.ch == 0 && from.line > cm.firstLine())
	    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
	  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
	    { to = Pos(to.line + 1, 0); }
	  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

	  var fromIndex, fromLine, fromNode;
	  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
	    fromLine = lineNo(display.view[0].line);
	    fromNode = display.view[0].node;
	  } else {
	    fromLine = lineNo(display.view[fromIndex].line);
	    fromNode = display.view[fromIndex - 1].node.nextSibling;
	  }
	  var toIndex = findViewIndex(cm, to.line);
	  var toLine, toNode;
	  if (toIndex == display.view.length - 1) {
	    toLine = display.viewTo - 1;
	    toNode = display.lineDiv.lastChild;
	  } else {
	    toLine = lineNo(display.view[toIndex + 1].line) - 1;
	    toNode = display.view[toIndex + 1].node.previousSibling;
	  }

	  if (!fromNode) { return false }
	  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
	  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
	  while (newText.length > 1 && oldText.length > 1) {
	    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
	    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
	    else { break }
	  }

	  var cutFront = 0, cutEnd = 0;
	  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
	  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
	    { ++cutFront; }
	  var newBot = lst(newText), oldBot = lst(oldText);
	  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
	                           oldBot.length - (oldText.length == 1 ? cutFront : 0));
	  while (cutEnd < maxCutEnd &&
	         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
	    { ++cutEnd; }
	  // Try to move start of change to start of selection if ambiguous
	  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
	    while (cutFront && cutFront > from.ch &&
	           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
	      cutFront--;
	      cutEnd++;
	    }
	  }

	  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
	  newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

	  var chFrom = Pos(fromLine, cutFront);
	  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
	  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
	    replaceRange(cm.doc, newText, chFrom, chTo, "+input");
	    return true
	  }
	};

	ContentEditableInput.prototype.ensurePolled = function () {
	  this.forceCompositionEnd();
	};
	ContentEditableInput.prototype.reset = function () {
	  this.forceCompositionEnd();
	};
	ContentEditableInput.prototype.forceCompositionEnd = function () {
	  if (!this.composing) { return }
	  clearTimeout(this.readDOMTimeout);
	  this.composing = null;
	  this.updateFromDOM();
	  this.div.blur();
	  this.div.focus();
	};
	ContentEditableInput.prototype.readFromDOMSoon = function () {
	    var this$1 = this;

	  if (this.readDOMTimeout != null) { return }
	  this.readDOMTimeout = setTimeout(function () {
	    this$1.readDOMTimeout = null;
	    if (this$1.composing) {
	      if (this$1.composing.done) { this$1.composing = null; }
	      else { return }
	    }
	    this$1.updateFromDOM();
	  }, 80);
	};

	ContentEditableInput.prototype.updateFromDOM = function () {
	    var this$1 = this;

	  if (this.cm.isReadOnly() || !this.pollContent())
	    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
	};

	ContentEditableInput.prototype.setUneditable = function (node) {
	  node.contentEditable = "false";
	};

	ContentEditableInput.prototype.onKeyPress = function (e) {
	  if (e.charCode == 0 || this.composing) { return }
	  e.preventDefault();
	  if (!this.cm.isReadOnly())
	    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
	};

	ContentEditableInput.prototype.readOnlyChanged = function (val) {
	  this.div.contentEditable = String(val != "nocursor");
	};

	ContentEditableInput.prototype.onContextMenu = function () {};
	ContentEditableInput.prototype.resetPosition = function () {};

	ContentEditableInput.prototype.needsContentAttribute = true;

	function posToDOM(cm, pos) {
	  var view = findViewForLine(cm, pos.line);
	  if (!view || view.hidden) { return null }
	  var line = getLine(cm.doc, pos.line);
	  var info = mapFromLineView(view, line, pos.line);

	  var order = getOrder(line, cm.doc.direction), side = "left";
	  if (order) {
	    var partPos = getBidiPartAt(order, pos.ch);
	    side = partPos % 2 ? "right" : "left";
	  }
	  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
	  result.offset = result.collapse == "right" ? result.end : result.start;
	  return result
	}

	function isInGutter(node) {
	  for (var scan = node; scan; scan = scan.parentNode)
	    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
	  return false
	}

	function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

	function domTextBetween(cm, from, to, fromLine, toLine) {
	  var text = "", closing = false, lineSep = cm.doc.lineSeparator();
	  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
	  function close() {
	    if (closing) {
	      text += lineSep;
	      closing = false;
	    }
	  }
	  function addText(str) {
	    if (str) {
	      close();
	      text += str;
	    }
	  }
	  function walk(node) {
	    if (node.nodeType == 1) {
	      var cmText = node.getAttribute("cm-text");
	      if (cmText != null) {
	        addText(cmText || node.textContent.replace(/\u200b/g, ""));
	        return
	      }
	      var markerID = node.getAttribute("cm-marker"), range$$1;
	      if (markerID) {
	        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
	        if (found.length && (range$$1 = found[0].find(0)))
	          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
	        return
	      }
	      if (node.getAttribute("contenteditable") == "false") { return }
	      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);
	      if (isBlock) { close(); }
	      for (var i = 0; i < node.childNodes.length; i++)
	        { walk(node.childNodes[i]); }
	      if (isBlock) { closing = true; }
	    } else if (node.nodeType == 3) {
	      addText(node.nodeValue);
	    }
	  }
	  for (;;) {
	    walk(from);
	    if (from == to) { break }
	    from = from.nextSibling;
	  }
	  return text
	}

	function domToPos(cm, node, offset) {
	  var lineNode;
	  if (node == cm.display.lineDiv) {
	    lineNode = cm.display.lineDiv.childNodes[offset];
	    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
	    node = null; offset = 0;
	  } else {
	    for (lineNode = node;; lineNode = lineNode.parentNode) {
	      if (!lineNode || lineNode == cm.display.lineDiv) { return null }
	      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
	    }
	  }
	  for (var i = 0; i < cm.display.view.length; i++) {
	    var lineView = cm.display.view[i];
	    if (lineView.node == lineNode)
	      { return locateNodeInLineView(lineView, node, offset) }
	  }
	}

	function locateNodeInLineView(lineView, node, offset) {
	  var wrapper = lineView.text.firstChild, bad = false;
	  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
	  if (node == wrapper) {
	    bad = true;
	    node = wrapper.childNodes[offset];
	    offset = 0;
	    if (!node) {
	      var line = lineView.rest ? lst(lineView.rest) : lineView.line;
	      return badPos(Pos(lineNo(line), line.text.length), bad)
	    }
	  }

	  var textNode = node.nodeType == 3 ? node : null, topNode = node;
	  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
	    textNode = node.firstChild;
	    if (offset) { offset = textNode.nodeValue.length; }
	  }
	  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
	  var measure = lineView.measure, maps = measure.maps;

	  function find(textNode, topNode, offset) {
	    for (var i = -1; i < (maps ? maps.length : 0); i++) {
	      var map$$1 = i < 0 ? measure.map : maps[i];
	      for (var j = 0; j < map$$1.length; j += 3) {
	        var curNode = map$$1[j + 2];
	        if (curNode == textNode || curNode == topNode) {
	          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
	          var ch = map$$1[j] + offset;
	          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
	          return Pos(line, ch)
	        }
	      }
	    }
	  }
	  var found = find(textNode, topNode, offset);
	  if (found) { return badPos(found, bad) }

	  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
	  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
	    found = find(after, after.firstChild, 0);
	    if (found)
	      { return badPos(Pos(found.line, found.ch - dist), bad) }
	    else
	      { dist += after.textContent.length; }
	  }
	  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
	    found = find(before, before.firstChild, -1);
	    if (found)
	      { return badPos(Pos(found.line, found.ch + dist$1), bad) }
	    else
	      { dist$1 += before.textContent.length; }
	  }
	}

	// TEXTAREA INPUT STYLE

	var TextareaInput = function(cm) {
	  this.cm = cm;
	  // See input.poll and input.reset
	  this.prevInput = "";

	  // Flag that indicates whether we expect input to appear real soon
	  // now (after some event like 'keypress' or 'input') and are
	  // polling intensively.
	  this.pollingFast = false;
	  // Self-resetting timeout for the poller
	  this.polling = new Delayed();
	  // Used to work around IE issue with selection being forgotten when focus moves away from textarea
	  this.hasSelection = false;
	  this.composing = null;
	};

	TextareaInput.prototype.init = function (display) {
	    var this$1 = this;

	  var input = this, cm = this.cm;
	  this.createField(display);
	  var te = this.textarea;

	  display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

	  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
	  if (ios) { te.style.width = "0px"; }

	  on(te, "input", function () {
	    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
	    input.poll();
	  });

	  on(te, "paste", function (e) {
	    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

	    cm.state.pasteIncoming = true;
	    input.fastPoll();
	  });

	  function prepareCopyCut(e) {
	    if (signalDOMEvent(cm, e)) { return }
	    if (cm.somethingSelected()) {
	      setLastCopied({lineWise: false, text: cm.getSelections()});
	    } else if (!cm.options.lineWiseCopyCut) {
	      return
	    } else {
	      var ranges = copyableRanges(cm);
	      setLastCopied({lineWise: true, text: ranges.text});
	      if (e.type == "cut") {
	        cm.setSelections(ranges.ranges, null, sel_dontScroll);
	      } else {
	        input.prevInput = "";
	        te.value = ranges.text.join("\n");
	        selectInput(te);
	      }
	    }
	    if (e.type == "cut") { cm.state.cutIncoming = true; }
	  }
	  on(te, "cut", prepareCopyCut);
	  on(te, "copy", prepareCopyCut);

	  on(display.scroller, "paste", function (e) {
	    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
	    cm.state.pasteIncoming = true;
	    input.focus();
	  });

	  // Prevent normal selection in the editor (we handle our own)
	  on(display.lineSpace, "selectstart", function (e) {
	    if (!eventInWidget(display, e)) { e_preventDefault(e); }
	  });

	  on(te, "compositionstart", function () {
	    var start = cm.getCursor("from");
	    if (input.composing) { input.composing.range.clear(); }
	    input.composing = {
	      start: start,
	      range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
	    };
	  });
	  on(te, "compositionend", function () {
	    if (input.composing) {
	      input.poll();
	      input.composing.range.clear();
	      input.composing = null;
	    }
	  });
	};

	TextareaInput.prototype.createField = function (_display) {
	  // Wraps and hides input textarea
	  this.wrapper = hiddenTextarea();
	  // The semihidden textarea that is focused when the editor is
	  // focused, and receives input.
	  this.textarea = this.wrapper.firstChild;
	};

	TextareaInput.prototype.prepareSelection = function () {
	  // Redraw the selection and/or cursor
	  var cm = this.cm, display = cm.display, doc = cm.doc;
	  var result = prepareSelection(cm);

	  // Move the hidden textarea near the cursor to prevent scrolling artifacts
	  if (cm.options.moveInputWithCursor) {
	    var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
	    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
	    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
	                                        headPos.top + lineOff.top - wrapOff.top));
	    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
	                                         headPos.left + lineOff.left - wrapOff.left));
	  }

	  return result
	};

	TextareaInput.prototype.showSelection = function (drawn) {
	  var cm = this.cm, display = cm.display;
	  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
	  removeChildrenAndAdd(display.selectionDiv, drawn.selection);
	  if (drawn.teTop != null) {
	    this.wrapper.style.top = drawn.teTop + "px";
	    this.wrapper.style.left = drawn.teLeft + "px";
	  }
	};

	// Reset the input to correspond to the selection (or to be empty,
	// when not typing and nothing is selected)
	TextareaInput.prototype.reset = function (typing) {
	  if (this.contextMenuPending || this.composing) { return }
	  var cm = this.cm;
	  if (cm.somethingSelected()) {
	    this.prevInput = "";
	    var content = cm.getSelection();
	    this.textarea.value = content;
	    if (cm.state.focused) { selectInput(this.textarea); }
	    if (ie && ie_version >= 9) { this.hasSelection = content; }
	  } else if (!typing) {
	    this.prevInput = this.textarea.value = "";
	    if (ie && ie_version >= 9) { this.hasSelection = null; }
	  }
	};

	TextareaInput.prototype.getField = function () { return this.textarea };

	TextareaInput.prototype.supportsTouch = function () { return false };

	TextareaInput.prototype.focus = function () {
	  if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
	    try { this.textarea.focus(); }
	    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
	  }
	};

	TextareaInput.prototype.blur = function () { this.textarea.blur(); };

	TextareaInput.prototype.resetPosition = function () {
	  this.wrapper.style.top = this.wrapper.style.left = 0;
	};

	TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

	// Poll for input changes, using the normal rate of polling. This
	// runs as long as the editor is focused.
	TextareaInput.prototype.slowPoll = function () {
	    var this$1 = this;

	  if (this.pollingFast) { return }
	  this.polling.set(this.cm.options.pollInterval, function () {
	    this$1.poll();
	    if (this$1.cm.state.focused) { this$1.slowPoll(); }
	  });
	};

	// When an event has just come in that is likely to add or change
	// something in the input textarea, we poll faster, to ensure that
	// the change appears on the screen quickly.
	TextareaInput.prototype.fastPoll = function () {
	  var missed = false, input = this;
	  input.pollingFast = true;
	  function p() {
	    var changed = input.poll();
	    if (!changed && !missed) {missed = true; input.polling.set(60, p);}
	    else {input.pollingFast = false; input.slowPoll();}
	  }
	  input.polling.set(20, p);
	};

	// Read input from the textarea, and update the document to match.
	// When something is selected, it is present in the textarea, and
	// selected (unless it is huge, in which case a placeholder is
	// used). When nothing is selected, the cursor sits after previously
	// seen text (can be empty), which is stored in prevInput (we must
	// not reset the textarea when typing, because that breaks IME).
	TextareaInput.prototype.poll = function () {
	    var this$1 = this;

	  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
	  // Since this is called a *lot*, try to bail out as cheaply as
	  // possible when it is clear that nothing happened. hasSelection
	  // will be the case when there is a lot of text in the textarea,
	  // in which case reading its value would be expensive.
	  if (this.contextMenuPending || !cm.state.focused ||
	      (hasSelection(input) && !prevInput && !this.composing) ||
	      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
	    { return false }

	  var text = input.value;
	  // If nothing changed, bail.
	  if (text == prevInput && !cm.somethingSelected()) { return false }
	  // Work around nonsensical selection resetting in IE9/10, and
	  // inexplicable appearance of private area unicode characters on
	  // some key combos in Mac (#2689).
	  if (ie && ie_version >= 9 && this.hasSelection === text ||
	      mac && /[\uf700-\uf7ff]/.test(text)) {
	    cm.display.input.reset();
	    return false
	  }

	  if (cm.doc.sel == cm.display.selForContextMenu) {
	    var first = text.charCodeAt(0);
	    if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
	    if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
	  }
	  // Find the part of the input that is actually new
	  var same = 0, l = Math.min(prevInput.length, text.length);
	  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

	  runInOp(cm, function () {
	    applyTextInput(cm, text.slice(same), prevInput.length - same,
	                   null, this$1.composing ? "*compose" : null);

	    // Don't leave long text in the textarea, since it makes further polling slow
	    if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
	    else { this$1.prevInput = text; }

	    if (this$1.composing) {
	      this$1.composing.range.clear();
	      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
	                                         {className: "CodeMirror-composing"});
	    }
	  });
	  return true
	};

	TextareaInput.prototype.ensurePolled = function () {
	  if (this.pollingFast && this.poll()) { this.pollingFast = false; }
	};

	TextareaInput.prototype.onKeyPress = function () {
	  if (ie && ie_version >= 9) { this.hasSelection = null; }
	  this.fastPoll();
	};

	TextareaInput.prototype.onContextMenu = function (e) {
	  var input = this, cm = input.cm, display = cm.display, te = input.textarea;
	  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
	  if (!pos || presto) { return } // Opera is difficult.

	  // Reset the current text selection only if the click is done outside of the selection
	  // and 'resetSelectionOnContextMenu' option is true.
	  var reset = cm.options.resetSelectionOnContextMenu;
	  if (reset && cm.doc.sel.contains(pos) == -1)
	    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

	  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
	  input.wrapper.style.cssText = "position: absolute";
	  var wrapperBox = input.wrapper.getBoundingClientRect();
	  te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
	  var oldScrollY;
	  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
	  display.input.focus();
	  if (webkit) { window.scrollTo(null, oldScrollY); }
	  display.input.reset();
	  // Adds "Select all" to context menu in FF
	  if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
	  input.contextMenuPending = true;
	  display.selForContextMenu = cm.doc.sel;
	  clearTimeout(display.detectingSelectAll);

	  // Select-all will be greyed out if there's nothing to select, so
	  // this adds a zero-width space so that we can later check whether
	  // it got selected.
	  function prepareSelectAllHack() {
	    if (te.selectionStart != null) {
	      var selected = cm.somethingSelected();
	      var extval = "\u200b" + (selected ? te.value : "");
	      te.value = "\u21da"; // Used to catch context-menu undo
	      te.value = extval;
	      input.prevInput = selected ? "" : "\u200b";
	      te.selectionStart = 1; te.selectionEnd = extval.length;
	      // Re-set this, in case some other handler touched the
	      // selection in the meantime.
	      display.selForContextMenu = cm.doc.sel;
	    }
	  }
	  function rehide() {
	    input.contextMenuPending = false;
	    input.wrapper.style.cssText = oldWrapperCSS;
	    te.style.cssText = oldCSS;
	    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

	    // Try to detect the user choosing select-all
	    if (te.selectionStart != null) {
	      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
	      var i = 0, poll = function () {
	        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
	            te.selectionEnd > 0 && input.prevInput == "\u200b") {
	          operation(cm, selectAll)(cm);
	        } else if (i++ < 10) {
	          display.detectingSelectAll = setTimeout(poll, 500);
	        } else {
	          display.selForContextMenu = null;
	          display.input.reset();
	        }
	      };
	      display.detectingSelectAll = setTimeout(poll, 200);
	    }
	  }

	  if (ie && ie_version >= 9) { prepareSelectAllHack(); }
	  if (captureRightClick) {
	    e_stop(e);
	    var mouseup = function () {
	      off(window, "mouseup", mouseup);
	      setTimeout(rehide, 20);
	    };
	    on(window, "mouseup", mouseup);
	  } else {
	    setTimeout(rehide, 50);
	  }
	};

	TextareaInput.prototype.readOnlyChanged = function (val) {
	  if (!val) { this.reset(); }
	  this.textarea.disabled = val == "nocursor";
	};

	TextareaInput.prototype.setUneditable = function () {};

	TextareaInput.prototype.needsContentAttribute = false;

	function fromTextArea(textarea, options) {
	  options = options ? copyObj(options) : {};
	  options.value = textarea.value;
	  if (!options.tabindex && textarea.tabIndex)
	    { options.tabindex = textarea.tabIndex; }
	  if (!options.placeholder && textarea.placeholder)
	    { options.placeholder = textarea.placeholder; }
	  // Set autofocus to true if this textarea is focused, or if it has
	  // autofocus and no other element is focused.
	  if (options.autofocus == null) {
	    var hasFocus = activeElt();
	    options.autofocus = hasFocus == textarea ||
	      textarea.getAttribute("autofocus") != null && hasFocus == document.body;
	  }

	  function save() {textarea.value = cm.getValue();}

	  var realSubmit;
	  if (textarea.form) {
	    on(textarea.form, "submit", save);
	    // Deplorable hack to make the submit method do the right thing.
	    if (!options.leaveSubmitMethodAlone) {
	      var form = textarea.form;
	      realSubmit = form.submit;
	      try {
	        var wrappedSubmit = form.submit = function () {
	          save();
	          form.submit = realSubmit;
	          form.submit();
	          form.submit = wrappedSubmit;
	        };
	      } catch(e) {}
	    }
	  }

	  options.finishInit = function (cm) {
	    cm.save = save;
	    cm.getTextArea = function () { return textarea; };
	    cm.toTextArea = function () {
	      cm.toTextArea = isNaN; // Prevent this from being ran twice
	      save();
	      textarea.parentNode.removeChild(cm.getWrapperElement());
	      textarea.style.display = "";
	      if (textarea.form) {
	        off(textarea.form, "submit", save);
	        if (typeof textarea.form.submit == "function")
	          { textarea.form.submit = realSubmit; }
	      }
	    };
	  };

	  textarea.style.display = "none";
	  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
	    options);
	  return cm
	}

	function addLegacyProps(CodeMirror) {
	  CodeMirror.off = off;
	  CodeMirror.on = on;
	  CodeMirror.wheelEventPixels = wheelEventPixels;
	  CodeMirror.Doc = Doc;
	  CodeMirror.splitLines = splitLinesAuto;
	  CodeMirror.countColumn = countColumn;
	  CodeMirror.findColumn = findColumn;
	  CodeMirror.isWordChar = isWordCharBasic;
	  CodeMirror.Pass = Pass;
	  CodeMirror.signal = signal;
	  CodeMirror.Line = Line;
	  CodeMirror.changeEnd = changeEnd;
	  CodeMirror.scrollbarModel = scrollbarModel;
	  CodeMirror.Pos = Pos;
	  CodeMirror.cmpPos = cmp;
	  CodeMirror.modes = modes;
	  CodeMirror.mimeModes = mimeModes;
	  CodeMirror.resolveMode = resolveMode;
	  CodeMirror.getMode = getMode;
	  CodeMirror.modeExtensions = modeExtensions;
	  CodeMirror.extendMode = extendMode;
	  CodeMirror.copyState = copyState;
	  CodeMirror.startState = startState;
	  CodeMirror.innerMode = innerMode;
	  CodeMirror.commands = commands;
	  CodeMirror.keyMap = keyMap;
	  CodeMirror.keyName = keyName;
	  CodeMirror.isModifierKey = isModifierKey;
	  CodeMirror.lookupKey = lookupKey;
	  CodeMirror.normalizeKeyMap = normalizeKeyMap;
	  CodeMirror.StringStream = StringStream;
	  CodeMirror.SharedTextMarker = SharedTextMarker;
	  CodeMirror.TextMarker = TextMarker;
	  CodeMirror.LineWidget = LineWidget;
	  CodeMirror.e_preventDefault = e_preventDefault;
	  CodeMirror.e_stopPropagation = e_stopPropagation;
	  CodeMirror.e_stop = e_stop;
	  CodeMirror.addClass = addClass;
	  CodeMirror.contains = contains;
	  CodeMirror.rmClass = rmClass;
	  CodeMirror.keyNames = keyNames;
	}

	// EDITOR CONSTRUCTOR

	defineOptions(CodeMirror$1);

	addEditorMethods(CodeMirror$1);

	// Set up methods on CodeMirror's prototype to redirect to the editor's document.
	var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
	for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
	  { CodeMirror$1.prototype[prop] = (function(method) {
	    return function() {return method.apply(this.doc, arguments)}
	  })(Doc.prototype[prop]); } }

	eventMixin(Doc);

	// INPUT HANDLING

	CodeMirror$1.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

	// MODE DEFINITION AND QUERYING

	// Extra arguments are stored as the mode's dependencies, which is
	// used by (legacy) mechanisms like loadmode.js to automatically
	// load a mode. (Preferred mechanism is the require/define calls.)
	CodeMirror$1.defineMode = function(name/*, mode, */) {
	  if (!CodeMirror$1.defaults.mode && name != "null") { CodeMirror$1.defaults.mode = name; }
	  defineMode.apply(this, arguments);
	};

	CodeMirror$1.defineMIME = defineMIME;

	// Minimal default mode.
	CodeMirror$1.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
	CodeMirror$1.defineMIME("text/plain", "null");

	// EXTENSIONS

	CodeMirror$1.defineExtension = function (name, func) {
	  CodeMirror$1.prototype[name] = func;
	};
	CodeMirror$1.defineDocExtension = function (name, func) {
	  Doc.prototype[name] = func;
	};

	CodeMirror$1.fromTextArea = fromTextArea;

	addLegacyProps(CodeMirror$1);

	CodeMirror$1.version = "5.37.0";

	return CodeMirror$1;

	})));


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(211));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";

	  var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
	  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

	  // This is the old interface, kept around for now to stay
	  // backwards-compatible.
	  CodeMirror.showHint = function(cm, getHints, options) {
	    if (!getHints) return cm.showHint(options);
	    if (options && options.async) getHints.async = true;
	    var newOpts = {hint: getHints};
	    if (options) for (var prop in options) newOpts[prop] = options[prop];
	    return cm.showHint(newOpts);
	  };

	  CodeMirror.defineExtension("showHint", function(options) {
	    options = parseOptions(this, this.getCursor("start"), options);
	    var selections = this.listSelections()
	    if (selections.length > 1) return;
	    // By default, don't allow completion when something is selected.
	    // A hint function can have a `supportsSelection` property to
	    // indicate that it can handle selections.
	    if (this.somethingSelected()) {
	      if (!options.hint.supportsSelection) return;
	      // Don't try with cross-line selections
	      for (var i = 0; i < selections.length; i++)
	        if (selections[i].head.line != selections[i].anchor.line) return;
	    }

	    if (this.state.completionActive) this.state.completionActive.close();
	    var completion = this.state.completionActive = new Completion(this, options);
	    if (!completion.options.hint) return;

	    CodeMirror.signal(this, "startCompletion", this);
	    completion.update(true);
	  });

	  function Completion(cm, options) {
	    this.cm = cm;
	    this.options = options;
	    this.widget = null;
	    this.debounce = 0;
	    this.tick = 0;
	    this.startPos = this.cm.getCursor("start");
	    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;

	    var self = this;
	    cm.on("cursorActivity", this.activityFunc = function() { self.cursorActivity(); });
	  }

	  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
	    return setTimeout(fn, 1000/60);
	  };
	  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

	  Completion.prototype = {
	    close: function() {
	      if (!this.active()) return;
	      this.cm.state.completionActive = null;
	      this.tick = null;
	      this.cm.off("cursorActivity", this.activityFunc);

	      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
	      if (this.widget) this.widget.close();
	      CodeMirror.signal(this.cm, "endCompletion", this.cm);
	    },

	    active: function() {
	      return this.cm.state.completionActive == this;
	    },

	    pick: function(data, i) {
	      var completion = data.list[i];
	      if (completion.hint) completion.hint(this.cm, data, completion);
	      else this.cm.replaceRange(getText(completion), completion.from || data.from,
	                                completion.to || data.to, "complete");
	      CodeMirror.signal(data, "pick", completion);
	      this.close();
	    },

	    cursorActivity: function() {
	      if (this.debounce) {
	        cancelAnimationFrame(this.debounce);
	        this.debounce = 0;
	      }

	      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
	      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||
	          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||
	          (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
	        this.close();
	      } else {
	        var self = this;
	        this.debounce = requestAnimationFrame(function() {self.update();});
	        if (this.widget) this.widget.disable();
	      }
	    },

	    update: function(first) {
	      if (this.tick == null) return
	      var self = this, myTick = ++this.tick
	      fetchHints(this.options.hint, this.cm, this.options, function(data) {
	        if (self.tick == myTick) self.finishUpdate(data, first)
	      })
	    },

	    finishUpdate: function(data, first) {
	      if (this.data) CodeMirror.signal(this.data, "update");

	      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
	      if (this.widget) this.widget.close();

	      this.data = data;

	      if (data && data.list.length) {
	        if (picked && data.list.length == 1) {
	          this.pick(data, 0);
	        } else {
	          this.widget = new Widget(this, data);
	          CodeMirror.signal(data, "shown");
	        }
	      }
	    }
	  };

	  function parseOptions(cm, pos, options) {
	    var editor = cm.options.hintOptions;
	    var out = {};
	    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
	    if (editor) for (var prop in editor)
	      if (editor[prop] !== undefined) out[prop] = editor[prop];
	    if (options) for (var prop in options)
	      if (options[prop] !== undefined) out[prop] = options[prop];
	    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)
	    return out;
	  }

	  function getText(completion) {
	    if (typeof completion == "string") return completion;
	    else return completion.text;
	  }

	  function buildKeyMap(completion, handle) {
	    var baseMap = {
	      Up: function() {handle.moveFocus(-1);},
	      Down: function() {handle.moveFocus(1);},
	      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},
	      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},
	      Home: function() {handle.setFocus(0);},
	      End: function() {handle.setFocus(handle.length - 1);},
	      Enter: handle.pick,
	      Tab: handle.pick,
	      Esc: handle.close
	    };
	    var custom = completion.options.customKeys;
	    var ourMap = custom ? {} : baseMap;
	    function addBinding(key, val) {
	      var bound;
	      if (typeof val != "string")
	        bound = function(cm) { return val(cm, handle); };
	      // This mechanism is deprecated
	      else if (baseMap.hasOwnProperty(val))
	        bound = baseMap[val];
	      else
	        bound = val;
	      ourMap[key] = bound;
	    }
	    if (custom)
	      for (var key in custom) if (custom.hasOwnProperty(key))
	        addBinding(key, custom[key]);
	    var extra = completion.options.extraKeys;
	    if (extra)
	      for (var key in extra) if (extra.hasOwnProperty(key))
	        addBinding(key, extra[key]);
	    return ourMap;
	  }

	  function getHintElement(hintsElement, el) {
	    while (el && el != hintsElement) {
	      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
	      el = el.parentNode;
	    }
	  }

	  function Widget(completion, data) {
	    this.completion = completion;
	    this.data = data;
	    this.picked = false;
	    var widget = this, cm = completion.cm;

	    var hints = this.hints = document.createElement("ul");
	    hints.className = "CodeMirror-hints";
	    this.selectedHint = data.selectedHint || 0;

	    var completions = data.list;
	    for (var i = 0; i < completions.length; ++i) {
	      var elt = hints.appendChild(document.createElement("li")), cur = completions[i];
	      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
	      if (cur.className != null) className = cur.className + " " + className;
	      elt.className = className;
	      if (cur.render) cur.render(elt, data, cur);
	      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
	      elt.hintId = i;
	    }

	    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
	    var left = pos.left, top = pos.bottom, below = true;
	    hints.style.left = left + "px";
	    hints.style.top = top + "px";
	    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
	    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
	    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
	    (completion.options.container || document.body).appendChild(hints);
	    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;
	    var scrolls = hints.scrollHeight > hints.clientHeight + 1
	    var startScroll = cm.getScrollInfo();

	    if (overlapY > 0) {
	      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
	      if (curTop - height > 0) { // Fits above cursor
	        hints.style.top = (top = pos.top - height) + "px";
	        below = false;
	      } else if (height > winH) {
	        hints.style.height = (winH - 5) + "px";
	        hints.style.top = (top = pos.bottom - box.top) + "px";
	        var cursor = cm.getCursor();
	        if (data.from.ch != cursor.ch) {
	          pos = cm.cursorCoords(cursor);
	          hints.style.left = (left = pos.left) + "px";
	          box = hints.getBoundingClientRect();
	        }
	      }
	    }
	    var overlapX = box.right - winW;
	    if (overlapX > 0) {
	      if (box.right - box.left > winW) {
	        hints.style.width = (winW - 5) + "px";
	        overlapX -= (box.right - box.left) - winW;
	      }
	      hints.style.left = (left = pos.left - overlapX) + "px";
	    }
	    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)
	      node.style.paddingRight = cm.display.nativeBarWidth + "px"

	    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
	      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
	      setFocus: function(n) { widget.changeActive(n); },
	      menuSize: function() { return widget.screenAmount(); },
	      length: completions.length,
	      close: function() { completion.close(); },
	      pick: function() { widget.pick(); },
	      data: data
	    }));

	    if (completion.options.closeOnUnfocus) {
	      var closingOnBlur;
	      cm.on("blur", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });
	      cm.on("focus", this.onFocus = function() { clearTimeout(closingOnBlur); });
	    }

	    cm.on("scroll", this.onScroll = function() {
	      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
	      var newTop = top + startScroll.top - curScroll.top;
	      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
	      if (!below) point += hints.offsetHeight;
	      if (point <= editor.top || point >= editor.bottom) return completion.close();
	      hints.style.top = newTop + "px";
	      hints.style.left = (left + startScroll.left - curScroll.left) + "px";
	    });

	    CodeMirror.on(hints, "dblclick", function(e) {
	      var t = getHintElement(hints, e.target || e.srcElement);
	      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}
	    });

	    CodeMirror.on(hints, "click", function(e) {
	      var t = getHintElement(hints, e.target || e.srcElement);
	      if (t && t.hintId != null) {
	        widget.changeActive(t.hintId);
	        if (completion.options.completeOnSingleClick) widget.pick();
	      }
	    });

	    CodeMirror.on(hints, "mousedown", function() {
	      setTimeout(function(){cm.focus();}, 20);
	    });

	    CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
	    return true;
	  }

	  Widget.prototype = {
	    close: function() {
	      if (this.completion.widget != this) return;
	      this.completion.widget = null;
	      this.hints.parentNode.removeChild(this.hints);
	      this.completion.cm.removeKeyMap(this.keyMap);

	      var cm = this.completion.cm;
	      if (this.completion.options.closeOnUnfocus) {
	        cm.off("blur", this.onBlur);
	        cm.off("focus", this.onFocus);
	      }
	      cm.off("scroll", this.onScroll);
	    },

	    disable: function() {
	      this.completion.cm.removeKeyMap(this.keyMap);
	      var widget = this;
	      this.keyMap = {Enter: function() { widget.picked = true; }};
	      this.completion.cm.addKeyMap(this.keyMap);
	    },

	    pick: function() {
	      this.completion.pick(this.data, this.selectedHint);
	    },

	    changeActive: function(i, avoidWrap) {
	      if (i >= this.data.list.length)
	        i = avoidWrap ? this.data.list.length - 1 : 0;
	      else if (i < 0)
	        i = avoidWrap ? 0  : this.data.list.length - 1;
	      if (this.selectedHint == i) return;
	      var node = this.hints.childNodes[this.selectedHint];
	      node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
	      node = this.hints.childNodes[this.selectedHint = i];
	      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
	      if (node.offsetTop < this.hints.scrollTop)
	        this.hints.scrollTop = node.offsetTop - 3;
	      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
	        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
	      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
	    },

	    screenAmount: function() {
	      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
	    }
	  };

	  function applicableHelpers(cm, helpers) {
	    if (!cm.somethingSelected()) return helpers
	    var result = []
	    for (var i = 0; i < helpers.length; i++)
	      if (helpers[i].supportsSelection) result.push(helpers[i])
	    return result
	  }

	  function fetchHints(hint, cm, options, callback) {
	    if (hint.async) {
	      hint(cm, callback, options)
	    } else {
	      var result = hint(cm, options)
	      if (result && result.then) result.then(callback)
	      else callback(result)
	    }
	  }

	  function resolveAutoHints(cm, pos) {
	    var helpers = cm.getHelpers(pos, "hint"), words
	    if (helpers.length) {
	      var resolved = function(cm, callback, options) {
	        var app = applicableHelpers(cm, helpers);
	        function run(i) {
	          if (i == app.length) return callback(null)
	          fetchHints(app[i], cm, options, function(result) {
	            if (result && result.list.length > 0) callback(result)
	            else run(i + 1)
	          })
	        }
	        run(0)
	      }
	      resolved.async = true
	      resolved.supportsSelection = true
	      return resolved
	    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
	      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }
	    } else if (CodeMirror.hint.anyword) {
	      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }
	    } else {
	      return function() {}
	    }
	  }

	  CodeMirror.registerHelper("hint", "auto", {
	    resolve: resolveAutoHints
	  });

	  CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
	    var cur = cm.getCursor(), token = cm.getTokenAt(cur)
	    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur
	    if (token.start < cur.ch && /\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
	      term = token.string.substr(0, cur.ch - token.start)
	    } else {
	      term = ""
	      from = cur
	    }
	    var found = [];
	    for (var i = 0; i < options.words.length; i++) {
	      var word = options.words[i];
	      if (word.slice(0, term.length) == term)
	        found.push(word);
	    }

	    if (found.length) return {list: found, from: from, to: to};
	  });

	  CodeMirror.commands.autocomplete = CodeMirror.showHint;

	  var defaultOptions = {
	    hint: CodeMirror.hint.auto,
	    completeSingle: true,
	    alignWithWord: true,
	    closeCharacters: /[\s()\[\]{};:>,]/,
	    closeOnUnfocus: true,
	    completeOnSingleClick: true,
	    container: null,
	    customKeys: null,
	    extraKeys: null
	  };

	  CodeMirror.defineOption("hintOptions", null);
	});


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(211), __webpack_require__(214));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror", "../../mode/css/css"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";

	  var pseudoClasses = {link: 1, visited: 1, active: 1, hover: 1, focus: 1,
	                       "first-letter": 1, "first-line": 1, "first-child": 1,
	                       before: 1, after: 1, lang: 1};

	  CodeMirror.registerHelper("hint", "css", function(cm) {
	    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
	    var inner = CodeMirror.innerMode(cm.getMode(), token.state);
	    if (inner.mode.name != "css") return;

	    if (token.type == "keyword" && "!important".indexOf(token.string) == 0)
	      return {list: ["!important"], from: CodeMirror.Pos(cur.line, token.start),
	              to: CodeMirror.Pos(cur.line, token.end)};

	    var start = token.start, end = cur.ch, word = token.string.slice(0, end - start);
	    if (/[^\w$_-]/.test(word)) {
	      word = ""; start = end = cur.ch;
	    }

	    var spec = CodeMirror.resolveMode("text/css");

	    var result = [];
	    function add(keywords) {
	      for (var name in keywords)
	        if (!word || name.lastIndexOf(word, 0) == 0)
	          result.push(name);
	    }

	    var st = inner.state.state;
	    if (st == "pseudo" || token.type == "variable-3") {
	      add(pseudoClasses);
	    } else if (st == "block" || st == "maybeprop") {
	      add(spec.propertyKeywords);
	    } else if (st == "prop" || st == "parens" || st == "at" || st == "params") {
	      add(spec.valueKeywords);
	      add(spec.colorKeywords);
	    } else if (st == "media" || st == "media_parens") {
	      add(spec.mediaTypes);
	      add(spec.mediaFeatures);
	    }

	    if (result.length) return {
	      list: result,
	      from: CodeMirror.Pos(cur.line, start),
	      to: CodeMirror.Pos(cur.line, end)
	    };
	  });
	});


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(211));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";

	CodeMirror.defineMode("css", function(config, parserConfig) {
	  var inline = parserConfig.inline
	  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

	  var indentUnit = config.indentUnit,
	      tokenHooks = parserConfig.tokenHooks,
	      documentTypes = parserConfig.documentTypes || {},
	      mediaTypes = parserConfig.mediaTypes || {},
	      mediaFeatures = parserConfig.mediaFeatures || {},
	      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
	      propertyKeywords = parserConfig.propertyKeywords || {},
	      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
	      fontProperties = parserConfig.fontProperties || {},
	      counterDescriptors = parserConfig.counterDescriptors || {},
	      colorKeywords = parserConfig.colorKeywords || {},
	      valueKeywords = parserConfig.valueKeywords || {},
	      allowNested = parserConfig.allowNested,
	      lineComment = parserConfig.lineComment,
	      supportsAtComponent = parserConfig.supportsAtComponent === true;

	  var type, override;
	  function ret(style, tp) { type = tp; return style; }

	  // Tokenizers

	  function tokenBase(stream, state) {
	    var ch = stream.next();
	    if (tokenHooks[ch]) {
	      var result = tokenHooks[ch](stream, state);
	      if (result !== false) return result;
	    }
	    if (ch == "@") {
	      stream.eatWhile(/[\w\\\-]/);
	      return ret("def", stream.current());
	    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
	      return ret(null, "compare");
	    } else if (ch == "\"" || ch == "'") {
	      state.tokenize = tokenString(ch);
	      return state.tokenize(stream, state);
	    } else if (ch == "#") {
	      stream.eatWhile(/[\w\\\-]/);
	      return ret("atom", "hash");
	    } else if (ch == "!") {
	      stream.match(/^\s*\w*/);
	      return ret("keyword", "important");
	    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
	      stream.eatWhile(/[\w.%]/);
	      return ret("number", "unit");
	    } else if (ch === "-") {
	      if (/[\d.]/.test(stream.peek())) {
	        stream.eatWhile(/[\w.%]/);
	        return ret("number", "unit");
	      } else if (stream.match(/^-[\w\\\-]+/)) {
	        stream.eatWhile(/[\w\\\-]/);
	        if (stream.match(/^\s*:/, false))
	          return ret("variable-2", "variable-definition");
	        return ret("variable-2", "variable");
	      } else if (stream.match(/^\w+-/)) {
	        return ret("meta", "meta");
	      }
	    } else if (/[,+>*\/]/.test(ch)) {
	      return ret(null, "select-op");
	    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
	      return ret("qualifier", "qualifier");
	    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
	      return ret(null, ch);
	    } else if (((ch == "u" || ch == "U") && stream.match(/rl(-prefix)?\(/i)) ||
	               ((ch == "d" || ch == "D") && stream.match("omain(", true, true)) ||
	               ((ch == "r" || ch == "R") && stream.match("egexp(", true, true))) {
	      stream.backUp(1);
	      state.tokenize = tokenParenthesized;
	      return ret("property", "word");
	    } else if (/[\w\\\-]/.test(ch)) {
	      stream.eatWhile(/[\w\\\-]/);
	      return ret("property", "word");
	    } else {
	      return ret(null, null);
	    }
	  }

	  function tokenString(quote) {
	    return function(stream, state) {
	      var escaped = false, ch;
	      while ((ch = stream.next()) != null) {
	        if (ch == quote && !escaped) {
	          if (quote == ")") stream.backUp(1);
	          break;
	        }
	        escaped = !escaped && ch == "\\";
	      }
	      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
	      return ret("string", "string");
	    };
	  }

	  function tokenParenthesized(stream, state) {
	    stream.next(); // Must be '('
	    if (!stream.match(/\s*[\"\')]/, false))
	      state.tokenize = tokenString(")");
	    else
	      state.tokenize = null;
	    return ret(null, "(");
	  }

	  // Context management

	  function Context(type, indent, prev) {
	    this.type = type;
	    this.indent = indent;
	    this.prev = prev;
	  }

	  function pushContext(state, stream, type, indent) {
	    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
	    return type;
	  }

	  function popContext(state) {
	    if (state.context.prev)
	      state.context = state.context.prev;
	    return state.context.type;
	  }

	  function pass(type, stream, state) {
	    return states[state.context.type](type, stream, state);
	  }
	  function popAndPass(type, stream, state, n) {
	    for (var i = n || 1; i > 0; i--)
	      state.context = state.context.prev;
	    return pass(type, stream, state);
	  }

	  // Parser

	  function wordAsValue(stream) {
	    var word = stream.current().toLowerCase();
	    if (valueKeywords.hasOwnProperty(word))
	      override = "atom";
	    else if (colorKeywords.hasOwnProperty(word))
	      override = "keyword";
	    else
	      override = "variable";
	  }

	  var states = {};

	  states.top = function(type, stream, state) {
	    if (type == "{") {
	      return pushContext(state, stream, "block");
	    } else if (type == "}" && state.context.prev) {
	      return popContext(state);
	    } else if (supportsAtComponent && /@component/i.test(type)) {
	      return pushContext(state, stream, "atComponentBlock");
	    } else if (/^@(-moz-)?document$/i.test(type)) {
	      return pushContext(state, stream, "documentTypes");
	    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
	      return pushContext(state, stream, "atBlock");
	    } else if (/^@(font-face|counter-style)/i.test(type)) {
	      state.stateArg = type;
	      return "restricted_atBlock_before";
	    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
	      return "keyframes";
	    } else if (type && type.charAt(0) == "@") {
	      return pushContext(state, stream, "at");
	    } else if (type == "hash") {
	      override = "builtin";
	    } else if (type == "word") {
	      override = "tag";
	    } else if (type == "variable-definition") {
	      return "maybeprop";
	    } else if (type == "interpolation") {
	      return pushContext(state, stream, "interpolation");
	    } else if (type == ":") {
	      return "pseudo";
	    } else if (allowNested && type == "(") {
	      return pushContext(state, stream, "parens");
	    }
	    return state.context.type;
	  };

	  states.block = function(type, stream, state) {
	    if (type == "word") {
	      var word = stream.current().toLowerCase();
	      if (propertyKeywords.hasOwnProperty(word)) {
	        override = "property";
	        return "maybeprop";
	      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
	        override = "string-2";
	        return "maybeprop";
	      } else if (allowNested) {
	        override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
	        return "block";
	      } else {
	        override += " error";
	        return "maybeprop";
	      }
	    } else if (type == "meta") {
	      return "block";
	    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
	      override = "error";
	      return "block";
	    } else {
	      return states.top(type, stream, state);
	    }
	  };

	  states.maybeprop = function(type, stream, state) {
	    if (type == ":") return pushContext(state, stream, "prop");
	    return pass(type, stream, state);
	  };

	  states.prop = function(type, stream, state) {
	    if (type == ";") return popContext(state);
	    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
	    if (type == "}" || type == "{") return popAndPass(type, stream, state);
	    if (type == "(") return pushContext(state, stream, "parens");

	    if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
	      override += " error";
	    } else if (type == "word") {
	      wordAsValue(stream);
	    } else if (type == "interpolation") {
	      return pushContext(state, stream, "interpolation");
	    }
	    return "prop";
	  };

	  states.propBlock = function(type, _stream, state) {
	    if (type == "}") return popContext(state);
	    if (type == "word") { override = "property"; return "maybeprop"; }
	    return state.context.type;
	  };

	  states.parens = function(type, stream, state) {
	    if (type == "{" || type == "}") return popAndPass(type, stream, state);
	    if (type == ")") return popContext(state);
	    if (type == "(") return pushContext(state, stream, "parens");
	    if (type == "interpolation") return pushContext(state, stream, "interpolation");
	    if (type == "word") wordAsValue(stream);
	    return "parens";
	  };

	  states.pseudo = function(type, stream, state) {
	    if (type == "meta") return "pseudo";

	    if (type == "word") {
	      override = "variable-3";
	      return state.context.type;
	    }
	    return pass(type, stream, state);
	  };

	  states.documentTypes = function(type, stream, state) {
	    if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
	      override = "tag";
	      return state.context.type;
	    } else {
	      return states.atBlock(type, stream, state);
	    }
	  };

	  states.atBlock = function(type, stream, state) {
	    if (type == "(") return pushContext(state, stream, "atBlock_parens");
	    if (type == "}" || type == ";") return popAndPass(type, stream, state);
	    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

	    if (type == "interpolation") return pushContext(state, stream, "interpolation");

	    if (type == "word") {
	      var word = stream.current().toLowerCase();
	      if (word == "only" || word == "not" || word == "and" || word == "or")
	        override = "keyword";
	      else if (mediaTypes.hasOwnProperty(word))
	        override = "attribute";
	      else if (mediaFeatures.hasOwnProperty(word))
	        override = "property";
	      else if (mediaValueKeywords.hasOwnProperty(word))
	        override = "keyword";
	      else if (propertyKeywords.hasOwnProperty(word))
	        override = "property";
	      else if (nonStandardPropertyKeywords.hasOwnProperty(word))
	        override = "string-2";
	      else if (valueKeywords.hasOwnProperty(word))
	        override = "atom";
	      else if (colorKeywords.hasOwnProperty(word))
	        override = "keyword";
	      else
	        override = "error";
	    }
	    return state.context.type;
	  };

	  states.atComponentBlock = function(type, stream, state) {
	    if (type == "}")
	      return popAndPass(type, stream, state);
	    if (type == "{")
	      return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
	    if (type == "word")
	      override = "error";
	    return state.context.type;
	  };

	  states.atBlock_parens = function(type, stream, state) {
	    if (type == ")") return popContext(state);
	    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
	    return states.atBlock(type, stream, state);
	  };

	  states.restricted_atBlock_before = function(type, stream, state) {
	    if (type == "{")
	      return pushContext(state, stream, "restricted_atBlock");
	    if (type == "word" && state.stateArg == "@counter-style") {
	      override = "variable";
	      return "restricted_atBlock_before";
	    }
	    return pass(type, stream, state);
	  };

	  states.restricted_atBlock = function(type, stream, state) {
	    if (type == "}") {
	      state.stateArg = null;
	      return popContext(state);
	    }
	    if (type == "word") {
	      if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
	          (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
	        override = "error";
	      else
	        override = "property";
	      return "maybeprop";
	    }
	    return "restricted_atBlock";
	  };

	  states.keyframes = function(type, stream, state) {
	    if (type == "word") { override = "variable"; return "keyframes"; }
	    if (type == "{") return pushContext(state, stream, "top");
	    return pass(type, stream, state);
	  };

	  states.at = function(type, stream, state) {
	    if (type == ";") return popContext(state);
	    if (type == "{" || type == "}") return popAndPass(type, stream, state);
	    if (type == "word") override = "tag";
	    else if (type == "hash") override = "builtin";
	    return "at";
	  };

	  states.interpolation = function(type, stream, state) {
	    if (type == "}") return popContext(state);
	    if (type == "{" || type == ";") return popAndPass(type, stream, state);
	    if (type == "word") override = "variable";
	    else if (type != "variable" && type != "(" && type != ")") override = "error";
	    return "interpolation";
	  };

	  return {
	    startState: function(base) {
	      return {tokenize: null,
	              state: inline ? "block" : "top",
	              stateArg: null,
	              context: new Context(inline ? "block" : "top", base || 0, null)};
	    },

	    token: function(stream, state) {
	      if (!state.tokenize && stream.eatSpace()) return null;
	      var style = (state.tokenize || tokenBase)(stream, state);
	      if (style && typeof style == "object") {
	        type = style[1];
	        style = style[0];
	      }
	      override = style;
	      if (type != "comment")
	        state.state = states[state.state](type, stream, state);
	      return override;
	    },

	    indent: function(state, textAfter) {
	      var cx = state.context, ch = textAfter && textAfter.charAt(0);
	      var indent = cx.indent;
	      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
	      if (cx.prev) {
	        if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
	                          cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
	          // Resume indentation from parent context.
	          cx = cx.prev;
	          indent = cx.indent;
	        } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
	            ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
	          // Dedent relative to current context.
	          indent = Math.max(0, cx.indent - indentUnit);
	        }
	      }
	      return indent;
	    },

	    electricChars: "}",
	    blockCommentStart: "/*",
	    blockCommentEnd: "*/",
	    blockCommentContinue: " * ",
	    lineComment: lineComment,
	    fold: "brace"
	  };
	});

	  function keySet(array) {
	    var keys = {};
	    for (var i = 0; i < array.length; ++i) {
	      keys[array[i].toLowerCase()] = true;
	    }
	    return keys;
	  }

	  var documentTypes_ = [
	    "domain", "regexp", "url", "url-prefix"
	  ], documentTypes = keySet(documentTypes_);

	  var mediaTypes_ = [
	    "all", "aural", "braille", "handheld", "print", "projection", "screen",
	    "tty", "tv", "embossed"
	  ], mediaTypes = keySet(mediaTypes_);

	  var mediaFeatures_ = [
	    "width", "min-width", "max-width", "height", "min-height", "max-height",
	    "device-width", "min-device-width", "max-device-width", "device-height",
	    "min-device-height", "max-device-height", "aspect-ratio",
	    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
	    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
	    "max-color", "color-index", "min-color-index", "max-color-index",
	    "monochrome", "min-monochrome", "max-monochrome", "resolution",
	    "min-resolution", "max-resolution", "scan", "grid", "orientation",
	    "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
	    "pointer", "any-pointer", "hover", "any-hover"
	  ], mediaFeatures = keySet(mediaFeatures_);

	  var mediaValueKeywords_ = [
	    "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
	    "interlace", "progressive"
	  ], mediaValueKeywords = keySet(mediaValueKeywords_);

	  var propertyKeywords_ = [
	    "align-content", "align-items", "align-self", "alignment-adjust",
	    "alignment-baseline", "anchor-point", "animation", "animation-delay",
	    "animation-direction", "animation-duration", "animation-fill-mode",
	    "animation-iteration-count", "animation-name", "animation-play-state",
	    "animation-timing-function", "appearance", "azimuth", "backface-visibility",
	    "background", "background-attachment", "background-blend-mode", "background-clip",
	    "background-color", "background-image", "background-origin", "background-position",
	    "background-repeat", "background-size", "baseline-shift", "binding",
	    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
	    "bookmark-target", "border", "border-bottom", "border-bottom-color",
	    "border-bottom-left-radius", "border-bottom-right-radius",
	    "border-bottom-style", "border-bottom-width", "border-collapse",
	    "border-color", "border-image", "border-image-outset",
	    "border-image-repeat", "border-image-slice", "border-image-source",
	    "border-image-width", "border-left", "border-left-color",
	    "border-left-style", "border-left-width", "border-radius", "border-right",
	    "border-right-color", "border-right-style", "border-right-width",
	    "border-spacing", "border-style", "border-top", "border-top-color",
	    "border-top-left-radius", "border-top-right-radius", "border-top-style",
	    "border-top-width", "border-width", "bottom", "box-decoration-break",
	    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
	    "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count",
	    "column-fill", "column-gap", "column-rule", "column-rule-color",
	    "column-rule-style", "column-rule-width", "column-span", "column-width",
	    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
	    "cue-after", "cue-before", "cursor", "direction", "display",
	    "dominant-baseline", "drop-initial-after-adjust",
	    "drop-initial-after-align", "drop-initial-before-adjust",
	    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
	    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
	    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
	    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
	    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
	    "font-stretch", "font-style", "font-synthesis", "font-variant",
	    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
	    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
	    "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow",
	    "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap",
	    "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap",
	    "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns",
	    "grid-template-rows", "hanging-punctuation", "height", "hyphens",
	    "icon", "image-orientation", "image-rendering", "image-resolution",
	    "inline-box-align", "justify-content", "justify-items", "justify-self", "left", "letter-spacing",
	    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
	    "line-stacking-shift", "line-stacking-strategy", "list-style",
	    "list-style-image", "list-style-position", "list-style-type", "margin",
	    "margin-bottom", "margin-left", "margin-right", "margin-top",
	    "marks", "marquee-direction", "marquee-loop",
	    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
	    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
	    "nav-left", "nav-right", "nav-up", "object-fit", "object-position",
	    "opacity", "order", "orphans", "outline",
	    "outline-color", "outline-offset", "outline-style", "outline-width",
	    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
	    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
	    "page", "page-break-after", "page-break-before", "page-break-inside",
	    "page-policy", "pause", "pause-after", "pause-before", "perspective",
	    "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position",
	    "presentation-level", "punctuation-trim", "quotes", "region-break-after",
	    "region-break-before", "region-break-inside", "region-fragment",
	    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
	    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
	    "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin",
	    "shape-outside", "size", "speak", "speak-as", "speak-header",
	    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
	    "tab-size", "table-layout", "target", "target-name", "target-new",
	    "target-position", "text-align", "text-align-last", "text-decoration",
	    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
	    "text-decoration-style", "text-emphasis", "text-emphasis-color",
	    "text-emphasis-position", "text-emphasis-style", "text-height",
	    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
	    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
	    "text-wrap", "top", "transform", "transform-origin", "transform-style",
	    "transition", "transition-delay", "transition-duration",
	    "transition-property", "transition-timing-function", "unicode-bidi",
	    "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration",
	    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
	    "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break",
	    "word-spacing", "word-wrap", "z-index",
	    // SVG-specific
	    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
	    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
	    "color-interpolation", "color-interpolation-filters",
	    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
	    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
	    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
	    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
	    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
	    "glyph-orientation-vertical", "text-anchor", "writing-mode"
	  ], propertyKeywords = keySet(propertyKeywords_);

	  var nonStandardPropertyKeywords_ = [
	    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
	    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
	    "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside",
	    "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button",
	    "searchfield-results-decoration", "zoom"
	  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);

	  var fontProperties_ = [
	    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",
	    "font-stretch", "font-weight", "font-style"
	  ], fontProperties = keySet(fontProperties_);

	  var counterDescriptors_ = [
	    "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
	    "speak-as", "suffix", "symbols", "system"
	  ], counterDescriptors = keySet(counterDescriptors_);

	  var colorKeywords_ = [
	    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
	    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
	    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
	    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
	    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
	    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
	    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
	    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
	    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
	    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
	    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
	    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
	    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
	    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
	    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
	    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
	    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
	    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
	    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
	    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
	    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
	    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
	    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
	    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
	    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
	    "whitesmoke", "yellow", "yellowgreen"
	  ], colorKeywords = keySet(colorKeywords_);

	  var valueKeywords_ = [
	    "above", "absolute", "activeborder", "additive", "activecaption", "afar",
	    "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
	    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
	    "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",
	    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
	    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
	    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
	    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
	    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
	    "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
	    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
	    "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
	    "compact", "condensed", "contain", "content", "contents",
	    "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop",
	    "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
	    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
	    "destination-in", "destination-out", "destination-over", "devanagari", "difference",
	    "disc", "discard", "disclosure-closed", "disclosure-open", "document",
	    "dot-dash", "dot-dot-dash",
	    "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
	    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
	    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
	    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
	    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
	    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
	    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
	    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
	    "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
	    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
	    "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove",
	    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
	    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
	    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
	    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
	    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
	    "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
	    "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
	    "katakana", "katakana-iroha", "keep-all", "khmer",
	    "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
	    "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
	    "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
	    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
	    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
	    "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d",
	    "media-controls-background", "media-current-time-display",
	    "media-fullscreen-button", "media-mute-button", "media-play-button",
	    "media-return-to-realtime-button", "media-rewind-button",
	    "media-seek-back-button", "media-seek-forward-button", "media-slider",
	    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
	    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
	    "menu", "menulist", "menulist-button", "menulist-text",
	    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
	    "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize",
	    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
	    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
	    "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
	    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
	    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
	    "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter",
	    "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
	    "progress", "push-button", "radial-gradient", "radio", "read-only",
	    "read-write", "read-write-plaintext-only", "rectangle", "region",
	    "relative", "repeat", "repeating-linear-gradient",
	    "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
	    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
	    "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
	    "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
	    "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
	    "searchfield-cancel-button", "searchfield-decoration",
	    "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end",
	    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
	    "simp-chinese-formal", "simp-chinese-informal", "single",
	    "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
	    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
	    "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
	    "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square",
	    "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub",
	    "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",
	    "table-caption", "table-cell", "table-column", "table-column-group",
	    "table-footer-group", "table-header-group", "table-row", "table-row-group",
	    "tamil",
	    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
	    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
	    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
	    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
	    "trad-chinese-formal", "trad-chinese-informal", "transform",
	    "translate", "translate3d", "translateX", "translateY", "translateZ",
	    "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up",
	    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
	    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
	    "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
	    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
	    "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
	    "xx-large", "xx-small"
	  ], valueKeywords = keySet(valueKeywords_);

	  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
	    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
	    .concat(valueKeywords_);
	  CodeMirror.registerHelper("hintWords", "css", allWords);

	  function tokenCComment(stream, state) {
	    var maybeEnd = false, ch;
	    while ((ch = stream.next()) != null) {
	      if (maybeEnd && ch == "/") {
	        state.tokenize = null;
	        break;
	      }
	      maybeEnd = (ch == "*");
	    }
	    return ["comment", "comment"];
	  }

	  CodeMirror.defineMIME("text/css", {
	    documentTypes: documentTypes,
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    mediaValueKeywords: mediaValueKeywords,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    fontProperties: fontProperties,
	    counterDescriptors: counterDescriptors,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (!stream.eat("*")) return false;
	        state.tokenize = tokenCComment;
	        return tokenCComment(stream, state);
	      }
	    },
	    name: "css"
	  });

	  CodeMirror.defineMIME("text/x-scss", {
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    mediaValueKeywords: mediaValueKeywords,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    fontProperties: fontProperties,
	    allowNested: true,
	    lineComment: "//",
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (stream.eat("/")) {
	          stream.skipToEnd();
	          return ["comment", "comment"];
	        } else if (stream.eat("*")) {
	          state.tokenize = tokenCComment;
	          return tokenCComment(stream, state);
	        } else {
	          return ["operator", "operator"];
	        }
	      },
	      ":": function(stream) {
	        if (stream.match(/\s*\{/, false))
	          return [null, null]
	        return false;
	      },
	      "$": function(stream) {
	        stream.match(/^[\w-]+/);
	        if (stream.match(/^\s*:/, false))
	          return ["variable-2", "variable-definition"];
	        return ["variable-2", "variable"];
	      },
	      "#": function(stream) {
	        if (!stream.eat("{")) return false;
	        return [null, "interpolation"];
	      }
	    },
	    name: "css",
	    helperType: "scss"
	  });

	  CodeMirror.defineMIME("text/x-less", {
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    mediaValueKeywords: mediaValueKeywords,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    fontProperties: fontProperties,
	    allowNested: true,
	    lineComment: "//",
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (stream.eat("/")) {
	          stream.skipToEnd();
	          return ["comment", "comment"];
	        } else if (stream.eat("*")) {
	          state.tokenize = tokenCComment;
	          return tokenCComment(stream, state);
	        } else {
	          return ["operator", "operator"];
	        }
	      },
	      "@": function(stream) {
	        if (stream.eat("{")) return [null, "interpolation"];
	        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
	        stream.eatWhile(/[\w\\\-]/);
	        if (stream.match(/^\s*:/, false))
	          return ["variable-2", "variable-definition"];
	        return ["variable-2", "variable"];
	      },
	      "&": function() {
	        return ["atom", "atom"];
	      }
	    },
	    name: "css",
	    helperType: "less"
	  });

	  CodeMirror.defineMIME("text/x-gss", {
	    documentTypes: documentTypes,
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    fontProperties: fontProperties,
	    counterDescriptors: counterDescriptors,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    supportsAtComponent: true,
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (!stream.eat("*")) return false;
	        state.tokenize = tokenCComment;
	        return tokenCComment(stream, state);
	      }
	    },
	    name: "css",
	    helperType: "gss"
	  });

	});


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _server = __webpack_require__(192);

	var _server2 = _interopRequireDefault(_server);

	var _component = __webpack_require__(196);

	var _component2 = _interopRequireDefault(_component);

	var _reactImmutableRenderMixin = __webpack_require__(185);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var manage = _server2.default.manage;

	var Paint = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(Paint, _Component);

	    function Paint(props) {
	        _classCallCheck(this, Paint);

	        var _this = _possibleConstructorReturn(this, (Paint.__proto__ || Object.getPrototypeOf(Paint)).call(this, props));

	        _this.state = {
	            components: manage.$$components
	        };
	        return _this;
	    }

	    _createClass(Paint, [{
	        key: 'get4uid',
	        value: function get4uid() {
	            var now = new Date().getTime() + "";
	            return now.substring(now.length - 4);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var components = [];
	            this.state.components.forEach(function (e, i) {
	                var Component = e.getReactComponent();
	                components.push(_react2.default.createElement(Component, { component: e, key: e.id }));
	            });
	            return _react2.default.createElement(
	                'div',
	                { id: 'canvas' },
	                components
	            );
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this2 = this;

	            var instance = this,
	                jsonData = void 0;

	            manage.setPaintUpdate(function (components) {
	                components && _this2.setState({
	                    components: components
	                });
	            });

	            _server2.default.on('listItem:drag_end', function (offset, icon) {
	                manage.add(new _component2.default(offset, icon));
	            });

	            window.addEventListener && window.addEventListener('keyup', function (e) {
	                var components = void 0;
	                switch (e.key) {
	                    /*case'a':{
	                        jsonData = manage.getJsonData();
	                        break;
	                    }
	                    case'r':{
	                        manage.recoveryFromJsonData(JSON.parse(jsonData));
	                        break;
	                    }*/
	                    case 'Delete':
	                        {
	                            manage.remove();
	                            break;
	                        }
	                    case 'z':
	                        {
	                            if (e.ctrlKey) {
	                                manage.undo();
	                                break;
	                            }
	                        }
	                    case 'y':
	                        {
	                            if (e.ctrlKey) {
	                                manage.redo();
	                                break;
	                            }
	                        }
	                    case 'c':
	                        {
	                            if (e.ctrlKey) {
	                                manage.setPlate();
	                                break;
	                            }
	                        }
	                    case 'v':
	                        {
	                            if (e.ctrlKey) {
	                                var plateCom = manage.getPlate();
	                                if (plateCom) {
	                                    manage.add(plateCom.copy(), plateCom.parentId);
	                                }
	                                break;
	                            }
	                        }
	                    default:
	                        break;
	                }
	            });
	        }
	    }]);

	    return Paint;
	}(_react.Component)) || _class;

	exports.default = Paint;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _server = __webpack_require__(192);

	var _server2 = _interopRequireDefault(_server);

	var _reactImmutableRenderMixin = __webpack_require__(185);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Nav = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(Nav, _Component);

	    function Nav(props) {
	        _classCallCheck(this, Nav);

	        var _this = _possibleConstructorReturn(this, (Nav.__proto__ || Object.getPrototypeOf(Nav)).call(this, props));

	        _this.state = {
	            deleteComponentId: []
	        };
	        _this.click = _this.click.bind(_this);
	        return _this;
	    }

	    _createClass(Nav, [{
	        key: 'click',
	        value: function click(state) {
	            _server2.default.emit('list_tab:click', state);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { className: 'nav', id: 'nav' },
	                _react2.default.createElement(
	                    'div',
	                    { className: 'leftMenu' },
	                    _react2.default.createElement(
	                        'a',
	                        { href: '#', onClick: this.click('new') },
	                        '\u65B0\u5EFA'
	                    ),
	                    _react2.default.createElement(
	                        'a',
	                        { href: '#', onClick: this.click('open') },
	                        '\u6253\u5F00'
	                    ),
	                    _react2.default.createElement(
	                        'a',
	                        { href: '#', onClick: this.click('delete') },
	                        '\u5220\u9664'
	                    )
	                ),
	                _react2.default.createElement('div', null)
	            );
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {}
	    }]);

	    return Nav;
	}(_react.Component)) || _class;

	exports.default = Nav;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class;

	var _react = __webpack_require__(1);

	var _react2 = _interopRequireDefault(_react);

	var _server = __webpack_require__(192);

	var _server2 = _interopRequireDefault(_server);

	var _reactImmutableRenderMixin = __webpack_require__(185);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var PopUp = (0, _reactImmutableRenderMixin.immutableRenderDecorator)(_class = function (_Component) {
	    _inherits(PopUp, _Component);

	    function PopUp(props) {
	        _classCallCheck(this, PopUp);

	        var _this = _possibleConstructorReturn(this, (PopUp.__proto__ || Object.getPrototypeOf(PopUp)).call(this, props));

	        _this.state = {
	            type: 'new'
	        };
	        _this.click = _this.click.bind(_this);
	        return _this;
	    }

	    _createClass(PopUp, [{
	        key: 'click',
	        value: function click(state) {
	            _server2.default.emit('list_tab:click', state);
	        }
	    }, {
	        key: 'getShadowList',
	        value: function getShadowList() {
	            if (this.state.type === 'new') {
	                return _react2.default.createElement('div', { className: 'shadow_content' });
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { className: 'shadow' },
	                this.getShadowList()
	            );
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {}
	    }]);

	    return PopUp;
	}(_react.Component)) || _class;

	exports.default = PopUp;

/***/ })
/******/ ]);